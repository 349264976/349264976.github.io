<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>testphotos</title>
      <link href="/2023/09/27/testphotos/"/>
      <url>/2023/09/27/testphotos/</url>
      
        <content type="html"><![CDATA[<p><img src="/2023/09/27/testphotos/personboke\blog\source_posts\testphotos\7.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>docker学习</title>
      <link href="/2023/09/19/docker%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/09/19/docker%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="nginx了解"><a href="#nginx了解" class="headerlink" title="nginx了解"></a>nginx了解</h3><p><strong>2、启动nginx</strong></p><p>有很多种方法启动nginx</p><p>(1)直接双击nginx.exe，双击后一个黑色的弹窗一闪而过</p><p>(2)打开cmd命令窗口，切换到nginx解压目录下，输入命令 <code>nginx.exe</code> ，回车即可</p><p><strong>3、检查nginx是否启动成功</strong></p><p>直接在浏览器地址栏输入网址 <a href="http://localhost/">http://localhost:80</a> 回车，出现以下页面说明启动成功！</p><p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/01/25/kuangstudya21688c8-159e-4caa-8e65-3dc056b6b78e.png" alt="img"></p><p><strong>4、配置监听</strong></p><p>nginx的配置文件是conf目录下的nginx.conf，默认配置的nginx监听的端口为80，如果80端口被占用可以修改为未被占用的端口即可。</p><p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/01/25/kuangstudyf23105c4-b0b2-4e22-a1bf-b8098f40c144.png" alt="img"></p><p>当我们修改了nginx的配置文件nginx.conf 时，不需要关闭nginx后重新启动nginx，只需要执行命令 <code>nginx -s reload</code> 即可让改动生效</p><p><strong>5、关闭nginx</strong></p><p>如果使用cmd命 令窗口启动nginx， 关闭cmd窗口是不能结束nginx进程的，可使用两种方法关闭nginx</p><p>(1)输入nginx命令 <code>nginx -s stop</code>(快速停止nginx) 或 <code>nginx -s quit</code>(完整有序的停止nginx)</p><p>(2)使用taskkill <code>taskkill /f /t /im nginx.exe</code></p><pre><code>taskkill是用来终止进程的，/f是强制终止 ./t终止指定的进程和任何由此启动的子进程。/im示指定的进程名称 .</code></pre><h2 id="linux下安装"><a href="#linux下安装" class="headerlink" title="linux下安装"></a>linux下安装</h2><p><strong>1、安装gcc</strong></p><p>安装 nginx 需要先将官网下载的源码进行编译，编译依赖 gcc 环境，如果没有 gcc 环境，则需要安装：</p><pre><code>yum install gcc-c++</code></pre><p><strong>2、PCRE pcre-devel 安装</strong></p><p>PCRE(Perl Compatible Regular Expressions) 是一个Perl库，包括 perl 兼容的正则表达式库。nginx 的 http 模块使用 pcre 来解析正则表达式，所以需要在 linux 上安装 pcre 库，pcre-devel 是使用 pcre 开发的一个二次开发库。nginx也需要此库。命令：</p><pre><code>yum install -y pcre pcre-devel</code></pre><p><strong>3、zlib 安装</strong></p><p>zlib 库提供了很多种压缩和解压缩的方式， nginx 使用 zlib 对 http 包的内容进行 gzip ，所以需要在 Centos 上安装 zlib 库。</p><pre><code>yum install -y zlib zlib-devel</code></pre><p><strong>4、OpenSSL 安装</strong><br>OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及 SSL 协议，并提供丰富的应用程序供测试或其它目的使用。<br>nginx 不仅支持 http 协议，还支持 https（即在ssl协议上传输http），所以需要在 Centos 安装 OpenSSL 库。</p><pre><code>yum install -y openssl openssl-devel</code></pre><p><strong>5、下载安装包</strong></p><p>手动下载.tar.gz安装包，地址：<a href="https://nginx.org/en/download.html">https://nginx.org/en/download.html</a></p><p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/01/25/kuangstudyf51b946d-fda4-4675-b913-2084e028a5c0.png" alt="img"></p><p>下载完毕上传到服务器上 &#x2F;root</p><p><strong>6、解压</strong></p><pre><code>tar -zxvf nginx-1.18.0.tar.gzcd nginx-1.18.0</code></pre><p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/01/25/kuangstudyd8290598-ede7-4b4b-875b-2f447a9c001f.png" alt="img"></p><p><strong>7、配置</strong></p><p>使用默认配置，在nginx根目录下执行</p><pre><code>./configuremakemake install</code></pre><p>查找安装路径： <code>whereis nginx</code></p><p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/01/25/kuangstudyf80f8dc2-d5df-4bc2-933d-6ce11f388f6e.png" alt="img"></p><h2 id="Nginx常用命令"><a href="#Nginx常用命令" class="headerlink" title="Nginx常用命令"></a>Nginx常用命令</h2><pre><code>cd /usr/local/nginx/sbin/./nginx  启动./nginx -s stop  停止./nginx -s quit  安全退出./nginx -s reload  重新加载配置文件ps aux|grep nginx  查看nginx进程</code></pre><p>启动成功访问 服务器ip:80</p><p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/01/25/kuangstudyd64b251b-817c-436b-b7a0-57da7bb48cd1.png" alt="img"></p><p>注意：如何连接不上，检查阿里云安全组是否开放端口，或者服务器防火墙是否开放端口！<br>相关命令：</p><pre><code># 开启service firewalld start# 重启service firewalld restart# 关闭service firewalld stop# 查看防火墙规则firewall-cmd --list-all# 查询端口是否开放firewall-cmd --query-port=8080/tcp# 开放80端口firewall-cmd --permanent --add-port=80/tcp# 移除端口firewall-cmd --permanent --remove-port=8080/tcp#重启防火墙(修改配置后要重启防火墙)firewall-cmd --reload# 参数解释1、firwall-cmd：是Linux提供的操作firewall的一个工具；2、--permanent：表示设置为持久；3、--add-port：标识添加的端口；</code></pre><h1 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h1><pre><code>upstream lb&#123;    server 127.0.0.1:8080 weight=1;    server 127.0.0.1:8081 weight=1;&#125;location / &#123;    proxy_pass http://lb;&#125;</code></pre><h1 id="Docker-学习"><a href="#Docker-学习" class="headerlink" title="Docker 学习"></a>Docker 学习</h1><h3 id="docker重要解释"><a href="#docker重要解释" class="headerlink" title="docker重要解释"></a>docker重要解释</h3><ul><li><p>镜像Image   相当于一个类模板  每个镜像都是一个文件</p></li><li><p>容器container 容器时镜像中的一个实例 像相当于一个类模板  每个容器都是一个实例</p></li><li><p>仓库repository 集中管理存放镜像的地方  (公开库)(私有库)</p></li></ul><h1 id="Docker基础篇"><a href="#Docker基础篇" class="headerlink" title="Docker基础篇"></a>Docker基础篇</h1><p>开始时间：2022-6-10 12:11:19</p><p>结束时间：2022-6-12 17:27:38</p><iframe class="ne-thirdparty-iframe" data-testid="ne-thirdparty-reader-iframe" sandbox="allow-forms allow-orientation-lock allow-presentation allow-same-origin allow-scripts allow-popups allow-downloads" data-src="https://music.163.com/outchain/player?type=2&amp;id=1825998212&amp;auto=0&amp;height=66" src="https://music.163.com/outchain/player?type=2&amp;id=1825998212&amp;auto=0&amp;height=66" frameborder="0" allowfullscreen style="box-sizing: border-box; position: relative; width: 746px; height: 88px; top: 0px; left: 0px; background: var(--larkx-editor-background-primary);"></iframe><p> 一、Docker概述 </p><ol><li>Docker简介</li></ol><p> 1）为什么有Docker? </p><p>Docker是基于GO语言实现的云开源项目，是一个虚拟化容器技术。</p><p>为了解决部署过程中遇见的版本、配置问题，Docker给出了一个标准化的解决方案</p><p>●系统平滑移植，容器虚拟化技术。</p><p>简单来说：</p><p>1环境不一致</p><p>2集群配置困难</p><p>Docker：将源码 + 配置 + 环境 + 版本打包成为一个镜像文件。</p><p>Docker的理念：Build, Ship and Run Any App, Anywhere，也就是通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的APP及其运行环境能做到一次镜像,处处运行。</p><p> 2）Docker的基本组成 </p><p>Docker的基本组成部分：</p><p>●镜像（image）</p><p>●容器（container）</p><p>●仓库（repository）</p><ul><li>镜像</li></ul><p>●Docker镜像就是一个只读的模板，镜像可以用来创建Docker容器，一个镜像可以创建多个容器。</p><p>●类似于Java中的类模板。</p><ul><li>容器</li></ul><p>●Docker利用容器独立运行的一个或一组应用，应用程序或服务运行在容器里面，容器就类似于一个虚拟化的运行环境，容器是用镜像创建的运行实例。</p><p>●最小配置的Linux环境。</p><p>●类似于Java中使用类模板创建的类实例。</p><ul><li>仓库</li></ul><p>●Docker仓库是集中存放镜像文件的场所。</p><p>●仓库分为公开仓库和私有仓库两种。</p><p>●最大的公开仓库是Docker官方的Docker Hub：<a href="https://hub.docker.com/">https://hub.docker.com/</a></p><ol start="2"><li>容器和虚拟机的比较</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/29162123/1654835911836-d4ec43af-8dfc-44eb-b3bf-4f926a48d8c0.png?x-oss-process=image/resize,w_617,limit_0" alt="image.png"></p><p> 1）传统虚拟机 </p><p>它可以在一种操作系统里面运行另一种操作系统，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。</p><p>这类虚拟机完美的运行了另一套系统，能够使应用程序，操作系统和硬件三者之间的逻辑不变。  </p><p>虚拟机的缺点：</p><p>1资源占用多</p><p>2冗余步骤多</p><p>3启动慢</p><p> 2）容器虚拟化技术 </p><p>为了解决传统虚拟机的缺点</p><p>Linux容器(Linux Containers，缩写为 LXC)</p><p>Linux容器是与系统其他部分隔离开的一系列进程，从另一个镜像运行，并由该镜像提供支持进程所需的全部文件。</p><p>容器提供的镜像包含了应用的所有依赖项，因而在从开发到测试再到生产的整个过程中，它都具有可移植性和一致性。</p><p>即：Docker容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，虚拟软件所需的最小化配置。</p><p> 3）对比 </p><p>比较了 Docker和传统虚拟化方式的不同之处：</p><p>●传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程。</p><p>●容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</p><p>●每个容器之间互相隔离，每个容器有自己的文件系统 ，容器之间进程不会相互影响，能区分计算资源。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/29162123/1654911061256-2b9c246c-6fd4-4caa-8731-bd89f5c69c64.png" alt="image.png"></p><p> 4）为什么Docker会比VM虚拟机快？ </p><ul><li>Docker有比虚拟机更少的抽象层：</li></ul><p>●由于Docker不需要Hypervisor（虚拟机）实现硬件资源虚拟化，运行在Docker容器上的程序直接使用的都是实际物理机的硬件资源，因此在CPU、内存利用率上Docker有明显优势。</p><ul><li>Docker利用的是宿主机的内核，而不需要加载操作系统OS内核：</li></ul><p>●当新建一个容器时，Docker不需要和虚拟机一样重新加载一个操作系统内核。进而避免引寻、加载操作系统内核返回等比较耗时耗资源的过程。当新建一个虚拟机时，虚拟机软件需要加载OS，返回新建过程是分钟级别的。而Docker由于直接利用宿主机的操作系统，则省略了返回过程，因此新建一个Docker容器只需要几秒钟。</p><p>Docker容器的本质就是一个进程。</p><ol start="3"><li>Docker的架构</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/29162123/1654838137985-a5def20f-2a43-4480-9583-d0c3d29a7811.png" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/29162123/1654910906955-92722db3-7692-4021-bfa8-c314da1f9d24.png" alt="image.png"></p><ol start="4"><li>Docker的工作流程</li></ol><p>Docker是一个 C&#x2F;S（Client-Server） 结构的系统，后端是一个松耦合架构，众多模块各司其职。</p><p>Docker守护进程运行在主机上，然后通过Socket连接从客户端访问，守护进程从容器接收命令并管理运行在主机上的容器。</p><p>1用户是使用Docker Client 与 Docker Daemon 建立通信，并发送请求给后者</p><p>aDocker Daemon 作为 Docker架构的主体部分，首先提供 Docker Server 的功能使其可以接收 Docker Client 的请求。</p><p>2Docker Engine 执行 Docker内部的一系列工作，每一项工作都是以一个 Job的形式存在。</p><p>3Job 的运行过程中，当需要容器镜像时，则从 Docker Registry 中下载镜像，并通过镜像管理驱动 Graph Driver 将下载镜像以 Graph 的形式存储</p><p>4当需要为 Docker创建网络环境时，通过网络管理驱动 Network driver 创建并配置 Docker容器网络环境</p><p>5当需要限制 Docker容器运行资源或执行用户指令等操作时，则通过 Exec driver 来完成</p><p>6Libcontainer是一项独立的容器管理包，Network driver 以及 Exec driver 都是通过 Libcontainer来实现具体对容器进行的操作</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/29162123/1654838248546-50fc8784-8517-44f0-a4c2-049313edb1cd.png?x-oss-process=image/resize,w_750,limit_0" alt="24825fc01ebc29a7a7276a064ff9e958_1652093347909-4fcf65d1-da12-47cb-9a2f-0c4528d7e4c9.png"></p><p> 二、Docker的安装以及下载配置 </p><ol><li>下载地址</li></ol><p>docker官网: <a href="http://www.docker.com/">http://www.docker.com</a></p><p>Docker Hub官网: <a href="https://hub.docker.com/">https://hub.docker.com/</a></p><p> 2.Docker的先决条件 </p><p>Docker并非是一个通用的容器工具，它依赖于已存在并运行的Linux内核环境，因此，Docker必须部署在Linux内核的系统上。</p><p>实质上是在Linux下创建了一个隔离的文件环境，因此它的效率等同于所部署的Linux主机。</p><p>目前，要求系统为64位、Linux系统内核版本为 3.8以上，这里选用Centos7.x</p><p>cat &#x2F;etc&#x2F;redhat- release：查看版本</p><p>uname -r：查看内核</p><ol start="3"><li>CentOs7下安装Docker</li></ol><p> 1）卸载 </p><p>如果之前安装过Docker，需要先卸载旧版本：</p><p>旧版本的Docker引擎包可能叫做：docker、docker-engine。<br>新版本的Docker引擎包叫做：docker-ce</p><p> 2）yum资源库 </p><p>1安装yum-config-manager</p><p>2配置Docker的资源库地址：</p><p>●官方地址：（比较慢，不推荐）</p><p>●阿里云镜像地址：</p><p>阿里云官网提供了很多资源镜像，镜像地址：<a href="https://mirrors.aliyun.com,进入之后可以选择自己需要的资源进行配置/">https://mirrors.aliyun.com，进入之后可以选择自己需要的资源进行配置</a></p><p>●创建缓存（可选）：</p><p> 3）安装Docker引擎 </p><p>安装最新版本的Docker引擎、Docker客户端：</p><p>安装指定版本：</p><p> 4）启动docker引擎 </p><p>如果没有启动Docker引擎，那么执行 docker version查看版本号时，只能看到 Client: Docker Engine（Docker引擎客户端）的版本号。</p><p>启动Docker引擎：</p><p> 5）卸载Docker </p><p>卸载Docker步骤：</p><p>1 关闭服务 </p><p>2 使用yum删除docker引擎 </p><p>3 删除镜像、容器、卷、自定义配置等文件 </p><p> 6）进行测试 </p><ol start="4"><li>Docker下载加速</li></ol><p> 1）容器镜像仓库 </p><p>使用网易数帆、阿里云等容器镜像仓库进行下载。</p><p>例如，下载网易数帆镜像中的mysql（网易数帆的地址为 hub.c.163.com，网易数帆对dockerhub官方的镜像命名空间为 library）。</p><p> 2）阿里云配置加速 </p><p>登录阿里云，进入 工作台 -&gt; 容器镜像服务 -&gt; 镜像工具 -&gt; 镜像加速器。</p><p>里面提供了一个加速器地址：<a href="https://xxxxx.mirror.aliyuncs.com，将该地址配置到Docker中：">https://xxxxx.mirror.aliyuncs.com，将该地址配置到Docker中：</a></p><p>在daemon.json中写入以下内容：（即加速器地址）</p><p>然后刷新配置、重启docker即可：</p><p>使用阿里云配置加速可以直接下载官方的镜像文件且镜像tag为官方tag，不需要加上云服务商的地址。</p><p> 三、常用命令 </p><p>主要分为三类</p><p>1帮助启动类命令</p><p>2镜像命令</p><p>3容器命令</p><ol><li>帮助启动类命令</li></ol><p>●启动docker：</p><p>●停止Docker：</p><p>●重启Docker：</p><p>●查看状态：</p><p>●设置开机自启：</p><ol start="2"><li>帮助命令</li></ol><p>●查看Docker概要</p><p>●帮助</p><p>●对具体的命令进行求助</p><p>●查看版本号</p><ol start="3"><li>镜像命令</li></ol><p> 1）查看窗口中的镜像 </p><p>●-a：列出本地的所有镜像（包括历史镜像）</p><p>●-q：只显示镜像ID</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/29162123/1654912011348-bf88d89c-9068-46e8-83be-390c174cfa63.png" alt="image.png"></p><p>●REPOSITORY：表示镜像的仓库源</p><p>●TAG：镜像的标签，版本号</p><p>●IMAGE ID：镜像ID</p><p>●CREATED：镜像创建时间</p><p>●SIZE：镜像大小</p><p>同一仓库源可以有多个 TAG版本，代表这个仓库源的不同个版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。</p><p>如果不指定TAG版本，那么Docker将默认使用 :latest 镜像，即最后一次更新。</p><p> 2）搜索远程仓库中的镜像 </p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/29162123/1654912624312-2606d38d-89ef-469e-b6f6-543ea5de9fec.png" alt="image.png"></p><p>●NAME：镜像名称。</p><p>●DESCRIPTION：镜像描述。</p><p>●Stars：点赞数量。</p><p>●OFFIVIAL：是否为官方认证。</p><p>●AUTOMATED：是否是自动构建的。</p><p>默认在Docker hub中进行搜索</p><p>●–limit 数量：只显示前数量项</p><p> 3）拉取远程仓库中的镜像 </p><ul><li>获取最新版本镜像</li></ul><p>等价于：docker pull 镜像名称:latest</p><ul><li>获取指定版本镜像</li></ul><p> 4）查看存储空间使用情况 </p><p> 5）删除镜像 </p><p>可以使用空格分隔镜像名称&#x2F;ID，删除多个镜像。</p><p>删除全部镜像</p><ul><li>强制删除</li></ul><ol start="4"><li>容器命令</li></ol><p>前提：有了镜像才能创建容器。</p><p> 1）新建并启动容器 </p><ul><li>options</li></ul><p>●–name&#x3D;名称：为容器指定一个名称，不指定则随机分配。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/29162123/1654916058237-3cdf2a07-ed7b-4c77-9b89-ddfa8e390506.png" alt="image.png"></p><p>●-d：后台运行容器并返回容器ID，即：启动守护式容器（后台运行）。</p><p>●-i：以交互模式运行容器，通常与-t同时使用。</p><p>●-t：为容器重新分配一个伪输入终端，通常与-i同时使用。</p><p>○-it：启动交互式容器（前台有伪终端，等待进行交互）</p><p>●-P：随机端口映射，注意是大写。</p><p>●-p：指定端口映射（常用），注意是小写。</p><p>○-p 主机端口:docker容器端口</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/29162123/1654915562718-bad7d1d2-686e-417d-94db-8556733a1935.png?x-oss-process=image/resize,w_750,limit_0" alt="image.png"></p><p>●bash：是添加shell接口。</p><p>●可以使用exit退出当前终端</p><p>在使用完run命令以后，都会使用ps命令查看是否启动成功。</p><p> 2）列出当前正在运行的容器 </p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/29162123/1654915831941-e6cfbbc2-4f88-425b-b2bb-610fb745c584.png" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/29162123/1654915871061-f7e00929-cca5-4ba1-ab78-8e5d3745d7b9.png" alt="image.png"></p><p> ：随机分配的名称。</p><ul><li>options</li></ul><p>●-a：列出当前所有正在运行的容器 + 历史上运行过的容器</p><p>○up：当前正在运行的。</p><p>○exited：历史上存在过的。</p><p>●-l：显示最近创建的容器。</p><p>●-n 数字：显示最近数字个创建的容器。</p><p>●-q：静默模式，只显示容器编号。</p><p> 3）退出、启动停止的容器、重启、强制停止 </p><ul><li>容器停止</li></ul><p>exit：退出当前容器，容器停止。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/29162123/1654917324547-a93d0ca6-9a9e-438a-9e8b-976443c787c7.png" alt="image.png"></p><ul><li>容器不停止</li></ul><p>ctrl + q + p：退出当前容器，容器不停止。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/29162123/1654917312976-fbc893c0-80c6-4c34-9b23-d47aa5986c86.png" alt="image.png"></p><ul><li><p>启动停止的容器 </p></li><li><p>重启容器 </p></li><li><p>停止容器 </p></li><li><p>强行停止容器</p></li></ul><p> 4）删除容器 </p><p>注意区别 rmi 和 rm</p><ul><li><p>删除已停止容器 </p></li><li><p>强制删除正在运行容器 </p></li><li><p>一次删除多个容器实例</p></li></ul><ol start="5"><li>容器命令实例（重要）</li></ol><p>1使用redis 6.0.8</p><p> 1）启动守护式容器（后台服务器） </p><p>Docker中如果想要容器后台运行，那么就必须有一个前台进程。</p><p>就是说，想要容器在后台运行，那么它必须要有一个前台进程</p><p>进行对比</p><p> 2）获取容器的信息 </p><ul><li><p>查看容器日志 </p></li><li><p>查看容器内运行的进程 </p></li><li><p>查看容器内部细节</p></li></ul><p> 3）与正在运行的容器进行交互 </p><p>1创建一个unbunt容器，并使用cttl + p + q退出。</p><ul><li>方法一：exec</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/29162123/1654920498142-a0e58b7e-0350-4731-96a9-822beee28d67.png?x-oss-process=image/resize,w_734,limit_0" alt="image.png"></p><p>后面一定要加 bash!!!!</p><ul><li>方法二：attach</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/29162123/1654920482826-b570d49e-bcb1-41b1-9ee0-72c4cf1ff9b8.png" alt="image.png"></p><ul><li>exec和attach的区别</li></ul><p>●attach：进入容器中启动命令终端，不会启动新的进程，使用exit会导致容器的退出。</p><p>●exec：在容器中打开新的终端，可以启动新的进程，使用exit只会退出当前终端，不会退出容器。</p><p>推荐使用exec</p><ol start="6"><li>容器拷贝文件到主机上（重要）</li></ol><p>把容器中的重要文件转移到主机上。</p><p>此时容器中&#x2F;tmp&#x2F;下存在文件hello.txt</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/29162123/1654923239520-9acf7d61-d705-44d7-aed4-0f188d18a760.png" alt="image.png"></p><ol start="7"><li>导入和导出容器（重要）</li></ol><p>将整个容器进行备份。</p><p>●export：导出容器的内容作为一个tar归档文件。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/29162123/1654923659556-4411966f-1a09-465b-afcf-5f50e9891211.png" alt="image.png"></p><p>●import：从tar包中创建一个新的文件系统再导入镜像</p><p>●镜像用户：类似于Java中的包名。</p><p>●镜像名：镜像的名称，可以自定义。</p><p>●镜像版本号：可以自定义。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/29162123/1654924261976-e9550b44-7dcd-450d-9723-e108cc2fe417.png?x-oss-process=image/resize,w_901,limit_0" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/29162123/1654924577731-002f4f19-3f5b-4238-bc49-0fad7e37f593.png" alt="image.png"></p><ol start="8"><li>其他命令</li></ol><ul><li>修改镜像名称</li></ul><p>实际上是创建了一个新的镜像。</p><p> 四、Docker镜像 </p><ol><li>是什么？</li></ol><p>●是一种轻量级、可执行的独立软件包，它包含运行某个软件所需的所有内容，我们把应用程序和配置依赖打包好形成一个可交付的运行环境（包括代码、运行时需要的库、环境变量和配置文件等），这个打包好的运行环境就是image镜像文件。</p><p>●只有通过这个镜像文件才能生成Docker容器实例。</p><p>●镜像是分层的，是有层次结构的，支持扩展现有的镜像，从而创建一个新的镜像，新镜像是从Base镜像一层一层叠加生成的。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/29162123/1654926902677-818a9646-2aa6-4d1b-9e56-7c3d67953800.png" alt="e2cbefdb5af44b79835584f335b2b649_1652093459380-335e0f0e-1213-47d9-a17b-f49734699ef2.png"></p><p>镜像分层最大的好处：共享资源、方便复制迁移、方便复用。</p><ol start="2"><li>镜像中的层次结构</li></ol><p> 1）UnionFS文件系统 </p><p>●是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。</p><p>●Union文件系统是 Docker镜像的基础。</p><p>●镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p><p>●特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。</p><p> 2）Docker的加载原理 </p><p>Docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。</p><p>bootfs主要包含bootloader和kernel, bootloader主要是引导加载kernel， Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是引导文件系统bootfs。</p><p>rootfs，在bootfs之上。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29162123/1654926817677-1433db30-e780-476c-88fc-b44a679fd66f.jpeg?x-oss-process=image/resize,w_317,limit_0/interlace,1" alt="5207c77a9c8ed25adce1a3e543d269e5_1652093445038-27095471-f01f-4978-a28f-d8e2df893dab_x-oss-process=image%2Fresize%2Cw_633%2Climit_0.jpeg"></p><ol start="3"><li>容器层</li></ol><p>当容器启动时，一个新的可写层将被加载到镜像的顶部，这一层称为容器层，容器层下都称为镜像层。</p><p>所有对容器的修改都只会发生在容器层中，镜像层是只读的。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29162123/1654927053953-85b8587c-d37e-4fc9-9c91-2dbd9a892c20.jpeg?x-oss-process=image/resize,w_656,limit_0/interlace,1" alt="3d3598a1c9e6c46446e7066ed542c3db_1652093466220-a1c70673-7ca7-4025-9432-d89152439000_x-oss-process=image%2Fresize%2Cw_800%2Climit_0.jpeg"></p><ol start="4"><li>Commit创建自己的镜像</li></ol><p>在ubuntu镜像文件中没有通过vim命令。</p><p>所以根据Base镜像构建一个具有vim命令的镜像用于使用。</p><p>1创建一个ubuntu容器作为Base</p><p>2安装vim</p><p>aapt-get update</p><p>bapt-get -y install vim</p><p>3进行提交</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/29162123/1654929785531-774cc59c-a992-4e89-856e-4cb8b7fad624.png" alt="image.png"></p><p> 五、发布镜像 </p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/29162123/1654930063861-f9fcedc0-71c6-4415-a814-d2e45f98058b.png?x-oss-process=image/resize,w_493,limit_0" alt="image.png"></p><ol><li>发布Docker到阿里云</li></ol><p>阿里云 -&gt; 容器镜像服务</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/29162123/1654930593943-d1a77bef-d58b-4e18-9777-c5634e7cabc0.png" alt="image.png"></p><p>●命名空间（类似于包名）</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/29162123/1654930695229-0694aa8b-b042-4287-ac5e-41e7a10c238c.png" alt="image.png"></p><p>●镜像窗口</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/29162123/1654930678657-21466ea4-cc8a-40c0-8439-ee2e2044e4fb.png" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/29162123/1654930791195-eac18f7d-cb10-4c24-8179-6cc708d28dda.png" alt="image.png"></p><p>生成窗口以后，会提供一系列命令</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/29162123/1654931667228-b39e84fc-d2a8-4736-b202-a927a57d59a8.png" alt="image.png"></p><p>拉取阿里云中的镜像</p><p> 六、容器数据卷 </p><ol><li>添加属性</li></ol><p>添加属性打卡权限</p><p>Docker挂载主机目录访问如果出现cannot open directory .: Permission denied</p><p>解决办法：在挂载目录后多加一个–privileged&#x3D;true参数即可</p><p>为什么？</p><p>●因为目录挂载的情况被默认为不安全的行为，也即使用该参数以后，container内的root拥有真正的root权限，否则，container内的root只是外部的一个普通用户权限。</p><ol start="2"><li>是什么？能干什么？</li></ol><p>●容器数据卷可以将容器的数据备份 + 持久化到本地主机目录。</p><p>●卷就是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过联合文件系统提供一些用于持续存储或共享数据的特性。</p><p>●卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷。</p><p>特点：</p><p>1数据卷可使容器之间共享或重用数据。</p><p>2数据卷中的更改实时生效。</p><p>3数据卷中的更改不会包含在镜像的更新中。</p><p>4数据卷的生命周期一直持续到没有容器使用它为止。</p><p>5当容器停止时，主机进行修改，仍然能够同步。</p><ol start="3"><li>使用容器数据卷</li></ol><p> 1）宿主与容器之间添加容器数据卷 </p><p>&#x2F;宿主机绝对路径目录:&#x2F;容器内目录：将宿主机的目录与容器内的目录创建映射关系。</p><p>当目录不存在时，可以自动创建。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/29162123/1654935270538-494cf1c2-3bc8-409c-a245-374a1c14496a.png" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/29162123/1654935307616-f818d9dd-e2f9-46fc-8053-f42758a40f75.png" alt="image.png"></p><p> 2）查看挂载情况 </p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/29162123/1654993488634-744b63bc-ed85-4ed8-9ec9-fa5694699fc1.png" alt="image.png"></p><p> 3）读写规则以及映射添加说明 </p><p>在容器内目录后添加参数</p><ul><li>可读可写</li></ul><p>默认情况下就是可读可写的，rw可以省略。</p><ul><li>只读</li></ul><p>容器只能读取数据，不能写入数据。</p><p> 4）容器卷的继承和共享 </p><p>子容器卷可以继承父容器卷的文件，如果子容器卷进行了修改，那么父容器卷也会发生对应的修改。</p><p>子容器卷和父容器卷是两个不同的容器卷，如果父容器卷被删除了，子容器卷也能正常工作。</p><p> 七、安装常用软件 </p><ol><li>安装步骤</li></ol><p>1搜索镜像</p><p>2拉取镜像</p><p>3查看镜像</p><p>4启动镜像：设置服务端口映射</p><p>5停止容器</p><p>6移除容器</p><ol start="2"><li>Tomcat</li></ol><p>1docker search tomcat</p><p>2docker pull tomcat</p><p>3docker images</p><p>4docker run -it -p 8080:8080 tomcat</p><p>5访问首页</p><p>●当出现404错误时，可能是防火墙的问题，也可能是Tomcat最新版的webapps文件夹是空的，如果想要出现Tomcat首页，需要将webapps.dist修改名称为webapps</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/29162123/1654995534551-f426c5e4-4905-4b95-ba69-8736e6305e86.png" alt="image.png"></p><ol start="3"><li>MySql</li></ol><p> 1）简单创建MySQL容器 </p><p>此时存在问题：</p><p>1字符编码问题：默认使用拉丁文字符集SHOW VARIABLES LIKE ‘character%’</p><p>2数据备份问题</p><p> 2）工作中MySQL安装 </p><p>docker run -it -p 3306:3306 –privileged&#x3D;true -v &#x2F;root&#x2F;mysql&#x2F;log:&#x2F;var&#x2F;log&#x2F;mysql -v &#x2F;root&#x2F;mysql&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql -v &#x2F;root&#x2F;mysql&#x2F;conf:&#x2F;etc&#x2F;mysql&#x2F;conf.d -e MYSQL_ROOT_PASSWORD&#x3D;123456 –name&#x3D;mysql5.7 mysql:5.7</p><p>注意是 -it<br>当是-d时，由于没有前台进程，容器一创建就结束了。</p><p>–privileged&#x3D;true：开启容器卷的权限</p><p>-v &#x2F;root&#x2F;mysql&#x2F;log:&#x2F;var&#x2F;log&#x2F;mysql</p><p>-v &#x2F;root&#x2F;mysql&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql</p><p>-v &#x2F;root&#x2F;mysql&#x2F;conf:&#x2F;etc&#x2F;mysql&#x2F;conf.d 建立容器卷的映射，解决数据备份、字符编码问题。</p><ul><li>创建my.cnf解决中文乱码问题</li></ul><p>1在&#x2F;root&#x2F;mysql&#x2F;conf创建my.cnf文件</p><p>Java</p><p>复制代码</p><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>[client]</p><p>default_character_set&#x3D;utf8</p><p>[mysqld]</p><p>collation_server &#x3D; utf8_general_ci</p><p>character_set_server &#x3D; utf8</p><p>2重新启动容器卷，查看编码</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/29162123/1655000165345-b391fcec-8fdd-4e46-a9c9-9a750b65e12c.png" alt="image.png"></p><ul><li>数据备份的问题</li></ul><p>当挂载了容器卷以后，即使容器删除了，对应的数据也能进行部分，在下一个mysql创建后仍然可以获取。</p><ol start="4"><li>Redis</li></ol><p>同MySQL一样，也有数据备份以及配置的问题。</p><p>mkdir &#x2F;app&#x2F;redis</p><p>拷贝redis.conf到&#x2F;app&#x2F;redis目录下作为我们自己的Redis配置文件。</p><p>修改redis.conf</p><p>1开启密码验证</p><p>●requirepass 123456</p><p>2运行Redis外地连接（必要）</p><p>●注释 bind 127.0.0.1</p><p>3修改后台启动（必要）</p><p>●daemonize no</p><p>该配置会和docker run -d冲突</p><p>4开启数据持久化（必要）</p><p>●appendonly yes</p><p>Java</p><p>复制代码</p><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>docker run  -p 6379:6379 –name 名称 –privileged&#x3D;true</p><p>-v &#x2F;app&#x2F;redis&#x2F;redis.conf:&#x2F;etc&#x2F;redis&#x2F;redis.conf</p><p>-v &#x2F;app&#x2F;redis&#x2F;data:&#x2F;data </p><p>-d redis:6.0.8 </p><p>redis-server &#x2F;etc&#x2F;redis&#x2F;redis.conf</p><p>redis-server &#x2F;etc&#x2F;redis&#x2F;redis.conf</p><p>指的是启动redis服务，并且使用这个路径下的redis.conf作为配置文件。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Springsecurity入门</title>
      <link href="/2023/09/11/Springsecurity%E5%85%A5%E9%97%A8/"/>
      <url>/2023/09/11/Springsecurity%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="springsecurity入门"><a href="#springsecurity入门" class="headerlink" title="springsecurity入门"></a>springsecurity入门</h2><p>引入xml</p><pre><code>   &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;        &lt;/dependency&gt;</code></pre><p><img src="/2023/09/11/Springsecurity%E5%85%A5%E9%97%A8/personboke\blog\source_posts\Springsecurity入门\image-20230913213403052.png" alt="image-20230913213403052"></p><p><img src="/2023/09/11/Springsecurity%E5%85%A5%E9%97%A8/personboke\blog\source_posts\Springsecurity入门\image-20230913213501312.png" alt="image-20230913213501312"></p><h3 id="springsecurity认证授权的流程"><a href="#springsecurity认证授权的流程" class="headerlink" title="springsecurity认证授权的流程"></a>springsecurity认证授权的流程</h3><p>springscty 的原理是过滤器 内部包含了提供各种功能的过滤器</p><p>UsernamePasswordAuthenticationfilter： 负责处理我们在登陆页面填写用户名密码后的登录请求 </p><p>ExceptionTranslationFilter：处理过滤器链中抛出的任何AccessDeniedException和AuthenticationException</p><p>FilterSecurityInterceptor：负责权限校验的过滤器</p><p><img src="/2023/09/11/Springsecurity%E5%85%A5%E9%97%A8/personboke\blog\source_posts\Springsecurity入门\image-20230913215529744.png" alt="image-20230913215529744"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java 开发手册 嵩山版</title>
      <link href="/2023/09/10/Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%20%E5%B5%A9%E5%B1%B1%E7%89%88/"/>
      <url>/2023/09/10/Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%20%E5%B5%A9%E5%B1%B1%E7%89%88/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Java-开发手册-嵩山版"><a href="#Java-开发手册-嵩山版" class="headerlink" title="Java 开发手册 嵩山版"></a>Java 开发手册 嵩山版</h1><h2 id="一、-编程规约"><a href="#一、-编程规约" class="headerlink" title="一、 编程规约"></a>一、 编程规约</h2><h3 id="一-命名风格"><a href="#一-命名风格" class="headerlink" title="(一) 命名风格"></a>(一) 命名风格</h3><ol><li><p><span style="color:red;font-weight:900">【强制】</span>代码中的命名均不能以&#x3D;&#x3D;下划线或美元符号&#x3D;&#x3D;开始，也不能以&#x3D;&#x3D;下划线或美元符号&#x3D;&#x3D;结束。</p><p><span style="color:orange">反例</span>：<span style="color:red"><em>name &#x2F; <em><em>name &#x2F; $name &#x2F; name</em> &#x2F; name$ &#x2F; name</em></em></span></p></li><li><p><span style="color:red;font-weight:900">【强制】</span>所有编程相关的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。</p><p><span style="color:#977c00">说明: </span>正确的英文拼写和语法可以让阅读者易于理解，避免歧义。注意，纯拼音命名方式更要避免采用。</p><p><span style="color:green">正例: </span>ali &#x2F; alibaba &#x2F; taobao &#x2F; cainiao&#x2F; aliyun&#x2F; youku &#x2F; hangzhou 等国际通用的名称，可视同英文。</p><p><span style="color:red">反例: </span>DaZhePromotion [打折] &#x2F; getPingfenByName() [评分] &#x2F; String fw[福娃] &#x2F; int 某变量 &#x3D; 3</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>代码和注释中都要避免使用任何语言的种族歧视性词语。</p><p><span style="color:green">正例: </span>日本人 &#x2F; 印度人 &#x2F; blockList &#x2F; allowList &#x2F; secondary</p><p><span style="color:red">反例: </span>RIBENGUIZI &#x2F; Asan &#x2F; blackList &#x2F; whiteList &#x2F; slave</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>类名使用 UpperCamelCase 风格，但以下情形例外：DO &#x2F; BO &#x2F; DTO &#x2F; VO &#x2F; AO &#x2F; PO &#x2F; UID 等。</p><p><span style="color:green">正例: </span>ForceCode &#x2F; UserDO &#x2F; HtmlDTO &#x2F; XmlService &#x2F; TcpUdpDeal &#x2F; TaPromotion</p><p><span style="color:red">反例: </span>forcecode &#x2F; UserDo &#x2F; HTMLDto &#x2F; XMLService &#x2F; TCPUDPDeal &#x2F; TAPromotion</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格。</p><p><span style="color:green">正例: </span> localValue &#x2F; getHttpMessage() &#x2F; inputUserId</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。</p><p><span style="color:green">正例: </span>MAX_STOCK_COUNT &#x2F; CACHE_EXPIRED_TIME</p><p><span style="color:red">反例: </span>MAX_COUNT &#x2F; EXPIRED_TIME</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；测试类命名以它要测试的类的名称开始，以 Test 结尾。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>类型与中括号紧挨相连来表示数组。</p><p><span style="color:green">正例: </span>定义整形数组 int[] arrayDemo。</p><p><span style="color:red">反例：</span>在 main 参数中，使用 String args[]来定</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>POJO 类中的任何布尔类型的变量，都不要加 is 前缀，否则部分框架解析会引起序列化错误。</p><p><span style="color:#977c00">说明：</span>在本文 MySQL 规约中的建表约定第一条，表达是与否的变量采用 is_xxx 的命名方式，所以，需要在<resultMap>设置从 is_xxx 到 xxx 的映射关系。</resultMap></p><p><span style="color:red">反例：</span>定义为基本数据类型 Boolean isDeleted 的属性，它的方法也是 isDeleted()，框架在反向解析的时候，“误以为”对应的属性名称是 deleted，导致属性获取不到，进而抛出异常。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用&#x3D;&#x3D;单数&#x3D;&#x3D;形式，但是类名如果有复数含义，类名可以使用复数形式。</p><p><span style="color:green">正例：</span> 应用工具类包名为 com.alibaba.ei.kunlun.aap.util、类名为 MessageUtils（此规则参考 spring 的框架结构）</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>避免在子父类的成员变量之间、或者不同代码块的局部变量之间采用完全相同的命名，使可理解性降低。</p><p><span style="color:#977c00">说明：</span>子类、父类成员变量名相同，即使是 public 类型的变量也能够通过编译，另外，局部变量在同一方法内的不同代码块中同名也是合法的，这些情况都要避免。对于非 setter&#x2F;getter 的参数名称也要避免与成员变量名称相同。</p><p><span style="color:red">反例：</span></p><pre><code class="java">public class ConfusingName &#123;    public int stock;    // 非 setter/getter 的参数名称，不允许与本类成员变量同名    public void get(String alibaba) &#123;        if (condition) &#123;            final int money = 666;            // ...        &#125;        for (int i = 0; i &lt; 10; i++) &#123;            // 在同一方法体中，不允许与其它代码块中的 money 命名相同            final int money = 15978;            // ...        &#125;    &#125;&#125;class Son extends ConfusingName &#123;    // 不允许与父类的成员变量名称相同    public int stock;&#125;</code></pre></li><li><p><span style="color:red;font-weight:900">【强制】</span>杜绝完全不规范的缩写，避免望文不知义。</p><p><span style="color:red">反例: </span>AbstractClass“缩写”成 AbsClass；condition“缩写”成 condi；Function 缩写”成 Fu，此类随意缩写严重降低了代码的可阅读性。</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>为了达到代码自解释的目标，任何自定义编程元素在命名时，使用尽量完整的单词组合来表达。</p><p><span style="color:green">正例：</span> 对某个对象引用的 volatile 字段进行原子更新的类名为 AtomicReferenceFieldUpdater。</p><p><span style="color:red">反例：</span>常见的方法内变量为 int a;的定义方式。</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>在常量与变量的命名时，表示类型的名词放在词尾，以提升辨识度。</p><p><span style="color:green">正例: </span>startTime &#x2F; workQueue &#x2F; nameList &#x2F; TERMINATED_THREAD_COUNT</p><p><span style="color:red">反例: </span>startedAt &#x2F; QueueOfWork &#x2F; listName &#x2F; COUNT_TERMINATED_THREAD</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>如果模块、接口、类、方法使用了设计模式，在命名时需体现出具体模式。</p><p><span style="color:#977c00">说明：</span>将设计模式体现在名字中，有利于阅读者快速理解架构设计理念。</p><p><span style="color:green">正例：</span> </p><pre><code class="java">public class OrderFactory;public class LoginProxy;public class ResourceObserver;</code></pre></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>接口类中的方法和属性不要加任何修饰符号（public 也不要加），保持代码的简洁性，并加上有效的 Javadoc 注释。尽量不要在接口里定义变量，如果一定要定义变量，确定与接口方法相关，并且是整个应用的基础常量。</p><p><span style="color:green">正例: </span>接口方法签名 void commit();</p><p>​ 接口基础常量 String COMPANY &#x3D; “alibaba”;</p><p><span style="color:red">反例：</span>接口方法定义 public abstract void f();</p><p><span style="color:#977c00">说明：</span>JDK8 中接口允许有默认实现，那么这个 default 方法，是对所有实现类都有价值的默认实现。</p></li><li><p>接口和实现类的命名有两套规则：</p><p>1）<span style="color:red;font-weight:900">【强制】</span>对于 Service 和 DAO 类，基于 SOA 的理念，暴露出来的服务一定是接口，内部的实现类用Impl 的后缀与接口区别。</p><p><span style="color:green">正例: </span> CacheServiceImpl 实现 CacheService 接口。</p><p>2）<span style="color:#ffc000;font-weight:900">【推荐】</span>如果是形容能力的接口名称，取对应的形容词为接口名（通常是–able 的形容词）。</p><p><span style="color:green">正例: </span>AbstractTranslator 实现 Translatable 接口。</p></li><li><p><span style="color:#76923c;font-weight:900">【参考】</span>枚举类名带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开。</p><p><span style="color:#977c00">说明：</span>枚举其实就是特殊的常量类，且构造方法被默认强制是私有。</p><p><span style="color:green">正例：</span>  枚举名字为 ProcessStatusEnum 的成员名称：SUCCESS &#x2F; UNKNOWN_REASON。</p></li><li><p><span style="color:#76923c;font-weight:900">【参考】</span>各层命名规约：</p><p>A) Service&#x2F;DAO 层方法命名规约</p><p>​1） 获取单个对象的方法用 get 做前缀。</p><p>​2） 获取多个对象的方法用 list 做前缀，复数结尾，如：listObjects。 </p><p>​3） 获取统计值的方法用 count 做前缀。 </p><p>​4） 插入的方法用 save&#x2F;insert 做前缀。</p><p>​5） 删除的方法用 remove&#x2F;delete 做前缀。</p><p>​6） 修改的方法用 update 做前缀。</p><p>B) 领域模型命名规约</p><p>​1） 数据对象：xxxDO，xxx 即为数据表名。</p><p>​2） 数据传输对象：xxxDTO，xxx 为业务领域相关的名称。</p><p>​3） 展示对象：xxxVO，xxx 一般为网页名称。</p><p>​4） POJO 是 DO&#x2F;DTO&#x2F;BO&#x2F;VO 的统称，禁止命名成 xxxPOJO。</p></li></ol><h3 id="二-常量定义"><a href="#二-常量定义" class="headerlink" title="(二) 常量定义"></a>(二) 常量定义</h3><ol><li><p><span style="color:red;font-weight:900">【强制】</span>不允许任何魔法值（即未经预先定义的常量）直接出现在代码中。</p><p><span style="color:red">反例：</span></p><pre><code class="java">// 本例中，开发者 A 定义了缓存的 key，然后开发者 B 使用缓存时少了下划线，即 key 是&quot;Id#taobao&quot;+tradeId，导致出现故障String key = &quot;Id#taobao_&quot; + tradeId;cache.put(key, value);</code></pre></li><li><p><span style="color:red;font-weight:900">【强制】</span>在 long 或者 Long 赋值时，数值后使用大写字母 L，不能是小写字母 l，小写容易跟数字混淆，造成误解。</p><p><span style="color:#977c00">说明：</span>Long a &#x3D; 2l; 写的是数字的 21，还是 Long 型的 2？</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>不要使用一个常量类维护所有常量，要按常量功能进行归类，分开维护。</p><p><span style="color:#977c00">说明：</span>大而全的常量类，杂乱无章，使用查找功能才能定位到修改的常量，不利于理解，也不利于维护。</p><p><span style="color:green">正例：</span> 缓存相关常量放在类 CacheConsts 下；系统配置相关常量放在类 SystemConfigConsts 下。</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量。</p><p>1） 跨应用共享常量：放置在二方库中，通常是 client.jar 中的 constant 目录下。</p><p>2） 应用内共享常量：放置在一方库中，通常是子模块中的 constant 目录下。</p><p><span style="color:red">反例：</span>易懂变量也要统一定义成应用内共享常量，两位工程师在两个类中分别定义了“YES”的变量：</p><p>​类 A 中：public static final String YES &#x3D; “yes”;</p><p>​类 B 中：public static final String YES &#x3D; “y”;</p><p>​A.YES.equals(B.YES)，预期是 true，但实际返回为 false，导致线上问题。</p><p>3） 子工程内部共享常量：即在当前子工程的 constant 目录下。</p><p>4） 包内共享常量：即在当前包下单独的 constant 目录下。</p><p>5） 类内共享常量：直接在类内部 private static final 定义。</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>如果变量值仅在一个固定范围内变化用 enum 类型来定义。</p><p><span style="color:#977c00">说明：</span>如果存在名称之外的延伸属性应使用 enum 类型，下面正例中的数字就是延伸信息，表示一年中的第几个季节。</p><p><span style="color:green">正例: </span></p><pre><code class="java">public enum SeasonEnum &#123;    SPRING(1), SUMMER(2), AUTUMN(3), WINTER(4);    private int seq;    SeasonEnum(int seq) &#123;        this.seq = seq;    &#125;    public int getSeq() &#123;        return seq;    &#125;&#125;</code></pre></li></ol><h3 id="三-代码格式"><a href="#三-代码格式" class="headerlink" title="(三) 代码格式"></a>(三) 代码格式</h3><ol><li><p><span style="color:red;font-weight:900">【强制】</span>如果是大括号内为空，则简洁地写成{}即可，大括号中间无需换行和空格；如果是非空代码块则： </p><p>1） 左大括号前不换行。</p><p>2） 左大括号后换行。</p><p>3） 右大括号前换行。</p><p>4） 右大括号后还有 else 等代码则不换行；表示终止的右大括号后必须换行。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>左小括号和右边相邻字符之间不出现空格；右小括号和左边相邻字符之间也不出现空格；而左大括号前需要加空格。详见第 5 条下方正例提示。</p><p><span style="color:red">反例: </span>if (<span style="background:#dae3e9">空格</span>a &#x3D;&#x3D; b<span style="background:#dae3e9">空格</span>)</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>if&#x2F;for&#x2F;while&#x2F;switch&#x2F;do 等保留字与括号之间都必须加空格。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>任何二目、三目运算符的左右两边都需要加一个空格。</p><p><span style="color:#977c00">说明：</span>包括赋值运算符&#x3D;、逻辑运算符&amp;&amp;、加减乘除符号等。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>采用 4 个空格缩进，禁止使用 Tab 字符。</p><p><span style="color:#977c00">说明：</span>如果使用 Tab 缩进，必须设置 1 个 Tab 为 4 个空格。IDEA 设置 Tab 为 4 个空格时，请勿勾选&#x3D;&#x3D;Use tab character&#x3D;&#x3D;；而在 Eclipse 中，必须勾选&#x3D;&#x3D;insert spaces for tabs&#x3D;&#x3D;。</p><p><span style="color:green">正例：</span> （涉及 1-5 点）</p><pre><code class="java">public static void main(String[] args) &#123;    // 缩进 4 个空格    String say = &quot;hello&quot;;    // 运算符的左右必须有一个空格    int flag = 0;    // 关键词 if 与括号之间必须有一个空格，括号内的 f 与左括号，0 与右括号不需要空格    if (flag == 0) &#123;        System.out.println(say);    &#125;    // 左大括号前加空格且不换行；左大括号后换行    if (flag == 1) &#123;        System.out.println(&quot;world&quot;);        // 右大括号前换行，右大括号后有 else，不用换行    &#125; else &#123;        System.out.println(&quot;ok&quot;);        // 在右大括号后直接结束，则必须换行    &#125;&#125;</code></pre></li><li><p><span style="color:red;font-weight:900">【强制】</span>注释的双斜线与注释内容之间有且仅有一个空格。</p><p><span style="color:green">正例: </span></p><pre><code class="java">// 这是示例注释，请注意在双斜线之后有一个空格String commentString = new String();</code></pre></li><li><p><span style="color:red;font-weight:900">【强制】</span>在进行类型强制转换时，右括号与强制转换值之间不需要任何空格隔开。</p><p><span style="color:green">正例: </span></p><pre><code class="java">double first = 3.2d;int second = (int)first + 2; </code></pre></li><li><p><span style="color:red;font-weight:900">【强制】</span>单行字符数限制不超过 120 个，超出需要换行，换行时遵循如下原则：</p><p>1）第二行相对第一行缩进 4 个空格，从第三行开始，不再继续缩进，参考示例。</p><p>2）运算符与下文一起换行。</p><p>3）方法调用的点符号与下文一起换行。</p><p>4）方法调用中的多个参数需要换行时，在逗号后进行。 </p><p>5）在括号前不要换行，见<span style="color:red">反例</span>。</p><p><span style="color:green">正例: </span></p><pre><code class="java">StringBuilder sb = new StringBuilder();// 超过 120 个字符的情况下，换行缩进 4 个空格，并且方法前的点号一起换行sb.append(&quot;yang&quot;).append(&quot;hao&quot;)...        .append(&quot;chen&quot;)...        .append(&quot;chen&quot;)...        .append(&quot;chen&quot;);</code></pre><p><span style="color:red">反例：</span></p><pre><code class="java">StringBuilder sb = new StringBuilder();// 超过 120 个字符的情况下，不要在括号前换行sb.append(&quot;you&quot;).append(&quot;are&quot;)...append (&quot;lucky&quot;);// 参数很多的方法调用可能超过 120 个字符，逗号后才是换行处method(args1, args2, args3, ... , argsX);</code></pre></li><li><p><span style="color:red;font-weight:900">【强制】</span>方法参数在定义和传入时，多个参数逗号后面必须加空格。</p><p><span style="color:green">正例: </span>下例中实参的 &#x3D;&#x3D;args1&#x3D;&#x3D;，后边必须要有一个空格。</p><p>​method(args1, args2, args3); </p></li><li><p><span style="color:red;font-weight:900">【强制】</span>IDE 的 text file encoding 设置为 UTF-8; IDE 中文件的换行符使用 Unix 格式，不要使用 Windows 格式。</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>单个方法的总行数不超过 80 行。</p><p><span style="color:#977c00">说明：</span>除注释之外的方法签名、左右大括号、方法内代码、空行、回车及任何不可见字符的总行数不超过80 行。</p><p><span style="color:green">正例：</span> 代码逻辑分清红花和绿叶，个性和共性，绿叶逻辑单独出来成为额外方法，使主干代码更加清晰；共性逻辑抽取成为共性方法，便于复用和维护。</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>没有必要增加若干空格来使变量的赋值等号与上一行对应位置的等号对齐。</p><p><span style="color:green">正例：</span> </p><pre><code class="java">int one = 1;long two = 2L;float three = 3F;StringBuilder sb = new StringBuilder();</code></pre><p><span style="color:#977c00">说明：</span>增加 sb 这个变量，如果需要对齐，则给 one、two、three 都要增加几个空格，在变量比较多的情况下，是非常累赘的事情。</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>不同逻辑、不同语义、不同业务的代码之间插入一个空行分隔开来以提升可读性。</p><p><span style="color:#977c00">说明：</span>任何情形，没有必要插入&#x3D;&#x3D;多个空行&#x3D;&#x3D;进行隔开。</p></li></ol><h3 id="四-OOP-规约"><a href="#四-OOP-规约" class="headerlink" title="(四) OOP 规约"></a>(四) OOP 规约</h3><ol><li><p><span style="color:red;font-weight:900">【强制】</span>避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用&#x3D;&#x3D;类名&#x3D;&#x3D;来访问即可。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>所有的覆写方法，必须加@Override 注解。</p><p>说明：getObject()与 get0bject()的问题。一个是字母的 O，一个是数字的 0，加@Override 可以准确判断是否覆盖成功。另外，如果在抽象类中对方法签名进行修改，其实现类会马上编译报错。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>相同参数类型，相同业务含义，才可以使用 Java 的可变参数，避免使用 Object。</p><p><span style="color:#977c00">说明：</span>可变参数必须放置在参数列表的最后。（建议开发者尽量不用可变参数编程）</p><p><span style="color:green">正例: </span>public List<User> listUsers(String type, Long… ids) {…}</User></p></li><li><p><span style="color:red;font-weight:900">【强制】</span>外部正在调用或者二方库依赖的接口，不允许修改方法签名，避免对接口调用方产生影响。接口过时必须@Deprecated 注解，并清晰地说明采用的新接口或者新服务是什么。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>不能使用过时的类或方法。</p><p><span style="color:#977c00">说明：</span>java.net.URLDecoder 中的方法 decode(String encodeStr) 这个方法已经过时，应该使用双参数decode(String source, String encode)。接口提供方既然明确是过时接口，那么有义务同时提供新的接口；作为调用方来说，有义务去考证过时方法的新实现是什么。</p></li><li><p>【强制】Object 的 equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用 equals。</p><p><span style="color:green">正例: </span>“test”.equals(object);</p><p><span style="color:red">反例: </span>object.equals(“test”);</p><p><span style="color:#977c00">说明：</span>推荐使用 JDK7 引入的工具类 java.util.Objects#equals(Object a, Object b)</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>所有整型包装类对象之间&#x3D;&#x3D;值的比较&#x3D;&#x3D;，全部使用 equals 方法比较。</p><p><span style="color:#977c00">说明：</span>对于 Integer var &#x3D; ? 在&#x3D;&#x3D;-128 至 127&#x3D;&#x3D; 之间的赋值，Integer 对象是在 IntegerCache.cache 产生，会复用已有对象，这个区间内的 Integer 值可以直接使用&#x3D;&#x3D;进行判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用 equals 方法进行判断。 </p></li><li><p><span style="color:red;font-weight:900">【强制】</span>任何货币金额，均以最小货币单位且整型类型来进行存储。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>浮点数之间的等值判断，基本数据类型不能用&#x3D;&#x3D;来比较，包装数据类型不能用 equals来判断。</p><p><span style="color:#977c00">说明：</span>浮点数采用“尾数+阶码”的编码方式，类似于科学计数法的“有效数字+指数”的表示方式。二进制无法精确表示大部分的十进制小数，具体原理参考《码出高效》。</p><p><span style="color:red">反例：</span></p><pre><code class="java">float a = 1.0F - 0.9F;float b = 0.9F - 0.8F;if (a == b) &#123;    // 预期进入此代码块，执行其它业务逻辑    // 但事实上 a==b 的结果为 false&#125;Float x = Float.valueOf(a);Float y = Float.valueOf(b);if (x.equals(y)) &#123;    // 预期进入此代码块，执行其它业务逻辑    // 但事实上 equals 的结果为 false&#125;</code></pre><p><span style="color:green">正例: </span></p><p>​(1) 指定一个误差范围，两个浮点数的差值在此范围之内，则认为是相等的。</p><pre><code class="java">float a = 1.0F - 0.9F;float b = 0.9F - 0.8F;float diff = 1e-6F;if (Math.abs(a - b) &lt; diff) &#123; System.out.println(&quot;true&quot;);&#125;</code></pre><p>​(2) 使用 BigDecimal 来定义值，再进行浮点数的运算操作。</p><pre><code class="java">BigDecimal a = new BigDecimal(&quot;1.0&quot;);BigDecimal b = new BigDecimal(&quot;0.9&quot;);BigDecimal c = new BigDecimal(&quot;0.8&quot;);BigDecimal x = a.subtract(b);BigDecimal y = b.subtract(c);if (x.compareTo(y) == 0) &#123; System.out.println(&quot;true&quot;);&#125;</code></pre></li><li><p><span style="color:red;font-weight:900">【强制】</span>如上所示 BigDecimal 的等值比较应使用 compareTo()方法，而不是 equals()方法。</p><p><span style="color:#977c00">说明：</span>equals()方法会比较值和精度<span style="font-size:14px">（1.0 与 1.00 返回结果为 false）</span>，而 compareTo()则会忽略精度。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>定义数据对象 DO 类时，属性类型要与数据库字段类型相匹配。</p><p><span style="color:green">正例: </span>数据库字段的 bigint 必须与类属性的 Long 类型相对应。</p><p><span style="color:red">反例：</span>某个案例的数据库表 id 字段定义类型 bigint unsigned，实际类对象属性为 Integer，随着 id 越来越大，超过 Integer 的表示范围而溢出成为负数。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>禁止使用构造方法 BigDecimal(double)的方式把 double 值转化为 BigDecimal 对象。</p><p><span style="color:#977c00">说明：</span>BigDecimal(double)存在精度损失风险，在精确计算或值比较的场景中可能会导致业务逻辑异常。</p><p>如：BigDecimal g &#x3D; new BigDecimal(0.1F); 实际的存储值为：0.10000000149</p><p><span style="color:green">正例: </span>优先推荐入参为 String 的构造方法，或使用 BigDecimal 的 valueOf 方法，此方法内部其实执行了Double 的 toString，而 Double 的 toString 按 double 的实际能表达的精度对尾数进行了截断。</p><pre><code class="java">BigDecimal recommend1 = new BigDecimal(&quot;0.1&quot;);BigDecimal recommend2 = BigDecimal.valueOf(0.1);</code></pre></li><li><p>关于基本数据类型与包装数据类型的使用标准如下：</p><p>1） <span style="color:red;font-weight:900">【强制】</span>所有的 POJO 类属性必须使用包装数据类型。</p><p>2） <span style="color:red;font-weight:900">【强制】</span>RPC 方法的返回值和参数必须使用包装数据类型。</p><p>3） <span style="color:#ffc000;font-weight:900">【推荐】</span>所有的局部变量使用基本数据类型。</p><p>​<span style="color:#977c00">说明：</span>POJO 类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何 NPE 问题，或者入库检查，都由使用者来保证。</p><p>​<span style="color:green">正例: </span>数据库的查询结果可能是 null，因为自动拆箱，用基本数据类型接收有 NPE 风险。</p><p>​<span style="color:red">反例：</span>某业务的交易报表上显示成交总额涨跌情况，即正负 x%，x 为基本数据类型，调用的 RPC 服务，调用不成功时，返回的是默认值，页面显示为 0%，这是不合理的，应该显示成中划线-。所以包装数据类型的 null 值，能够表示额外的信息，如：远程调用失败，异常退出。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>定义 DO&#x2F;DTO&#x2F;VO 等 POJO 类时，不要设定任何属性&#x3D;&#x3D;默认值&#x3D;&#x3D;。</p><p><span style="color:red">反例: </span>POJO 类的 createTime 默认值为 new Date()，但是这个属性在数据提取时并没有置入具体值，在更新其它字段时又附带更新了此字段，导致创建时间被修改成当前时间。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>序列化类新增属性时，请不要修改 serialVersionUID 字段，避免反序列失败；如果完全不兼容升级，避免反序列化混乱，那么请修改 serialVersionUID 值。</p><p><span style="color:#977c00">说明：</span>注意 serialVersionUID 不一致会抛出序列化运行时异常。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在 init 方法中。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>POJO 类必须写 toString 方法。使用 IDE 中的工具：source&gt; generate toString时，如果继承了另一个 POJO 类，注意在前面加一下 super.toString。</p><p><span style="color:#977c00">说明：</span>在方法执行抛出异常时，可以直接调用 POJO 的 toString()方法打印其属性值，便于排查问题。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>禁止在 POJO 类中，同时存在对应属性 xxx 的 isXxx()和 getXxx()方法。</p><p><span style="color:#977c00">说明：</span>框架在调用属性 xxx 的提取方法时，并不能确定哪个方法一定是被优先调用到的。</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>使用索引访问用 String 的 split 方法得到的数组时，需做最后一个分隔符后有无内容的检查，否则会有抛 IndexOutOfBoundsException 的风险。</p><p><span style="color:#977c00">说明：</span></p><pre><code class="java">String str = &quot;a,b,c,,&quot;;String[] ary = str.split(&quot;,&quot;);// 预期大于 3，结果是 3System.out.println(ary.length);</code></pre></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，便于阅读，此条规则优先于下一条。</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span> 类内方法定义的顺序依次是：公有方法或保护方法 &gt; 私有方法 &gt; getter &#x2F; setter方法。</p><p><span style="color:#977c00">说明：</span>公有方法是类的调用者和维护者最关心的方法，首屏展示最好；保护方法虽然只是子类关心，也可能是“模板设计模式”下的核心方法；而私有方法外部一般不需要特别关心，是一个黑盒实现；因为承载的信息价值较低，所有 Service 和 DAO 的 getter&#x2F;setter 方法放在类体最后。</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>setter 方法中，参数名称与类成员变量名称一致，this.成员名 &#x3D; 参数名。在getter&#x2F;setter 方法中，不要增加业务逻辑，增加排查问题的难度。</p><p><span style="color:red">反例：</span></p><pre><code class="java">public Integer getData () &#123;    if (condition) &#123;        return this.data + 100;    &#125; else &#123;        return this.data - 100;    &#125;&#125;</code></pre></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>循环体内，字符串的连接方式，使用 StringBuilder 的 append 方法进行扩展。</p><p><span style="color:#977c00">说明：</span>下例中，反编译出的字节码文件显示每次循环都会 new 出一个 StringBuilder 对象，然后进行 append操作，最后通过 toString 方法返回 String 对象，造成内存资源浪费。</p><p><span style="color:red">反例：</span></p><pre><code class="java">String str = &quot;start&quot;;for (int i = 0; i &lt; 100; i++) &#123;    str = str + &quot;hello&quot;;&#125;</code></pre></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>final 可以声明类、成员变量、方法、以及本地变量，下列情况使用 final 关键字：</p><p>1） 不允许被继承的类，如：String 类。</p><p>2） 不允许修改引用的域对象，如：POJO 类的域变量。 </p><p>3） 不允许被覆写的方法，如：POJO 类的 setter 方法。</p><p>4） 不允许运行过程中重新赋值的局部变量。 </p><p>5） 避免上下文重复使用一个变量，使用 final 关键字可以强制重新定义一个变量，方便更好地进行重构。</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>慎用 Object 的 clone 方法来拷贝对象。</p><p><span style="color:#977c00">说明：</span>对象 clone 方法默认是浅拷贝，若想实现深拷贝，需覆写 clone 方法实现域对象的深度遍历式拷贝。</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>类成员与方法访问控制从严：</p><p>1） 如果不允许外部直接通过 new 来创建对象，那么构造方法必须是 private。 </p><p>2） 工具类不允许有 public 或 default 构造方法。</p><p>3） 类非 static 成员变量并且与子类共享，必须是 protected。 </p><p>4） 类非 static 成员变量并且仅在本类使用，必须是 private。</p><p>5） 类 static 成员变量如果仅在本类使用，必须是 private。 </p><p>6） 若是 static 成员变量，考虑是否为 final。 </p><p>7） 类成员方法只供类内部调用，必须是 private。 </p><p>8） 类成员方法只对继承类公开，那么限制为 protected。</p><p><span style="color:#977c00">说明：</span>任何类、方法、参数、变量，严控访问范围。过于宽泛的访问范围，不利于模块解耦。思考：如果是一个 private 的方法，想删除就删除，可是一个 public 的 service 成员方法或成员变量，删除一下，不得手心冒点汗吗？变量像自己的小孩，尽量在自己的视线内，变量作用域太大，无限制的到处跑，那么你会担心的。</p></li></ol><h3 id="五-日期时间"><a href="#五-日期时间" class="headerlink" title="(五) 日期时间"></a>(五) 日期时间</h3><ol><li><p><span style="color:red;font-weight:900">【强制】</span>日期格式化时，传入 pattern 中表示年份统一使用小写的 y。</p><p><span style="color:#977c00">说明：</span>日期格式化时，yyyy 表示当天所在的年，而大写的 YYYY 代表是 week in which year（JDK7 之后引入的概念），意思是当天所在的周属于的年份，一周从周日开始，周六结束，只要本周跨年，返回的 YYYY就是下一年。</p><p><span style="color:green">正例：</span> 表示日期和时间的格式如下所示：</p><pre><code class="java">new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;)</code></pre></li><li><p><span style="color:red;font-weight:900">【强制】</span>在日期格式中分清楚大写的 M 和小写的 m，大写的 H 和小写的 h 分别指代的意义。</p><p><span style="color:#977c00">说明：</span>日期格式中的这两对字母表意如下：</p><p>​1） 表示月份是大写的 M； </p><p>​2） 表示分钟则是小写的 m； </p><p>​3） 24 小时制的是大写的 H； </p><p>​4） 12 小时制的则是小写的 h。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>获取当前毫秒数：System.currentTimeMillis(); 而不是 new Date().getTime()。</p><p><span style="color:#977c00">说明：</span>如果想获取更加精确的纳秒级时间值，使用 System.nanoTime 的方式。在 JDK8 中，针对统计时间等场景，推荐使用 Instant 类。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>不允许在程序任何地方中使用：1）java.sql.Date。 2）java.sql.Time。 3）java.sql.Timestamp。</p><p><span style="color:#977c00">说明：</span>第 1 个不记录时间，getHours()抛出异常；第 2 个不记录日期，getYear()抛出异常；第 3 个在构造方法 super((time&#x2F;1000)*1000)，在 Timestamp 属性 fastTime 和 nanos 分别存储秒和纳秒信息。</p><p><span style="color:red">反例：</span> java.util.Date.after(Date)进行时间比较时，当入参是 java.sql.Timestamp 时，会触发 JDK BUG(JDK9 已修复)，可能导致比较时的意外结果。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>不要在程序中写死一年为 365 天，避免在公历闰年时出现日期转换错误或程序逻辑错误。</p><p><span style="color:green">正例：</span> </p><pre><code class="java">// 获取今年的天数int daysOfThisYear = LocalDate.now().lengthOfYear();// 获取指定某年的天数LocalDate.of(2011, 1, 1).lengthOfYear();</code></pre><p><span style="color:red">反例：</span></p><pre><code class="java">// 第一种情况：在闰年 366 天时，出现数组越界异常int[] dayArray = new int[365];// 第二种情况：一年有效期的会员制，今年 1 月 26 日注册，硬编码 365 返回的却是 1 月 25 日Calendar calendar = Calendar.getInstance();calendar.set(2020, 1, 26);calendar.add(Calendar.DATE, 365);</code></pre></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>避免公历闰年 2 月问题。闰年的 2 月份有 29 天，一年后的那一天不可能是 2 月 29日。</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>使用枚举值来指代月份。如果使用数字，注意 Date，Calendar 等日期相关类的月份month 取值在 0-11 之间。</p><p><span style="color:#977c00">说明：</span>参考 JDK 原生注释，Month value is 0-based. e.g., 0 for January.</p><p><span style="color:green">正例：</span>  Calendar.JANUARY，Calendar.FEBRUARY，Calendar.MARCH 等来指代相应月份来进行传参或比较。</p></li></ol><h3 id="六-集合处理"><a href="#六-集合处理" class="headerlink" title="(六) 集合处理"></a>(六) 集合处理</h3><ol><li><p><span style="color:red;font-weight:900">【强制】</span>关于 hashCode 和 equals 的处理，遵循如下规则：</p><p>1） 只要覆写 equals，就必须覆写 hashCode。 </p><p>2） 因为 Set 存储的是不重复的对象，依据 hashCode 和 equals 进行判断，所以 Set 存储的对象必须覆写这两种方法。</p><p>3） 如果自定义对象作为 Map 的键，那么必须覆写 hashCode 和 equals。</p><p><span style="color:#977c00">说明：</span>String 因为覆写了 hashCode 和 equals 方法，所以可以愉快地将 String 对象作为 key 来使用。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>判断所有集合内部的元素是否为空，使用 isEmpty()方法，而不是 size()&#x3D;&#x3D;0 的方式。</p><p><span style="color:#977c00">说明：</span>在某些集合中，前者的时间复杂度为 O(1)，而且可读性更好。</p><p><span style="color:green">正例：</span> </p><pre><code class="java">Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(16);if(map.isEmpty()) &#123;    System.out.println(&quot;no element in this map.&quot;);&#125;</code></pre></li><li><p><span style="color:red;font-weight:900">【强制】</span>在使用 java.util.stream.Collectors 类的 toMap()方法转为 Map 集合时，一定要使用含有参数类型为 BinaryOperator，参数名为 mergeFunction 的方法，否则当出现相同 key值时会抛出 IllegalStateException 异常。</p><p><span style="color:#977c00">说明：</span>参数 mergeFunction 的作用是当出现 key 重复时，自定义对 value 的处理策略。</p><p><span style="color:green">正例：</span> </p><pre><code class="java">List&lt;Pair&lt;String, Double&gt;&gt; pairArrayList = new ArrayList&lt;&gt;(3);pairArrayList.add(new Pair&lt;&gt;(&quot;version&quot;, 12.10));pairArrayList.add(new Pair&lt;&gt;(&quot;version&quot;, 12.19));pairArrayList.add(new Pair&lt;&gt;(&quot;version&quot;, 6.28));Map&lt;String, Double&gt; map = pairArrayList.stream().collect(// 生成的 map 集合中只有一个键值对：&#123;version=6.28&#125;Collectors.toMap(Pair::getKey, Pair::getValue, (v1, v2) -&gt; v2));</code></pre><p><span style="color:red">反例：</span></p><pre><code class="java">String[] departments = new String[] &#123;&quot;iERP&quot;, &quot;iERP&quot;, &quot;EIBU&quot;&#125;;// 抛出 IllegalStateException 异常Map&lt;Integer, String&gt; map = Arrays.stream(departments)    .collect(Collectors.toMap(String::hashCode, str -&gt; str));</code></pre></li><li><p><span style="color:red;font-weight:900">【强制】</span>在使用 java.util.stream.Collectors 类的 toMap()方法转为 Map 集合时，一定要注意当 value 为 null 时会抛 NPE 异常。</p><p><span style="color:#977c00">说明：</span>在 java.util.HashMap 的 merge 方法里会进行如下的判断：</p><pre><code class="java">if (value == null || remappingFunction == null)&#123;    throw new NullPointerException();&#125;</code></pre><p><span style="color:red">反例：</span></p><pre><code class="java">List&lt;Pair&lt;String, Double&gt;&gt; pairArrayList = new ArrayList&lt;&gt;(2);pairArrayList.add(new Pair&lt;&gt;(&quot;version1&quot;, 8.3));pairArrayList.add(new Pair&lt;&gt;(&quot;version2&quot;, null));Map&lt;String, Double&gt; map = pairArrayList.stream().collect(// 抛出 NullPointerException 异常Collectors.toMap(Pair::getKey, Pair::getValue, (v1, v2) -&gt; v2));</code></pre></li><li><p><span style="color:red;font-weight:900">【强制】</span>ArrayList 的 subList 结果不可强转成 ArrayList，否则会抛出 ClassCastException 异 常：java.util.RandomAccessSubList cannot be cast to java.util.ArrayList。</p><p><span style="color:#977c00">说明：</span>subList()返回的是 ArrayList 的内部类 SubList，并不是 ArrayList 本身，而是 ArrayList 的一个视图，对于 SubList 的所有操作最终会反映到原列表上。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>使用 Map 的方法 keySet()&#x2F;values()&#x2F;entrySet()返回集合对象时，不可以对其进行添加元素操作，否则会抛出 UnsupportedOperationException 异常。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>Collections 类返回的对象，如：emptyList()&#x2F;singletonList()等都是 immutable list，不可对其进行添加或者删除元素的操作。</p><p><span style="color:red">反例：</span>如果查询无结果，返回 Collections.emptyList()空集合对象，调用方一旦进行了添加元素的操作，就会触发 UnsupportedOperationException 异常。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>在 subList 场景中，&#x3D;&#x3D;高度注意&#x3D;&#x3D;对父集合元素的增加或删除，均会导致子列表的遍历、增加、删除产生 ConcurrentModificationException 异常。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>使用集合转数组的方法，必须使用集合的 toArray(T[] array)，传入的是类型完全一致、长度为 0 的空数组。</p><p><span style="color:red">反例：</span>直接使用 toArray 无参方法存在问题，此方法返回值只能是 Object[]类，若强转其它类型数组将出现ClassCastException 错误。</p><p><span style="color:green">正例：</span> </p><pre><code class="java">List&lt;String&gt; list = new ArrayList&lt;&gt;(2);list.add(&quot;guan&quot;);list.add(&quot;bao&quot;);String[] array = list.toArray(new String[0]);</code></pre><p><span style="color:#977c00">说明：</span>使用 toArray 带参方法，数组空间大小的 length： </p><p>​1） &#x3D;&#x3D;等于 0&#x3D;&#x3D;，动态创建与 size 相同的数组，性能最好。</p><p>​2） &#x3D;&#x3D;大于 0&#x3D;&#x3D; 但小于 size，重新创建大小等于 size 的数组，增加 GC 负担。</p><p>​3） &#x3D;&#x3D;等于 size&#x3D;&#x3D;，在高并发情况下，数组创建完成之后，size 正在变大的情况下，负面影响与 2 相同。</p><p>​4） &#x3D;&#x3D;大于 size&#x3D;&#x3D;，空间浪费，且在 size 处插入 null 值，存在 NPE 隐患。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>在使用 Collection 接口任何实现类的 addAll()方法时，都要对输入的集合参数进行NPE 判断。</p><p><span style="color:#977c00">说明：</span>在 ArrayList#addAll 方法的第一行代码即 Object[] a &#x3D; c.toArray(); 其中 c 为输入集合参数，如果为 null，则直接抛出异常。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>使用工具类 Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方法，它的 add&#x2F;remove&#x2F;clear 方法会抛出 UnsupportedOperationException 异常。</p><p><span style="color:#977c00">说明：</span>asList 的返回对象是一个 Arrays 内部类，并没有实现集合的修改方法。Arrays.asList 体现的是适配器模式，只是转换接口，后台的数据仍是数组。</p><pre><code class="java"> String[] str = new String[] &#123; &quot;chen&quot;, &quot;yang&quot;, &quot;hao&quot; &#125;; List list = Arrays.asList(str);</code></pre><p>第一种情况：list.add(“yangguanbao”); 运行时异常。</p><p>第二种情况：str[0] &#x3D; “change”; 也会随之修改，反之亦然。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>泛型通配符&lt;? extends T&gt;来接收返回的数据，此写法的泛型集合不能使用 add 方法， 而&lt;? super T&gt;不能使用 get 方法，两者在接口调用赋值的场景中容易出错。</p><p><span style="color:#977c00">说明：</span>扩展说一下 PECS(Producer Extends Consumer Super)原则：第一、频繁往外读取内容的，适合用&lt;? extends T&gt;。第二、经常往里插入的，适合用&lt;? super T&gt;</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>在无泛型限制定义的集合赋值给泛型限制的集合时，在使用集合元素时，需要进行instanceof 判断，避免抛出 ClassCastException 异常。</p><p><span style="color:#977c00">说明：</span>毕竟泛型是在 JDK5 后才出现，考虑到向前兼容，编译器是允许非泛型集合与泛型集合互相赋值。</p><p><span style="color:red">反例：</span></p><pre><code class="java">List&lt;String&gt; generics = null;List notGenerics = new ArrayList(10);notGenerics.add(new Object());notGenerics.add(new Integer(1));generics = notGenerics;// 此处抛出 ClassCastException 异常String string = generics.get(0);</code></pre></li><li><p><span style="color:red;font-weight:900">【强制】</span>不要在 foreach 循环里进行元素的 remove&#x2F;add 操作。remove 元素请使用 Iterator方式，如果并发操作，需要对 Iterator 对象加锁。</p><p><span style="color:green">正例：</span> </p><pre><code class="java">List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;1&quot;);list.add(&quot;2&quot;);Iterator&lt;String&gt; iterator = list.iterator();while (iterator.hasNext()) &#123;    String item = iterator.next();    if (删除元素的条件) &#123;        iterator.remove();    &#125;&#125;</code></pre><p><span style="color:red">反例：</span></p><pre><code class="java">for (String item : list) &#123;    if (&quot;1&quot;.equals(item)) &#123;        list.remove(item);    &#125;&#125;</code></pre><p><span style="color:#977c00">说明：</span>以上代码的执行结果肯定会出乎大家的意料，那么试一下把“1”换成“2”，会是同样的结果吗？</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>在 JDK7 版本及以上，Comparator 实现类要满足如下三个条件，不然 Arrays.sort，Collections.sort 会抛 IllegalArgumentException 异常。</p><p><span style="color:#977c00">说明：</span>三个条件如下 </p><p>​1） x，y 的比较结果和 y，x 的比较结果相反。</p><p>​2） x&gt;y，y&gt;z，则 x&gt;z。 </p><p>​3） x&#x3D;y，则 x，z 比较结果和 y，z 比较结果相同。</p><p><span style="color:red">反例：</span>下例中没有处理相等的情况，交换两个对象判断结果并不互反，不符合第一个条件，在实际使用中可能会出现异常。</p><pre><code class="java">new Comparator&lt;Student&gt;() &#123;    @Override    public int compare(Student o1, Student o2) &#123;        return o1.getId() &gt; o2.getId() ? 1 : -1;    &#125;&#125;;</code></pre></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>集合泛型定义时，在 JDK7 及以上，使用 diamond 语法或全省略。</p><p><span style="color:#977c00">说明：</span>菱形泛型，即 diamond，直接使用&lt;&gt;来指代前边已经指定的类型。</p><p><span style="color:green">正例：</span> </p><pre><code class="java">// diamond 方式，即&lt;&gt;HashMap&lt;String, String&gt; userCache = new HashMap&lt;&gt;(16);// 全省略方式ArrayList&lt;User&gt; users = new ArrayList(10);</code></pre></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>集合初始化时，指定集合初始值大小。</p><p><span style="color:#977c00">说明：</span>HashMap 使用 HashMap(int initialCapacity) 初始化，如果暂时无法确定集合大小，那么指定默认值（16）即可。</p><p><span style="color:green">正例: </span> initialCapacity &#x3D; (需要存储的元素个数 &#x2F; 负载因子) + 1。注意负载因子（即 loader factor）默认为 0.75，如果暂时无法确定初始值大小，请设置为 16（即默认值）。</p><p><span style="color:red">反例：</span> HashMap 需要放置 1024 个元素，由于没有设置容量初始大小，随着元素增加而被迫不断扩容，resize()方法总共会调用 8 次，反复重建哈希表和数据迁移。当放置的集合元素个数达千万级时会影响程序性能。</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>使用 entrySet 遍历 Map 类集合 KV，而不是 keySet 方式进行遍历。</p><p><span style="color:#977c00">说明：</span>keySet 其实是遍历了 2 次，一次是转为 Iterator 对象，另一次是从 hashMap 中取出 key 所对应的value。而 entrySet 只是遍历了一次就把 key 和 value 都放到了 entry 中，效率更高。如果是 JDK8，使用Map.forEach 方法。</p><p><span style="color:green">正例: </span> values()返回的是 V 值集合，是一个 list 集合对象；keySet()返回的是 K 值集合，是一个 Set 集合对象；entrySet()返回的是 K-V 值组合集合。</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>高度注意 Map 类集合 K&#x2F;V 能不能存储 null 值的情况，如下表格：</p><table><thead><tr><th>集合类</th><th>Key</th><th>Value</th><th>Super</th><th>说明</th></tr></thead><tbody><tr><td>Hashtable</td><td><span style="color:red">不允许为 null</span></td><td><span style="color:red">不允许为 null</span></td><td>Dictionary</td><td>线程安全</td></tr><tr><td>ConcurrentHashMap</td><td><span style="color:red">不允许为 null</span></td><td><span style="color:red">不允许为 null</span></td><td>AbstractMap</td><td>锁分段技术（JDK8:CAS）</td></tr><tr><td>TreeMap</td><td><span style="color:red">不允许为 null</span></td><td><span style="color:blue">允许为 null</span></td><td>AbstractMap</td><td>线程不安全</td></tr><tr><td>HashMap</td><td><span style="color:blue">允许为 null</span></td><td><span style="color:blue">允许为 null</span></td><td>AbstractMap</td><td>线程不安全</td></tr></tbody></table><p><span style="color:red">反例：</span>由于 HashMap 的干扰，很多人认为 ConcurrentHashMap 是可以置入 null 值，而事实上，存储null 值时会抛出 NPE 异常。</p></li><li><p><span style="color:#76923c;font-weight:900">【参考】</span>合理利用好集合的有序性(sort)和稳定性(order)，避免集合的无序性(unsort)和不稳定性(unorder)带来的负面影响。</p><p><span style="color:#977c00">说明：</span>有序性是指遍历的结果是按某种比较规则依次排列的。稳定性指集合每次遍历的元素次序是一定的。</p><p>如：ArrayList 是 order&#x2F;unsort；HashMap 是 unorder&#x2F;unsort；TreeSet 是 order&#x2F;sort。</p></li><li><p><span style="color:#76923c;font-weight:900">【参考】</span>利用 Set 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 List 的contains()进行遍历去重或者判断包含操作。</p></li></ol><h3 id="七-并发处理"><a href="#七-并发处理" class="headerlink" title="(七) 并发处理"></a>(七) 并发处理</h3><ol><li><p><span style="color:red;font-weight:900">【强制】</span>获取单例对象需要保证线程安全，其中的方法也要保证线程安全。</p><p><span style="color:#977c00">说明：</span>资源驱动类、工具类、单例工厂类都需要注意。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。</p><p><span style="color:green">正例：</span> 自定义线程工厂，并且根据外部特征进行分组，比如，来自同一机房的调用，把机房编号赋值给 whatFeatureOfGroup</p><pre><code class="java">public class UserThreadFactory implements ThreadFactory &#123;    private final String namePrefix;    private final AtomicInteger nextId = new AtomicInteger(1);    // 定义线程组名称，在利用 jstack 来排查问题时，非常有帮助    UserThreadFactory(String whatFeatureOfGroup) &#123;        namePrefix = &quot;From UserThreadFactory&#39;s &quot; + whatFeatureOfGroup + &quot;-Worker-&quot;;    &#125;    @Override    public Thread newThread(Runnable task) &#123;        String name = namePrefix + nextId.getAndIncrement();        // 以下这句有问题?        Thread thread = new Thread(null, task, name, 0, false);        System.out.println(thread.getName());        return thread;    &#125;&#125;</code></pre></li><li><p><span style="color:red;font-weight:900">【强制】</span>线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。</p><p><span style="color:#977c00">说明：</span>线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p><p><span style="color:#977c00">说明：</span>Executors 返回的线程池对象的弊端如下： </p><p>1） <span style="color:#c7254e">FixedThreadPool</span> 和 <span style="color:#c7254e">SingleThreadPool</span>：</p><p>​允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。 </p><p>2） <span style="color:#c7254e">CachedThreadPool</span>：</p><p>​允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>SimpleDateFormat 是线程不安全的类，一般不要定义为 static 变量，如果定义为 static，必须加锁，或者使用 DateUtils 工具类。</p><p><span style="color:green">正例：</span> 注意线程安全，使用 DateUtils。亦推荐如下处理：</p><pre><code class="java">private static final ThreadLocal&lt;DateFormat&gt; df = new ThreadLocal&lt;DateFormat&gt;() &#123;    @Override    protected DateFormat initialValue() &#123;        return new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);    &#125;&#125;;</code></pre><p><span style="color:#977c00">说明：</span>如果是 JDK8 的应用，可以使用 Instant 代替 Date，LocalDateTime 代替 Calendar，DateTimeFormatter 代替 SimpleDateFormat，官方给出的解释：simple beautiful strong immutable thread-safe。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>必须回收自定义的 ThreadLocal 变量，尤其在线程池场景下，线程经常会被复用，如果不清理自定义的 ThreadLocal 变量，可能会影响后续业务逻辑和造成内存泄露等问题。尽量在代理中使用 try-finally 块进行回收。</p><p><span style="color:green">正例：</span> </p><pre><code class="java">objectThreadLocal.set(userInfo);try &#123;    // ...&#125; finally &#123;    objectThreadLocal.remove();&#125;</code></pre></li><li><p><span style="color:red;font-weight:900">【强制】</span>高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。</p><p><span style="color:#977c00">说明：</span>尽可能使加锁的代码块工作量尽可能的小，避免在锁代码块中调用 RPC 方法。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。</p><p><span style="color:#977c00">说明：</span>线程一需要对表 A、B、C 依次全部加锁后才可以进行更新操作，那么线程二的加锁顺序也必须是 A、 B、C，否则可能出现死锁。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>在使用阻塞等待获取锁的方式中，必须在 try 代码块之外，并且在加锁方法与 try 代码块之间没有任何可能抛出异常的方法调用，避免加锁成功后，在 finally 中无法解锁。</p><p><span style="color:#977c00">说明一：</span>如果在 lock 方法与 try 代码块之间的方法调用抛出异常，那么无法解锁，造成其它线程无法成功获取锁。</p><p><span style="color:#977c00">说明二：</span>如果 lock 方法在 try 代码块之内，可能由于其它方法抛出异常，导致在 finally 代码块中，unlock对未加锁的对象解锁，它会调用 AQS 的 tryRelease 方法（取决于具体实现类），抛出IllegalMonitorStateException 异常。</p><p><span style="color:#977c00">说明三：</span>在 Lock 对象的 lock 方法实现中可能抛出 unchecked 异常，产生的后果与说明二相同。</p><p><span style="color:green">正例：</span> </p><pre><code class="java">Lock lock = new XxxLock();// ...lock.lock();try &#123;    doSomething();    doOthers();&#125; finally &#123;    lock.unlock();&#125;</code></pre><p><span style="color:red">反例：</span></p><pre><code class="java">Lock lock = new XxxLock();// ...try &#123;    // 如果此处抛出异常，则直接执行 finally 代码块    doSomething();    // 无论加锁是否成功，finally 代码块都会执行    lock.lock();    doOthers();&#125; finally &#123;    lock.unlock();&#125;</code></pre></li><li><p><span style="color:red;font-weight:900">【强制】</span>在使用尝试机制来获取锁的方式中，进入业务代码块之前，必须先判断当前线程是否持有锁。锁的释放规则与锁的阻塞等待方式相同。</p><p><span style="color:#977c00">说明：</span>Lock 对象的 unlock 方法在执行时，它会调用 AQS 的 tryRelease 方法（取决于具体实现类），如果当前线程不持有锁，则抛出 IllegalMonitorStateException 异常。</p><p><span style="color:green">正例：</span> </p><pre><code class="java">Lock lock = new XxxLock();// ...boolean isLocked = lock.tryLock();if (isLocked) &#123;    try &#123;        doSomething();        doOthers();    &#125; finally &#123;        lock.unlock();    &#125;&#125;</code></pre></li><li><p><span style="color:red;font-weight:900">【强制】</span>并发修改同一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用 version 作为更新依据。</p><p><span style="color:#977c00">说明：</span>如果每次访问冲突概率小于 20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次数不得小于3 次。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>多线程并行处理定时任务时，Timer 运行多个 TimeTask 时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用 ScheduledExecutorService 则没有这个问题。</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>资金相关的金融敏感信息，使用悲观锁策略。</p><p><span style="color:#977c00">说明：</span>乐观锁在获得锁的同时已经完成了更新操作，校验逻辑容易出现漏洞，另外，乐观锁对冲突的解决策略有较复杂的要求，处理不当容易造成系统压力或数据异常，所以资金相关的金融敏感信息不建议使用乐观锁更新。</p><p><span style="color:green">正例：</span> 悲观锁遵循一锁、二判、三更新、四释放的原则。</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>使用 CountDownLatch 进行异步转同步操作，每个线程退出前必须调用 countDown 方法，线程执行代码注意 catch 异常，确保 countDown 方法被执行到，避免主线程无法执行至await 方法，直到超时才返回结果。</p><p><span style="color:#977c00">说明：</span>注意，子线程抛出异常堆栈，不能在主线程 try-catch 到。</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>避免 Random 实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一 seed导致的性能下降。</p><p><span style="color:#977c00">说明：</span>Random 实例包括 java.util.Random 的实例或者 Math.random()的方式。</p><p><span style="color:green">正例：</span> 在 JDK7 之后，可以直接使用 API ThreadLocalRandom，而在 JDK7 之前，需要编码保证每个线程持有一个单独的 Random 实例。</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>通过双重检查锁（double-checked locking）（在并发场景下）存在延迟初始化的优化问题隐患（可参考 The “Double-Checked Locking is Broken” Declaration），推荐解决方案中较为简单一种（适用于 JDK5 及以上版本），将目标属性声明为 volatile 型，比如将 helper 的属性声明修改为<code>private volatile Helper helper = null;</code>。 </p><p><span style="color:green">正例：</span> </p><pre><code class="java">public class LazyInitDemo &#123;    private volatile Helper helper = null;    public Helper getHelper() &#123;        if (helper == null) &#123;            synchronized (this) &#123;                if (helper == null) &#123; helper = new Helper(); &#125;            &#125;        &#125;        return helper;    &#125;    // other methods and fields... &#125;</code></pre></li><li><p><span style="color:#76923c;font-weight:900">【参考】</span>volatile 解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题，但是如果多写，同样无法解决线程安全问题。</p><p><span style="color:#977c00">说明：</span>如果是 count++操作，使用如下类实现：AtomicInteger count &#x3D; new AtomicInteger(); count.addAndGet(1); 如果是 JDK8，推荐使用 LongAdder 对象，比 AtomicLong 性能更好（减少乐观锁的重试次数）。</p></li><li><p><span style="color:#76923c;font-weight:900">【参考】</span>HashMap 在容量不够进行 resize 时由于高并发可能出现死链，导致 CPU 飙升，在开发过程中注意规避此风险。</p></li><li><p><span style="color:#76923c;font-weight:900">【参考】</span>ThreadLocal 对象使用 static 修饰，ThreadLocal 无法解决共享对象的更新问题。</p><p><span style="color:#977c00">说明：</span>这个变量是针对一个线程内所有操作共享的，所以设置为静态变量，所有此类实例共享此静态变量，也就是说在类第一次被使用时装载，只分配一块存储空间，所有此类的对象(只要是这个线程内定义的)都可以操控这个变量。</p></li></ol><h3 id="八-控制语句"><a href="#八-控制语句" class="headerlink" title="(八) 控制语句"></a>(八) 控制语句</h3><ol><li><p><span style="color:red;font-weight:900">【强制】</span>在一个 switch 块内，每个 case 要么通过 continue&#x2F;break&#x2F;return 等来终止，要么注释说明程序将继续执行到哪一个 case 为止；在一个 switch 块内，都必须包含一个 default语句并且放在最后，即使它什么代码也没有。</p><p><span style="color:#977c00">说明：</span>注意 break 是退出 switch 语句块，而 return 是退出方法体。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>当 switch 括号内的变量类型为 String 并且此变量为外部参数时，必须先进行 null判断。</p><p><span style="color:red">反例：</span>如下的代码输出是什么？</p><pre><code class="java">public class SwitchString &#123;    public static void main(String[] args) &#123;        method(null);    &#125;    public static void method(String param) &#123;        switch (param) &#123;            // 肯定不是进入这里            case &quot;sth&quot;:                System.out.println(&quot;it&#39;s sth&quot;);                break;            // 也不是进入这里            case &quot;null&quot;:                System.out.println(&quot;it&#39;s null&quot;);                break;            // 也不是进入这里            default:                System.out.println(&quot;default&quot;);        &#125;    &#125;&#125;</code></pre></li><li><p><span style="color:red;font-weight:900">【强制】</span>在 if&#x2F;else&#x2F;for&#x2F;while&#x2F;do 语句中必须使用大括号。</p><p><span style="color:#977c00">说明：</span>即使只有一行代码，也禁止不采用大括号的编码方式：if (condition) statements; </p></li><li><p><span style="color:red;font-weight:900">【强制】</span>三目运算符 condition? 表达式 1 : 表达式 2 中，高度注意表达式 1 和 2 在类型对齐时，可能抛出因自动拆箱导致的 NPE 异常。</p><p><span style="color:#977c00">说明：</span>以下两种场景会触发类型对齐的拆箱操作：</p><p>1） 表达式 1 或表达式 2 的值只要有一个是原始类型。</p><p>2） 表达式 1 或表达式 2 的值的类型不一致，会强制拆箱升级成表示范围更大的那个类型。</p><p><span style="color:red">反例：</span></p><pre><code class="java">Integer a = 1;Integer b = 2;Integer c = null;Boolean flag = false;// a*b 的结果是 int 类型，那么 c 会强制拆箱成 int 类型，抛出 NPE 异常Integer result=(flag? a*b : c);</code></pre></li><li><p><span style="color:red;font-weight:900">【强制】</span>在高并发场景中，避免使用”等于”判断作为中断或退出的条件。</p><p><span style="color:#977c00">说明：</span>如果并发控制没有处理好，容易产生等值判断被“击穿”的情况，使用大于或小于的区间判断条件来代替。</p><p><span style="color:red">反例：</span>判断剩余奖品数量等于 0 时，终止发放奖品，但因为并发处理错误导致奖品数量瞬间变成了负数，这样的话，活动无法终止。</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>当某个方法的代码总行数超过 10 行时，return &#x2F; throw 等中断逻辑的右大括号后均需要加一个空行。</p><p><span style="color:#977c00">说明：</span>这样做逻辑清晰，有利于代码阅读时重点关注。</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>表达异常的分支时，少用 if-else 方式，这种方式可以改写成：</p><pre><code class="java">if (condition) &#123;     ...    return obj; &#125;// 接着写 else 的业务逻辑代码; </code></pre><p><span style="color:#977c00">说明：</span>如果非使用 if()…else if()…else…方式表达逻辑，避免后续代码维护困难，请勿超过 3 层。</p><p><span style="color:green">正例：</span> 超过 3 层的 if-else 的逻辑判断代码可以使用卫语句、策略模式、状态模式等来实现，其中卫语句示例如下：</p><pre><code class="java">public void findBoyfriend (Man man) &#123;    if (man.isUgly()) &#123;        System.out.println(&quot;本姑娘是外貌协会的资深会员&quot;);        return;    &#125;    if (man.isPoor()) &#123;        System.out.println(&quot;贫贱夫妻百事哀&quot;);        return;    &#125;    if (man.isBadTemper()) &#123;        System.out.println(&quot;银河有多远，你就给我滚多远&quot;);        return; &#125;    System.out.println(&quot;可以先交往一段时间看看&quot;);&#125;</code></pre></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>除常用方法（如 getXxx&#x2F;isXxx）等外，不要在条件判断中执行其它复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。</p><p><span style="color:#977c00">说明：</span>很多 if 语句内的逻辑表达式相当复杂，与、或、取反混合运算，甚至各种方法纵深调用，理解成本非常高。如果赋值一个非常好理解的布尔变量名字，则是件令人爽心悦目的事情。</p><p><span style="color:green">正例：</span> </p><pre><code class="java">// 伪代码如下final boolean existed = (file.open(fileName, &quot;w&quot;) != null) &amp;&amp; (...) || (...);if (existed) &#123;    ...&#125;</code></pre><p><span style="color:red">反例：</span></p><pre><code class="java">public final void acquire ( long arg) &#123;    if (!tryAcquire(arg) &amp;&amp;    acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) &#123;    selfInterrupt(); &#125;</code></pre></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>不要在其它表达式（尤其是条件表达式）中，插入赋值语句。</p><p><span style="color:#977c00">说明：</span>赋值点类似于人体的穴位，对于代码的理解至关重要，所以赋值语句需要清晰地单独成为一行。</p><p><span style="color:red">反例：</span></p><pre><code class="java">public Lock getLock(boolean fair) &#123;    // 算术表达式中出现赋值操作，容易忽略 count 值已经被改变    threshold = (count = Integer.MAX_VALUE) - 1;    // 条件表达式中出现赋值操作，容易误认为是 sync==fair    return (sync = fair) ? new FairSync() : new NonfairSync();&#125;</code></pre></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>循环体中的语句要考量性能，以下操作尽量移至循环体外处理，如定义对象、变量、获取数据库连接，进行不必要的 try-catch 操作（这个 try-catch 是否可以移至循环体外）。</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>避免采用取反逻辑运算符。</p><p><span style="color:#977c00">说明：</span>取反逻辑不利于快速理解，并且取反逻辑写法一般都存在对应的正向逻辑写法。</p><p><span style="color:green">正例：</span> 使用 if (x &lt; 628) 来表达 x 小于 628。</p><p><span style="color:red">反例：</span>使用 if (!(x &gt;&#x3D; 628)) 来表达 x 小于 628。</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>公开接口需要进行入参保护，尤其是批量操作的接口。</p><p><span style="color:red">反例：</span>某业务系统，提供一个用户批量查询的接口，API 文档上有说最多查多少个，但接口实现上没做任何保护，导致调用方传了一个 1000 的用户 id 数组过来后，查询信息后，内存爆了。</p></li><li><p><span style="color:#76923c;font-weight:900">【参考】</span>下列情形，需要进行参数校验： </p><p>1） 调用频次低的方法。</p><p>2） 执行时间开销很大的方法。此情形中，参数校验时间几乎可以忽略不计，但如果因为参数错误导致 中间执行回退，或者错误，那得不偿失。</p><p>3） 需要极高稳定性和可用性的方法。</p><p>4） 对外提供的开放接口，不管是 RPC&#x2F;API&#x2F;HTTP 接口。</p><p>5） 敏感权限入口。</p></li><li><p><span style="color:#76923c;font-weight:900">【参考】</span>下列情形，不需要进行参数校验： </p><p>1） 极有可能被循环调用的方法。但在方法说明里必须注明外部参数检查。</p><p>2） 底层调用频度比较高的方法。毕竟是像纯净水过滤的最后一道，参数错误不太可能到底层才会暴露问题。一般 DAO 层与 Service 层都在同一个应用中，部署在同一台服务器中，所以 DAO 的参数校验，可以省略。</p><p>3） 被声明成 private 只会被自己代码所调用的方法，如果能够确定调用方法的代码传入参数已经做过检查或者肯定不会有问题，此时可以不校验参数。</p></li></ol><h3 id="九-注释规约"><a href="#九-注释规约" class="headerlink" title="(九) 注释规约"></a>(九) 注释规约</h3><ol><li><p><span style="color:red;font-weight:900">【强制】</span>类、类属性、类方法的注释必须使用 Javadoc 规范，使用&#x2F;*<em>内容</em>&#x2F;格式，不得使用&#x2F;&#x2F; xxx 方式。</p><p><span style="color:#977c00">说明：</span>在 IDE 编辑窗口中，Javadoc 方式会提示相关注释，生成 Javadoc 可以正确输出相应注释；在 IDE中，工程调用方法时，不进入方法即可悬浮提示方法、参数、返回值的意义，提高阅读效率。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>所有的抽象方法（包括接口中的方法）必须要用 Javadoc 注释、除了返回值、参数、异常说明外，还必须指出该方法做什么事情，实现什么功能。</p><p><span style="color:#977c00">说明：</span>对子类的实现要求，或者调用注意事项，请一并说明。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>所有的类都必须添加创建者和创建日期。</p><p><span style="color:#977c00">说明：</span>在设置模板时，注意 IDEA 的@author 为<code>$&#123;USER&#125;</code>，而 eclipse 的@author 为<code>$&#123;user&#125;</code>，大小写有区别，而日期的设置统一为 yyyy&#x2F;MM&#x2F;dd 的格式。</p><p> <span style="color:green">正例：</span> </p><pre><code class="java">/** * @author yangguanbao * @date 2016/10/31 */</code></pre></li><li><p><span style="color:red;font-weight:900">【强制】</span>方法内部单行注释，在被注释语句上方另起一行，使用&#x2F;&#x2F;注释。方法内部多行注释使用&#x2F;* *&#x2F;注释，注意与代码对齐。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>所有的枚举类型字段必须要有注释，说明每个数据项的用途。</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持英文原文即可。</p><p><span style="color:red">反例：</span>“TCP 连接超时”解释成“传输控制协议连接超时”，理解反而费脑筋。</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等的修改。</p><p><span style="color:#977c00">说明：</span>代码与注释更新不同步，就像路网与导航软件更新不同步一样，如果导航软件严重滞后，就失去了导航的意义。</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>在类中删除未使用的任何字段、方法、内部类；在方法中删除未使用的任何参数声明与内部变量。</p></li><li><p><span style="color:#76923c;font-weight:900">【参考】</span>谨慎注释掉代码。在上方详细说明，而不是简单地注释掉。如果无用，则删除。</p><p><span style="color:#977c00">说明：</span>代码被注释掉有两种可能性：1）后续会恢复此段代码逻辑。2）永久不用。前者如果没有备注信息，难以知晓注释动机。后者建议直接删掉即可，假如需要查阅历史代码，登录代码仓库即可。</p></li><li><p><span style="color:#76923c;font-weight:900">【参考】</span>对于注释的要求：第一、能够准确反映设计思想和代码逻辑；第二、能够描述业务含义，使别的程序员能够迅速了解到代码背后的信息。完全没有注释的大段代码对于阅读者形同天书，注释是给自己看的，即使隔很长时间，也能清晰理解当时的思路；注释也是给继任者看的，使其能够快速接替自己的工作。</p></li><li><p><span style="color:#76923c;font-weight:900">【参考】</span>好的命名、代码结构是自解释的，注释力求精简准确、表达到位。避免出现注释的一个极端：过多过滥的注释，代码的逻辑一旦修改，修改注释又是相当大的负担。</p><p><span style="color:red">反例：</span></p><pre><code class="java">// put elephant into fridge put(elephant, fridge);</code></pre><p>方法名 put，加上两个有意义的变量名 elephant 和 fridge，已经说明了这是在干什么，语义清晰的代码不需要额外的注释。</p></li><li><p><span style="color:#76923c;font-weight:900">【参考】</span>特殊注释标记，请注明标记人与标记时间。注意及时处理这些标记，通过标记扫描，经常清理此类标记。线上故障有时候就是来源于这些标记处的代码。</p><p>1） 待办事宜（&#x3D;&#x3D;<strong>TODO</strong>&#x3D;&#x3D;）:（标记人，标记时间，[预计处理时间]）表示需要实现，但目前还未实现的功能。这实际上是一个 Javadoc 的标签，目前的 Javadoc 还没有实现，但已经被广泛使用。只能应用于类，接口和方法（因为它是一个 Javadoc 标签）。</p><p>2） 错误，不能工作（&#x3D;&#x3D;<strong>FIXME</strong>&#x3D;&#x3D;）:（标记人，标记时间，[预计处理时间]）在注释中用 FIXME 标记某代码是错误的，而且不能工作，需要及时纠正的情况。</p></li></ol><h3 id="十-前后端规约"><a href="#十-前后端规约" class="headerlink" title="(十) 前后端规约"></a>(十) 前后端规约</h3><ol><li><p><span style="color:red;font-weight:900">【强制】</span>前后端交互的 API，需要明确协议、域名、路径、请求方法、请求内容、状态码、响应体。</p><p><span style="color:#977c00">说明：</span></p><p>1） 协议：生产环境必须使用 HTTPS。 </p><p>2） 路径：每一个 API 需对应一个路径，表示 API 具体的请求地址：</p><p>​a） 代表一种资源，只能为名词，推荐使用复数，不能为动词，请求方法已经表达动作意义。</p><p>​b） URL 路径不能使用大写，单词如果需要分隔，统一使用下划线。</p><p>​c） 路径禁止携带表示请求内容类型的后缀，比如”.json”,”.xml”，通过 accept 头表达即可。</p><p>3） 请求方法：对具体操作的定义，常见的请求方法如下：</p><p>​a） GET：从服务器取出资源。</p><p>​b） POST：在服务器新建一个资源。</p><p>​c） PUT：在服务器更新资源。</p><p>​d） DELETE：从服务器删除资源。</p><p>4） 请求内容：URL 带的参数必须无敏感信息或符合安全要求；body 里带参数时必须设置 Content-Type。 </p><p>5） 响应体：响应体 body 可放置多种数据类型，由 Content-Type 头来确定。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>前后端数据列表相关的接口返回，如果为空，则返回空数组[]或空集合{}。</p><p><span style="color:#977c00">说明：</span>此条约定有利于数据层面上的协作更加高效，减少前端很多琐碎的 null 判断。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>服务端发生错误时，返回给前端的响应信息必须包含 HTTP 状态码，errorCode、errorMessage、用户提示信息四个部分。</p><p><span style="color:#977c00">说明：</span>四个部分的涉众对象分别是浏览器、前端开发、错误排查人员、用户。其中输出给用户的提示信息</p><p>要求：简短清晰、提示友好，引导用户进行下一步操作或解释错误原因，提示信息可以包括错误原因、上下文环境、推荐操作等。 errorCode：参考<strong>附表 3</strong>。errorMessage：简要描述后端出错原因，便于错误排查人员快速定位问题，注意不要包含敏感数据信息。</p><p><span style="color:green">正例：</span> 常见的 HTTP 状态码如下</p><p>1） 200 OK: 表明该请求被成功地完成，所请求的资源发送到客户端。</p><p>2） 401 Unauthorized: 请求要求身份验证，常见对于需要登录而用户未登录的情况。</p><p>3） 403 Forbidden：服务器拒绝请求，常见于机密信息或复制其它登录用户链接访问服务器的情况。</p><p>4） 404 Not Found: 服务器无法取得所请求的网页，请求资源不存在。</p><p>5） 500 Internal Server Error: 服务器内部错误。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>在前后端交互的 JSON 格式数据中，所有的 key 必须为小写字母开始的lowerCamelCase 风格，符合英文表达习惯，且表意完整。</p><p><span style="color:green">正例: </span> errorCode &#x2F; errorMessage &#x2F; assetStatus &#x2F; menuList &#x2F; orderList &#x2F; configFlag</p><p><span style="color:red">反例: </span>ERRORCODE &#x2F; ERROR_CODE &#x2F; error_message &#x2F; error-message &#x2F; errormessage &#x2F; ErrorMessage &#x2F; msg</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>errorMessage 是前后端错误追踪机制的体现，可以在前端输出到 type&#x3D;”hidden”文字类控件中，或者用户端的日志中，帮助我们快速地定位出问题。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>对于需要使用超大整数的场景，服务端一律使用 String 字符串类型返回，禁止使用Long 类型。</p><p><span style="color:#977c00">说明：</span>Java 服务端如果直接返回 Long 整型数据给前端，JS 会自动转换为 Number 类型（注：此类型为双精度浮点数，表示原理与取值范围等同于 Java 中的 Double）。Long 类型能表示的最大值是 2 的 63 次方-1，在取值范围之内，超过 2 的 53 次方 (9007199254740992)的数值转化为 JS 的 Number 时，有些数值会有精度损失。扩展说明，在 Long 取值范围内，任何 2 的指数次整数都是绝对不会存在精度损失的，所以说精度损失是一个概率问题。若浮点数尾数位与指数位空间不限，则可以精确表示任何整数，但很不幸，双精度浮点数的尾数位只有 52 位。</p><p><span style="color:red">反例：</span>通常在订单号或交易号大于等于 16 位，大概率会出现前后端单据不一致的情况，比如，”orderId”: 362909601374617692，前端拿到的值却是: 362909601374617660。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>HTTP 请求通过 URL 传递参数时，不能超过 2048 字节。</p><p><span style="color:#977c00">说明：</span>不同浏览器对于 URL 的最大长度限制略有不同，并且对超出最大长度的处理逻辑也有差异，2048字节是取所有浏览器的最小值。</p><p><span style="color:red">反例：</span>某业务将退货的商品 id 列表放在 URL 中作为参数传递，当一次退货商品数量过多时，URL 参数超长，传递到后端的参数被截断，导致部分商品未能正确退货。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>HTTP 请求通过 body 传递内容时，必须控制长度，超出最大长度后，后端解析会出错。</p><p>说明：nginx 默认限制是 1MB，tomcat 默认限制为 2MB，当确实有业务需要传较大内容时，可以通过调大服务器端的限制。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>在翻页场景中，用户输入参数的小于 1，则前端返回第一页参数给后端；后端发现用户输入的参数大于总页数，直接返回最后一页。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>服务器内部重定向必须使用 forward；外部重定向地址必须使用 URL 统一代理模块生成，否则会因线上采用 HTTPS 协议而导致浏览器提示“不安全”，并且还会带来 URL 维护不一致的问题。</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>服务器返回信息必须被标记是否可以缓存，如果缓存，客户端可能会重用之前的请求结果。</p><p><span style="color:#977c00">说明：</span>缓存有利于减少交互次数，减少交互的平均延迟。</p><p><span style="color:green">正例: </span> http 1.1 中，s-maxage 告诉服务器进行缓存，时间单位为秒，用法如下，</p><pre><code class="java">response.setHeader(&quot;Cache-Control&quot;, &quot;s-maxage=&quot; + cacheSeconds);</code></pre></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>服务端返回的数据，使用 JSON 格式而非 XML。</p><p><span style="color:#977c00">说明：</span>尽管 HTTP 支持使用不同的输出格式，例如纯文本，JSON，CSV，XML，RSS 甚至 HTML。如果我们使用的面向用户的服务，应该选择 JSON 作为通信中使用的标准数据交换格式，包括请求和响应。此外，application&#x2F;JSON 是一种通用的 MIME 类型，具有实用、精简、易读的特点。</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>前后端的时间格式统一为”yyyy-MM-dd HH:mm:ss”，统一为 GMT。</p></li><li><p><span style="color:#76923c;font-weight:900">【参考】</span>在接口路径中不要加入版本号，版本控制在 HTTP 头信息中体现，有利于向前兼容。</p><p><span style="color:#977c00">说明：</span>当用户在低版本与高版本之间反复切换工作时，会导致迁移复杂度升高，存在数据错乱风险。</p></li></ol><h3 id="十一-其他"><a href="#十一-其他" class="headerlink" title="(十一) 其他"></a>(十一) 其他</h3><ol><li><p><span style="color:red;font-weight:900">【强制】</span>在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。</p><p><span style="color:#977c00">说明：</span>不要在方法体内定义：Pattern pattern &#x3D; Pattern.compile(“规则”);</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>避免用 Apache Beanutils 进行属性的 copy。</p><p>说明：Apache BeanUtils 性能较差，可以使用其他方案比如 Spring BeanUtils, Cglib BeanCopier，注意均是浅拷贝。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>velocity 调用 POJO 类的属性时，直接使用属性名取值即可，模板引擎会自动按规范调用 POJO 的 getXxx()，如果是 boolean 基本数据类型变量（boolean 命名不需要加 is 前缀），会自动调用 isXxx()方法。</p><p><span style="color:#977c00">说明：</span>注意如果是 Boolean 包装类对象，优先调用 getXxx()的方法。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>后台输送给页面的变量必须加$!{var}——中间的感叹号。</p><p><span style="color:#977c00">说明：</span>如果 var 等于 null 或者不存在，那么${var}会直接显示在页面上。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>注意 Math.random() 这个方法返回是 double 类型，注意取值的范围 0≤x&lt;1（能够取到&#x3D;&#x3D;零&#x3D;&#x3D;值，注意除零异常），如果想获取整数类型的随机数，不要将 x 放大 10 的若干倍然后取整，直接使用 Random 对象的 &#x3D;&#x3D;nextInt&#x3D;&#x3D; 或者 &#x3D;&#x3D;nextLong&#x3D;&#x3D; 方法。</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>不要在视图模板中加入任何复杂的逻辑。</p><p><span style="color:#977c00">说明：</span>根据 MVC 理论，视图的职责是展示，不要抢模型和控制器的活。</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>任何数据结构的构造或初始化，都应指定大小，避免数据结构无限增长吃光内存。</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>及时清理不再使用的代码段或配置信息。</p><p><span style="color:#977c00">说明：</span>对于垃圾代码或过时配置，坚决清理干净，避免程序过度臃肿，代码冗余。</p><p><span style="color:green">正例：</span> 对于暂时被注释掉，后续可能恢复使用的代码片断，在注释代码上方，统一规定使用三个斜杠(&#x2F;&#x2F;&#x2F;)来说明注释掉代码的理由。如：</p><pre><code class="java">public static void hello() &#123;    /// 业务方通知活动暂停    // Business business = new Business();    // business.active();    System.out.println(&quot;it&#39;s finished&quot;);&#125;</code></pre></li></ol><h2 id="二、异常日志"><a href="#二、异常日志" class="headerlink" title="二、异常日志"></a>二、异常日志</h2><h3 id="一-错误码"><a href="#一-错误码" class="headerlink" title="(一) 错误码"></a>(一) 错误码</h3><ol><li><p><span style="color:red;font-weight:900">【强制】</span>错误码的制定原则：快速溯源、沟通标准化。</p><p><span style="color:#977c00">说明：</span> 错误码想得过于完美和复杂，就像康熙字典中的生僻字一样，用词似乎精准，但是字典不容易随身携带并且简单易懂。</p><p><span style="color:green">正例：</span> 错误码回答的问题是谁的错？错在哪？</p><p>​1）错误码必须能够快速知晓错误来源，可快速判断是谁的问题。</p><p>​2）错误码必须能够进行清晰地比对（代码中容易 equals）。</p><p>​3）错误码有利于团队快速对错误原因达到一致认知。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>错误码不体现版本号和错误等级信息。</p><p><span style="color:#977c00">说明：</span>错误码以不断追加的方式进行兼容。错误等级由日志和错误码本身的释义来决定。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>全部正常，但不得不填充错误码时返回五个零：00000。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>错误码为字符串类型，共 5 位，分成两个部分：错误产生来源+四位数字编号。</p><p><span style="color:#977c00">说明：</span>错误产生来源分为 A&#x2F;B&#x2F;C，A 表示错误来源于用户，比如参数错误，用户安装版本过低，用户支付超时等问题；B 表示错误来源于当前系统，往往是业务逻辑出错，或程序健壮性差等问题；C 表示错误来源于第三方服务，比如 CDN 服务出错，消息投递超时等问题；四位数字编号从 0001 到 9999，大类之间的步长间距预留 100，参考文末<strong>附表 3</strong>。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>编号不与公司业务架构，更不与组织架构挂钩，以先到先得的原则在统一平台上进行，审批生效，编号即被永久固定。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>错误码使用者避免随意定义新的错误码。</p><p><span style="color:#977c00">说明：</span>尽可能在原有错误码附表中找到语义相同或者相近的错误码在代码中使用即可。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>错误码不能直接输出给用户作为提示信息使用。</p><p><span style="color:#977c00">说明：</span>堆栈（stack_trace）、错误信息(error_message)、错误码（error_code）、提示信息（user_tip）是一个有效关联并互相转义的和谐整体，但是请勿互相越俎代庖。</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>错误码之外的业务独特信息由 error_message 来承载，而不是让错误码本身涵盖过多具体业务属性。</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>在获取第三方服务错误码时，向上抛出允许本系统转义，由 C 转为 B，并且在错误信息上带上原有的第三方错误码。</p></li><li><p><span style="color:#76923c;font-weight:900">【参考】</span>错误码分为一级宏观错误码、二级宏观错误码、三级宏观错误码。</p><p><span style="color:#977c00">说明：</span>在无法更加具体确定的错误场景中，可以直接使用一级宏观错误码，分别是：A0001（用户端错误）、B0001（系统执行出错）、C0001（调用第三方服务出错）。</p><p>​<span style="color:green">正例：</span> 调用第三方服务出错是一级，中间件错误是二级，消息服务出错是三级。</p></li><li><p><span style="color:#76923c;font-weight:900">【参考】</span>错误码的后三位编号与 HTTP 状态码没有任何关系。</p></li><li><p><span style="color:#76923c;font-weight:900">【参考】</span>错误码有利于不同文化背景的开发者进行交流与代码协作。</p><p><span style="color:#977c00">说明：</span>英文单词形式的错误码不利于非英语母语国家（如阿拉伯语、希伯来语、俄罗斯语等）之间的开发者互相协作。</p></li><li><p><span style="color:#76923c;font-weight:900">【参考】</span>错误码即人性，感性认知+口口相传，使用纯数字来进行错误码编排不利于感性记忆和分类。</p><p><span style="color:#977c00">说明：</span>数字是一个整体，每位数字的地位和含义是相同的。 </p><p><span style="color:red">反例：</span>一个五位数字 12345，第 1 位是错误等级，第 2 位是错误来源，345 是编号，人的大脑不会主动地拆开并分辨每位数字的不同含义。</p></li></ol><h3 id="二-异常处理"><a href="#二-异常处理" class="headerlink" title="(二) 异常处理"></a>(二) 异常处理</h3><ol><li><p><span style="color:red;font-weight:900">【强制】</span>Java 类库中定义的可以通过预检查方式规避的 RuntimeException 异常不应该通过catch 的方式来处理，比如：NullPointerException，IndexOutOfBoundsException 等等。</p><p><span style="color:#977c00">说明：</span>无法通过预检查的异常除外，比如，在解析字符串形式的数字时，可能存在数字格式错误，不得不通过 catch NumberFormatException 来实现。</p><p><span style="color:green">正例: </span> if (obj !&#x3D; null) {…}</p><p><span style="color:red">反例: </span>try { obj.method(); } catch (NullPointerException e) {…}</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>异常捕获后不要用来做流程控制，条件控制。</p><p><span style="color:#977c00">说明：</span>异常设计的初衷是解决程序运行中的各种意外情况，且异常的处理效率比条件判断方式要低很多。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>catch 时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。对于非稳定代码的 catch 尽可能进行区分异常类型，再做对应的异常处理。</p><p><span style="color:#977c00">说明：</span>对大段代码进行 try-catch，使程序无法根据不同的异常做出正确的应激反应，也不利于定位问题，这是一种不负责任的表现。</p><p><span style="color:green">正例：</span> 用户注册的场景中，如果用户输入非法字符，或用户名称已存在，或用户输入密码过于简单，在程序上作出分门别类的判断，并提示给用户。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的内容。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>事务场景中，抛出异常被 catch 后，如果需要回滚，一定要注意手动回滚事务。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>finally 块必须对资源对象、流对象进行关闭，有异常也要做 try-catch。</p><p><span style="color:#977c00">说明：</span>如果 JDK7 及以上，可以使用 try-with-resources 方式。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>不要在 finally 块中使用 return。</p><p><span style="color:#977c00">说明：</span>try 块中的 return 语句执行成功后，并不马上返回，而是继续执行 finally 块中的语句，如果此处存在 return 语句，则在此直接返回，无情丢弃掉 try 块中的返回点。</p><p><span style="color:red">反例：</span></p><pre><code class="java">public int checkReturn() &#123;    try &#123;        // x 等于 1，此处不返回        return ++x;    &#125; finally &#123;        // 返回的结果是 2        return ++x;    &#125;&#125;</code></pre></li><li><p><span style="color:red;font-weight:900">【强制】</span>捕获异常与抛异常，必须是完全匹配，或者捕获异常是抛异常的父类。</p><p><span style="color:#977c00">说明：</span>如果预期对方抛的是绣球，实际接到的是铅球，就会产生意外情况。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>在调用 RPC、二方包、或动态生成类的相关方法时，捕捉异常必须使用 Throwable类来进行拦截。</p><p><span style="color:#977c00">说明：</span>通过反射机制来调用方法，如果找不到方法，抛出 NoSuchMethodException。什么情况会抛出NoSuchMethodError 呢？二方包在类冲突时，仲裁机制可能导致引入非预期的版本使类的方法签名不匹配，或者在字节码修改框架（比如：ASM）动态创建或修改类时，修改了相应的方法签名。这些情况，即使代码编译期是正确的，但在代码运行期时，会抛出 NoSuchMethodError。</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>方法的返回值可以为 null，不强制返回空集合，或者空对象等，必须添加注释充分说明什么情况下会返回 null 值。</p><p><span style="color:#977c00">说明：</span>本手册明确防止 NPE 是调用者的责任。即使被调用方法返回空集合或者空对象，对调用者来说，也并非高枕无忧，必须考虑到远程调用失败、序列化失败、运行时异常等场景返回 null 的情况。</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>防止 NPE，是程序员的基本修养，注意 NPE 产生的场景：</p><p>1） 返回类型为基本数据类型，return 包装数据类型的对象时，自动拆箱有可能产生 NPE。</p><p> <span style="color:red">反例: </span>public int f() { return Integer 对象}， 如果为 null，自动解箱抛 NPE。 </p><p>2） 数据库的查询结果可能为 null。 </p><p>3） 集合里的元素即使 isNotEmpty，取出的数据元素也可能为 null。 </p><p>4） 远程调用返回对象时，一律要求进行空指针判断，防止 NPE。 </p><p>5） 对于 Session 中获取的数据，建议进行 NPE 检查，避免空指针。</p><p>6） 级联调用 obj.getA().getB().getC()；一连串调用，易产生 NPE。</p><p><span style="color:green">正例：</span> 使用 JDK8 的 Optional 类来防止 NPE 问题。</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>定义时区分 unchecked &#x2F; checked 异常，避免直接抛出 new RuntimeException()，更不允许抛出 Exception 或者 Throwable，应使用有业务含义的自定义异常。推荐业界已定义过的自定义异常，如：DAOException &#x2F; ServiceException 等。</p></li><li><p><span style="color:#76923c;font-weight:900">【参考】</span>对于公司外的 http&#x2F;api 开放接口必须使用 errorCode；而应用内部推荐异常抛出；跨应用间 RPC 调用优先考虑使用 Result 方式，封装 isSuccess()方法、errorCode、errorMessage；而应用内部直接抛出异常即可。</p><p><span style="color:#977c00">说明：</span>关于 RPC 方法返回方式使用 Result 方式的理由：</p><p>1）使用抛异常返回方式，调用方如果没有捕获到就会产生运行时错误。</p><p>2）如果不加栈信息，只是 new 自定义异常，加入自己的理解的 error message，对于调用端解决问题的帮助不会太多。如果加了栈信息，在频繁调用出错的情况下，数据序列化和传输的性能损耗也是问题。</p></li></ol><h3 id="三-日志规约"><a href="#三-日志规约" class="headerlink" title="(三) 日志规约"></a>(三) 日志规约</h3><ol><li><p><span style="color:red;font-weight:900">【强制】</span>应用中不可直接使用日志系统（Log4j、Logback）中的 API，而应依赖使用日志框架（SLF4J、JCL–Jakarta Commons Logging）中的 API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。</p><p><span style="color:#977c00">说明：</span>日志框架（SLF4J、JCL–Jakarta Commons Logging）的使用方式（推荐使用 SLF4J）</p><p> 使用 SLF4J：</p><pre><code class="java">import org.slf4j.Logger;import org.slf4j.LoggerFactory;private static final Logger logger = LoggerFactory.getLogger(Test.class);</code></pre><p>使用 JCL：</p><pre><code class="java">import org.apache.commons.logging.Log;import org.apache.commons.logging.LogFactory;private static final Log log = LogFactory.getLog(Test.class);</code></pre></li><li><p><span style="color:red;font-weight:900">【强制】</span>所有日志文件至少保存 15 天，因为有些异常具备以“周”为频次发生的特点。对于当天日志，以“应用名.log”来保存，保存在&#x2F;home&#x2F;admin&#x2F;应用名&#x2F;logs&#x2F;目录下，过往日志格式为: {logname}.log.{保存日期}，日期格式：yyyy-MM-dd</p><p><span style="color:green">正例：</span> 以 aap 应用为例，日志保存在&#x2F;home&#x2F;admin&#x2F;aapserver&#x2F;logs&#x2F;aap.log，历史日志名称为aap.log.2016-08-01</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>根据国家法律，网络运行状态、网络安全事件、个人敏感信息操作等相关记录，留存的日志不少于六个月，并且进行网络多机备份。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>应用中的扩展日志（如打点、临时监控、访问日志等）命名方式：appName_logType_logName.log。logType:日志类型，如 stats&#x2F;monitor&#x2F;access 等；logName:日志描述。这种命名的好处：通过文件名就可知道日志文件属于什么应用，什么类型，什么目的，也有利于归类查找。</p><p><span style="color:#977c00">说明：</span>推荐对日志进行分类，如将错误日志和业务日志分开存放，便于开发人员查看，也便于通过日志对系统进行及时监控。</p><p><span style="color:green">正例: </span> mppserver 应用中单独监控时区转换异常，如：mppserver_monitor_timeZoneConvert.log</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>在日志输出时，字符串变量之间的拼接使用占位符的方式。</p><p><span style="color:#977c00">说明：</span>因为 String 字符串的拼接会使用 StringBuilder 的 append()方式，有一定的性能损耗。使用占位符仅是替换动作，可以有效提升性能。</p><p><span style="color:green">正例: </span></p><pre><code class="java"> logger.debug(&quot;Processing trade with id: &#123;&#125; and symbol: &#123;&#125;&quot;, id, symbol);</code></pre></li><li><p><span style="color:red;font-weight:900">【强制】</span>对于 trace&#x2F;debug&#x2F;info 级别的日志输出，必须进行日志级别的开关判断。</p><p><span style="color:#977c00">说明：</span>虽然在 debug(参数)的方法体内第一行代码 isDisabled(Level.DEBUG_INT)为真时（Slf4j 的常见实现Log4j 和 Logback），就直接 return，但是参数可能会进行字符串拼接运算。此外，如果 debug(getName())这种参数内有 getName()方法调用，无谓浪费方法调用的开销。</p><p><span style="color:green">正例：</span> </p><pre><code class="java">// 如果判断为真，那么可以输出 trace 和 debug 级别的日志if (logger.isDebugEnabled()) &#123;    logger.debug(&quot;Current ID is: &#123;&#125; and name is: &#123;&#125;&quot;, id, getName());&#125;</code></pre></li><li><p><span style="color:red;font-weight:900">【强制】</span>避免重复打印日志，浪费磁盘空间，务必在日志配置文件中设置 additivity&#x3D;false。</p><p><span style="color:green">正例：</span></p><pre><code class="xml">&lt;logger name=&quot;com.taobao.dubbo.config&quot; additivity=&quot;false&quot;&gt; </code></pre></li><li><p><span style="color:red;font-weight:900">【强制】</span>生产环境禁止直接使用 System.out 或 System.err 输出日志或使用e.printStackTrace()打印异常堆栈。</p><p><span style="color:#977c00">说明：</span>标准日志输出与标准错误输出文件每次 Jboss 重启时才滚动，如果大量输出送往这两个文件，容易造成文件大小超过操作系统大小限制。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>异常信息应该包括两类信息：案发现场信息和异常堆栈信息。如果不处理，那么通过关键字 throws 往上抛出。</p><p><span style="color:green">正例: </span> logger.error(“inputParams:{} and errorMessage:{}”, 各类参数或者对象 toString(), e.getMessage(), e);</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>日志打印时禁止直接用 JSON 工具将对象转换成 String。</p><p><span style="color:#977c00">说明：</span>如果对象里某些 get 方法被覆写，存在抛出异常的情况，则可能会因为打印日志而影响正常业务流程的执行。</p><p><span style="color:green">正例：</span> 打印日志时仅打印出业务相关属性值或者调用其对象的 toString()方法。</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>谨慎地记录日志。生产环境禁止输出 debug 日志；有选择地输出 info 日志；如果使用warn 来记录刚上线时的业务行为信息，一定要注意日志输出量的问题，避免把服务器磁盘撑爆，并记得及时删除这些观察日志。</p><p><span style="color:#977c00">说明：</span>大量地输出无效日志，不利于系统性能提升，也不利于快速定位错误点。记录日志时请思考：这些日志真的有人看吗？看到这条日志你能做什么？能不能给问题排查带来好处？</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>可以使用 warn 日志级别来记录用户输入参数错误的情况，避免用户投诉时，无所适从。如非必要，请不要在此场景打出 error 级别，避免频繁报警。</p><p><span style="color:#977c00">说明：</span>注意日志输出的级别，error 级别只记录系统逻辑出错、异常或者重要的错误信息。</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>尽量用英文来描述日志错误信息，如果日志中的错误信息用英文描述不清楚的话使用中文描述即可，否则容易产生歧义。</p><p><span style="color:#977c00">说明：</span>国际化团队或海外部署的服务器由于字符集问题，使用全英文来注释和描述日志错误信息。</p></li></ol><h2 id="三、单元测试"><a href="#三、单元测试" class="headerlink" title="三、单元测试"></a>三、单元测试</h2><ol><li><p><span style="color:red;font-weight:900">【强制】</span>好的单元测试必须遵守 AIR 原则。</p><p><span style="color:#977c00">说明：</span>单元测试在线上运行时，感觉像空气（AIR）一样感觉不到，但在测试质量的保障上，却是非常关键的。好的单元测试宏观上来说，具有自动化、独立性、可重复执行的特点。</p><ul><li>&#x3D;&#x3D;A&#x3D;&#x3D;：Automatic（自动化）</li><li>&#x3D;&#x3D;I&#x3D;&#x3D;：Independent（独立性）</li><li>&#x3D;&#x3D;R&#x3D;&#x3D;：Repeatable（可重复）</li></ul></li><li><p><span style="color:red;font-weight:900">【强制】</span>单元测试应该是全自动执行的，并且非交互式的。测试用例通常是被定期执行的，执行过程必须完全自动化才有意义。输出结果需要人工检查的测试不是一个好的单元测试。单元测试中不准使用 System.out 来进行人肉验证，必须使用 assert 来验证。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>保持单元测试的独立性。为了保证单元测试稳定可靠且便于维护，单元测试用例之间决不能互相调用，也不能依赖执行的先后次序。</p><p><span style="color:red">反例: </span>method2 需要依赖 method1 的执行，将执行结果作为 method2 的输入。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>单元测试是可以重复执行的，不能受到外界环境的影响。</p><p><span style="color:#977c00">说明：</span>单元测试通常会被放到持续集成中，每次有代码 check in 时单元测试都会被执行。如果单测对外部环境（网络、服务、中间件等）有依赖，容易导致持续集成机制的不可用。</p><p><span style="color:green">正例：</span> 为了不受外界环境影响，要求设计代码时就把 SUT 的依赖改成注入，在测试时用 spring 这样的 DI框架注入一个本地（内存）实现或者 Mock 实现。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>对于单元测试，要保证测试粒度足够小，有助于精确定位问题。单测粒度至多是类级别，一般是方法级别。</p><p><span style="color:#977c00">说明：</span>只有测试粒度小才能在出错时尽快定位到出错位置。单测不负责检查跨类或者跨系统的交互逻辑，那是集成测试的领域。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>核心业务、核心应用、核心模块的增量代码确保单元测试通过。</p><p><span style="color:#977c00">说明：</span>新增代码及时补充单元测试，如果新增代码影响了原有单元测试，请及时修正。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>单元测试代码必须写在如下工程目录：src&#x2F;test&#x2F;java，不允许写在业务代码目录下。</p><p><span style="color:#977c00">说明：</span>源码编译时会跳过此目录，而单元测试框架默认是扫描此目录。</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>单元测试的基本目标：语句覆盖率达到 70%；核心模块的语句覆盖率和分支覆盖率都要达到 100%</p><p><span style="color:#977c00">说明：</span>在工程规约的应用分层中提到的 DAO 层，Manager 层，可重用度高的 Service，都应该进行单元测试。</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>编写单元测试代码遵守 BCDE 原则，以保证被测试模块的交付质量。</p><ul><li>&#x3D;&#x3D;B&#x3D;&#x3D;：Border，边界值测试，包括循环边界、特殊取值、特殊时间点、数据顺序等。</li><li>&#x3D;&#x3D;C&#x3D;&#x3D;：Correct，正确的输入，并得到预期的结果。</li><li>&#x3D;&#x3D;D&#x3D;&#x3D;：Design，与设计文档相结合，来编写单元测试。</li><li>&#x3D;&#x3D;E&#x3D;&#x3D;：Error，强制错误信息输入（如：非法数据、异常流程、业务允许外等），并得到预期的结果。</li></ul></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>对于数据库相关的查询，更新，删除等操作，不能假设数据库里的数据是存在的，或者直接操作数据库把数据插入进去，请使用程序插入或者导入数据的方式来准备数据。</p><p><span style="color:red">反例：</span>删除某一行数据的单元测试，在数据库中，先直接手动增加一行作为删除目标，但是这一行新增数据并不符合业务插入规则，导致测试结果异常。</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>和数据库相关的单元测试，可以设定自动回滚机制，不给数据库造成脏数据。或者对单元测试产生的数据有明确的前后缀标识。</p><p><span style="color:green">正例：</span> 在阿里巴巴企业智能事业部的内部单元测试中，使用 *ENTERPRISE_INTELLIGENCE <em>UNIT_TEST</em>*的前缀来标识单元测试相关代码。</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>对于不可测的代码在适当的时机做必要的重构，使代码变得可测，避免为了达到测试要求而书写不规范测试代码。</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>在设计评审阶段，开发人员需要和测试人员一起确定单元测试范围，单元测试最好覆盖所有测试用例（UC）。</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>单元测试作为一种质量保障手段，在项目提测前完成单元测试，不建议项目发布后补充单元测试用例。</p></li><li><p><span style="color:#76923c;font-weight:900">【参考】</span>为了更方便地进行单元测试，业务代码应避免以下情况：</p><ul><li>构造方法中做的事情过多。</li><li>存在过多的全局变量和静态方法。</li><li>存在过多的外部依赖。</li><li>存在过多的条件语句。</li></ul><p><span style="color:#977c00">说明：</span>多层条件语句建议使用卫语句、策略模式、状态模式等方式重构。</p></li><li><p><span style="color:#76923c;font-weight:900">【参考】</span>不要对单元测试存在如下误解：</p><ul><li>那是测试同学干的事情。本文是开发手册，凡是本文内容都是与开发同学强相关的。</li><li>单元测试代码是多余的。系统的整体功能与各单元部件的测试正常与否是强相关的。</li><li>单元测试代码不需要维护。一年半载后，那么单元测试几乎处于废弃状态。</li><li>单元测试与线上故障没有辩证关系。好的单元测试能够最大限度地规避线上故障。</li></ul></li></ol><h2 id="四、安全规约"><a href="#四、安全规约" class="headerlink" title="四、安全规约"></a>四、安全规约</h2><ol><li><p><span style="color:red;font-weight:900">【强制】</span>隶属于用户个人的页面或者功能必须进行权限控制校验。</p><p><span style="color:#977c00">说明：</span>防止没有做水平权限校验就可随意访问、修改、删除别人的数据，比如查看他人的私信内容。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>用户敏感数据禁止直接展示，必须对展示数据进行脱敏。</p><p><span style="color:#977c00">说明：</span>中国大陆个人手机号码显示：139****1219，隐藏中间 4 位，防止隐私泄露。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>用户输入的 SQL 参数严格使用参数绑定或者 METADATA 字段值限定，防止 SQL 注入，禁止字符串拼接 SQL 访问数据库。</p><p><span style="color:red">反例：</span>某系统签名大量被恶意修改，即是因为对于危险字符 # –没有进行转义，导致数据库更新时，where后边的信息被注释掉，对全库进行更新。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>用户请求传入的任何参数必须做有效性验证。</p><p><span style="color:#977c00">说明：</span>忽略参数校验可能导致：</p><ul><li>page size 过大导致内存溢出</li><li>恶意 order by 导致数据库慢查询</li><li>缓存击穿</li><li>SSRF</li><li>任意重定向</li><li>SQL 注入，Shell 注入，反序列化注入</li><li>正则输入源串拒绝服务 ReDoS</li></ul><p>Java 代码用正则来验证客户端的输入，有些正则写法验证普通用户输入没有问题，但是如果攻击人员使用的是特殊构造的字符串来验证，有可能导致死循环的结果。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>禁止向 HTML 页面输出未经安全过滤或未正确转义的用户数据。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>表单、AJAX 提交必须执行 CSRF 安全验证。</p><p>说明：CSRF(Cross-site request forgery)跨站请求伪造是一类常见编程漏洞。对于存在 CSRF 漏洞的应用&#x2F;网站，攻击者可以事先构造好 URL，只要受害者用户一访问，后台便在用户不知情的情况下对数据库中用户参数进行相应修改。</p></li><li><p>【强制】URL 外部重定向传入的目标地址必须执行白名单过滤。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>在使用平台资源，譬如短信、邮件、电话、下单、支付，必须实现正确的防重放的机制，如数量限制、疲劳度控制、验证码校验，避免被滥刷而导致资损。</p><p><span style="color:#977c00">说明：</span>如注册时发送验证码到手机，如果没有限制次数和频率，那么可以利用此功能骚扰到其它用户，并造成短信平台资源浪费。</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>发贴、评论、发送即时消息等用户生成内容的场景必须实现防刷、文本内容违禁词过滤等风控策略。</p></li></ol><h2 id="五、MySQL-数据库"><a href="#五、MySQL-数据库" class="headerlink" title="五、MySQL 数据库"></a>五、MySQL 数据库</h2><h3 id="一-建表规约"><a href="#一-建表规约" class="headerlink" title="(一) 建表规约"></a>(一) 建表规约</h3><ol><li><p><span style="color:red;font-weight:900">【强制】</span>表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint（1 表示是，0 表示否）。</p><p><span style="color:#977c00">说明：</span>任何字段如果为非负数，必须是 unsigned。</p><p>注意：POJO 类中的任何布尔类型的变量，都不要加 is 前缀，所以，需要在<resultMap>设置从 is_xxx 到Xxx 的映射关系。数据库表示是与否的值，使用 tinyint 类型，坚持 is_xxx 的命名方式是为了明确其取值含义与取值范围。</resultMap></p><p><span style="color:green">正例：</span> 表达逻辑删除的字段名 is_deleted，1 表示删除，0 表示未删除。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。</p><p>说明：MySQL 在 Windows 下不区分大小写，但在 Linux 下默认是区分大小写。因此，数据库名、表名、字段名，都不允许出现任何大写字母，避免节外生枝。</p><p><span style="color:green">正例: </span> aliyun_admin，rdc_config，level3_name</p><p><span style="color:red">反例: </span>AliyunAdmin，rdcConfig，level_3_name</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>表名不使用复数名词。</p><p><span style="color:#977c00">说明：</span>表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于 DO 类名也是单数形式，符合表达习惯。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>禁用保留字，如 desc、range、match、delayed 等，请参考 MySQL 官方保留字。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>主键索引名为 pk_字段名；唯一索引名为 uk_字段名；普通索引名则为 idx_字段名。</p><p><span style="color:#977c00">说明：</span>pk_ 即 primary key；uk_ 即 unique key；idx_ 即 index 的简称。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>小数类型为 decimal，禁止使用 float 和 double。</p><p><span style="color:#977c00">说明：</span>在存储的时候，float 和 double 都存在精度损失的问题，很可能在比较值的时候，得到不正确的结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数并分开存储。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>如果存储的字符串长度几乎相等，使用 char 定长字符串类型。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长度大于此值，定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索引效率。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>表必备三字段：id, create_time, update_time。</p><p><span style="color:#977c00">说明：</span>其中 id 必为主键，类型为 bigint unsigned、单表时自增、步长为 1。create_time, update_time的类型均为 datetime 类型，前者现在时表示主动式创建，后者过去分词表示被动式更新。</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>表的命名最好是遵循“业务名称_表的作用”。</p><p><span style="color:green">正例: </span> alipay_task &#x2F; force_project &#x2F; trade_config</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>库名与应用名称尽量一致。</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>如果修改字段含义或对字段表示的状态追加时，需要及时更新字段注释。</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循：</p><p>1） 不是频繁修改的字段。</p><p>2） 不是唯一索引的字段。</p><p>3） 不是 varchar 超长字段，更不能是 text 字段。</p><p> <span style="color:green">正例：</span> 各业务线经常冗余存储商品名称，避免查询时需要调用 IC 服务获取。</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。</p><p><span style="color:#977c00">说明：</span>如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。</p></li><li><p><span style="color:#76923c;font-weight:900">【参考】</span>合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。</p><p><span style="color:green">正例：</span> 无符号值可以避免误存负数，且扩大了表示范围。</p><table><thead><tr><th>对象</th><th>年龄区间</th><th>类型</th><th>字节</th><th>表示范围</th></tr></thead><tbody><tr><td>人</td><td>150 岁之内</td><td>tinyint unsigned</td><td>1</td><td>无符号值：0 到 255</td></tr><tr><td>龟</td><td>数百岁</td><td>smallint unsigned</td><td>2</td><td>无符号值：0 到 65535</td></tr><tr><td>恐龙化石</td><td>数千万年</td><td>int unsigned</td><td>4</td><td>无符号值：0 到约 43 亿</td></tr><tr><td>太阳</td><td>约 50 亿年</td><td>bigint unsigned</td><td>8</td><td>无符号值：0 到约 10 的 19 次方</td></tr></tbody></table></li></ol><h3 id="二-索引规约"><a href="#二-索引规约" class="headerlink" title="(二)索引规约"></a>(二)索引规约</h3><ol><li><p><span style="color:red;font-weight:900">【强制】</span>业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。</p><p><span style="color:#977c00">说明：</span>不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的；另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>超过三个表禁止 join。需要 join 的字段，数据类型保持绝对一致；多表关联查询时，保证被关联的字段需要有索引。</p><p><span style="color:#977c00">说明：</span>即使双表 join 也要注意表索引、SQL 性能。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度。</p><p><span style="color:#977c00">说明：</span>索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会高达 90%以上，可以使用 count(distinct left(列名, 索引长度))&#x2F;count(*)的区分度来确定。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。</p><p><span style="color:#977c00">说明：</span>索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>如果有 order by 的场景，请注意利用索引的有序性。order by 最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现 file_sort 的情况，影响查询性能。</p><p><span style="color:green">正例: </span> where a&#x3D;? and b&#x3D;? order by c; 索引：a_b_c</p><p><span style="color:red">反例：</span>索引如果存在范围查询，那么索引有序性无法利用，如：WHERE a&gt;10 ORDER BY b; 索引 a_b 无法排序。</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>利用覆盖索引来进行查询操作，避免回表。</p><p><span style="color:#977c00">说明：</span>如果一本书需要知道第 11 章是什么标题，会翻开第 11 章对应的那一页吗？目录浏览一下就好，这个目录就是起到覆盖索引的作用。</p><p><span style="color:green">正例：</span> 能够建立索引的种类分为主键索引、唯一索引、普通索引三种，而覆盖索引只是一种查询的一种效果，用 explain 的结果，extra 列会出现：using index。</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>利用延迟关联或者子查询优化超多分页场景。</p><p><span style="color:#977c00">说明：</span>MySQL 并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前 offset 行，返回 N 行，那当offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行 SQL改写。</p><p><span style="color:green">正例：</span> 先快速定位需要获取的 id 段，然后再关联： SELECT t1.* FROM 表 1 as t1, (select id from 表 1 where 条件 LIMIT 100000,20 ) as t2 where t1.id&#x3D;t2.id</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>SQL 性能优化的目标：至少要达到 range 级别，要求是 ref 级别，如果可以是 consts最好。</p><p><span style="color:#977c00">说明：</span></p><p>1） consts 单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。</p><p>2） ref 指的是使用普通的索引（normal index）。 </p><p>3） range 对索引进行范围检索。</p><p><span style="color:red">反例: </span>explain 表的结果，type&#x3D;index，索引物理文件全扫描，速度非常慢，这个 index 级别比较 range还低，与全表扫描是小巫见大巫。</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>建组合索引的时候，区分度最高的在最左边。</p><p><span style="color:green">正例：</span> 如果 where a&#x3D;? and b&#x3D;?，a 列的几乎接近于唯一值，那么只需要单建 idx_a 索引即可。</p><p><span style="color:#977c00">说明：</span>存在非等号和等号混合判断条件时，在建索引时，请把等号条件的列前置。如：where c&gt;? and d&#x3D;? 那么即使 c 的区分度更高，也必须把 d 放在索引的最前列，即建立组合索引 idx_d_c。</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>防止因字段类型不同造成的隐式转换，导致索引失效。</p></li><li><p><span style="color:#76923c;font-weight:900">【参考】</span>创建索引时避免有如下极端误解：</p><p>1） 索引宁滥勿缺。认为一个查询就需要建一个索引。</p><p>2） 吝啬索引的创建。认为索引会消耗空间、严重拖慢记录的更新以及行的新增速度。</p><p>3） 抵制惟一索引。认为惟一索引一律需要在应用层通过“先查后插”方式解决。</p></li></ol><h3 id="三-SQL-语句"><a href="#三-SQL-语句" class="headerlink" title="(三) SQL 语句"></a>(三) SQL 语句</h3><ol><li><p><span style="color:red;font-weight:900">【强制】</span>不要使用 count(列名)或 count(常量)来替代 count(<em>)，count(</em>)是 SQL92 定义的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。</p><p><span style="color:#977c00">说明：</span>count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>count(distinct col) 计算该列除 NULL 之外的不重复行数，注意 count(distinct col1, col2) 如果其中一列全为 NULL，那么即使另一列有不同的值，也返回为 0。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>当某一列的值全是 NULL 时，count(col)的返回结果为 0，但 sum(col)的返回结果为NULL，因此使用 sum()时需注意 NPE 问题。</p><p><span style="color:green">正例：</span> 可以使用如下方式来避免 sum 的 NPE 问题：SELECT IFNULL(SUM(column), 0) FROM table;</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>使用 &#x3D;&#x3D;ISNULL()&#x3D;&#x3D;来判断是否为 &#x3D;&#x3D;NULL&#x3D;&#x3D; 值。</p><p><span style="color:#977c00">说明：</span>NULL 与任何值的直接比较都为 NULL。 </p><p>​1） &#x3D;&#x3D;NULL&lt;&gt;NULL&#x3D;&#x3D; 的返回结果是 NULL，而不是 <span style="color:red">false</span>。 </p><p>​2） &#x3D;&#x3D;NULL&#x3D;NULL&#x3D;&#x3D; 的返回结果是 NULL，而不是 <span style="color:red">true</span>。 </p><p>​3） &#x3D;&#x3D;NULL&lt;&gt;1&#x3D;&#x3D; 的返回结果是 NULL，而不是 <span style="color:red">true</span>。</p><p><span style="color:red">反例：</span>在 SQL 语句中，如果在 null 前换行，影响可读性。select * from table where column1 is null and column3 is not null; 而<code>ISNULL(column)</code>是一个整体，简洁易懂。从性能数据上分析，<code>ISNULL(column)</code>执行效率更快一些。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>代码中写分页查询逻辑时，若 count 为 0 应直接返回，避免执行后面的分页语句。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>不得使用外键与级联，一切外键概念必须在应用层解决。</p><p><span style="color:#977c00">说明：</span>（概念解释）学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>数据订正（特别是删除或修改记录操作）时，要先 select，避免出现误删除，确认无</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>对于数据库中表记录的查询和变更，只要涉及多个表，都需要在列名前加表的别名（或表名）进行限定。</p><p><span style="color:#977c00">说明：</span>对多表进行查询记录、更新记录、删除记录时，如果对操作列没有限定表的别名（或表名），并且操作列在多个表中存在时，就会抛异常。</p><p><span style="color:green">正例: </span> select t1.name from table_first as t1 , table_second as t2 where t1.id&#x3D;t2.id;</p><p><span style="color:red">反例：</span>在某业务中，由于多表关联查询语句没有加表的别名（或表名）的限制，正常运行两年后，最近在某个表中增加一个同名字段，在预发布环境做数据库变更后，线上查询语句出现出 1052 异常：Column ‘name’ in field list is ambiguous。</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>SQL 语句中表的别名前加 as，并且以 t1、t2、t3、…的顺序依次命名。</p><p><span style="color:#977c00">说明：</span>1）别名可以是表的简称，或者是依照表在 SQL 语句中出现的顺序，以 t1、t2、t3 的方式命名。2）别名前加 as 使别名更容易识别。</p><p><span style="color:green">正例: </span> select t1.name from table_first as t1, table_second as t2 where t1.id&#x3D;t2.id;</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>in 操作能避免则避免，若实在避免不了，需要仔细评估 in 后边的集合元素数量，控制在 1000 个之内。</p></li><li><p><span style="color:#76923c;font-weight:900">【参考】</span>因国际化需要，所有的字符存储与表示，均采用 utf8 字符集，那么字符计数方法需 要注意。</p><p><span style="color:#977c00">说明：</span>SELECT LENGTH(“轻松工作”)； 返回为 12 SELECT CHARACTER_LENGTH(“轻松工作”)； 返回为 4 如果需要存储表情，那么选择 utf8mb4 来进行存储，注意它与 utf8 编码的区别。</p></li><li><p><span style="color:#76923c;font-weight:900">【参考】</span>TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，但 TRUNCATE无事务且不触发 trigger，有可能造成事故，故不建议在开发代码中使用此语句。</p><p><span style="color:#977c00">说明：</span>TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同。</p></li></ol><h3 id="四-ORM-映射"><a href="#四-ORM-映射" class="headerlink" title="(四) ORM 映射"></a>(四) ORM 映射</h3><ol><li><p><span style="color:red;font-weight:900">【强制】</span>在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明。</p><p><span style="color:#977c00">说明：</span>1）增加查询分析器解析成本。2）增减字段容易与 resultMap 配置不一致。3）无用字段增加网络消耗，尤其是 text 类型的字段。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>POJO 类的布尔属性不能加 is，而数据库字段必须加 is_，要求在 resultMap 中进行字段与属性之间的映射。</p><p><span style="color:#977c00">说明：</span>参见定义 POJO 类以及数据库字段定义规定，在 sql.xml 增加映射，是必须的。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>不要用 resultClass 当返回参数，即使所有类属性名与数据库字段一一对应，也需要定义<resultMap>；反过来，每一个表也必然有一个<resultMap>与之对应。</resultMap></resultMap></p><p><span style="color:#977c00">说明：</span>配置映射关系，使字段与 DO 类解耦，方便维护。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>sql.xml 配置参数使用：#{}，#param# 不要使用${} 此种方式容易出现 SQL 注入。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>iBATIS 自带的 queryForList(String statementName,int start,int size)不推荐使用。</p><p><span style="color:#977c00">说明：</span>其实现方式是在数据库取到 statementName 对应的 SQL 语句的所有记录，再通过 subList 取start,size 的子集合。</p><p><span style="color:green">正例：</span> </p><pre><code class="java">Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(16);map.put(&quot;start&quot;, start);map.put(&quot;size&quot;, size);</code></pre></li><li><p><span style="color:red;font-weight:900">【强制】</span>不允许直接拿 HashMap 与 Hashtable 作为查询结果集的输出。</p><p><span style="color:red">反例：</span>某同学为避免写一个<resultMap>xxx</resultMap>，直接使用 HashTable 来接收数据库返回结果，结果出现日常是把 bigint 转成 Long 值，而线上由于数据库版本不一样，解析成 BigInteger，导致线上问题。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>更新数据表记录时，必须同时更新记录对应的 update_time 字段值为当前时间。</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>不要写一个大而全的数据更新接口。传入为 POJO 类，不管是不是自己的目标更新字段，都进行 update table set c1&#x3D;value1,c2&#x3D;value2,c3&#x3D;value3; 这是不对的。执行 SQL 时，不要更新无改动的字段，一是易出错；二是效率低；三是增加 binlog 存储。</p></li><li><p><span style="color:#76923c;font-weight:900">【参考】</span>@Transactional 事务不要滥用。事务会影响数据库的 QPS，另外使用事务的地方需要考虑各方面的回滚方案，包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等。</p></li><li><p><span style="color:#76923c;font-weight:900">【参考】</span><isEqual>中的 compareValue 是与属性值对比的常量，一般是数字，表示相等时带上此条件；<isNotEmpty>表示不为空且不为 null 时执行；<isNotNull>表示不为 null 值时执行。</isNotNull></isNotEmpty></isEqual></p></li></ol><h2 id="六、工程结构"><a href="#六、工程结构" class="headerlink" title="六、工程结构"></a>六、工程结构</h2><h3 id="一-应用分层"><a href="#一-应用分层" class="headerlink" title="(一) 应用分层"></a>(一) 应用分层</h3><ol><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>根据业务架构实践，结合业界分层规范与流行技术框架分析，推荐分层结构如图所示，默认上层依赖于下层，箭头关系表示可直接依赖，如：开放 API 层可以依赖于 Web 层 （Controller 层），也可以直接依赖于 Service 层，依此类推：</p><img src="https://gitee.com/manaphy/imageUpload/raw/master/img/image-20200814202759600.png" height="450"><ul><li><p>开放 API 层：可直接封装 Service 接口暴露成 RPC 接口；通过 Web 封装成 http 接口；网关控制层等。</p></li><li><p>终端显示层：各个端的模板渲染并执行显示的层。当前主要是 velocity 渲染，JS 渲染，JSP 渲染，移动端展示等。 </p></li><li><p>Web 层：主要是对访问控制进行转发，各类基本参数校验，或者不复用的业务简单处理等。 </p></li><li><p>Service 层：相对具体的业务逻辑服务层。 </p></li><li><p>Manager 层：通用业务处理层，它有如下特征：</p><p>1） 对第三方平台封装的层，预处理返回结果及转化异常信息，适配上层接口。</p><p>2） 对 Service 层通用能力的下沉，如缓存方案、中间件通用处理。 </p><p>3） 与 DAO 层交互，对多个 DAO 的组合复用。 </p></li><li><p>DAO 层：数据访问层，与底层 MySQL、Oracle、Hbase、OB 等进行数据交互。 </p></li><li><p>第三方服务：包括其它部门 RPC 服务接口，基础平台，其它公司的 HTTP 接口，如淘宝开放平台、支付宝付款服务、高德地图服务等。</p></li><li><p>外部数据接口：外部（应用）数据存储服务提供的接口，多见于数据迁移场景中。</p></li></ul><ol start="2"><li><span style="color:#76923c;font-weight:900">【参考】</span>（分层异常处理规约）在 DAO 层，产生的异常类型有很多，无法用细粒度的异常进行 catch，使用 catch(Exception e)方式，并 throw new DAOException(e)，不需要打印日志，因为日志在 Manager&#x2F;Service 层一定需要捕获并打印到日志文件中去，如果同台服务器再打日志，浪费性能和存储。在 Service 层出现异常时，必须记录出错日志到磁盘，尽可能带上参数信息，相当于保护案发现场。Manager 层与 Service 同机部署，日志方式与 DAO 层处理一致，如果是单独部署，则采用与 Service 一致的处理方式。Web 层绝不应该继续往上抛异常，因为已经处于顶层，如果意识到这个异常将导致页面无法正常渲染，那么就应该直接跳转到友好错误页面，尽量加上友好的错误提示信息。开放接口层要将异常处理成错误码和错误信息方式返回。</li><li><span style="color:#76923c;font-weight:900">【参考】</span>分层领域模型规约：<ul><li>&#x3D;&#x3D;DO&#x3D;&#x3D;（Data Object）：此对象与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。 </li><li>&#x3D;&#x3D;DTO&#x3D;&#x3D;（Data Transfer Object）：数据传输对象，Service 或 Manager 向外传输的对象。 </li><li>&#x3D;&#x3D;BO&#x3D;&#x3D;（Business Object）：业务对象，可以由 Service 层输出的封装业务逻辑的对象。</li><li>&#x3D;&#x3D;Query&#x3D;&#x3D;：数据查询对象，各层接收上层的查询请求。注意超过 2 个参数的查询封装，禁止使用 Map 类来传输</li><li>&#x3D;&#x3D;VO&#x3D;&#x3D;（View Object）：显示层对象，通常是 Web 向模板渲染引擎层传输的对象。</li></ul></li></ol></li></ol><h3 id="二-二方库依赖"><a href="#二-二方库依赖" class="headerlink" title="(二) 二方库依赖"></a>(二) 二方库依赖</h3><ol><li><p><span style="color:red;font-weight:900">【强制】</span>定义 GAV 遵从以下规则：</p><p>1） <span style="color:blue">G</span>roupID 格式：com.{公司&#x2F;BU }.业务线 [.子业务线]，最多 4 级。</p><p>​<span style="color:#977c00">说明：</span>{公司&#x2F;BU} 例如：alibaba&#x2F;taobao&#x2F;tmall&#x2F;aliexpress 等 BU 一级；子业务线可选。</p><p>​<span style="color:green">正例: </span> com.taobao.jstorm 或 com.alibaba.dubbo.register</p><p>2） <span style="color:blue">A</span>rtifactID 格式：产品线名-模块名。语义不重复不遗漏，先到中央仓库去查证一下。</p><p>​<span style="color:green">正例: </span> dubbo-client &#x2F; fastjson-api &#x2F; jstorm-tool</p><p>3） <span style="color:blue">V</span>ersion：详细规定参考下方。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>二方库版本号命名方式：主版本号.次版本号.修订号</p><p>1）主版本号：产品方向改变，或者大规模 API 不兼容，或者架构不兼容升级。 </p><p>2） 次版本号：保持相对兼容性，增加主要功能特性，影响范围极小的 API 不兼容修改。</p><p>3） 修订号：保持完全兼容性，修复 BUG、新增次要功能特性等。</p><p><span style="color:#977c00">说明：</span>注意起始版本号必须为：&#x3D;&#x3D;1.0.0&#x3D;&#x3D;，而不是 0.0.1。</p><p><span style="color:red">反例：</span>仓库内某二方库版本号从 1.0.0.0 开始，一直默默“升级”成 1.0.0.64，完全失去版本的语义信息。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>线上应用不要依赖 SNAPSHOT 版本（安全包除外）；正式发布的类库必须先去中央仓库进行查证，使 RELEASE 版本号有延续性，且版本号不允许覆盖升级。</p><p><span style="color:#977c00">说明：</span>不依赖 SNAPSHOT 版本是保证应用发布的幂等性。另外，也可以加快编译时的打包构建。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>二方库的新增或升级，保持除功能点之外的其它 jar 包仲裁结果不变。如果有改变，必须明确评估和验证。</p><p><span style="color:#977c00">说明：</span>在升级时，进行 dependency:resolve 前后信息比对，如果仲裁结果完全不一致，那么通过dependency:tree 命令，找出差异点，进行<exclude>排除 jar 包。</exclude></p></li><li><p><span style="color:red;font-weight:900">【强制】</span>二方库里可以定义枚举类型，参数可以使用枚举类型，但是接口返回值不允许使用枚举类型或者包含枚举类型的 POJO 对象。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>依赖于一个二方库群时，必须定义一个统一的版本变量，避免版本号不一致。</p><p><span style="color:#977c00">说明：</span>依赖 springframework-core,-context,-beans，它们都是同一个版本，可以定义一个变量来保存版本：${spring.version}，定义依赖的时候，引用该版本。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>禁止在子项目的 pom 依赖中出现相同的 GroupId，相同的 ArtifactId，但是不同的Version。</p><p><span style="color:#977c00">说明：</span>在本地调试时会使用各子项目指定的版本号，但是合并成一个 war，只能有一个版本号出现在最后的lib 目录中。曾经出现过线下调试是正确的，发布到线上却出故障的先例。</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>底层基础技术框架、核心数据管理平台、或近硬件端系统谨慎引入第三方实现。</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>所有 pom 文件中的依赖声明放在<dependencies>语句块中，所有版本仲裁放在<dependencyManagement>语句块中。</dependencyManagement></dependencies></p><p><span style="color:#977c00">说明：</span><dependencyManagement>里只是声明版本，并不实现引入，因此子项目需要显式的声明依赖，version 和 scope 都读取自父 pom。而<dependencies>所有声明在主 pom 的<dependencies>里的依赖都会自动引入，并默认被所有的子项目继承。</dependencies></dependencies></dependencyManagement></p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>二方库不要有配置项，最低限度不要再增加配置项。</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>不要使用不稳定的工具包或者 Utils 类。</p><p><span style="color:#977c00">说明：</span>不稳定指的是提供方无法做到向下兼容，在编译阶段正常，但在运行时产生异常，因此，尽量使用业界稳定的二方工具包。</p></li><li><p><span style="color:#76923c;font-weight:900">【参考】</span>为避免应用二方库的依赖冲突问题，二方库发布者应当遵循以下原则：</p><p>1）<strong>精简可控原则</strong>。移除一切不必要的 API 和依赖，只包含 Service API、必要的领域模型对象、Utils 类、常量、枚举等。如果依赖其它二方库，尽量是 provided 引入，让二方库使用者去依赖具体版本号；无 log具体实现，只依赖日志框架。</p><p>2）<strong>稳定可追溯原则</strong>。每个版本的变化应该被记录，二方库由谁维护，源码在哪里，都需要能方便查到。除非用户主动升级版本，否则公共二方库的行为不应该发生变化。</p></li></ol><h3 id="三-服务器"><a href="#三-服务器" class="headerlink" title="(三) 服务器"></a>(三) 服务器</h3><ol><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>高并发服务器建议调小 TCP 协议的 time_wait 超时时间。</p><p><span style="color:#977c00">说明：</span>操作系统默认 240 秒后，才会关闭处于 time_wait 状态的连接，在高并发访问下，服务器端会因为处于 time_wait 的连接数太多，可能无法建立新的连接，所以需要在服务器上调小此等待值。</p><p><span style="color:green">正例：</span> 在 linux 服务器上请通过变更&#x2F;etc&#x2F;sysctl.conf 文件去修改该缺省值（秒）：net.ipv4.tcp_fin_timeout &#x3D; 30</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>调大服务器所支持的最大文件句柄数（File Descriptor，简写为 fd）。</p><p><span style="color:#977c00">说明：</span>主流操作系统的设计是将 TCP&#x2F;UDP 连接采用与文件一样的方式去管理，即一个连接对应于一个 fd。主流的linux服务器默认所支持最大fd数量为1024，当并发连接数很大时很容易因为fd不足而出现“open too many files”错误，导致新的连接无法建立。建议将 linux 服务器所支持的最大句柄数调高数倍（与服务器的内存数量相关）。</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>给 JVM 环境参数设置-XX:+HeapDumpOnOutOfMemoryError 参数，让 JVM 碰到 OOM场景时输出 dump 信息。</p><p><span style="color:#977c00">说明：</span>OOM 的发生是有概率的，甚至相隔数月才出现一例，出错时的堆内信息对解决问题非常有帮助。</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>在线上生产环境，JVM 的 Xms 和 Xmx 设置一样大小的内存容量，避免在 GC 后调整堆大小带来的压力。</p></li><li><p><span style="color:#76923c;font-weight:900">【参考】</span>服务器内部重定向必须使用 forward；外部重定向地址必须使用 URL Broker 生成，否 则因线上采用 HTTPS 协议而导致浏览器提示“不安全“。此外，还会带来 URL 维护不一致的问题。</p></li></ol><h2 id="七、设计规约"><a href="#七、设计规约" class="headerlink" title="七、设计规约"></a>七、设计规约</h2><ol><li><p><span style="color:red;font-weight:900">【强制】</span>&#x3D;&#x3D;存储方案&#x3D;&#x3D;和&#x3D;&#x3D;底层数据结构&#x3D;&#x3D;的设计获得评审一致通过，并沉淀成为文档。</p><p><span style="color:#977c00">说明：</span>有缺陷的底层数据结构容易导致系统风险上升，可扩展性下降，重构成本也会因历史数据迁移和系统平滑过渡而陡然增加，所以，存储方案和数据结构需要认真地进行设计和评审，生产环境提交执行后，需要进行 double check。</p><p><span style="color:green">正例：</span> 评审内容包括存储介质选型、表结构设计能否满足技术方案、存取性能和存储空间能否满足业务发展、表或字段之间的辩证关系、字段名称、字段类型、索引等；数据结构变更（如在原有表中新增字段）也需要进行评审通过后上线。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>在需求分析阶段，如果与系统交互的 User 超过&#x3D;&#x3D;一类&#x3D;&#x3D;并且相关的 User Case 超过 &#x3D;&#x3D;5 个&#x3D;&#x3D;，使用用例图来表达更加清晰的结构化需求。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>如果某个业务对象的状态超过 &#x3D;&#x3D;3 个&#x3D;&#x3D;，使用状态图来表达并且明确状态变化的各个触发条件。</p><p><span style="color:#977c00">说明：</span>状态图的核心是对象状态，首先明确对象有多少种状态，然后明确两两状态之间是否存在直接转换关系，再明确触发状态转换的条件是什么。</p><p><span style="color:green">正例：</span> 淘宝订单状态有已下单、待付款、已付款、待发货、已发货、已收货等。比如已下单与已收货这两种状态之间是不可能有直接转换关系的。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>如果系统中某个功能的调用链路上的涉及对象超过 &#x3D;&#x3D;3 个&#x3D;&#x3D;，使用时序图来表达并且明确各调用环节的输入与输出。</p><p><span style="color:#977c00">说明：</span>时序图反映了一系列对象间的交互与协作关系，清晰立体地反映系统的调用纵深链路。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>如果系统中模型类超过 &#x3D;&#x3D;5 个&#x3D;&#x3D;，并且存在复杂的依赖关系，使用类图来表达并且明确类之间的关系。</p><p><span style="color:#977c00">说明：</span>类图像建筑领域的施工图，如果搭平房，可能不需要，但如果建造蚂蚁 Z 空间大楼，肯定需要详细的施工图。</p></li><li><p><span style="color:red;font-weight:900">【强制】</span>如果系统中超过 &#x3D;&#x3D;2 个&#x3D;&#x3D;对象之间存在协作关系，并且需要表示复杂的处理流程，使用活动图来表示。</p><p><span style="color:#977c00">说明：</span>活动图是流程图的扩展，增加了能够体现协作关系的对象泳道，支持表示并发等。</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>系统架构设计时明确以下目标： </p><ul><li>确定系统边界。确定系统在技术层面上的做与不做。</li><li>确定系统内模块之间的关系。确定模块之间的依赖关系及模块的宏观输入与输出。 </li><li>确定指导后续设计与演化的原则。使后续的子系统或模块设计在一个既定的框架内和技术方向上继续演化。</li><li>确定非功能性需求。非功能性需求是指安全性、可用性、可扩展性等。</li></ul></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>需求分析与系统设计在考虑主干功能的同时，需要充分评估异常流程与业务边界。</p><p><span style="color:red">反例：</span>用户在淘宝付款过程中，银行扣款成功，发送给用户扣款成功短信，但是支付宝入款时由于断网演练产生异常，淘宝订单页面依然显示未付款，导致用户投诉。</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>类在设计与实现时要符合单一原则。</p><p><span style="color:#977c00">说明：</span>单一原则最易理解却是最难实现的一条规则，随着系统演进，很多时候，忘记了类设计的初衷。</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>谨慎使用继承的方式来进行扩展，优先使用聚合&#x2F;组合的方式来实现。</p><p><span style="color:#977c00">说明：</span>不得已使用继承的话，必须符合里氏代换原则，此原则说父类能够出现的地方子类一定能够出现，比如，“把钱交出来”，钱的子类美元、欧元、人民币等都可以出现。</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>系统设计阶段，根据依赖倒置原则，尽量依赖抽象类与接口，有利于扩展与维护。</p><p><span style="color:#977c00">说明：</span>低层次模块依赖于高层次模块的抽象，方便系统间的解耦。</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>系统设计阶段，注意对扩展开放，对修改闭合。</p><p><span style="color:#977c00">说明：</span>极端情况下，交付的代码是不可修改的，同一业务域内的需求变化，通过模块或类的扩展来实现。</p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>系统设计阶段，共性业务或公共行为抽取出来公共模块、公共配置、公共类、公共方法等，在系统中不出现重复代码的情况，即 DRY 原则（Don’t Repeat Yourself）。</p><p><span style="color:#977c00">说明：</span>随着代码的重复次数不断增加，维护成本指数级上升。随意复制和粘贴代码，必然会导致代码的重复，在维护代码时，需要修改所有的副本，容易遗漏。必要时抽取共性方法，或者抽象公共类，甚至是组件化。</p><p><span style="color:green">正例：</span> 一个类中有多个 public 方法，都需要进行数行相同的参数校验操作，这个时候请抽取：private boolean checkParam(DTO dto) {…} </p></li><li><p><span style="color:#ffc000;font-weight:900">【推荐】</span>避免如下误解：<strong>敏捷开发 &#x3D; 讲故事 + 编码 + 发布</strong>。</p><p><span style="color:#977c00">说明：</span>敏捷开发是快速交付迭代可用的系统，省略多余的设计方案，摒弃传统的审批流程，但核心关键点上的必要设计和文档沉淀是需要的。</p><p><span style="color:red">反例：</span>某团队为了业务快速发展，敏捷成了产品经理催进度的借口，系统中均是勉强能运行但像面条一样的代码，可维护性和可扩展性极差，一年之后，不得不进行大规模重构，得不偿失。</p></li><li><p><span style="color:#76923c;font-weight:900">【参考】</span>设计文档的作用是明确需求、理顺逻辑、后期维护，次要目的用于指导编码。</p><p><span style="color:#977c00">说明：</span>避免为了设计而设计，系统设计文档有助于后期的系统维护和重构，所以设计结果需要进行分类归档保存。</p></li><li><p><span style="color:#76923c;font-weight:900">【参考】</span>可扩展性的本质是找到系统的变化点，并隔离变化点。</p><p><span style="color:#977c00">说明：</span>世间众多设计模式其实就是一种设计模式即隔离变化点的模式。</p><p><span style="color:green">正例：</span> 极致扩展性的标志，就是需求的新增，不会在原有代码交付物上进行任何形式的修改。</p></li><li><p><span style="color:#76923c;font-weight:900">【参考】</span>设计的本质就是识别和表达系统难点。</p><p><span style="color:#977c00">说明：</span>识别和表达完全是两回事，很多人错误地认为识别到系统难点在哪里，表达只是自然而然的事情，但是大家在设计评审中经常出现语焉不详，甚至是词不达意的情况。准确地表达系统难点需要具备如下能力： 表达规则和表达工具的熟练性。抽象思维和总结能力的局限性。基础知识体系的完备性。深入浅出的生动表达力。</p></li><li><p><span style="color:#76923c;font-weight:900">【参考】</span>代码即文档的观点是错误的，清晰的代码只是文档的某个片断，而不是全部。</p></li></ol><p>​<span style="color:#977c00">说明：</span>代码的深度调用，模块层面上的依赖关系网，业务场景逻辑，非功能性需求等问题是需要相应的文档来完整地呈现的。</p><ol start="19"><li><p><span style="color:#76923c;font-weight:900">【参考】</span>在做无障碍产品设计时，需要考虑到：</p><ul><li>所有可交互的控件元素必须能被 tab 键聚焦，并且焦点顺序需符合自然操作逻辑。 </li><li>用于登录校验和请求拦截的验证码均需提供图形验证以外的其它方式。 </li><li>自定义的控件类型需明确交互方式。</li></ul><p><span style="color:green">正例：</span> 用户登录场景中，输入框的按钮都需要考虑 tab 键聚焦，符合自然逻辑的操作顺序如下，“输入用户名，输入密码，输入验证码，点击登录”，其中验证码实现语音验证方式。如果有自定义标签实现的控件设置控件类型可使用 role 属性。</p></li></ol><h2 id="附-1：版本历史"><a href="#附-1：版本历史" class="headerlink" title="附 1：版本历史"></a>附 1：版本历史</h2><p>略</p><h2 id="附-2：专有名词解释"><a href="#附-2：专有名词解释" class="headerlink" title="附 2：专有名词解释"></a>附 2：专有名词解释</h2><ol><li><p>&#x3D;&#x3D;POJO&#x3D;&#x3D;（Plain Ordinary Java Object）: 在本规约中，POJO 专指只有 setter&#x2F;getter&#x2F;toString 的简单类，包括 DO&#x2F;DTO&#x2F;BO&#x2F;VO 等。</p></li><li><p>&#x3D;&#x3D;DO&#x3D;&#x3D;（Data Object）：阿里巴巴专指数据库表一一对应的 POJO 类。此对象与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。</p></li><li><p>&#x3D;&#x3D;DTO&#x3D;&#x3D;（Data Transfer Object）：数据传输对象，Service 或 Manager 向外传输的对象。</p></li><li><p>&#x3D;&#x3D;BO&#x3D;&#x3D;（Business Object）：业务对象，可以由 Service 层输出的封装业务逻辑的对象。</p></li><li><p>&#x3D;&#x3D;Query&#x3D;&#x3D; 数据查询对象，各层接收上层的查询请求。注意超过 2 个参数的查询封装，禁止使用Map 类来传输。</p></li><li><p>&#x3D;&#x3D;VO&#x3D;&#x3D;（View Object）：显示层对象，通常是 Web 向模板渲染引擎层传输的对象。</p></li><li><p>&#x3D;&#x3D;AO&#x3D;&#x3D;（Application Object）: 阿里巴巴专指 Application Object，即在 Service 层上，极为贴近业务的复用代码。</p></li><li><p>&#x3D;&#x3D;CAS&#x3D;&#x3D;（Compare And Swap）：解决多线程并行情况下使用锁造成性能损耗的一种机制，这是硬件实现的原子操作。CAS 操作包含三个操作数：内存位置、预期原值和新值。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。</p></li><li><p>&#x3D;&#x3D;GAV&#x3D;&#x3D;（GroupId、ArtifactId、Version）: Maven 坐标，是用来唯一标识 jar 包。</p></li><li><p>&#x3D;&#x3D;OOP&#x3D;&#x3D;（Object Oriented Programming）: 本文泛指类、对象的编程处理方式。</p></li><li><p>&#x3D;&#x3D;AQS&#x3D;&#x3D;（AbstractQueuedSynchronizer）: 利用先进先出队列实现的底层同步工具类，它是很多上层同步实现类的基础，比如：ReentrantLock、CountDownLatch、Semaphore 等，它们通过继承 AQS 实现其模版方法，然后将 AQS 子类作为同步组件的内部类，通常命名为 Sync。</p></li><li><p>&#x3D;&#x3D;ORM&#x3D;&#x3D;（Object Relation Mapping）: 对象关系映射，对象领域模型与底层数据之间的转换，本文泛指 iBATIS, mybatis 等框架。</p></li><li><p>&#x3D;&#x3D;NPE&#x3D;&#x3D;（java.lang.NullPointerException）: 空指针异常。</p></li><li><p>&#x3D;&#x3D;OOM&#x3D;&#x3D;（Out Of Memory）: 源于 java.lang.OutOfMemoryError，当 JVM 没有足够的内存来为对象分配空间并且垃圾回收器也无法回收空间时，系统出现的严重状况。</p></li><li><p>&#x3D;&#x3D;一方库&#x3D;&#x3D;: 本工程内部子项目模块依赖的库（jar 包）。</p></li><li><p>&#x3D;&#x3D;二方库&#x3D;&#x3D;: 公司内部发布到中央仓库，可供公司内部其它应用依赖的库（jar 包）。</p></li><li><p>&#x3D;&#x3D;三方库&#x3D;&#x3D;: 公司之外的开源库（jar 包）。</p></li></ol><h2 id="附-3：错误码列表"><a href="#附-3：错误码列表" class="headerlink" title="附 3：错误码列表"></a>附 3：错误码列表</h2><table><thead><tr><th>错误码</th><th>中文描述</th><th>说明</th></tr></thead><tbody><tr><td><span style="color:green">00000</span></td><td>一切 ok</td><td>正确执行后的返回</td></tr><tr><td><span style="color:red">A0001</span></td><td>用户端错误</td><td>一级宏观错误码</td></tr><tr><td><span style="color:blue">A0100</span></td><td>用户注册错误</td><td>二级宏观错误码</td></tr><tr><td>A0101</td><td>用户未同意隐私协议</td><td></td></tr><tr><td>A0102</td><td>注册国家或地区受限</td><td></td></tr><tr><td>A0110</td><td>用户名校验失败</td><td></td></tr><tr><td>A0111</td><td>用户名已存在</td><td></td></tr><tr><td>A0112</td><td>用户名包含敏感词</td><td></td></tr><tr><td>A0113</td><td>用户名包含特殊字符</td><td></td></tr><tr><td>A0120</td><td>密码校验失败</td><td></td></tr><tr><td>A0121</td><td>密码长度不够</td><td></td></tr><tr><td>A0122</td><td>密码强度不够</td><td></td></tr><tr><td>A0130</td><td>校验码输入错误</td><td></td></tr><tr><td>A0131</td><td>短信校验码输入错误</td><td></td></tr><tr><td>A0132</td><td>邮件校验码输入错误</td><td></td></tr><tr><td>A0133</td><td>语音校验码输入错误</td><td></td></tr><tr><td>A0140</td><td>用户证件异常</td><td></td></tr><tr><td>A0141</td><td>用户证件类型未选择</td><td></td></tr><tr><td>A0142</td><td>大陆身份证编号校验非法</td><td></td></tr><tr><td>A0143</td><td>护照编号校验非法</td><td></td></tr><tr><td>A0144</td><td>军官证编号校验非法</td><td></td></tr><tr><td>A0150</td><td>用户基本信息校验失败</td><td></td></tr><tr><td>A0151</td><td>手机格式校验失败</td><td></td></tr><tr><td>A0152</td><td>地址格式校验失败</td><td></td></tr><tr><td>A0153</td><td>邮箱格式校验失败</td><td></td></tr><tr><td>A0200</td><td>用户登录异常</td><td>二级宏观错误码</td></tr><tr><td>A0201</td><td>用户账户不存在</td><td></td></tr><tr><td>A0202</td><td>用户账户被冻结</td><td></td></tr><tr><td>A0203</td><td>用户账户已作废</td><td></td></tr><tr><td>A0210</td><td>用户密码错误</td><td></td></tr><tr><td>A0211</td><td>用户输入密码错误次数超限</td><td></td></tr><tr><td>A0220</td><td>用户身份校验失败</td><td></td></tr><tr><td>A0221</td><td>用户指纹识别失败</td><td></td></tr><tr><td>A0222</td><td>用户面容识别失败</td><td></td></tr><tr><td>A0223</td><td>用户未获得第三方登录授权</td><td></td></tr><tr><td>A0230</td><td>用户登录已过期</td><td></td></tr><tr><td>A0240</td><td>用户验证码错误</td><td></td></tr><tr><td>A0241</td><td>用户验证码尝试次数超限</td><td></td></tr><tr><td>A0300</td><td>访问权限异常</td><td>二级宏观错误码</td></tr><tr><td>A0301</td><td>访问未授权</td><td></td></tr><tr><td>A0302</td><td>正在授权中</td><td></td></tr><tr><td>A0303</td><td>用户授权申请被拒绝</td><td></td></tr><tr><td>A0310</td><td>因访问对象隐私设置被拦截</td><td></td></tr><tr><td>A0311</td><td>授权已过期</td><td></td></tr><tr><td>A0312</td><td>无权限使用 API</td><td></td></tr><tr><td>A0320</td><td>用户访问被拦截</td><td></td></tr><tr><td>A0321</td><td>黑名单用户</td><td></td></tr><tr><td>A0322</td><td>账号被冻结</td><td></td></tr><tr><td>A0323</td><td>非法 IP 地址</td><td></td></tr><tr><td>A0324</td><td>网关访问受限</td><td></td></tr><tr><td>A0325</td><td>地域黑名单</td><td></td></tr><tr><td>A0330</td><td>服务已欠费</td><td></td></tr><tr><td>A0340</td><td>用户签名异常</td><td></td></tr><tr><td>A0341</td><td>RSA 签名错误</td><td></td></tr><tr><td>A0400</td><td>用户请求参数错误</td><td>二级宏观错误码</td></tr><tr><td>A0401</td><td>包含非法恶意跳转链接</td><td></td></tr><tr><td>A0402</td><td>无效的用户输入</td><td></td></tr><tr><td>A0410</td><td>请求必填参数为空</td><td></td></tr><tr><td>A0411</td><td>用户订单号为空</td><td></td></tr><tr><td>A0412</td><td>订购数量为空</td><td></td></tr><tr><td>A0413</td><td>缺少时间戳参数</td><td></td></tr><tr><td>A0414</td><td>非法的时间戳参数</td><td></td></tr><tr><td>A0420</td><td>请求参数值超出允许的范围</td><td></td></tr><tr><td>A0421</td><td>参数格式不匹配</td><td></td></tr><tr><td>A0422</td><td>地址不在服务范围</td><td></td></tr><tr><td>A0423</td><td>时间不在服务范围</td><td></td></tr><tr><td>A0424</td><td>金额超出限制</td><td></td></tr><tr><td>A0425</td><td>数量超出限制</td><td></td></tr><tr><td>A0426</td><td>请求批量处理总个数超出限制</td><td></td></tr><tr><td>A0427</td><td>请求 JSON 解析失败</td><td></td></tr><tr><td>A0430</td><td>用户输入内容非法</td><td></td></tr><tr><td>A0431</td><td>包含违禁敏感词</td><td></td></tr><tr><td>A0432</td><td>图片包含违禁信息</td><td></td></tr><tr><td>A0433</td><td>文件侵犯版权</td><td></td></tr><tr><td>A0440</td><td>用户操作异常</td><td></td></tr><tr><td>A0441</td><td>用户支付超时</td><td></td></tr><tr><td>A0442</td><td>确认订单超时</td><td></td></tr><tr><td>A0443</td><td>订单已关闭</td><td></td></tr><tr><td>A0500</td><td>用户请求服务异常</td><td>二级宏观错误码</td></tr><tr><td>A0501</td><td>请求次数超出限制</td><td></td></tr><tr><td>A0502</td><td>请求并发数超出限制</td><td></td></tr><tr><td>A0503</td><td>用户操作请等待</td><td></td></tr><tr><td>A0504</td><td>WebSocket 连接异常</td><td></td></tr><tr><td>A0505</td><td>WebSocket 连接断开</td><td></td></tr><tr><td>A0506</td><td>用户重复请求</td><td></td></tr><tr><td>A0600</td><td>用户资源异常</td><td>二级宏观错误码</td></tr><tr><td>A0601</td><td>账户余额不足</td><td></td></tr><tr><td>A0602</td><td>用户磁盘空间不足</td><td></td></tr><tr><td>A0603</td><td>用户内存空间不足</td><td></td></tr><tr><td>A0604</td><td>用户 OSS 容量不足</td><td></td></tr><tr><td>A0605</td><td>用户配额已用光</td><td>蚂蚁森林浇水数或每天抽奖数</td></tr><tr><td>A0700</td><td>用户上传文件异常</td><td>二级宏观错误码</td></tr><tr><td>A0701</td><td>用户上传文件类型不匹配</td><td></td></tr><tr><td>A0702</td><td>用户上传文件太大</td><td></td></tr><tr><td>A0703</td><td>用户上传图片太大</td><td></td></tr><tr><td>A0704</td><td>用户上传视频太大</td><td></td></tr><tr><td>A0705</td><td>用户上传压缩文件太大</td><td></td></tr><tr><td>A0800</td><td>用户当前版本异常</td><td>二级宏观错误码</td></tr><tr><td>A0801</td><td>用户安装版本与系统不匹配</td><td></td></tr><tr><td>A0802</td><td>用户安装版本过低</td><td></td></tr><tr><td>A0803</td><td>用户安装版本过高</td><td></td></tr><tr><td>A0804</td><td>用户安装版本已过期</td><td></td></tr><tr><td>A0805</td><td>用户 API 请求版本不匹配</td><td></td></tr><tr><td>A0806</td><td>用户 API 请求版本过高</td><td></td></tr><tr><td>A0807</td><td>用户 API 请求版本过低</td><td></td></tr><tr><td>A0900</td><td>用户隐私未授权</td><td>二级宏观错误码</td></tr><tr><td>A0901</td><td>用户隐私未签署</td><td></td></tr><tr><td>A0902</td><td>用户摄像头未授权</td><td></td></tr><tr><td>A0903</td><td>用户相机未授权</td><td></td></tr><tr><td>A0904</td><td>用户图片库未授权</td><td></td></tr><tr><td>A0905</td><td>用户文件未授权</td><td></td></tr><tr><td>A0906</td><td>用户位置信息未授权</td><td></td></tr><tr><td>A0907</td><td>用户通讯录未授权</td><td></td></tr><tr><td>A1000</td><td>用户设备异常</td><td>二级宏观错误码</td></tr><tr><td>A1001</td><td>用户相机异常</td><td></td></tr><tr><td>A1002</td><td>用户麦克风异常</td><td></td></tr><tr><td>A1003</td><td>用户听筒异常</td><td></td></tr><tr><td>A1004</td><td>用户扬声器异常</td><td></td></tr><tr><td>A1005</td><td>用户 GPS 定位异常</td><td></td></tr><tr><td><span style="color:red">B0001</span></td><td>系统执行出错</td><td>一级宏观错误码</td></tr><tr><td>B0100</td><td>系统执行超时</td><td>二级宏观错误码</td></tr><tr><td>B0101</td><td>系统订单处理超时</td><td></td></tr><tr><td>B0200</td><td>系统容灾功能被触发</td><td>二级宏观错误码</td></tr><tr><td>B0210</td><td>系统限流</td><td></td></tr><tr><td>B0220</td><td>系统功能降级</td><td></td></tr><tr><td>B0300</td><td>系统资源异常</td><td>二级宏观错误码</td></tr><tr><td>B0310</td><td>系统资源耗尽</td><td></td></tr><tr><td>B0311</td><td>系统磁盘空间耗尽</td><td></td></tr><tr><td>B0312</td><td>系统内存耗尽</td><td></td></tr><tr><td>B0313</td><td>文件句柄耗尽</td><td></td></tr><tr><td>B0314</td><td>系统连接池耗尽</td><td></td></tr><tr><td>B0315</td><td>系统线程池耗尽</td><td></td></tr><tr><td>B0320</td><td>系统资源访问异常</td><td></td></tr><tr><td>B0321</td><td>系统读取磁盘文件失败</td><td></td></tr><tr><td><span style="color:red">C0001</span></td><td>调用第三方服务出错</td><td>一级宏观错误码</td></tr><tr><td>C0100</td><td>中间件服务出错</td><td>二级宏观错误码</td></tr><tr><td>C0110</td><td>RPC 服务出错</td><td></td></tr><tr><td>C0111</td><td>RPC 服务未找到</td><td></td></tr><tr><td>C0112</td><td>RPC 服务未注册</td><td></td></tr><tr><td>C0113</td><td>接口不存在</td><td></td></tr><tr><td>C0120</td><td>消息服务出错</td><td></td></tr><tr><td>C0121</td><td>消息投递出错</td><td></td></tr><tr><td>C0122</td><td>消息消费出错</td><td></td></tr><tr><td>C0123</td><td>消息订阅出错</td><td></td></tr><tr><td>C0124</td><td>消息分组未查到</td><td></td></tr><tr><td>C0130</td><td>缓存服务出错</td><td></td></tr><tr><td>C0131</td><td>key 长度超过限制</td><td></td></tr><tr><td>C0132</td><td>value 长度超过限制</td><td></td></tr><tr><td>C0133</td><td>存储容量已满</td><td></td></tr><tr><td>C0134</td><td>不支持的数据格式</td><td></td></tr><tr><td>C0140</td><td>配置服务出错</td><td></td></tr><tr><td>C0150</td><td>网络资源服务出错</td><td></td></tr><tr><td>C0151</td><td>VPN 服务出错</td><td></td></tr><tr><td>C0152</td><td>CDN 服务出错</td><td></td></tr><tr><td>C0153</td><td>域名解析服务出错</td><td></td></tr><tr><td>C0154</td><td>网关服务出错</td><td></td></tr><tr><td>C0200</td><td>第三方系统执行超时</td><td>二级宏观错误码</td></tr><tr><td>C0210</td><td>RPC 执行超时</td><td></td></tr><tr><td>C0220</td><td>消息投递超时</td><td></td></tr><tr><td>C0230</td><td>缓存服务超时</td><td></td></tr><tr><td>C0240</td><td>配置服务超时</td><td></td></tr><tr><td>C0250</td><td>数据库服务超时</td><td></td></tr><tr><td>C0300</td><td>数据库服务出错</td><td>二级宏观错误码</td></tr><tr><td>C0311</td><td>表不存在</td><td></td></tr><tr><td>C0312</td><td>列不存在</td><td></td></tr><tr><td>C0321</td><td>多表关联中存在多个相同名称的列</td><td></td></tr><tr><td>C0331</td><td>数据库死锁</td><td></td></tr><tr><td>C0341</td><td>主键冲突</td><td></td></tr><tr><td>C0400</td><td>第三方容灾系统被触发</td><td>二级宏观错误码</td></tr><tr><td>C0401</td><td>第三方系统限流</td><td></td></tr><tr><td>C0402</td><td>第三方功能降级</td><td></td></tr><tr><td>C0500</td><td>通知服务出错</td><td>二级宏观错误码</td></tr><tr><td>C0501</td><td>短信提醒服务失败</td><td></td></tr><tr><td>C0502</td><td>语音提醒服务失败</td><td></td></tr><tr><td>C0503</td><td>邮件提醒服务失败</td><td></td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>jdk8新特性学习使用</title>
      <link href="/2023/09/06/jdk8%E6%96%B0%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/09/06/jdk8%E6%96%B0%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="JDK8新特性学习及使用"><a href="#JDK8新特性学习及使用" class="headerlink" title="JDK8新特性学习及使用"></a>JDK8新特性学习及使用</h1><h2 id="1-Lambda表达式初体验"><a href="#1-Lambda表达式初体验" class="headerlink" title="1.Lambda表达式初体验"></a>1.Lambda表达式初体验</h2><p><strong>代码片段对比</strong></p><p><img src="/2023/09/06/jdk8%E6%96%B0%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8/personboke\blog\source_posts\jdk8新特性学习使用\image-20230927203405662.png" alt="image-20230927203405662"></p><p>开启一个新的线程 需要执行的代码</p><p><strong>普通代码块</strong></p><pre><code>new Thread(    new Runnable()&#123;    @Override    public void run()&#123;    System.outprintlin(&quot;新线程中执行的代码&quot;+Thread.currentThread().getname())    &#125;    &#125;).start</code></pre><p><strong>Lambad代码块</strong></p><p>Lambda表达式是一个匿名函数可以理解为一段可以传递的代码片段</p><p>使用Lambda时不关心方法名称 不关心 方法名称 只关心方法参数 方法内部步骤 </p><pre><code>new Thread(()-&gt;&#123;System.outprintlin(&quot;新线程中执行的代码&quot;+Thread.currentThread().getname()) &#125; ).start（）;</code></pre><p>Lambda表达式的有点：简化了匿名内部类的使用，语法更加简单</p><p><strong>Lambad表达式语法规则</strong></p><p>Lambad 省去了面向对象的限制  标准的格式是三个部分：</p><pre><code>(参数类型 参数名称)-&gt;&#123;    代码体；&#125;</code></pre><h2 id="补充知识集合比较"><a href="#补充知识集合比较" class="headerlink" title="补充知识集合比较"></a>补充知识集合比较</h2><pre><code class="java">        List&lt;Person&gt; list = new ArrayList&lt;&gt;();        list.add(new Person(&quot;周杰伦&quot;,33,175));        list.add(new Person(&quot;刘德华&quot;,43,185));        list.add(new Person(&quot;周星驰&quot;,38,177));        list.add(new Person(&quot;郭富城&quot;,23,170));                Collections.sort(list, new Comparator&lt;Person&gt;() &#123;            @Override            public int compare(Person o1, Person o2) &#123;                return o1.getHeight() - o2.getHeight();            &#125;        &#125;);</code></pre><p><strong>源码解读</strong></p><p>比较其两个顺序参数。返回负整数、零或正整数，因为第一个参数小于、等于或大于第二个参数。在前面的描述中，符号 sgn（expression） 指定数学符号函数，该函数被定义为根据表达式的值是负、零还是正返回 -1、0 或 1 之一。实现者必须确保 sgn（compare（x， y）） &#x3D;&#x3D; -sgn（compare（y， x）） 对于所有 x 和 y。 （这意味着 compare（x， y） 必须抛出异常当且仅当 compare（y， x） 抛出异常。实现者还必须确保关系是传递的：（（compare（x， y）&gt;0） &amp;&amp; （compare（y， z）&gt;0）） 意味着 compare（x， z）&gt;0。最后，实现者必须确保 compare（x， y）&#x3D;&#x3D;0 意味着所有 z 的 sgn（compare（x， z））&#x3D;&#x3D;sgn（compare（y， z））。一般情况下是这样，但不是严格要求的（compare（x， y）&#x3D;&#x3D;0） &#x3D;&#x3D; （x.equals（y））。一般而言，任何违反此条件的比较器都应明确指出这一事实。推荐的语言是“注意：此比较器施加的排序与相等不一致。参数：o1 – 要比较的第一个对象。O2 – 要比较的第二个对象。返回：负整数、零或正整数，因为第一个参数小于、等于或大于第二个参数。抛出：NullPointerException – 如果参数为 null 并且此比较器不允许空参数 ClassCastException – 如果参数的类型阻止此比较器比较它们。</p><p>int compare(T o1, T o2); </p><p>针对这段代码我这边翻看了一下源码</p><p>在集合比较的过程中</p><p>我们利用jdk工具进行集合的比较</p><pre><code> Collections.sort(list, new Comparator&lt;Person&gt;() &#123;            @Override            public int compare(Person o1, Person o2) &#123;                return o1.getHeight() - o2.getHeight();            &#125;        &#125;);</code></pre><p>会进入sort方法</p><pre><code>  public static &lt;T&gt; void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c) &#123;        list.sort(c);    &#125;</code></pre><p>会调用list的sort方法 并且把比较器传递进去</p><p>这里先转换成      Object[] a &#x3D; this.toArray();数组</p><pre><code class="java">    @SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)    default void sort(Comparator&lt;? super E&gt; c) &#123;        Object[] a = this.toArray();        Arrays.sort(a, (Comparator) c);        ListIterator&lt;E&gt; i = this.listIterator();        for (Object e : a) &#123;            i.next();            i.set((E) e);        &#125;    &#125;</code></pre><p>调用</p><p> Arrays.sort(a, (Comparator) c);</p><p>真可怕 一个小小的排序用到了不下二十余个方法</p><p>我这边扒了一些最终找到 当我们传递了比较器的比较方法</p><pre><code class="java">   private static void mergeSort(Object[] src,                                  Object[] dest,                                  int low, int high, int off,                                  Comparator c) &#123;        int length = high - low;        // Insertion sort on smallest arrays        if (length &lt; INSERTIONSORT_THRESHOLD) &#123;            for (int i=low; i&lt;high; i++)                for (int j=i; j&gt;low &amp;&amp; c.compare(dest[j-1], dest[j])&gt;0; j--)                    swap(dest, j, j-1);            return;        &#125;        // Recursively sort halves of dest into src        int destLow  = low;        int destHigh = high;        low  += off;        high += off;        int mid = (low + high) &gt;&gt;&gt; 1;        mergeSort(dest, src, low, mid, -off, c);        mergeSort(dest, src, mid, high, -off, c);        // If list is already sorted, just copy from src to dest.  This is an        // optimization that results in faster sorts for nearly ordered lists.        if (c.compare(src[mid-1], src[mid]) &lt;= 0) &#123;           System.arraycopy(src, low, dest, destLow, length);           return;        &#125;        // Merge sorted halves (now in src) into dest        for(int i = destLow, p = low, q = mid; i &lt; destHigh; i++) &#123;            if (q &gt;= high || p &lt; mid &amp;&amp; c.compare(src[p], src[q]) &lt;= 0)                dest[i] = src[p++];            else                dest[i] = src[q++];        &#125;    &#125;</code></pre><pre><code class="java">    private static void mergeSort(Object[] src,                                  Object[] dest,                                  int low, int high, int off,                                  Comparator c) &#123;        int length = high - low;        // Insertion sort on smallest arrays        if (length &lt; INSERTIONSORT_THRESHOLD) &#123;            for (int i=low; i&lt;high; i++)                for (int j=i; j&gt;low &amp;&amp; c.compare(dest[j-1], dest[j])&gt;0; j--)                    swap(dest, j, j-1);            return;        &#125;</code></pre><p>太难lwc</p><p>先简单理解  </p><pre><code class="java">  Collections.sort(list, new Comparator&lt;Person&gt;() &#123;            @Override            public int compare(Person o1, Person o2) &#123;                return o1.getHeight() - o2.getHeight();            &#125;        &#125;);</code></pre><p>compare 一般是是传入比较的值 返回值  -1则是前面的值小</p><p>0则是相等 1则是后面的值大</p><p>具体排序不做深入研究</p><p>这里继续研究Lambda </p><p>既然这里是需要匿名内部类那我们就可以改写成Lambda</p><pre><code class="java">  Collections.sort(list,(Person o1, Person o2)-&gt;&#123;                return o1.getHeight() - o2.getHeight();            &#125;        &#125;);</code></pre><p>既然这里我们没有写方法名字那我们可以大胆判断 </p><p>我们的匿名内部类的实现的接口必定只有一个参数为两个的方法</p><p>int compare(T o1, T o2);</p><p>果然经过查看接口</p><p>只有一个唯一的方法</p><p>@FunctionalInterface</p><p>你提到的<code>Comparator&lt;T&gt;</code>接口被<code>@FunctionalInterface</code>修饰是因为它只包含一个抽象方法<code>compare()</code>，满足函数式接口的要求。函数式接口是指只有一个抽象方法的接口，可以用作Lambda表达式和方法引用的目标类型。</p><p>虽然<code>Comparator&lt;T&gt;</code>接口只有一个抽象方法，但它可以包含其他默认方法和静态方法。这些方法提供了额外的功能和操作，以便更方便地使用和组合比较器。这些附加的默认方法和静态方法并不违反函数式接口的定义，因为它们不会影响接口的函数式特性。</p><p>默认方法是接口中具有默认实现的方法。它们允许在接口中添加新的方法，而不会破坏现有的实现类。<code>Comparator&lt;T&gt;</code>接口中的默认方法提供了一些便捷的比较器组合操作。例如，<code>thenComparing()</code>方法允许在现有的比较器基础上添加额外的比较规则，实现多级排序。</p><p>静态方法是接口中的类级别方法，可以直接通过接口名称调用。<code>Comparator&lt;T&gt;</code>接口中的静态方法提供了一些实用的工具方法，用于创建和组合比较器。例如，<code>comparing()</code>方法用于基于对象的某个属性提取器创建比较器。</p><p>尽管<code>Comparator&lt;T&gt;</code>接口包含默认方法和静态方法，但它仍然是一个函数式接口，因为它只有一个抽象方法<code>compare()</code>。这意味着你可以使用Lambda表达式或方法引用来创建<code>Comparator&lt;T&gt;</code>的实例，而不需要实现额外的方法。</p><p>总之，虽然<code>Comparator&lt;T&gt;</code>接口包含一些默认方法和静态方法，但它仍然被标记为<code>@FunctionalInterface</code>，因为它只有一个抽象方法，满足函数式接口的要求。这使得它可以被用作Lambda表达式和方法引用的目标类型，提供了更灵活和便捷的比较器操作。</p><p>**关于Lambda我们需要知道的是 他只适用于函数时接口 **</p><p>我个人理解 Lambda只是语法糖</p><p>实际上还是一个匿名内部类 去重写这个方法</p><h3 id="Lambda-表达式的省略写法"><a href="#Lambda-表达式的省略写法" class="headerlink" title="Lambda 表达式的省略写法"></a>Lambda 表达式的省略写法</h3><p>在lambda的表达式的标准写法上可以省略写法的规则为</p><p>1.小括号内的参数类型可以省略</p><p>2.如果小括号内有且仅有一个参数则小括号可以省略</p><p>3.如果大括号有且仅有一个语句 可以同时省略大括号 return关键子以及语句分号</p><p><img src="/2023/09/06/jdk8%E6%96%B0%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8/personboke\blog\source_posts\jdk8新特性学习使用\image-20230907220250280.png" alt="image-20230907220250280"></p><h2 id="二、接口中新增的方法"><a href="#二、接口中新增的方法" class="headerlink" title="二、接口中新增的方法"></a>二、接口中新增的方法</h2><h3 id="1-0JDK8中接口的新增"><a href="#1-0JDK8中接口的新增" class="headerlink" title="1.0JDK8中接口的新增"></a>1.0JDK8中接口的新增</h3><p>在jdk8中这妞的接口有做增强  j8之前</p><pre><code>interface 接口名&#123;    静态常量；    抽象方法；&#125;</code></pre><pre><code>interface 接口名&#123;    静态常量；    抽象方法；    默认方法；    静态方法；&#125;</code></pre><h3 id="2静态方法"><a href="#2静态方法" class="headerlink" title="2静态方法"></a>2静态方法</h3><h4 id="为什么要增加？"><a href="#为什么要增加？" class="headerlink" title="为什么要增加？"></a>为什么要增加？</h4><p>为了解决咱们如果一个接口被多个实现类实现了  </p><p>再增加方法实现类都要实现  非常差的体验 </p><pre><code>interface A&#123;public  default String method（）&#123;sout（&quot;接口中的方法&quot;）&#125;&#125;</code></pre><pre><code>class b implment A&#123;@Overridepublic  String method（）&#123;sout（&quot;实现类中的方法&quot;）&#125;&#125;</code></pre><h3 id="3默认方法"><a href="#3默认方法" class="headerlink" title="3默认方法"></a>3默认方法</h3><p>作用：拓展接口的功能</p><h4 id="3-1语法规则"><a href="#3-1语法规则" class="headerlink" title="3.1语法规则"></a>3.1语法规则</h4><pre><code>interface A&#123;public static String test4()&#123; sout(&quot;接口中的静态方法&quot;)；&#125;&#125;&#125;class b implment A&#123;不能重写静态方法只能A.staticMethod();&#125;</code></pre><h2 id="三、函数式接口"><a href="#三、函数式接口" class="headerlink" title="三、函数式接口"></a>三、函数式接口</h2><h3 id="1-函数式接口的由来"><a href="#1-函数式接口的由来" class="headerlink" title="1.函数式接口的由来"></a>1.函数式接口的由来</h3><p>我们知道lambda表达式的前提式需要有函数时接口 而lambad表达式使用时不关心接口名抽象方法名、只关心抽象方法的参数列表和返回值类型。因此为了我们可以使用lambda表达式更加的方法在jdk中提供的大量的常用的函数式接口</p><p>1.Consumer接口</p><p>void accept（T t）；</p><p>2.Supplier接口</p><p>R apply（T t）；</p><h3 id="2-函数式接口介绍"><a href="#2-函数式接口介绍" class="headerlink" title="2.函数式接口介绍"></a>2.函数式接口介绍</h3><h4 id="2-1Supplier"><a href="#2-1Supplier" class="headerlink" title="2.1Supplier"></a>2.1Supplier</h4><p><strong>无参有返回值  供给型</strong></p><pre><code>@FunctionalInterfavepublic interface Supplier&lt;T&gt;&#123;/**Gets a result@Return a result；**/T get();&#125;</code></pre><h3 id="2-1-1使用"><a href="#2-1-1使用" class="headerlink" title="2.1.1使用"></a>2.1.1使用</h3><pre><code>  public class SupplierTest &#123;    public static void main(String[] args) &#123;        fun1(()-&gt;&#123;            int arr[] = &#123;22,33,55,66,44,99,10&#125;;            // 计算出数组中的最大值            Arrays.sort(arr);            return arr[arr.length-1];        &#125;);        funcition(()-&gt;&#123;            String getString=&quot;Supplier&lt;Integer&gt; supplier&quot;;            return getString;        &#125;);    &#125;    private static void fun1(Supplier&lt;Integer&gt; supplier)&#123;        // get() 是一个无参的有返回值的 抽象方法        Integer max = supplier.get();        System.out.println(&quot;max = &quot; + max);    &#125;    private static void funcition(Supplier&lt;String&gt; supplier)&#123;        // get() 是一个无参的有返回值的 抽象方法        String getString = supplier.get();        System.out.println(getString);    &#125;&#125;</code></pre><h4 id="2-2Consumer"><a href="#2-2Consumer" class="headerlink" title="2.2Consumer"></a>2.2Consumer</h4><p><strong>有参无返回值</strong></p><p><strong>Consumer接口是用来消费数据的 使用的售后需要指定反省来定义参数类型</strong></p><pre><code>@FunctionalInterfacepublic interface Consumer&lt;T&gt; &#123;    /**     * Performs this operation on the given argument.     *     * @param t the input argument     */    void accept(T t);&#125;</code></pre><p><img src="/2023/09/06/jdk8%E6%96%B0%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8/personboke\blog\source_posts\jdk8新特性学习使用\image-20230908231516817.png" alt="image-20230908231516817"></p><pre><code>   public static void main(String[] args) &#123;        test2(msg1-&gt;&#123;            System.out.println(msg1 + &quot;-&gt; 转换为小写：&quot; + msg1.toLowerCase());        &#125;,msg2-&gt;&#123;            System.out.println(msg2 + &quot;-&gt; 转换为大写：&quot; + msg2.toUpperCase());        &#125;);    &#125;    public static void test2(Consumer&lt;String&gt; c1,Consumer&lt;String&gt; c2)&#123;        String str = &quot;Hello World&quot;;        //c1.accept(str); // 转小写        //c2.accept(str); // 转大写        //c1.andThen(c2).accept(str);        c2.andThen(c1).accept(str);    &#125;</code></pre><h3 id="2-3-Function"><a href="#2-3-Function" class="headerlink" title="2.3 Function"></a>2.3 Function</h3><p><strong>有参有返回值</strong></p><p><strong>function 根据一个类型的数据得到另一个类型的数据 前者称为前置条件</strong></p><p><strong>后者成为后置条件  有参有返回值</strong></p><pre><code>@FunctionalInterfacepublic interface Function&lt;T, R&gt; &#123;    /**     * Applies this function to the given argument.     * @param t the function argument     * @return the function result     */    R apply(T t);        &#125;</code></pre><pre><code>  public static void main(String[] args) &#123;        test(msg -&gt;&#123;            return Integer.parseInt(msg);        &#125;);    &#125;    public static void test(Function&lt;String,Integer&gt; function)&#123;        Integer apply = function.apply(&quot;666&quot;);        System.out.println(&quot;apply = &quot; + apply);    &#125;</code></pre><p>默认方法 </p><p>andThen()</p><pre><code>    public static void main(String[] args) &#123;        test(msg -&gt;&#123;            return Integer.parseInt(msg);        &#125;,msg2-&gt;&#123;            return msg2 * 10;        &#125;);    &#125;    public static void test(Function&lt;String,Integer&gt; f1,Function&lt;Integer,Integer&gt; f2)&#123;        /*Integer i1 = f1.apply(&quot;666&quot;);        Integer i2 = f2.apply(i1);*/       // Integer i2 = f1.andThen(f2).apply(&quot;666&quot;);        Integer i2 = f2.compose(f1).apply(&quot;666&quot;);        System.out.println(&quot;i2:&quot; + i2);    &#125;</code></pre><p>compose方法的作用顺序和andThen方法刚好相反</p><p>静态方法identity则是输入什么参数就返回什么参数</p><h4 id="2-4Predicate"><a href="#2-4Predicate" class="headerlink" title="2.4Predicate"></a>2.4Predicate</h4><p>有参有返回值 切返回值为布尔</p><pre><code>@FunctionalInterfacepublic interface Predicate&lt;T&gt; &#123;    /**     * Evaluates this predicate on the given argument.     *     * @param t the input argument     * @return &#123;@code true&#125; if the input argument matches the predicate,     * otherwise &#123;@code false&#125;     */    boolean test(T t);&#125;</code></pre><p>test（）</p><pre><code>    public static void main(String[] args) &#123;        test(msg1 -&gt; &#123;            return msg1.contains(&quot;H&quot;);        &#125;,msg2 -&gt; &#123;            return msg2.contains(&quot;W&quot;);        &#125;);    &#125;    private static void test(Predicate&lt;String&gt; p1,Predicate&lt;String&gt; p2)&#123;        /*boolean b1 = predicate.test(msg);        boolean b2 = predicate.test(&quot;Hello&quot;);*/        // b1 包含H b2 包含W        // p1 包含H 同时 p2 包含W        boolean bb1 = p1.and(p2).test(&quot;Hello&quot;);        // p1 包含H 或者 p2 包含W        boolean bb2 = p1.or(p2).test(&quot;Hello&quot;);        // p1 不包含H        boolean bb3 = p1.negate().test(&quot;Hello&quot;);        System.out.println(bb1); // FALSE        System.out.println(bb2); // TRUE        System.out.println(bb3); // FALSE    &#125;</code></pre><h2 id="四、方法引用"><a href="#四、方法引用" class="headerlink" title="四、方法引用"></a>四、方法引用</h2><p>符号标识：：</p><p>符号说明： 双冒号为方法引用运算符 而他所在的表达式被称为方法引用</p><p>应用场景： 如果Lambda表达式所要实现方案已经有方法存在相同方案 那么可以使用方法引用</p><p>常见的引用方法</p><p> ag：</p><pre><code>1. instanceName::methodName 对象::方法名2.Classname::staticMethodName 类名：：静态方法3.ClassName：：methodName 类名：：普通方法4.ClassName：：new 类名：：new 调用的构造器5.Typename[]::new String[]::new 调用数组的构造器</code></pre><p><img src="/2023/09/06/jdk8%E6%96%B0%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8/personboke\blog\source_posts\jdk8新特性学习使用\image-20230909003224091.png" alt="image-20230909003224091"></p><h2 id="User-getUsername-相当于"><a href="#User-getUsername-相当于" class="headerlink" title="**User::getUsername **  相当于"></a>**User::getUsername **  相当于</h2><p><strong>实际上也是一个实现类的方法</strong></p><h2 id="User-user-gt-user-getUsername"><a href="#User-user-gt-user-getUsername" class="headerlink" title="(User user) -&gt; user.getUsername()"></a>(User user) -&gt; user.getUsername()</h2><pre><code class="java">    @Override    public List&lt;User&gt; queryUsers(String username, Integer status, Long min, Long max) &#123;        return lambdaQuery().like(User::getUsername, username).list();    &#125;</code></pre><h2 id="记忆深化案例"><a href="#记忆深化案例" class="headerlink" title="记忆深化案例"></a>记忆深化案例</h2><p><strong>以下是一个示例，展示了如何创建一个匿名实现类：</strong></p><pre><code class="java">interface MyInterface &#123;    void doSomething();&#125;public class Main &#123;    public static void main(String[] args) &#123;        // 创建匿名实现类        MyInterface myInterface = new MyInterface() &#123;            @Override            public void doSomething() &#123;                System.out.println(&quot;Doing something in anonymous implementation.&quot;);            &#125;        &#125;;        // 调用匿名实现类的方法        myInterface.doSomething();    &#125;&#125;</code></pre><p><strong>使用 Lambda 表达式：</strong></p><pre><code class="java">interface MyInterface &#123;    void doSomething();&#125;public class Main &#123;    public static void main(String[] args) &#123;        // 使用 Lambda 表达式创建接口实例        MyInterface myInterface = () -&gt; &#123;            System.out.println(&quot;Doing something in Lambda expression.&quot;);        &#125;;        // 调用接口方法        myInterface.doSomething();    &#125;&#125;</code></pre><p><strong>使用方法引用：</strong></p><pre><code class="java">interface MyInterface &#123;    void doSomething();&#125;public class Main &#123;    public static void main(String[] args) &#123;        // 使用方法引用创建接口实例        MyInterface myInterface = Main::doSomethingMethodReference;        // 调用接口方法        myInterface.doSomething();    &#125;    // 静态方法作为方法引用的目标    public static void doSomethingMethodReference() &#123;        System.out.println(&quot;Doing something in method reference.&quot;);    &#125;</code></pre><p><strong>再次记忆深化</strong></p><pre><code class="java">new MyInterface() &#123;            @Override            public void doSomething() &#123;                System.out.println(&quot;Doing something in anonymous implementation.&quot;);            &#125;        &#125;;</code></pre><p>等价于</p><pre><code>() -&gt; System.out.println(&quot;Doing something in lambda expression.&quot;)).doSomething();    &#125;</code></pre><h2 id="五、Stream-APi"><a href="#五、Stream-APi" class="headerlink" title="五、Stream APi"></a>五、Stream APi</h2><h4 id="1-集合处理数据的弊端"><a href="#1-集合处理数据的弊端" class="headerlink" title="1.集合处理数据的弊端"></a>1.集合处理数据的弊端</h4><p>当我们需要对集合中的元素进行操作的时候除了必须的添加删除获取外 </p><p>最典型的操作就是集合遍历</p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><pre><code>    list.forEach(new Consumer&lt;String&gt;() &#123;            @Override            public void accept(String a) &#123;                System.out.println(a);            &#125;        &#125;);        list.forEach(s -&gt; &#123;            System.out.println(s);        &#125;);        list.forEach(System.out::println);</code></pre><p>foreach里面的对象类型必须跟方法引用得参数保持一致</p><pre><code>// 定义一个List集合        List&lt;String&gt; list = Arrays.asList(&quot;张三&quot;,&quot;张三丰&quot;,&quot;成龙&quot;,&quot;周星驰&quot;);        // 1.获取所有 姓张的信息        // 2.获取名称长度为3的用户        // 3. 输出所有的用户信息        list.stream()                .filter(s-&gt;s.startsWith(&quot;张&quot;))                .filter(s-&gt;s.length() == 3)                .forEach(s-&gt;&#123;                    System.out.println(s);                &#125;);        System.out.println(&quot;----------&quot;);        list.stream()                .filter(s-&gt;s.startsWith(&quot;张&quot;))                .filter(s-&gt;s.length() == 3)                .forEach(System.out::println);        </code></pre><h3 id="Stream流的获取方式"><a href="#Stream流的获取方式" class="headerlink" title="Stream流的获取方式"></a>Stream流的获取方式</h3><h4 id="3-1-根据Collection获取"><a href="#3-1-根据Collection获取" class="headerlink" title="3.1 根据Collection获取"></a>3.1 根据Collection获取</h4><p> <strong>java.util.Collection接口中假如default方法 Stream 也就是Collection</strong></p><p><strong>接口下的所有实现都可以通过stream方法来获取Stream流</strong></p><pre><code>  public static void main(String[] args) &#123;        Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();        Stream&lt;String&gt; stream = map.keySet().stream(); // key        Stream&lt;Object&gt; stream1 = map.values().stream(); // value        Stream&lt;Map.Entry&lt;String, Object&gt;&gt; stream2 = map.entrySet().stream(); // entry    &#125;</code></pre><p>Map接口没有实现collection接口如何获取？</p><p> 通过 Map key集合 和value集合来获取</p><pre><code>    Stream&lt;String&gt; stream = map.keySet().stream(); // key    Stream&lt;Object&gt; stream1 = map.values().stream(); // value</code></pre><h3 id="3-2-Stream的of方法"><a href="#3-2-Stream的of方法" class="headerlink" title="3.2 Stream的of方法"></a><strong>3.2 Stream的of方法</strong></h3><p><strong>在实际开发中我们不可避免的还是会操作到数组中的数据 由于数组对象 中不可能添加默认方法 所有的Stream接口中提供了静态方法 of</strong></p><pre><code>   Stream&lt;String&gt; a1 = Stream.of(&quot;a1&quot;, &quot;a2&quot;, &quot;a3&quot;);        String[] arr1 = &#123;&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;&#125;;        Stream&lt;String&gt; arr11 = Stream.of(arr1);        Integer[] arr2 = &#123;1,2,3,4&#125;;        Stream&lt;Integer&gt; arr21 = Stream.of(arr2);        arr21.forEach(System.out::println);        // 注意：基本数据类型的数组是不行的        int[] arr3 = &#123;1,2,3,4&#125;;        Stream.of(arr3).forEach(System.out::println);       </code></pre><table><thead><tr><th align="center">方法名</th><th align="center">方法作用</th><th align="center">返回值类型</th><th align="center">方法种类</th></tr></thead><tbody><tr><td align="center">count</td><td align="center">统计个数</td><td align="center">long</td><td align="center">终结</td></tr><tr><td align="center">forEach</td><td align="center">逐一遍历</td><td align="center">void</td><td align="center">终结</td></tr><tr><td align="center">filter</td><td align="center">过滤</td><td align="center">Stream</td><td align="center">函数拼接</td></tr><tr><td align="center">limit</td><td align="center">取用前几个</td><td align="center">Stream</td><td align="center">函数拼接</td></tr><tr><td align="center">skip</td><td align="center">跳过前几个</td><td align="center">Stream</td><td align="center">函数拼接</td></tr><tr><td align="center">map</td><td align="center">映射</td><td align="center">Stream</td><td align="center">函数拼接</td></tr><tr><td align="center">concat</td><td align="center">组合 连接</td><td align="center">Stream</td><td align="center">函数拼接</td></tr><tr><td align="center">Match</td><td align="center">匹配集合中元素是否符合</td><td align="center">Boolean</td><td align="center">匹配</td></tr></tbody></table><p><strong>终结方法</strong>：返回值类型不再是Stream类型的方法不再支持链式调用</p><p>count 和forEach</p><p><strong>非终结方法</strong>： 返回值类型仍然是Stream类型的方法 支持链式调用</p><p>除了终结方法则为非终结</p><p><strong>Stream流注意事项）</strong></p><p>1.Stream流只能操作一次</p><p>2.Stream流方法返回最新的流</p><p>3.Stream不调用终结方法中间的操作不会执行</p><h4 id="3-11-ForEach"><a href="#3-11-ForEach" class="headerlink" title="3.11 ForEach"></a>3.11 ForEach</h4><pre><code> public static void main(String[] args) &#123;        Stream.of(&quot;a1&quot;, &quot;a2&quot;, &quot;a3&quot;).forEach(System.out::println);;    &#125;</code></pre><h4 id="3-12-Count"><a href="#3-12-Count" class="headerlink" title="3.12 Count"></a>3.12 Count</h4><pre><code>   public static void main(String[] args) &#123;        long count = Stream.of(&quot;a1&quot;, &quot;a2&quot;, &quot;a3&quot;).count();        System.out.println(count);    &#125;</code></pre><h4 id="3-13Filter"><a href="#3-13Filter" class="headerlink" title="3.13Filter"></a>3.13Filter</h4><h4 id="3-14Limit"><a href="#3-14Limit" class="headerlink" title="3.14Limit"></a>3.14Limit</h4><h4 id="3-15Skip"><a href="#3-15Skip" class="headerlink" title="3.15Skip"></a>3.15Skip</h4><h4 id="3-16Map方法"><a href="#3-16Map方法" class="headerlink" title="3.16Map方法"></a>3.16Map方法</h4><h4 id="3-17Sorted"><a href="#3-17Sorted" class="headerlink" title="3.17Sorted"></a>3.17Sorted</h4><h4 id="3-18Distinct"><a href="#3-18Distinct" class="headerlink" title="3.18Distinct"></a>3.18Distinct</h4><h4 id="3-19-match"><a href="#3-19-match" class="headerlink" title="3.19 match"></a>3.19 match</h4><p>终结方法</p><p><strong>allMatch(s -&gt; s &gt; 0) 所有元素都大于0</strong><br><strong>anyMatch(s -&gt; s &gt;0 ）集合中任意元素大于0</strong></p><pre><code>    public static void main(String[] args) &#123;        boolean b = Stream.of(&quot;1&quot;, &quot;3&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;1&quot;, &quot;7&quot;)                .map(Integer::parseInt)                //.allMatch(s -&gt; s &gt; 0)                //.anyMatch(s -&gt; s &gt;4)                 .noneMatch(s -&gt; s &gt; 4)                ;        System.out.println(b);    &#125;</code></pre><h4 id="3-20Find"><a href="#3-20Find" class="headerlink" title="3.20Find"></a>3.20Find</h4><p>找到符合条件的数据</p><pre><code class="java">   public static void main(String[] args) &#123;        Optional&lt;String&gt; first = Stream.of(&quot;1&quot;, &quot;3&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;1&quot;, &quot;7&quot;).findFirst();        System.out.println(first.get());        Optional&lt;String&gt; any = Stream.of(&quot;1&quot;, &quot;3&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;1&quot;, &quot;7&quot;).findAny();        System.out.println(any.get());    &#125;</code></pre><p><strong>Optional<String> any &#x3D; Stream.<em>of</em>(“10”, “3”, “3”, “4”, “5”, “0”, “7”).findAny();</String></strong><br><strong>System.<em>out</em>.println(any.get());</strong></p><p><strong>我测试时一直返回第一个元素</strong></p><h4 id="3-21Max和Min"><a href="#3-21Max和Min" class="headerlink" title="3.21Max和Min"></a>3.21Max和Min</h4><pre><code class="java">     Optional&lt;Integer&gt; max = Stream.of(&quot;1&quot;, &quot;3&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;1&quot;, &quot;7&quot;)                .map(Integer::parseInt)                .max((o1,o2)-&gt;o1-o2);        System.out.println(max.get());        Optional&lt;Integer&gt; min = Stream.of(&quot;1&quot;, &quot;3&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;1&quot;, &quot;7&quot;)                .map(Integer::parseInt)                .min((o1,o2)-&gt;o1-o2);        System.out.println(min.get());</code></pre><h4 id="3-22Reduce方法"><a href="#3-22Reduce方法" class="headerlink" title="3.22Reduce方法"></a>3.22Reduce方法</h4><pre><code class="java">   public static void main(String[] args) &#123;        Integer sum = Stream.of(4, 5, 3, 9)                .reduce(0,(x,y)-&gt;&#123;                    return x + y;                &#125;);                // identity默认值                // 第一次的时候会将默认值赋值给x                //操作时 x=x+y   y=collection（index）//        reduce(0,(x,y)设置为0时就是 return的数据会赋值给x //                集合元素数据赋值给y        Integer max = Stream.of(4, 5, 3, 9)                .reduce(0,(x,y)-&gt;&#123;                    return x&gt;y?x:y;                &#125;);        System.out.println(sum);        System.out.println(max);    &#125;</code></pre><h4 id="3-23-map和reduce组合"><a href="#3-23-map和reduce组合" class="headerlink" title="3.23 map和reduce组合"></a>3.23 map和reduce组合</h4><pre><code class="java">     // 1.求出所有年龄的总和        Integer sumAge = Stream.of(                new Person(&quot;张三&quot;, 18)                , new Person(&quot;李四&quot;, 22)                , new Person(&quot;张三&quot;, 13)                , new Person(&quot;王五&quot;, 15)                , new Person(&quot;张三&quot;, 19)        ).map(Person::getAge) // 实现数据类型的转换                .reduce(0, Integer::sum);        System.out.println(sumAge);        // 2.求出所有年龄中的最大值        Integer maxAge = Stream.of(                new Person(&quot;张三&quot;, 18)                , new Person(&quot;李四&quot;, 22)                , new Person(&quot;张三&quot;, 13)                , new Person(&quot;王五&quot;, 15)                , new Person(&quot;张三&quot;, 19)          ).map(Person::getAge) // 实现数据类型的转换，符合reduce对数据的要求                .reduce(0, Math::max); // reduce实现数据的处理        System.out.println(maxAge);        // 3.统计 字符 a 出现的次数        Integer count = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;a&quot;, &quot;c&quot;, &quot;a&quot;)                .map(ch -&gt; &quot;a&quot;.equals(ch) ? 1 : 0)                .reduce(0, Integer::sum);        System.out.println(count);    &#125;</code></pre><h4 id="3-24MapToInt"><a href="#3-24MapToInt" class="headerlink" title="3.24MapToInt"></a>3.24MapToInt</h4><p>主要是将集合元素转换成int</p><pre><code>       // Integer占用的内存比int多很多，在Stream流操作中会自动装修和拆箱操作        Integer arr[] = &#123;1,2,3,5,6,8&#125;;        Stream.of(arr)                .filter(i-&gt;i&gt;0)                .forEach(System.out::println);        System.out.println(&quot;---------&quot;);        // 为了提高程序代码的效率，我们可以先将流中Integer数据转换为int数据，然后再操作        IntStream intStream = Stream.of(arr)                .mapToInt(Integer::intValue);        intStream.filter(i-&gt;i&gt;3)                .forEach(System.out::println);    &#125;</code></pre><h4 id="3-25Concat"><a href="#3-25Concat" class="headerlink" title="3.25Concat"></a>3.25Concat</h4><pre><code>        Stream&lt;String&gt; stream1 = Stream.of(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);        Stream&lt;String&gt; stream2 = Stream.of(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;);        // 通过concat方法将两个流合并为一个新的流        Stream.concat(stream1,stream2).forEach(System.out::println);</code></pre><h2 id="2-流的常用创建方式"><a href="#2-流的常用创建方式" class="headerlink" title="2. 流的常用创建方式"></a>2. 流的常用创建方式</h2><pre><code class="java">/** * stream，获取各种集合的stream流 */@Testpublic void testCollectionStream()&#123;    //List集合      List&lt;String&gt; stringList = new ArrayList&lt;&gt;();    //Set集合    Set&lt;String&gt; stringSet = new HashSet&lt;&gt;();    //Map集合    Map&lt;String,Object&gt; stringObjectMap = new HashMap&lt;&gt;();    //数组    String[] stringArray = &#123;&quot;张三三&quot;,&quot;李四&quot;,&quot;王五&quot;,&quot;王五&quot;,&quot;赵八&quot;,&#125;;    //通过list获取stream流    Stream&lt;String&gt; streamList = stringList.stream();    //通过set获取stream流    Stream&lt;String&gt; streamSet = stringSet.stream();    //通过map获取stream流    Stream&lt;String&gt; streamMap = stringObjectMap.keySet().stream();    //通过array获取stream流    Stream&lt;String&gt; streamArray1 = Stream.of(stringArray);&#125;</code></pre><h2 id="3-构造流的几种常见方法"><a href="#3-构造流的几种常见方法" class="headerlink" title="3. 构造流的几种常见方法"></a>3. 构造流的几种常见方法</h2><pre><code class="java">@Testpublic void testCollectionStream()&#123;   // 1. Individual values  Stream stream = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);    // 2. Arrays  String[] strArray = new String[]&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;;  stream = Stream.of(strArray);  stream = Arrays.stream(strArray);    // 3. Collections  List&lt;String&gt; list = Arrays.asList(strArray);  stream = list.stream();  &#125;</code></pre><h1 id="五-Stream在代码中的使用方式"><a href="#五-Stream在代码中的使用方式" class="headerlink" title="五. Stream在代码中的使用方式"></a>五. Stream在代码中的使用方式</h1><p>关于Stream的常见操作方式，主要分为两大类： 中间操作和终止操作 ，接下来就通过这两大分类，讲解下具体的语法用法。</p><h2 id="1-流的中间操作"><a href="#1-流的中间操作" class="headerlink" title="1. 流的中间操作"></a>1. 流的中间操作</h2><h3 id="1-1-筛选过滤"><a href="#1-1-筛选过滤" class="headerlink" title="1.1 筛选过滤"></a>1.1 筛选过滤</h3><ul><li><p>filter：过滤流中的某些元素</p><pre><code class="java">   /**     * filter 方法 ， 返回符合过滤条件的值     */    @Test    public void testFilter() &#123;        List&lt;String&gt; list = new ArrayList&lt;&gt;();        list.add(&quot;张三三&quot;);        list.add(&quot;李四&quot;);        list.add(&quot;王五&quot;);        list.add(&quot;孙七&quot;);        list.add(&quot;赵八&quot;);        list.stream().filter(e -&gt; e.contains(&quot;张&quot;)).forEach(System.out::println);    &#125;</code></pre><p>或</p><ul><li>filter多个过滤筛选条件</li></ul><pre><code class="java">   /**  * list集合stream流式操作  */ @Test public void testStreamList() &#123;     List&lt;String&gt; list = new ArrayList&lt;&gt;();     list.add(&quot;张三三&quot;);     list.add(&quot;李四&quot;);     list.add(&quot;王五&quot;);     list.add(&quot;孙七&quot;);     list.add(&quot;赵八&quot;);     list.stream().filter(e -&gt; e.startsWith(&quot;张&quot;)) //过滤所有姓张的人             .filter(e -&gt; e.length() == 3) //过滤所有姓名是3个字的人             .forEach(System.out::println); //遍历打印,System.out::println表明System.out调用println打印方法 &#125;</code></pre></li><li><p>limit(n)：获取前n个元素</p><pre><code class="java"> /**     * limit 方法 ，返回前n个元素数据值组成的Stream。     */    @Test    public void testLimit() &#123;        List&lt;String&gt; list = new ArrayList&lt;&gt;();        list.add(&quot;张三三&quot;);        list.add(&quot;李四&quot;);        list.add(&quot;王五&quot;);        list.add(&quot;孙七&quot;);        list.add(&quot;赵八&quot;);        list.add(&quot;王二麻子&quot;);        list.stream().limit(3).forEach(System.out::println); //取前3个    &#125;</code></pre></li><li><p>skip(n)：跳过n元素，配合limit(n)可实现分页</p><pre><code class="java"> /**     * skip方法 ，跳过前n个元素的中间流操作，返回剩下的值。     */    @Test    public void testSkip() &#123;        List&lt;String&gt; list = new ArrayList&lt;&gt;();        list.add(&quot;张三三&quot;);        list.add(&quot;李四&quot;);        list.add(&quot;王五&quot;);        list.add(&quot;孙七&quot;);        list.add(&quot;赵八&quot;);        list.add(&quot;王二麻子&quot;);        //list.stream().skip(3).forEach(System.out::println); //跳过前3个        list.stream().skip(3).limit(2).forEach(System.out::println); //skip+limit实现分页    &#125;</code></pre></li><li><p>distinct：通过流中元素的 hashCode() 和 equals() 去除重复元素</p><pre><code class="java"> /**     * distinct， 返回去重的Stream     */    @Test    public void testDistinct() &#123;        List&lt;String&gt; list = new ArrayList&lt;&gt;();        list.add(&quot;张三三&quot;);        list.add(&quot;李四&quot;);        list.add(&quot;李四&quot;);        list.add(&quot;王五&quot;);        list.add(&quot;王五&quot;);        list.add(&quot;孙七&quot;);        list.add(&quot;赵八&quot;);        list.add(&quot;王二麻子&quot;);        list.stream().distinct().collect(Collectors.toList()).forEach(System.out::println);    &#125;</code></pre></li></ul><h3 id="1-2-排序"><a href="#1-2-排序" class="headerlink" title="1.2 排序"></a>1.2 排序</h3><ul><li><p>sorted()：自然排序，流中元素需实现Comparable接口</p><pre><code class="java"> /**     * sorted: 返回一个排序的Stream     */    @Test    public void testSorted() &#123;        List&lt;String&gt; list = new ArrayList&lt;&gt;();        list.add(&quot;张三三&quot;);        list.add(&quot;李四&quot;);        list.add(&quot;李四&quot;);        list.add(&quot;王五&quot;);        list.add(&quot;王五&quot;);        list.add(&quot;孙七&quot;);        list.add(&quot;赵八&quot;);        list.add(&quot;王二麻子&quot;);        list.stream().distinct().sorted().collect(Collectors.toList()).forEach(System.out::println);    &#125;</code></pre></li><li><p>sorted(Comparator com)：定制排序，自定义Comparator排序器</p></li></ul><h3 id="1-3-映射"><a href="#1-3-映射" class="headerlink" title="1.3 映射"></a>1.3 映射</h3><ul><li>map：接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。</li></ul><pre><code class="java">/**    * 遍历map集合，截取substring(2)开始的值    */   @Test   public void testMap() &#123;       List&lt;String&gt; list = new ArrayList&lt;&gt;();       list.add(&quot;张三三&quot;);       list.add(&quot;李四&quot;);       list.add(&quot;王五&quot;);       list.add(&quot;孙七&quot;);       list.add(&quot;赵八&quot;);       list.add(&quot;王二麻子&quot;);       Stream&lt;String&gt; stream = list.stream().map(e -&gt; e.substring(2));       stream.forEach(System.out::println);   &#125;</code></pre><ul><li><p>forEach：ForEach流式遍历集合</p><pre><code class="java">  /**     * forEach， ForEach流式遍历list集合     */    @Test    public void testForEach() &#123;        List&lt;String&gt; list = new ArrayList&lt;&gt;();        list.add(&quot;张三三&quot;);        list.add(&quot;李四&quot;);        list.add(&quot;王五&quot;);        list.add(&quot;孙七&quot;);        list.add(&quot;赵八&quot;);        list.stream().forEach(System.out::println);    &#125;</code></pre></li></ul><h2 id="2-流的终止操作"><a href="#2-流的终止操作" class="headerlink" title="2. 流的终止操作"></a>2. 流的终止操作</h2><h3 id="2-1-匹配、聚合操作"><a href="#2-1-匹配、聚合操作" class="headerlink" title="2.1 匹配、聚合操作"></a><strong>2.1 匹配、聚合操作</strong></h3><ul><li><p>allMatch：接收一个 Predicate 函数，当流中每个元素都符合该断言时才返回true，否则返回false</p><pre><code class="java"> /**     * allMatch：接收一个 Predicate 函数，当流中每个元素都符合该断言时才返回true，否则返回false     */    @Test    public void testAllMatch() &#123;        List&lt;String&gt; list = new ArrayList&lt;&gt;();        list.add(&quot;张三三&quot;);        list.add(&quot;李四&quot;);        list.add(&quot;李四&quot;);        list.add(&quot;王五&quot;);        list.add(&quot;王五&quot;);        list.add(&quot;孙七&quot;);        list.add(&quot;赵八&quot;);        list.add(&quot;王二麻子&quot;);        boolean b = list.stream()                .allMatch(e -&gt; list.size() &gt; 8);        System.out.println(&quot;b = &quot; + b);    &#125;</code></pre></li><li><p>noneMatch：接收一个 Predicate 函数，当流中每个元素都不符合该断言时才返回true，否则返回false</p><pre><code class="java">    /**     * noneMatch: 接收一个 Predicate 函数，当流中每个元素都不符合该断言时才返回true，否则返回false     */    @Test    public void testNoneMatch() &#123;        List&lt;String&gt; list = new ArrayList&lt;&gt;();        list.add(&quot;张三三&quot;);        list.add(&quot;李四&quot;);        list.add(&quot;李四&quot;);        list.add(&quot;王五&quot;);        list.add(&quot;王五&quot;);        list.add(&quot;孙七&quot;);        list.add(&quot;赵八&quot;);        list.add(&quot;王二麻子&quot;);        boolean b = list.stream().noneMatch(e-&gt;e.equals(&quot;张三&quot;));        System.out.println(&quot;b = &quot; + b);    &#125;</code></pre></li><li><p>anyMatch：接收一个 Predicate 函数，只要流中有一个元素满足该断言则返回true，否则返回false</p><pre><code class="java">/**     * anyMatch：接收一个 Predicate 函数，只要流中有一个元素满足该断言则返回true，否则返回false     */    @Test    public void testAnyMatch() &#123;        List&lt;String&gt; list = new ArrayList&lt;&gt;();        list.add(&quot;张三三&quot;);        list.add(&quot;李四&quot;);        list.add(&quot;李四&quot;);        list.add(&quot;王五&quot;);        list.add(&quot;王五&quot;);        list.add(&quot;孙七&quot;);        list.add(&quot;赵八&quot;);        list.add(&quot;王二麻子&quot;);        boolean b = list.stream().anyMatch(e -&gt; e.equals(&quot;王二麻子&quot;));        System.out.println(&quot;b = &quot; + b);    &#125;</code></pre></li><li><p>findFirst：返回流中第一个元素</p><pre><code class="java"> /**     * findFirst：返回流中第一个元素     */    @Test    public void testFindFirsth() &#123;        List&lt;String&gt; list = new ArrayList&lt;&gt;();        list.add(&quot;张三三&quot;);        list.add(&quot;李四&quot;);        list.add(&quot;李四&quot;);        list.add(&quot;王五&quot;);        list.add(&quot;王五&quot;);        list.add(&quot;孙七&quot;);        list.add(&quot;赵八&quot;);        list.add(&quot;王二麻子&quot;);        Optional&lt;String&gt; first = list.stream().findFirst();        System.out.println(&quot;first = &quot; + first.get());    &#125;</code></pre></li><li><p>findAny：返回流中的任意元素</p><pre><code class="java">    /**     * findAny：返回流中第一个元素     */    @Test    public void testFindAny() &#123;        List&lt;String&gt; list = new ArrayList&lt;&gt;();        list.add(&quot;张三三&quot;);        list.add(&quot;李四&quot;);        list.add(&quot;李四&quot;);        list.add(&quot;王五&quot;);        list.add(&quot;王五&quot;);        list.add(&quot;孙七&quot;);        list.add(&quot;赵八&quot;);        list.add(&quot;王二麻子&quot;);        Optional&lt;String&gt; any = list.stream().findAny();        System.out.println(&quot;any = &quot; + any.get());    &#125;</code></pre></li><li><p>count：返回流中元素的总个数</p><pre><code class="java"> /**     * count，获取List集合的长度     */    @Test    public void testCount() &#123;        List&lt;String&gt; list = new ArrayList&lt;&gt;();        list.add(&quot;张三三&quot;);        list.add(&quot;李四&quot;);        list.add(&quot;王五&quot;);        list.add(&quot;孙七&quot;);        list.add(&quot;赵八&quot;);        list.add(&quot;王二麻子&quot;);        long count = list.stream().count();        System.out.println(&quot;count = &quot; + count);        int size = list.size();        System.out.println(&quot;size = &quot; + size);    &#125;</code></pre></li><li><p>max：返回流中元素最大值</p><pre><code class="java">/**     * max：返回流中元素最大值     */    @Test    public void testMax() &#123;        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();        list.add(11);        list.add(22);        list.add(33);        list.add(44);        list.add(55);        list.add(66);        list.add(77);        list.add(88);        Integer integer = list.stream().max(Integer::compareTo).get();        System.out.println(&quot;integer = &quot; + integer);    &#125;</code></pre></li><li><p>min：返回流中元素最小值</p><pre><code class="java">/** * min：返回流中元素最小值 */@Testpublic void testMin() &#123;    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();    list.add(11);    list.add(22);    list.add(33);    list.add(44);    list.add(55);    list.add(66);    list.add(77);    list.add(88);    Integer integer = list.stream().min(Integer::compareTo).get();    System.out.println(&quot;integer = &quot; + integer);    list.stream().limit(1).limit(2).distinct().skip(3).filter(f -&gt; f.equals(55)).forEach(System.out::println);&#125;</code></pre></li><li><p>collect：聚合操作，封装目标数据，将流转换为其他形式接收，List、Map、Set等</p></li></ul><pre><code class="java">   /**     * collect，将流转化为List集合，然后遍历集合     */    @Test    public void testCollect() &#123;        List&lt;String&gt; list = new ArrayList&lt;&gt;();        list.add(&quot;张三三&quot;);        list.add(&quot;李四&quot;);        list.add(&quot;王五&quot;);        list.add(&quot;孙七&quot;);        list.add(&quot;赵八&quot;);        list.add(&quot;王二麻子&quot;);        List&lt;String&gt; collect = list.stream().skip(3).limit(2).collect(Collectors.toList());        collect.forEach(System.out::println);    &#125;</code></pre><ul><li>reduce：聚合操作，用来做统计，将流中元素反复结合起来统计计算，得到一个值</li></ul><pre><code class="java">    /**     * reduce： 聚合操作，用来做统计，将流中元素反复结合起来统计计算，得到一个值.     */    @Test    public void testReduce() &#123;        //1.求集合元素只和        Stream&lt;Integer&gt; stream = Arrays.stream(new Integer[]&#123;1, 2, 3, 4, 5, 6, 7, 8&#125;);        Integer result = stream.reduce(0, Integer::sum);        System.out.println(result);        //2.求和        Stream&lt;Integer&gt; stream1 = Arrays.stream(new Integer[]&#123;1, 2, 3, 4, 5, 6, 7&#125;);        stream1.reduce((i, j) -&gt; i + j).ifPresent(System.out::println);        //3.求最大值        Stream&lt;Integer&gt; stream2 = Arrays.stream(new Integer[]&#123;1, 2, 3, 4, 5, 6, 7&#125;);        stream2.reduce(Integer::max).ifPresent(System.out::println);        //4.求最小值        Stream&lt;Integer&gt; stream3 = Arrays.stream(new Integer[]&#123;1, 2, 3, 4, 5, 6, 7&#125;);        stream3.reduce(Integer::min).ifPresent(System.out::println);        //5.做逻辑        Stream&lt;Integer&gt; stream4 = Arrays.stream(new Integer[]&#123;1, 2, 3, 4, 5, 6, 7&#125;);        stream4.reduce((i, j) -&gt; i &gt; j ? j : i).ifPresent(System.out::println);        //6.求逻辑求乘机        Stream&lt;Integer&gt; stream5 = Arrays.stream(new Integer[]&#123;1, 2, 3, 4, 5, 6, 7&#125;);        int result2 = stream5.filter(i -&gt; i % 2 == 0).reduce(1, (i, j) -&gt; i * j);        Optional.of(result2).ifPresent(System.out::println);    &#125;</code></pre><h3 id="2-2-Collector-工具库：Collectors"><a href="#2-2-Collector-工具库：Collectors" class="headerlink" title="2.2 Collector 工具库：Collectors"></a>2.2 Collector 工具库：Collectors</h3><ul><li><p><strong>Collectors</strong></p><pre><code class="java">Student s1 = new Student(&quot;aa&quot;, 10,1);Student s2 = new Student(&quot;bb&quot;, 20,2);Student s3 = new Student(&quot;cc&quot;, 10,3);List&lt;Student&gt; list = Arrays.asList(s1, s2, s3);  //stream转成listList&lt;Integer&gt; ageList = list.stream().map(Student::getAge).collect(Collectors.toList()); // [10, 20, 10]  //stream转成setSet&lt;Integer&gt; ageSet = list.stream().map(Student::getAge).collect(Collectors.toSet()); // [20, 10]  //stream转成map,注:key不能相同，否则报错Map&lt;String, Integer&gt; studentMap = list.stream().collect(Collectors.toMap(Student::getName, Student::getAge)); // &#123;cc=10, bb=20, aa=10&#125;  //字符串分隔符连接String joinName = list.stream().map(Student::getName).collect(Collectors.joining(&quot;,&quot;, &quot;(&quot;, &quot;)&quot;)); // (aa,bb,cc)  //聚合操作//1.学生总数Long count = list.stream().collect(Collectors.counting()); // 3//2.最大年龄 (最小的minBy同理)Integer maxAge = list.stream().map(Student::getAge).collect(Collectors.maxBy(Integer::compare)).get(); // 20//3.所有人的年龄Integer sumAge = list.stream().collect(Collectors.summingInt(Student::getAge)); // 40//4.平均年龄Double averageAge = list.stream().collect(Collectors.averagingDouble(Student::getAge)); // 13.333333333333334// 带上以上所有方法DoubleSummaryStatistics statistics = list.stream().collect(Collectors.summarizingDouble(Student::getAge));System.out.println(&quot;count:&quot; + statistics.getCount() + &quot;,max:&quot; + statistics.getMax() + &quot;,sum:&quot; + statistics.getSum() + &quot;,average:&quot; + statistics.getAverage());  //分组Map&lt;Integer, List&lt;Student&gt;&gt; ageMap = list.stream().collect(Collectors.groupingBy(Student::getAge));//多重分组,先根据类型分再根据年龄分Map&lt;Integer, Map&lt;Integer, List&lt;Student&gt;&gt;&gt; typeAgeMap = list.stream().collect(Collectors.groupingBy(Student::getType, Collectors.groupingBy(Student::getAge)));  //分区//分成两部分，一部分大于10岁，一部分小于等于10岁Map&lt;Boolean, List&lt;Student&gt;&gt; partMap = list.stream().collect(Collectors.partitioningBy(v -&gt; v.getAge() &gt; 10));  //规约Integer allAge = list.stream().map(Student::getAge).collect(Collectors.reducing(Integer::sum)).get(); //40　　</code></pre></li></ul><h3 id="综合案例"><a href="#综合案例" class="headerlink" title="综合案例"></a>综合案例</h3><p>定义两个集合，然后在集合中存储多个用户名称 完成一下操作</p><ol><li>第一个队伍只保留姓名长度为3的成员</li><li>第一个队伍删选后只要前三个人</li><li>第二个队伍只要姓张的成员</li><li>第二个队伍筛选之后只要后2个人</li><li>将两给i五合并为一个队伍</li><li>根据姓名创建person对象</li><li>打印整个队伍的person值</li></ol><pre><code>//        List&lt;String&gt; list1 = new ArrayList&lt;&gt;();//        List&lt;String&gt; list2 = new ArrayList&lt;&gt;();//        list1.add(&quot;张三&quot;);//        list1.add(&quot;李四&quot;);//        list1.add(&quot;王五&quot;);//        list1.add(&quot;孙吧1&quot;);//        list1.add(&quot;钱七2&quot;);//        list1.add(&quot;赵六&quot;);////        list2.add(&quot;张三l2&quot;);//        list2.add(&quot;李l2&quot;);//        list2.add(&quot;王五l2&quot;);//        list2.add(&quot;孙吧1l2&quot;);//        list2.add(&quot;钱2l2&quot;);//        list2.add(&quot;赵l2&quot;);        List&lt;String&gt; list1 = Arrays.asList(&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;, &quot;孙吧1&quot;, &quot;钱七2&quot;, &quot;赵六&quot;);        List&lt;String&gt; list2 = Arrays.asList(&quot;李2&quot;, &quot;王五2&quot;, &quot;孙吧2&quot;, &quot;钱七22&quot;, &quot;张2&quot;);        Stream&lt;String&gt; limit3andsize3 = list1.stream().filter(s -&gt; &#123;            return s.length() == 3;        &#125;).limit(3);        Stream&lt;String&gt; limit2 = list2.stream().filter(s -&gt; &#123;                    return s.startsWith(&quot;张&quot;);                &#125;        ).skip(list2.size()-2);        Stream&lt;Person&gt; personStream = Stream.concat(limit3andsize3, limit2).map(Person::new);        List&lt;Person&gt; collect = personStream.collect(Collectors.toList());        collect.stream().forEach(System.out::println);    &#125;</code></pre><h3 id="三-结果收集"><a href="#三-结果收集" class="headerlink" title="三 结果收集"></a>三 结果收集</h3><p>结果收集到集合中</p><pre><code>  @Test    public void test01()&#123;        // Stream&lt;String&gt; stream = Stream.of(&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;);        List&lt;String&gt; list = Stream.of(&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;,&quot;aa&quot;)                .collect(Collectors.toList());        System.out.println(list);        // 收集到 Set集合中        Set&lt;String&gt; set = Stream.of(&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;, &quot;aa&quot;)                .collect(Collectors.toSet());        System.out.println(set);        // 如果需要获取的类型为具体的实现，比如：ArrayList HashSet        ArrayList&lt;String&gt; arrayList = Stream.of(&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;, &quot;aa&quot;)                //.collect(Collectors.toCollection(() -&gt; new ArrayList&lt;&gt;()));                .collect(Collectors.toCollection(ArrayList::new));        System.out.println(arrayList);        HashSet&lt;String&gt; hashSet = Stream.of(&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;, &quot;aa&quot;)                .collect(Collectors.toCollection(HashSet::new));        System.out.println(hashSet);    &#125;</code></pre><p>结果收集到数组中</p><pre><code>   @Test    public void test02()&#123;        Object[] objects = Stream.of(&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;, &quot;aa&quot;)                .toArray(); // 返回的数组中的元素是 Object类型        System.out.println(Arrays.toString(objects));        // 如果我们需要指定返回的数组中的元素类型        String[] strings = Stream.of(&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;, &quot;aa&quot;)                .toArray(String[]::new);        System.out.println(Arrays.toString(strings));    &#125;</code></pre><h3 id="5-3结果集聚合计算"><a href="#5-3结果集聚合计算" class="headerlink" title="5.3结果集聚合计算"></a>5.3结果集聚合计算</h3><p>当我们使用Stream流处理数据后，可以像数据库的聚合函数一样对某个字段进行操作</p><p>如 最大值 最小值 </p><pre><code class="java">   /**     * Stream流中数据的聚合计算     */    @Test    public void test03()&#123;        // 获取年龄的最大值        Optional&lt;Person&gt; maxAge = Stream.of(                new Person(&quot;张三&quot;, 18)                , new Person(&quot;李四&quot;, 22)                , new Person(&quot;张三&quot;, 13)                , new Person(&quot;王五&quot;, 15)                , new Person(&quot;张三&quot;, 19)        ).collect(Collectors.maxBy((p1, p2) -&gt; p1.getAge() - p2.getAge()));        System.out.println(&quot;最大年龄：&quot; + maxAge.get());        // 获取年龄的最小值        Optional&lt;Person&gt; minAge = Stream.of(                new Person(&quot;张三&quot;, 18)                , new Person(&quot;李四&quot;, 22)                , new Person(&quot;张三&quot;, 13)                , new Person(&quot;王五&quot;, 15)                , new Person(&quot;张三&quot;, 19)        ).collect(Collectors.minBy((p1, p2) -&gt; p1.getAge() - p2.getAge()));        System.out.println(&quot;最新年龄:&quot; + minAge.get());        // 求所有人的年龄之和        Integer sumAge = Stream.of(                new Person(&quot;张三&quot;, 18)                , new Person(&quot;李四&quot;, 22)                , new Person(&quot;张三&quot;, 13)                , new Person(&quot;王五&quot;, 15)                , new Person(&quot;张三&quot;, 19)        )                //.collect(Collectors.summingInt(s -&gt; s.getAge()))                .collect(Collectors.summingInt(Person::getAge))                ;        System.out.println(&quot;年龄总和：&quot; + sumAge);        // 年龄的平均值        Double avgAge = Stream.of(                new Person(&quot;张三&quot;, 18)                , new Person(&quot;李四&quot;, 22)                , new Person(&quot;张三&quot;, 13)                , new Person(&quot;王五&quot;, 15)                , new Person(&quot;张三&quot;, 19)        ).collect(Collectors.averagingInt(Person::getAge));        System.out.println(&quot;年龄的平均值：&quot; + avgAge);        // 统计数量        Long count = Stream.of(                new Person(&quot;张三&quot;, 18)                , new Person(&quot;李四&quot;, 22)                , new Person(&quot;张三&quot;, 13)                , new Person(&quot;王五&quot;, 15)                , new Person(&quot;张三&quot;, 19)        ).filter(p-&gt;p.getAge() &gt; 18)                .collect(Collectors.counting());        System.out.println(&quot;满足条件的记录数:&quot; + count);    &#125;    /**     * 分组计算     */    @Test    public void test04()&#123;        // 根据账号对数据进行分组        Map&lt;String, List&lt;Person&gt;&gt; map1 = Stream.of(                new Person(&quot;张三&quot;, 18, 175)                , new Person(&quot;李四&quot;, 22, 177)                , new Person(&quot;张三&quot;, 14, 165)                , new Person(&quot;李四&quot;, 15, 166)                , new Person(&quot;张三&quot;, 19, 182)        ).collect(Collectors.groupingBy(Person::getName));        map1.forEach((k,v)-&gt; System.out.println(&quot;k=&quot; + k +&quot;\t&quot;+ &quot;v=&quot; + v));        System.out.println(&quot;-----------&quot;);        // 根据年龄分组 如果大于等于18 成年否则未成年        Map&lt;String, List&lt;Person&gt;&gt; map2 = Stream.of(                new Person(&quot;张三&quot;, 18, 175)                , new Person(&quot;李四&quot;, 22, 177)                , new Person(&quot;张三&quot;, 14, 165)                , new Person(&quot;李四&quot;, 15, 166)                , new Person(&quot;张三&quot;, 19, 182)        ).collect(Collectors.groupingBy(p -&gt; p.getAge() &gt;= 18 ? &quot;成年&quot; : &quot;未成年&quot;));        map2.forEach((k,v)-&gt; System.out.println(&quot;k=&quot; + k +&quot;\t&quot;+ &quot;v=&quot; + v));    &#125;    /**    * 分组计算--多级分组     */    @Test    public void test05()&#123;        // 先根据name分组，然后根据age(成年和未成年)分组        Map&lt;String,Map&lt;Object,List&lt;Person&gt;&gt;&gt; map =  Stream.of(                new Person(&quot;张三&quot;, 18, 175)                , new Person(&quot;李四&quot;, 22, 177)                , new Person(&quot;张三&quot;, 14, 165)                , new Person(&quot;李四&quot;, 15, 166)                , new Person(&quot;张三&quot;, 19, 182)        ).collect(Collectors.groupingBy(                Person::getName                ,Collectors.groupingBy(p-&gt;p.getAge()&gt;=18?&quot;成年&quot;:&quot;未成年&quot;                )        ));        map.forEach((k,v)-&gt;&#123;            System.out.println(k);            v.forEach((k1,v1)-&gt;&#123;                System.out.println(&quot;\t&quot;+k1 + &quot;=&quot; + v1);            &#125;);        &#125;);    &#125;    /**     * 分区操作     */    @Test    public void test06()&#123;        Map&lt;Boolean, List&lt;Person&gt;&gt; map = Stream.of(                new Person(&quot;张三&quot;, 18, 175)                , new Person(&quot;李四&quot;, 22, 177)                , new Person(&quot;张三&quot;, 14, 165)                , new Person(&quot;李四&quot;, 15, 166)                , new Person(&quot;张三&quot;, 19, 182)        ).collect(Collectors.partitioningBy(p -&gt; p.getAge() &gt; 18));        map.forEach((k,v)-&gt; System.out.println(k+&quot;\t&quot; + v));    &#125;    /**     * 对流中的数据做拼接操作     */    @Test    public void test07()&#123;        String s1 = Stream.of(                new Person(&quot;张三&quot;, 18, 175)                , new Person(&quot;李四&quot;, 22, 177)                , new Person(&quot;张三&quot;, 14, 165)                , new Person(&quot;李四&quot;, 15, 166)                , new Person(&quot;张三&quot;, 19, 182)        ).map(Person::getName)                .collect(Collectors.joining());        // 张三李四张三李四张三        System.out.println(s1);        String s2 = Stream.of(                new Person(&quot;张三&quot;, 18, 175)                , new Person(&quot;李四&quot;, 22, 177)                , new Person(&quot;张三&quot;, 14, 165)                , new Person(&quot;李四&quot;, 15, 166)                , new Person(&quot;张三&quot;, 19, 182)        ).map(Person::getName)                .collect(Collectors.joining(&quot;_&quot;));        // 张三_李四_张三_李四_张三        System.out.println(s2);        String s3 = Stream.of(                new Person(&quot;张三&quot;, 18, 175)                , new Person(&quot;李四&quot;, 22, 177)                , new Person(&quot;张三&quot;, 14, 165)                , new Person(&quot;李四&quot;, 15, 166)                , new Person(&quot;张三&quot;, 19, 182)        ).map(Person::getName)                .collect(Collectors.joining(&quot;_&quot;, &quot;###&quot;, &quot;$$$&quot;));        // ###张三_李四_张三_李四_张三$$$        System.out.println(s3);    &#125;&#125;</code></pre><h3 id="5-4并行的Stream"><a href="#5-4并行的Stream" class="headerlink" title="5.4并行的Stream"></a>5.4并行的Stream</h3><p>多线程下的Stream</p><p>parallelStram其实就是一个并行执行的流</p><p>它通过ForkjoinPool可以提高多线程的任务速度</p><p><em>&#x2F;</em>*<br>* *** *获取并行流的两种方式<br>* **&#x2F;</p><ol><li><strong>通过List 接口 直接获取并行流</strong></li><li><strong>将已有的串行流转换为并行流</strong></li></ol><pre><code>*@Testpublic void test02()&#123;    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();    // 通过List 接口 直接获取并行流    Stream&lt;Integer&gt; integerStream = list.parallelStream();    // 将已有的串行流转换为并行流    Stream&lt;Integer&gt; parallel = Stream.*of*(1, 2, 3).parallel();&#125;</code></pre><p>AA</p><p><em>&#x2F;</em>*<br>* *** *并行流操作<br>* **&#x2F;</p><pre><code>@Testpublic void test03()&#123;​    Stream.*of*(1,4,2,6,1,5,9)​            .parallel() // 将流转换为并发流，Stream处理的时候就会通过多线程处理​            .filter(s-&gt;&#123;​                System.*out*.println(Thread.*currentThread*() + &quot; s=&quot; +s);​                return s &gt; 2;​            &#125;).count();&#125;</code></pre><h5 id="并行流的线程安全问题"><a href="#并行流的线程安全问题" class="headerlink" title="并行流的线程安全问题"></a>并行流的线程安全问题</h5><pre><code>    /**     * 并行流中的数据安全问题     */    @Test    public void test01()&#123;        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();        for (int i = 0; i &lt; 1000; i++) &#123;            list.add(i);        &#125;        System.out.println(list.size());        List&lt;Integer&gt; listNew = new ArrayList&lt;&gt;();        // 使用并行流来向集合中添加数据        list.parallelStream()                //.forEach(s-&gt;listNew.add(s));                .forEach(listNew::add);        System.out.println(listNew.size());    &#125;    /**     * 加同步锁     */    @Test    public void test02()&#123;        List&lt;Integer&gt; listNew = new ArrayList&lt;&gt;();        Object obj = new Object();        IntStream.rangeClosed(1,1000)                .parallel()                .forEach(i-&gt;&#123;                    synchronized (obj)&#123;                        listNew.add(i);                    &#125;                &#125;);        System.out.println(listNew.size());    &#125;    /**     * 使用线程安全的容器     */    @Test    public void test03()&#123;        Vector v = new Vector();        Object obj = new Object();        IntStream.rangeClosed(1,1000)                .parallel()                .forEach(i-&gt;&#123;                    synchronized (obj)&#123;                        v.add(i);                    &#125;                &#125;);        System.out.println(v.size());    &#125;    /**     * 将线程不安全的容器转换为线程安全的容器     */    @Test    public void test04()&#123;        List&lt;Integer&gt; listNew = new ArrayList&lt;&gt;();        // 将线程不安全的容器包装为线程安全的容器        List&lt;Integer&gt; synchronizedList = Collections.synchronizedList(listNew);        Object obj = new Object();        IntStream.rangeClosed(1,1000)                .parallel()                .forEach(i-&gt;&#123;                        synchronizedList.add(i);                &#125;);        System.out.println(synchronizedList.size());    &#125;    /**     * 我们还可以通过Stream中的 toArray方法或者 collect方法来操作     * 就是满足线程安全的要求     */    @Test    public void test05()&#123;        List&lt;Integer&gt; listNew = new ArrayList&lt;&gt;();        Object obj = new Object();        List&lt;Integer&gt; list = IntStream.rangeClosed(1, 1000)                .parallel()                .boxed()                .collect(Collectors.toList());        System.out.println(list.size());    &#125;</code></pre><h1 id="ForkJoin详解"><a href="#ForkJoin详解" class="headerlink" title="ForkJoin详解"></a>ForkJoin详解</h1><h2 id="ForkJoin简介"><a href="#ForkJoin简介" class="headerlink" title="ForkJoin简介"></a>ForkJoin简介</h2><p>Fork&#x2F;Join框架是Java 7提供的一种用于并行执行任务的框架，它将大任务分解为若干个小任务,并行执行这些小任务，最终通过合并每个小任务的结果得到大任务的结果。</p><p>Fork&#x2F;Join采用的是分而治之的基本思想，分而治之就是将一个复杂的任务，按照规定的阈值划分成多个简单的小任务，然后将这些小任务的结果再进行汇总返回，得到最终的任务。</p><blockquote><p>欢迎关注个人公众号【好好学技术】交流学习</p></blockquote><h2 id="并行和并发的区别"><a href="#并行和并发的区别" class="headerlink" title="并行和并发的区别"></a>并行和并发的区别</h2><p>并行和并发是计算机科学中的两个概念，它们之间有一些相似之处，但也有明显的区别。</p><p>并行是指多个处理器或者是多核的处理器同时处理多个不同的任务。并行可以在多处理器系统中实现，利用每个处理机来处理一个可并发执行的程序，从而实现多个程序的同时执行。在并行执行时，每个处理器可以同时执行多个程序，从而提高计算效率。</p><p>并发是指逻辑上的同时发生（即 true 的同时性），而并行是物理上的同时发生。在多道程序环境下，并发性是指在一段时间内宏观上有多个程序在同时运行，但在单处理机系统中，每一时刻却仅能有一道程序执行，故微观上这些程序只能是分时地交替执行。</p><p>简而言之，并行是指多个处理器或多核处理器同时处理多个任务，而并发是指在同一时间内多个任务同时发生。</p><h2 id="工作窃取算法"><a href="#工作窃取算法" class="headerlink" title="工作窃取算法"></a>工作窃取算法</h2><p>工作窃取算法是指某个线程从其他队列里窃取任务来执行。当工作队列中有空闲任务时，就将任务从原线程的队列中窃取过来，执行完成后再将结果返回给原线程。这样就保证了原线程不会一直等待空闲任务，从而提高了程序的效率。</p><p>Fork&#x2F;Join框架使用ForkJoinPool这个特殊的线程池来处理任务之间有依赖的情况，其实现了“work-stealing”算法（工作量窃取算法）并执行ForkJoinTask对象。ForkJoinPool保持多个线程，其线程数量默认为机器cpu核心数。每个线程都有一个特殊类型的deques队列（双端队列），放置该线程的所有任务，而不是所有线程共享一个公共队列。</p><p>每个线程都会保证将自己队列中的任务执行完，当自己的任务执行完成之后，在去看其他线程的任务队列中是否有未处理完的任务，如果有则会帮助其他线程执行。</p><p>这时双端队列的优势就体现出来了,被窃取的任务只会从队列的头部获取任务，而正常处理的线程每次都是从队列的尾部获取任务。</p><h2 id="求1到1亿的和"><a href="#求1到1亿的和" class="headerlink" title="求1到1亿的和"></a>求1到1亿的和</h2><pre><code class="java">package com.fandf.test.forkjoin;    import lombok.extern.slf4j.Slf4j;  import org.springframework.util.StopWatch;    import java.util.concurrent.ForkJoinPool;  import java.util.concurrent.Future;  import java.util.concurrent.RecursiveTask;    /**  * @author fandongfeng  */  @Slf4j  public class ForkJoinDemo extends RecursiveTask&lt;Long&gt; &#123;        /**      * 小任务的大小阈值      */      public static final int TASK_SIZE = 100000;      /**      * 开始数字      */      private final Long start;      /**      * 结束数字      */      private final Long end;      public ForkJoinDemo(Long start, Long end) &#123;          this.start = start;          this.end = end;      &#125;      @Override      protected Long compute() &#123;          long sum = 0L;          //如果任务足够小就计算任务          boolean canCompute = (end - start) &lt;= TASK_SIZE;          if (canCompute) &#123;              for (Long i = start; i &lt;= end; i++) &#123;                  sum += i;              &#125;          &#125; else &#123;              // 如果任务大于阈值，就分裂成两个子任务计算              long middle = (start + end) / 2;              ForkJoinDemo leftTask = new ForkJoinDemo(start, middle);              ForkJoinDemo rightTask = new ForkJoinDemo(middle + 1, end);              // 执行子任务              leftTask.fork();              rightTask.fork();              // 等待任务执行结束合并其结果              Long leftResult = leftTask.join();              Long rightResult = rightTask.join();              // 合并子任务              sum = leftResult + rightResult;          &#125;          return sum;      &#125;      public static void main(String[] args) &#123;          ForkJoinPool forkjoinPool = new ForkJoinPool();          //生成一个计算任务，计算1+2+3+4+...+100000000          ForkJoinDemo task = new ForkJoinDemo(1L, 100000000L);          StopWatch stopWatch = new StopWatch();          stopWatch.start();          //执行一个任务          Future&lt;Long&gt; result = forkjoinPool.submit(task);          try &#123;              System.out.println(&quot;result:&quot; + result.get());          &#125; catch (Exception e) &#123;              log.error(&quot;exception&quot;, e);          &#125;          stopWatch.stop();          System.out.println(&quot;总耗时：&quot; + stopWatch.getTotalTimeMillis() + &quot;毫秒&quot;);          System.out.println(&quot;getParallelism:&quot; + forkjoinPool.getParallelism());          System.out.println(&quot;getPoolSize:&quot; + forkjoinPool.getPoolSize());      &#125;  &#125;</code></pre><p>输出结果</p><pre><code class="java">result:5000000050000000总耗时：330毫秒getParallelism:6getPoolSize:7</code></pre><h2 id="ForkJoin框架实现"><a href="#ForkJoin框架实现" class="headerlink" title="ForkJoin框架实现"></a>ForkJoin框架实现</h2><h3 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a>ForkJoinPool</h3><p><code>ForkJoinPool</code>是用于运行<code>ForkJoinTasks</code>的线程池，实现了<code>Executor</code>接口</p><p><img src="https://img-blog.csdnimg.cn/e036acdd7317493dbfad45955346f1ce.png" alt="在这里插入图片描述"></p><pre><code class="java">public ForkJoinPool() &#123;      this(Math.min(MAX_CAP, Runtime.getRuntime().availableProcessors()),          defaultForkJoinWorkerThreadFactory, null, false);  &#125;public ForkJoinPool(int parallelism,                      ForkJoinWorkerThreadFactory factory,                      UncaughtExceptionHandler handler,                      boolean asyncMode) &#123;      this(checkParallelism(parallelism),          checkFactory(factory),          handler,          asyncMode ? FIFO_QUEUE : LIFO_QUEUE,          &quot;ForkJoinPool-&quot; + nextPoolId() + &quot;-worker-&quot;);      checkPermission();  &#125;</code></pre><p>ForkJoinPool构造方法有四个参数：</p><ul><li>parallelism：期望并发数。默认会使用<code>Runtime.getRuntime().availableProcessors()</code>的值</li><li>factory：创建ForkJoin工作线程的工厂，默认为defaultForkJoinWorkerThreadFactory</li><li>handler：执行任务时遇到不可恢复的错误时的处理程序，默认为null</li><li>asyncMode：工作线程获取任务使用FIFO(先进先出)模式还是LIFO(后进先出)模式，默认为LIFO</li></ul><h3 id="ForkJoinTask"><a href="#ForkJoinTask" class="headerlink" title="ForkJoinTask"></a>ForkJoinTask</h3><p><code>ForkJoinTask</code>是对于在<code>ForkJoinPool</code>中运行任务的抽象类定义。</p><p>JDK为我们提供了三种特定类型的ForkJoinTask父类供我们自定义时继承使用。</p><ul><li><strong>RecursiveAction</strong>：子任务不返回结果</li><li><strong>RecursiveTask</strong>：子任务返回结果</li><li><strong>CountedCompleter</strong>：在任务完成执行后会触发执行</li></ul><h3 id="ForkJoinWorkerThread"><a href="#ForkJoinWorkerThread" class="headerlink" title="ForkJoinWorkerThread"></a>ForkJoinWorkerThread</h3><p><code>ForkJoinPool</code>中用于执行<code>ForkJoinTask</code>的线程。<br>ForkJoinPool实现了Executor接口。但是和我们常用的ThreadPoolExecutor又有一些区别。</p><p>如果使用ThreadPoolExecutor来实现上面分治任务，那么每个子任务都需要创建一个线程，如果子任务的数量很大，假设有上万个，那么使用ThreadPoolExecutor创建出上万个线程，这显然是不可行也不合理的；</p><p>而ForkJoinPool在处理任务时，并不会按照任务开启线程，而是按照指定的期望并行数量创建线程。在每个线程工作时，如果需要继续拆分子任务，则会将当前任务放入ForkJoinWorkerThread的任务队列中，递归处理直到最外层的任务。</p><h3 id="ForkJoinTask启动方式"><a href="#ForkJoinTask启动方式" class="headerlink" title="ForkJoinTask启动方式"></a>ForkJoinTask启动方式</h3><ul><li>异步执行<br>forkjoinPool.execute(task);无返回结果</li><li>同步执行<br>forkjoinPool.invoke(task);等待返回结果</li><li>异步执行，通过Future获取结果<br>forkjoinPool.submit(task);</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在使用Fork&#x2F;Join框架时，需要注意以下几点：</p><ol><li>必须首先创建一个ForkJoinTask对象。</li><li>在分发任务时，需要注意线程安全问题，防止多个线程同时访问共享资源。可以使用synchronized关键字或者Lock对象来保证线程安全。</li><li>在合并结果时，也需要注意线程安全问题，可以使用CountDownLatch对象来确保每个Fork执行完成后才能提交结果。</li><li>在使用Fork&#x2F;Join框架时，需要考虑算法的效率和性能问题。可以使用Cache技术来减少不必要的计算，使用join策略来合并结果等。</li></ol><p>总之，Fork&#x2F;Join框架是一种非常有用的并行计算框架，可以大大提高程序的执行效率和并发能力。</p><h3 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h3><h1 id="Java-8特性之Optional详解"><a href="#Java-8特性之Optional详解" class="headerlink" title="Java 8特性之Optional详解"></a>Java 8特性之Optional详解</h1><h1 id="一、Optional类-简介"><a href="#一、Optional类-简介" class="headerlink" title="一、Optional类 简介"></a>一、Optional类 简介</h1><p>Optional类是 Java 8 引入的一个很有趣的特性。它主要解决的问题是臭名昭著的空指针异常（NullPointerException）</p><ul><li>Optional 类是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。</li><li>Optional 是个容器：它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。</li><li>Optional 类的引入很好的解决空指针异常。</li></ul><p>Optional 是一个对象容器，具有以下两个特点：</p><ul><li>提示用户要注意该对象有可能为null</li><li>简化if else代码</li></ul><p>举一个简单的例子，在 Java 8 之前，任何访问对象方法或属性的调用都可能导致 NullPointerException：</p><pre><code class="java">用户 -&gt; 家庭住址  -&gt; 城市  -&gt;邮编String postCode = user.getAddress().getCity().getPostCode();</code></pre><p>在这个示例中，为了避免异常，就得在访问每一个值之前对其进行明确地检查：</p><pre><code class="java">if (user != null) &#123;    Address address = user.getAddress();    if (address != null) &#123;        City city= address.getCity();        if (city != null) &#123;            String postCode = city.getPostCode();            if (postCode != null) &#123;                //对postCode进行操作               test(postCode);            &#125;        &#125;    &#125;&#125;</code></pre><p>这很容易就变得冗长，难以维护。<br>为了简化这个过程，我们就可以用 Optional 类。</p><h1 id="二、Optional类的使用"><a href="#二、Optional类的使用" class="headerlink" title="二、Optional类的使用"></a>二、Optional类的使用</h1><h2 id="1-创建："><a href="#1-创建：" class="headerlink" title="1. 创建："></a>1. 创建：</h2><p>Optional类的实例创建有三种方式：</p><ul><li><p><strong>Optional.empty()</strong> ：创建一个空的 Optional 实例。</p></li><li><p><strong>Optional.of(T t)</strong> ：创建一个 Optional 实例，当 t为null时抛出异常（NullPointerException）。</p></li><li><p><strong>Optional.ofNullable(T t)</strong> ：创建一个 Optional 实例，但当 t为null时不会抛出异常，而是返回一个空的实例。</p><h5 id="Optional中的常用方法介绍"><a href="#Optional中的常用方法介绍" class="headerlink" title="Optional中的常用方法介绍"></a>Optional中的常用方法介绍</h5><p>*<em>get():</em> *如果Optional有值则返回，否则抛出NoSuchElementException异常<br>get()通常和isPresent方法一块使用<br>isPresent():判断是否包含值，包含值返回true，不包含值返回false orElse(T t):如果调用对象包含值，就返回该值，否则返回t<br>orElseGet(Supplier s):*<em>如果调用对象包含值，就返回该值，否则返回</em>  Lambda表达式的返回值</p><p>**</p></li></ul><h2 id="2-获取："><a href="#2-获取：" class="headerlink" title="2. 获取："></a><strong>2. 获取</strong>：</h2><ul><li>**get()**：获取optional实例中的对象，当optional 容器为空时报错。</li></ul><h2 id="3-判断："><a href="#3-判断：" class="headerlink" title="3. 判断："></a>3. 判断：</h2><ul><li>**isPresent()**：判断optional是否为空，如果空则返回false，否则返回true</li><li>**ifPresent(Consumer c)**：如果optional不为空，则将optional中的对象传给Comsumer函数</li></ul><pre><code class="java">public class OptionalDemo &#123;    public static void main(String[] args) &#123;        User user = new User(&quot;王也&quot;, &quot;5&quot;);        User userNull= null;        Optional&lt;User&gt; optional = Optional.ofNullable(user);        System.out.println(optional.isPresent());                optional.ifPresent(u -&gt; System.out.println(&quot;optional不为null  &quot;+u));    &#125;&#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/3776490092084d9785bc5432f4cd1159.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAUGx1dG8zNzI=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><ul><li>**orElse(T other)**：如果optional不为空，则返回optional中的对象；如果为null，则返回 other 这个默认值</li></ul><pre><code class="java">   User user = new User(&quot;王也&quot;, &quot;5&quot;);   User userNull= null;   //orElse的工作方式非常直接，如果有值则返回该值，否则返回传递给它的参数值：   User user1 = Optional.ofNullable(userNull).orElse(user);   System.out.println(user1);   //控制台输出：User(name=王也, age=5)</code></pre><ul><li>**orElseGet(Supplier other)**：如果optional不为空，则返回optional中的对象；如果为null，则使用Supplier函数生成默认值other</li></ul><pre><code class="java">  User user1 = Optional.ofNullable(userNull).orElseGet(()-&gt;user );  //结果同上</code></pre><ul><li>**orElseThrow(Supplier exception)**：如果optional不为空，则返回optional中的对象；如果为null，则抛出Supplier函数生成的异常</li></ul><pre><code class="java">//这个方法让我们有更丰富的语义，可以决定抛出什么样的异常，而不总是抛出 NullPointerException。 User result = Optional.ofNullable(userNull)      .orElseThrow( () -&gt; new IllegalArgumentException());</code></pre><h3 id="orElse-和-orElseGet-的不同之处"><a href="#orElse-和-orElseGet-的不同之处" class="headerlink" title="orElse() 和 orElseGet() 的不同之处"></a>orElse() 和 orElseGet() 的不同之处</h3><p>乍一看，这两种方法似乎起着同样的作用。然而事实并非如此。我们创建一些示例来突出二者行为上的异同。</p><p><strong>（1）当对象为空时：</strong></p><pre><code class="java">public class OptionalDemo &#123;    public static void main(String[] args) &#123;        User userNull = null;                System.out.println(&quot;使用orElse()：&quot;);        User result = Optional.ofNullable(userNull).orElse(createNewUser());        System.out.println(&quot;使用orElseGet()：&quot;);        User result2 = Optional.ofNullable(userNull).orElseGet(() -&gt; createNewUser());    &#125;    private static User createNewUser() &#123;        System.out.println(&quot;Creating New User&quot;);        return new User(&quot;新的user对象&quot;, &quot;1234&quot;);    &#125;&#125;</code></pre><p>上面的代码中，两种方法都调用了 createNewUser() 方法，这个方法会记录一个消息并返回 User 对象。</p><p>控制台输出:</p><pre><code class="java">使用orElse()：Creating New User使用orElseGet()：Creating New User</code></pre><p>由此可见，当对象为空而返回默认对象时，行为并无差异。</p><p><strong>（2）当对象不为空时：</strong></p><pre><code class="java">public class OptionalDemo &#123;    public static void main(String[] args) &#123;        User user = new User(&quot;王也&quot;, &quot;5&quot;);                System.out.println(&quot;使用orElse()：&quot;);        User result = Optional.ofNullable(user).orElse(createNewUser());        System.out.println(&quot;使用orElseGet()：&quot;);        User result2 = Optional.ofNullable(user).orElseGet(() -&gt; createNewUser());    &#125;    private static User createNewUser() &#123;        System.out.println(&quot;Creating New User&quot;);        return new User(&quot;新的user对象&quot;, &quot;1234&quot;);    &#125;&#125;</code></pre><p>控制台输出:</p><pre><code class="java">使用orElse()：Creating New User使用orElseGet()：</code></pre><p>这个示例中，两个 Optional 对象都包含非空值，两个方法都会返回对应的非空值。不过，orElse() 方法仍然创建了 User 对象。与之相反，orElseGet() 方法不创建 User 对象。</p><p>在执行较密集的调用时，比如调用 Web 服务或数据查询，这个差异会对性能产生重大影响。</p><p><strong>demo</strong></p><pre><code>    @Test    public void test01()&#123;        //String userName = &quot;张三&quot;;        String userName = null;        if(userName != null)&#123;            System.out.println(&quot;字符串的长度：&quot; + userName.length());        &#125;else&#123;            System.out.println(&quot;字符串为空&quot;);        &#125;    &#125;    /**     * Optional对象的创建方式     */    @Test    public void test02()&#123;        // 第一种方式 通过of方法  of方法是不支持null的        Optional&lt;String&gt; op1 = Optional.of(&quot;zhangsan&quot;);        //Optional&lt;Object&gt; op2 = Optional.of(null);        // 第二种方式通过 ofNullable方法 支持null        Optional&lt;String&gt; op3 = Optional.ofNullable(&quot;lisi&quot;);        Optional&lt;Object&gt; op4 = Optional.ofNullable(null);        // 第三种方式 通过empty方法直接创建一个空的Optional对象        Optional&lt;Object&gt; op5 = Optional.empty();    &#125;    /**     * Optional中的常用方法介绍     *   get(): 如果Optional有值则返回，否则抛出NoSuchElementException异常     *          get()通常和isPresent方法一块使用     *   isPresent():判断是否包含值，包含值返回true，不包含值返回false     *   orElse(T t):如果调用对象包含值，就返回该值，否则返回t     *   orElseGet(Supplier s):如果调用对象包含值，就返回该值，否则返回 Lambda表达式的返回值     */    @Test    public void test03()&#123;        Optional&lt;String&gt; op1 = Optional.of(&quot;zhangsan&quot;);        Optional&lt;String&gt; op2 = Optional.empty();        // 获取Optional中的值        if(op1.isPresent())&#123;            String s1 = op1.get();            System.out.println(&quot;用户名称:&quot; +s1);        &#125;        if(op2.isPresent())&#123;            System.out.println(op2.get());        &#125;else&#123;            System.out.println(&quot;op2是一个空Optional对象&quot;);        &#125;        String s3 = op1.orElse(&quot;李四&quot;);        System.out.println(s3);        String s4 = op2.orElse(&quot;王五&quot;);        System.out.println(s4);        String s5 = op2.orElseGet(()-&gt;&#123;            return &quot;Hello&quot;;        &#125;);        System.out.println(s5);    &#125;    @Test    public void test04()&#123;        Optional&lt;String&gt; op1 = Optional.of(&quot;zhangsan&quot;);        Optional&lt;String&gt; op2 = Optional.empty();        // 如果存在值 就做什么        op1.ifPresent(s-&gt; System.out.println(&quot;有值:&quot; +s));        op1.ifPresent(System.out::println);    &#125;    /**     * 自定义一个方法，将Person对象中的 name 转换为大写 并返回     */    @Test    public void test05()&#123;        Person p = new Person(&quot;zhangsan&quot;,18);        Optional&lt;Person&gt; op = Optional.of(p);        String name = getNameForOptional(op);        System.out.println(&quot;name=&quot;+name);    &#125;    /**     * 根据Person对象 将name转换为大写并返回     *    通过Optional方式实现     * @param op     * @return     */    public String getNameForOptional(Optional&lt;Person&gt; op)&#123;       if(op.isPresent())&#123;           String msg = //op.map(p -&gt; p.getName())                   op.map(Person::getName)                   //.map(p -&gt; p.toUpperCase())                   .map(String::toUpperCase)                   .orElse(&quot;空值&quot;);           return msg;       &#125;       return null;    &#125;    /**     * 根据Person对象 将name转换为大写并返回     * @param person     * @return     */    public String getName(Person person)&#123;        if(person != null)&#123;            String name = person.getName();            if(name != null)&#123;                return name.toUpperCase();            &#125;else&#123;                return null;            &#125;        &#125;else&#123;            return null;        &#125;    &#125;&#125;</code></pre><h2 id="四、jdk的时间操作"><a href="#四、jdk的时间操作" class="headerlink" title="四、jdk的时间操作"></a>四、jdk的时间操作</h2><p><strong>旧版本的日期格式</strong></p><pre><code>public class Test07 &#123;    /**     * 旧版日期时间设计的问题     */    @Test    public void test01() throws Exception&#123;        // 1.设计不合理        Date date = new Date(2021,05,05);        System.out.println(date);        // 2.时间格式化和解析操作是线程不安全的        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);        for (int i = 0; i &lt; 50; i++) &#123;            new Thread(()-&gt;&#123;               // System.out.println(sdf.format(date));                try &#123;                    System.out.println(sdf.parse(&quot;2021-05-06&quot;));                &#125; catch (ParseException e) &#123;                    e.printStackTrace();                &#125;            &#125;).start();        &#125;    &#125;&#125;</code></pre><p>缺点</p><p>1.设计不合理 在java.util和java.sql包下都有日期类 java.util.Date同时包含日期和时间</p><p>而java.sql.Date仅仅包含日期，此外用于格式化和解析的类在java.text包下</p><p>2.非线程安全 java.util.Date是非线程安全的所有的日期是可变的这是java日期类的问题</p><p>3.时区处理不支持国际化</p><h1 id="JDK8时间API整理"><a href="#JDK8时间API整理" class="headerlink" title="JDK8时间API整理"></a>JDK8时间API整理</h1><p>在jdk8之前经常使用到的时间API包括（Date、Calendar），date与字符串之间的转换使用SimpleDateFormat进行转换，用SimpleDateFormat类的parse方法，可以将满足格式要求的字符串转换成Date对象，使用SimpleDateFormat类的format方法，可以将Date类型的对象转换成一定格式的字符串。然而SimpleDateFormat并非是线程安全的。在jdk8中为了使用时间更加便利，在java.time包下新增时间API。使用DateTimeFormatter的parse将字符串转换成时间格式，format方法将日期、时间转换成字符串格式。</p><h3 id="1-1、时间API"><a href="#1-1、时间API" class="headerlink" title="1.1、时间API"></a>1.1、时间API</h3><ol><li>ZoneId:时区ID,用来确定Instant和LocalDateTime互相转换的规则。</li><li>Instant:用来表示时间线上的一个点。</li><li>LocalDate:表示没有时区的日期，LocalDate是不可变且线程安全的。</li><li>LocalTime:表示没有时区的时间，LocalTime是不可变且线程安全的。</li><li>LocalDateTime:表示没有时区的日期时间，LocalDateTime是不可变且线程安全的。</li><li>Clock:用于访问当前时刻、日期、时间、用到时区。</li><li>Duration:用秒和纳秒表示时间。</li></ol><p>最常用的就是LocalDate、LocalTime、LocalDateTime了、从他们的名字可以看出是操作日期、时间的。</p><p><strong>LocalDate</strong>（<strong>日期</strong>）</p><table><thead><tr><th>说明</th><th>方法</th><th>返回结果示例</th></tr></thead><tbody><tr><td>获取当前日期</td><td>LocalDate.now()</td><td>2019-05-14</td></tr><tr><td>日期构造</td><td>LocalDate.of(2019,05,14)</td><td>2019-05-14</td></tr><tr><td>字符串转LocalDate</td><td>LocalDate.parse(“2019-06-01”)</td><td>2019-06-01</td></tr><tr><td>获取明天的日期</td><td>LocalDate.now().plusDays(1) &#x2F; LocalDate.now().plus(1, ChronoUnit.DAYS)</td><td>2019-05-15</td></tr><tr><td>在今天的基础上减去一个月</td><td>LocalDate.now().minusMonths(1)&#x2F;LocalDate.now().minus(1, ChronoUnit.MONTHS)</td><td>2019-04-14</td></tr><tr><td>解析日期，获取星期</td><td>LocalDate.parse(“2019-05-14”).getDayOfWeek()</td><td>TUESDAY</td></tr><tr><td>解析日期，获取本月的第几天</td><td>LocalDate.parse(“2019-05-14”).getDayOfMonth()</td><td>14</td></tr><tr><td>判断今年是否为闰年</td><td>LocalDate.now().isLeapYear()</td><td>false</td></tr><tr><td>获取本月的第一天</td><td>LocalDate.parse(“2019-05-14”).with(TemporalAdjusters.firstDayOfMonth())</td><td>2019-05-01</td></tr></tbody></table><p>显示详细信息</p><p><strong>LocalTime</strong>（<strong>时间</strong>）</p><table><thead><tr><th>说明</th><th>方法</th><th>示例</th></tr></thead><tbody><tr><td>获取当前时间</td><td>LocalTime.now()</td><td>20:46:15.170</td></tr><tr><td>时间构造</td><td>LocalTime.of(17,30,14)</td><td>17:30:14</td></tr><tr><td>字符串时间解析为LocalTime</td><td>LocalTime.parse(“17:30”)</td><td>17:30</td></tr><tr><td>获取小时</td><td>LocalTime.now().getHour()</td><td>20</td></tr><tr><td>获取分钟</td><td>LocalTime.now().getMinute()</td><td>46</td></tr><tr><td>判断一个时间是否在另一时间之前</td><td>LocalTime.parse(“17:30”).isBefore(LocalTime.parse(“17:29”))</td><td>false</td></tr><tr><td>判断一个时间是否在另一时间之后</td><td>LocalTime.parse(“17:30”).isAfter(LocalTime.parse(“17:29”))</td><td>true</td></tr><tr><td>每天的开始</td><td>LocalTime.MIN</td><td>00:00</td></tr><tr><td>每天的结束</td><td>LocalTime.MAX</td><td>23:59:59.999999999</td></tr></tbody></table><p>显示详细信息</p><p><strong>LocalDateTime</strong>（日期时间，可通过getXX获取年月日时分秒）</p><table><thead><tr><th>说明</th><th>方法</th><th>示例</th></tr></thead><tbody><tr><td>获取当前日期的时间</td><td>LocalDateTime.now()</td><td>2019-05-14T20:57:18.094</td></tr><tr><td>日期时间构造</td><td>LocalDateTime.of(2019,05,14,17,30,14)</td><td>2019-05-14T17:30:14</td></tr><tr><td>日期时间加1天</td><td>LocalDateTime.now().plusDays(1)</td><td>2019-05-15T20:57:18.094</td></tr><tr><td>日期时间减1天</td><td>LocalDateTime.now().minusDays(1)</td><td>2019-05-13T20:57:18.094</td></tr></tbody></table><p><strong>Instant(时间戳)</strong></p><table><thead><tr><th>说明</th><th>方法</th><th>示例</th></tr></thead><tbody><tr><td>当前UTC时区</td><td>Instant.now()</td><td>2019-05-14T13:10:33.982Z</td></tr><tr><td>东八区</td><td>Instant.now().atOffset(ZoneOffset.ofHours(8))</td><td>2019-05-14T21:10:34.022+08:00</td></tr><tr><td>获取毫秒值</td><td>Instant.now().toEpochMilli()</td><td>1557839434023</td></tr><tr><td>通过毫秒获取时间（UTC时区）</td><td>Instant.ofEpochMilli(1)</td><td>1970-01-01T00:00:00.001Z</td></tr><tr><td>通过时区ID获取时间</td><td>LocalDateTime.now(ZoneId.of(“Europe&#x2F;London”))</td><td>2019-05-14T14:10:34.030</td></tr><tr><td>比较两个日期的差别</td><td>ChronoUnit.DAYS.between(temporal1,temporal2)</td><td>相差的天数</td></tr></tbody></table><p><strong>DateTimeFormatter</strong>（时间与字符串之间的转换）</p><table><thead><tr><th>说明</th><th>方法</th><th>示例</th></tr></thead><tbody><tr><td>转换格式</td><td>DateTimeFormatter.ofPattern(“yyyy-MM-dd HH:mm:ss.SSS”)</td><td></td></tr><tr><td>字符串转LocalDateTime</td><td>LocalDateTime.parse(“2019-05-14 21:15:30.555”,DateTimeFormatter.ofPattern(“yyyy-MM-dd HH:mm:ss.SSS”))</td><td>2019-05-14T21:15:30.555</td></tr><tr><td>LocalDateTime转字符串</td><td>DateTimeFormatter.ofPattern(“yyyy-MM-dd HH:mm:ss.SSS”).format(LocalDateTime.now())</td><td>2019-05-14 21:18:22.902</td></tr></tbody></table><p><strong>各时间与Date之间互转</strong></p><table><thead><tr><th>说明</th><th>方法</th><th>示例</th></tr></thead><tbody><tr><td>Date转换为LocalDateTime</td><td>Date.from(Instant.now()).toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime()</td><td>2019-05-14T21:43:57.650</td></tr><tr><td>LocalDateTime转Date</td><td>Date.from(LocalDateTime.now().atZone(ZoneId.systemDefault()).toInstant())</td><td>Tue May 14 21:43:57 CST 2019</td></tr><tr><td>LocalDate转Date</td><td>Date.from(LocalDate.now().atStartOfDay(ZoneId.systemDefault()).toInstant())</td><td>Tue May 14 00:00:00 CST 2019</td></tr><tr><td>Date转字符串</td><td>DateTimeFormatter.ofPattern(“yyyy-MM-dd HH:mm:ss.SSS”).format(Date.from(new Date().toInstant()).toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime())</td><td>2019-05-14 21:43:57.706</td></tr></tbody></table><h3 id="JDK8时间操作demo"><a href="#JDK8时间操作demo" class="headerlink" title="JDK8时间操作demo"></a>JDK8时间操作demo</h3><pre><code>public class Test08 &#123;    /**     * JDK8 日期时间操作     */    @Test    public void test01()&#123;        // 1.创建指定的日期        LocalDate date1 = LocalDate.of(2021, 05, 06);        System.out.println(&quot;date1 = &quot;+date1);        // 2.得到当前的日期        LocalDate now = LocalDate.now();        System.out.println(&quot;now = &quot;+now);        // 3.根据LocalDate对象获取对应的日期信息        System.out.println(&quot;年：&quot; + now.getYear());        System.out.println(&quot;月：&quot; + now.getMonth().getValue());        System.out.println(&quot;日：&quot; + now.getDayOfMonth());        System.out.println(&quot;星期：&quot; + now.getDayOfWeek().getValue());    &#125;    /**     * 时间操作     */    @Test    public void test02()&#123;        // 1.得到指定的时间        LocalTime time = LocalTime.of(5,26,33,23145);        System.out.println(time);        // 2.获取当前的时间        LocalTime now = LocalTime.now();        System.out.println(now);        // 3.获取时间信息        System.out.println(now.getHour());        System.out.println(now.getMinute());        System.out.println(now.getSecond());        System.out.println(now.getNano());    &#125;    /**     * 日期时间类型  LocalDateTime     */    @Test    public void test03()&#123;        // 获取指定的日期时间        LocalDateTime dateTime =                LocalDateTime.of(2020                        , 06                        , 01                        , 12                        , 12                        , 33                        , 213);        System.out.println(dateTime);        // 获取当前的日期时间        LocalDateTime now = LocalDateTime.now();        System.out.println(now);        // 获取日期时间信息        System.out.println(now.getYear());        System.out.println(now.getMonth().getValue());        System.out.println(now.getDayOfMonth());        System.out.println(now.getDayOfWeek().getValue());        System.out.println(now.getHour());        System.out.println(now.getMinute());        System.out.println(now.getSecond());        System.out.println(now.getNano());    &#125;&#125;</code></pre><h4 id="日期时间的修改"><a href="#日期时间的修改" class="headerlink" title="日期时间的修改"></a>日期时间的修改</h4><pre><code>    /**     * 日期时间的修改     */    @Test    public void test01()&#123;        LocalDateTime now = LocalDateTime.now();        System.out.println(&quot;now = &quot;+now);        // 修改日期时间  对日期时间的修改，对已存在的LocalDate对象，创建了它模板        // 并不会修改原来的信息        LocalDateTime localDateTime = now.withYear(1998);        System.out.println(&quot;now :&quot;+now);        System.out.println(&quot;修改后的：&quot; + localDateTime);        System.out.println(&quot;月份：&quot; + now.withMonth(10));        System.out.println(&quot;天：&quot; + now.withDayOfMonth(6));        System.out.println(&quot;小时：&quot; + now.withHour(8));        System.out.println(&quot;分钟:&quot; + now.withMinute(15));        // 在当前日期时间的基础上 加上或者减去指定的时间        System.out.println(&quot;两天后:&quot; + now.plusDays(2));        System.out.println(&quot;10年后:&quot;+now.plusYears(10));        System.out.println(&quot;6个月后 = &quot; + now.plusMonths(6));        System.out.println(&quot;10年前 = &quot; + now.minusYears(10));        System.out.println(&quot;半年前 = &quot; + now.minusMonths(6));        System.out.println(&quot;一周前 = &quot; + now.minusDays(7));    &#125;    /**     * 日期时间的比较     */    @Test    public void test02()&#123;        LocalDate now = LocalDate.now();        LocalDate date = LocalDate.of(2020, 1, 3);        // 在JDK8中要实现 日期的比较 isAfter  isBefore isEqual 通过这几个方法来直接比较        System.out.println(now.isAfter(date)); // true        System.out.println(now.isBefore(date)); // false        System.out.println(now.isEqual(date)); // false    &#125;&#125;</code></pre><h3 id="日期的解析与格式化"><a href="#日期的解析与格式化" class="headerlink" title="日期的解析与格式化"></a>日期的解析与格式化</h3><pre><code>   /**     * 日期格式化     */    @Test    public void test01()&#123;        LocalDateTime now = LocalDateTime.now();        // 指定格式  使用系统默认的格式 2021-05-27T16:16:38.139        DateTimeFormatter isoLocalDateTime = DateTimeFormatter.ISO_LOCAL_DATE_TIME;        // 将日期时间转换为字符串        String format = now.format(isoLocalDateTime);        System.out.println(&quot;format = &quot; + format);        // 通过 ofPattern 方法来指定特定的格式        DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);        String format1 = now.format(dateTimeFormatter);        // 2021-05-27 16:16:38        System.out.println(&quot;format1 = &quot; + format1);        // 将字符串解析为一个 日期时间类型        LocalDateTime parse = LocalDateTime.parse(&quot;1997-05-06 22:45:16&quot;, dateTimeFormatter);        // parse = 1997-05-06T22:45:16        System.out.println(&quot;parse = &quot; + parse);    &#125;</code></pre><h3 id="Instant-类"><a href="#Instant-类" class="headerlink" title="Instant 类"></a>Instant 类</h3><p>在jdk8中给我们新增一个instant类（时间戳&#x2F;时间线）内部保存了从1970年1月1日 0时0分0秒</p><pre><code>  @Test    public void test01() throws Exception&#123;        Instant now = Instant.now();        System.out.println(&quot;now = &quot; + now);        // 获取从1970年一月一日 00:00:00 到现在的 纳秒        System.out.println(now.getNano());        Thread.sleep(5);        Instant now1 = Instant.now();        System.out.println(&quot;耗时：&quot; + (now1.getNano() - now.getNano()));    &#125;</code></pre><h3 id="计算日期时间差"><a href="#计算日期时间差" class="headerlink" title="计算日期时间差"></a>计算日期时间差</h3><p><strong>通过Duration来计算时间差</strong></p><p> <strong>计算日期差period</strong> </p><p>  <strong>时间校正器</strong></p><pre><code>  /**     * 计算日期时间差     */    @Test    public void test01()&#123;        // 计算时间差        LocalTime now = LocalTime.now();        LocalTime time = LocalTime.of(22, 48, 59);        System.out.println(&quot;now = &quot; + now);        // 通过Duration来计算时间差        Duration duration = Duration.between(now, time);        System.out.println(duration.toDays()); // 0        System.out.println(duration.toHours()); // 6        System.out.println(duration.toMinutes()); // 368        System.out.println(duration.toMillis()); // 22124240        // 计算日期差period         LocalDate nowDate = LocalDate.now();        LocalDate date = LocalDate.of(1997, 12, 5);        Period period = Period.between(date, nowDate);        System.out.println(period.getYears()); // 23        System.out.println(period.getMonths()); // 5        System.out.println(period.getDays()); // 22    &#125;    /**     * 时间校正器     */    @Test    public void test02()&#123;        LocalDateTime now = LocalDateTime.now();        // 将当前的日期调整到下个月的一号        TemporalAdjuster adJuster = (temporal)-&gt;&#123;            LocalDateTime dateTime = (LocalDateTime) temporal;            LocalDateTime nextMonth = dateTime.plusMonths(1).withDayOfMonth(1);            System.out.println(&quot;nextMonth = &quot; + nextMonth);            return nextMonth;        &#125;;        // 我们可以通过TemporalAdjusters 来实现        // LocalDateTime nextMonth = now.with(adJuster);        LocalDateTime nextMonth = now.with(TemporalAdjusters.firstDayOfNextMonth());        System.out.println(&quot;nextMonth = &quot; + nextMonth);    &#125;</code></pre><h3 id="jdk8的关于时区的定义"><a href="#jdk8的关于时区的定义" class="headerlink" title="jdk8的关于时区的定义"></a>jdk8的关于时区的定义</h3><pre><code>   @Test    public void test01()&#123;        // 1.获取所有的时区id        // ZoneId.getAvailableZoneIds().forEach(System.out::println);        // 获取当前时间 中国使用的 东八区的时区，比标准时间早8个小时        LocalDateTime now = LocalDateTime.now();        System.out.println(&quot;now = &quot; + now); // 2021-05-27T17:17:06.951        // 获取标准时间        ZonedDateTime bz = ZonedDateTime.now(Clock.systemUTC());        System.out.println(&quot;bz = &quot; + bz); // 2021-05-27T09:17:06.952Z        // 使用计算机默认的时区，创建日期时间        ZonedDateTime now1 = ZonedDateTime.now();        System.out.println(&quot;now1 = &quot; + now1); //2021-05-27T17:17:06.952+08:00[Asia/Shanghai]        // 使用指定的时区创建日期时间        ZonedDateTime now2 = ZonedDateTime.now(ZoneId.of(&quot;America/Marigot&quot;));        System.out.println(&quot;now2 = &quot; + now2);    &#125;</code></pre><h2 id="jdk新的日期和时间api优势"><a href="#jdk新的日期和时间api优势" class="headerlink" title="jdk新的日期和时间api优势"></a>jdk新的日期和时间api优势</h2><p>1.新版api 日期时间不可变 改变时生成新的对象</p><p>2.提供不同的两种方式区分了人和机器</p><p>3.TemporalAdjuster精确的操作时期</p><p>4.线程安全</p><h2 id="其他新特性重复注解"><a href="#其他新特性重复注解" class="headerlink" title="其他新特性重复注解"></a>其他新特性重复注解</h2><pre><code>@MyAnnotation(&quot;test1&quot;)@MyAnnotation(&quot;test2&quot;)@MyAnnotation(&quot;test3&quot;)public class AnnoTest01 &#123;    @MyAnnotation(&quot;fun1&quot;)    @MyAnnotation(&quot;fun2&quot;)    public void test01()&#123;    &#125;    /**     * 解析重复注解     * @param args     */    public static void main(String[] args) throws NoSuchMethodException &#123;        // 获取类中标注的重复注解        MyAnnotation[] annotationsByType = AnnoTest01.class.getAnnotationsByType(MyAnnotation.class);        for (MyAnnotation myAnnotation : annotationsByType) &#123;            System.out.println(myAnnotation.value());        &#125;        // 获取方法上标注的重复注解        MyAnnotation[] test01s = AnnoTest01.class.getMethod(&quot;test01&quot;)                .getAnnotationsByType(MyAnnotation.class);        for (MyAnnotation test01 : test01s) &#123;            System.out.println(test01.value());        &#125;    &#125;&#125;</code></pre><h2 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>mybatis_plus</title>
      <link href="/2023/09/03/mybatis-plus/"/>
      <url>/2023/09/03/mybatis-plus/</url>
      
        <content type="html"><![CDATA[<h1 id="mybatis-plusreviews"><a href="#mybatis-plusreviews" class="headerlink" title="mybatis_plusreviews"></a>mybatis_plusreviews</h1><h2 id="mybatis回顾"><a href="#mybatis回顾" class="headerlink" title="mybatis回顾"></a>mybatis回顾</h2><p>因为引入mp自动会做mybatis的一系列配置所以配置暂不回顾</p><p>谈谈使用</p><p>定义一个实体类</p><pre><code>public class Student &#123;    private String sno;    private String sname;    private String ssex;    public String getSno() &#123;        return sno;    &#125;    public void setSno(String sno) &#123;        this.sno = sno;    &#125;    public String getSname() &#123;        return sname;    &#125;    public void setSname(String sname) &#123;        this.sname = sname;    &#125;    public String getSsex() &#123;        return ssex;    &#125;&#125;</code></pre><p>定义对应的mapper</p><pre><code>package com.mapper;import com.po.Student;public interface StudentMapper &#123;    public Student selectStudentBySno(String sno);       public List&lt;Student&gt; selectStudentBySname(String sname);    public int insertStudent(Student student);    public int deleteStudent(String sno);    public int updateStudent(Student student);    public Student selectStudentBySno(String sno，int id);    public Student selectStudentBySno(@Param(&quot;studentno&quot;) String sno, int id);&#125;</code></pre><p>定义对应的mapper.xml</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;    &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.mapper.StudentMapper&quot;&gt;    &lt;select id=&quot;selectStudentBySno&quot; parameterType=&quot;String&quot; resultType=&quot;com.po.Student&quot;&gt;        select * from stu where sno=#&#123;sno&#125;;    &lt;/select&gt;    &lt;select id=&quot;selectStudentBySname&quot; parameterType=&quot;String&quot; resultType=&quot;com.po.Student&quot;&gt;        select * from stu where sname like concat(&#39;%&#39;,#&#123;sname&#125;,&#39;%&#39;);    &lt;/select&gt;    &lt;insert id=&quot;insertStudent&quot; parameterType=&quot;com.po.Student&quot;&gt;        insert into stu(sno,sname,ssex,snative,mno) values(#&#123;sno&#125;,#&#123;sname&#125;,#&#123;ssex&#125;,#&#123;snative&#125;,#&#123;mno&#125;);    &lt;/insert&gt;    &lt;delete id=&quot;deleteStudent&quot; parameterType=&quot;String&quot;&gt;        delete from stu where sno=#&#123;sno&#125;    &lt;/delete&gt;    &lt;update id=&quot;updateStudent&quot; parameterType=&quot;com.po.Student&quot;&gt;        update stu set sname=#&#123;sname&#125;,ssex=#&#123;ssex&#125;,snative=#&#123;snative&#125;,mno=#&#123;mno&#125; where sno=#&#123;sno&#125;    &lt;/update&gt;        &lt;select id=&quot;selectStudentBySno&quot; parameterType=&quot;java.util.Map&quot; resultType=&quot;com.po.Student&quot;&gt;  SELECT * FROM stu WHERE sno = #&#123;sno&#125; AND id = #&#123;id&#125;&lt;/select&gt;       &lt;select id=&quot;selectStudentBySno&quot; parameterType=&quot;java.util.Map&quot; resultType=&quot;com.po.Student&quot;&gt;  SELECT * FROM stu WHERE sno = #&#123;studentno&#125; AND id = #&#123;id&#125;&lt;/select&gt;        &lt;/mapper&gt;</code></pre><h4 id="这里也提一嘴parameterType-x3D-”String”"><a href="#这里也提一嘴parameterType-x3D-”String”" class="headerlink" title="这里也提一嘴parameterType&#x3D;”String”"></a>这里也提一嘴parameterType&#x3D;”String”</h4><p>如果是一个参数我们可以省略不写</p><p>如果是多个参数我们可以使用map或者实体类来传递</p><p>parameterType&#x3D;”java.util.Map”</p><p> parameterType&#x3D;”com.po.Student”</p><p>我们也可以省略不写 因为mybatis底层帮我们自动映射到</p><p>#{studentno} 这里可以是实体的名字 也可以是map的key</p><p>但是我们需要注意的是当我们的map中的key和我们#{sno}不一致的时候我们需要在传递过来的时候用@param（”指定名称”）</p><p>如果你的实体类或者Map中的键（key）与SQL语句中的占位符（<code>#&#123;value&#125;</code>）的名称不相同，你可以使用<code>@Param</code>注解（对于Java）或者指定键（key）的方式（对于Map）来映射它们。</p><p>对于Java实体类，你可以在方法参数上使用<code>@Param</code>注解来指定实体类中属性与占位符的对应关系。例如：</p><pre><code>public void deleteStudent(@Param(&quot;studentId&quot;) String id, @Param(&quot;studentName&quot;) String name) &#123;  // 执行删除学生的逻辑&#125;</code></pre><p>然后，在XML映射文件中，你可以使用指定的名称来引用这些参数：</p><pre><code>&lt;delete id=&quot;deleteStudent&quot;&gt;  DELETE FROM students  WHERE id = #&#123;studentId&#125;    AND name = #&#123;studentName&#125;&lt;/delete&gt;</code></pre><p>对于Map，你可以在传递参数时，指定键与占位符的对应关系。例如：</p><pre><code>Map&lt;String, Object&gt; parameters = new HashMap&lt;&gt;();parameters.put(&quot;idParam&quot;, id);parameters.put(&quot;nameParam&quot;, name);deleteStudent(parameters);</code></pre><p>然后，在XML映射文件中，你可以使用指定的键来引用这些参数：</p><pre><code>&lt;delete id=&quot;deleteStudent&quot;&gt;  DELETE FROM students  WHERE id = #&#123;idParam&#125;    AND name = #&#123;nameParam&#125;&lt;/delete&gt;</code></pre><p>具体的实体我们也可以这样对应</p><p>Java方法定义：</p><pre><code>public void deleteStudent(Student student) &#123;  // 执行删除学生的逻辑&#125;</code></pre><p>XML映射文件：</p><pre><code>&lt;delete id=&quot;deleteStudent&quot;&gt;  DELETE FROM students  WHERE id = #&#123;student.studentId&#125;    AND name = #&#123;student.studentName&#125;&lt;/delete&gt;</code></pre><p>在这个示例中，你可以创建一个名为<code>Student</code>的Java类，其中包含<code>studentId</code>和<code>studentName</code>等属性，并将其作为参数传递给<code>deleteStudent</code>方法。在XML映射文件中，你可以使用<code>#&#123;student.studentId&#125;</code>和<code>#&#123;student.studentName&#125;</code>来引用<code>Student</code>对象的属性。</p><h4 id="几个特殊的查询单独说"><a href="#几个特殊的查询单独说" class="headerlink" title="几个特殊的查询单独说"></a>几个特殊的查询单独说</h4><pre><code>public Map&lt;String, Object&gt; selectStudentBySno(String sno, int id);</code></pre><pre><code>&lt;select id=&quot;selectStudentBySno&quot; parameterType=&quot;java.util.Map&quot; resultType=&quot;java.util.Map&quot;&gt;  SELECT * FROM stu WHERE sno = #&#123;sno&#125; AND id = #&#123;id&#125;&lt;/select&gt;</code></pre><p>这里写的map只是一个map 如果查到了多个数据 默认保留最后一条数据</p><p>如果想要接收多个数据可以</p><pre><code>List&lt;Map&lt;String, Object&gt;&gt; resultList  selectStudentBySnameResultmap(String sname);</code></pre><pre><code>   &lt;select id=&quot;selectStudentBySnameResultmap&quot; parameterType=&quot;java.util.Map&quot; resultType=&quot;com.po.Student&quot;&gt;  SELECT * FROM stu WHERE sname=sname&lt;/select&gt;</code></pre><p>这里需要注意 返回的map默认情况下 应该是 字段名称作为key值 value作为 value值</p><p>这里千万不要误解 map只是一个类似对象的集合  他不是多个可以存储多条数据的集合 一个map只能存储一条数据</p><p>List&lt;Map&lt;String, Object&gt;&gt; resultList 如有多条请使用list</p><h4 id="自定义resultmap集合"><a href="#自定义resultmap集合" class="headerlink" title="自定义resultmap集合"></a>自定义resultmap集合</h4><p>另外如果你想指定返回的map集合的key值名称可以这样来操作</p><pre><code>&lt;resultMap id=&quot;customResultMap&quot; type=&quot;java.util.Map&quot;&gt;  &lt;id column=&quot;customKey&quot; property=&quot;customKey&quot; /&gt;  &lt;result column=&quot;column1&quot; property=&quot;value1&quot; /&gt;  &lt;result column=&quot;column2&quot; property=&quot;value2&quot; /&gt;  &lt;!-- 其他字段映射规则 --&gt;&lt;/resultMap&gt;</code></pre><pre><code>&lt;select id=&quot;selectCustomData&quot; resultMap=&quot;customResultMap&quot;&gt;  SELECT customKey, column1, column2 FROM your_table&lt;/select&gt;</code></pre><pre><code>&lt;resultMap id=&quot;customResultMap&quot; type=&quot;java.util.Map&quot;&gt;  &lt;id column=&quot;id&quot; property=&quot;studentno&quot; /&gt;  &lt;result column=&quot;name&quot; property=&quot;studentname&quot; /&gt;  &lt;result column=&quot;age&quot; property=&quot;studentage&quot; /&gt;  &lt;!-- 其他字段映射规则 --&gt;&lt;/resultMap&gt;&lt;select id=&quot;selectCustomData&quot; resultMap=&quot;customResultMap&quot;&gt;  SELECT id, name, age FROM your_table&lt;/select&gt;</code></pre><p>我们在返回的map集合中数据应该是</p><p>{</p><pre><code>&quot;studentno&quot;, 1&quot;studentname&quot;, &quot;John&quot;&quot;studentage&quot;, 25</code></pre><p><strong>注意我们查询的结果mybatis默认不会帮我们做驼峰映射</strong></p><p>如果你在 MyBatis 的配置文件中设置了 <code>mapUnderscoreToCamelCase</code> 为 <code>true</code>，并且没有使用自定义的 <code>&lt;resultMap&gt;</code> 配置，那么在没有其他特殊配置的情况下，查询结果的字段将按照驼峰命名规则映射到 <code>Map</code> 中的键名。</p><p>假设数据库表中的字段和查询结果如下：</p><p>数据库表字段：<code>custom_key</code>, <code>column1</code>, <code>column2</code></p><p>查询结果数据：<code>1</code>, <code>value1</code>, <code>value2</code></p><p>使用以下的配置：</p><pre><code>&lt;configuration&gt;  &lt;settings&gt;    &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;  &lt;/settings&gt;  &lt;!-- 其他配置 --&gt;&lt;/configuration&gt;</code></pre><p>查询结果将会映射到 <code>Map</code> 中的键名为驼峰命名规则，即：</p><pre><code>Map&lt;String, Object&gt; resultMap = new HashMap&lt;&gt;();resultMap.put(&quot;customKey&quot;, 1);resultMap.put(&quot;column1&quot;, &quot;value1&quot;);resultMap.put(&quot;column2&quot;, &quot;value2&quot;);</code></pre><p>如果你的实体类中的属性采用了驼峰命名规则，并且希望查询结果按照驼峰命名规则映射到实体类中的属性，那么你需要在 MyBatis 的配置文件中开启驼峰配置。</p><p>假设你有一个实体类 <code>Student</code>，其中包含属性 <code>studentNo</code>、<code>studentName</code> 和 <code>studentAge</code>，对应数据库表中的字段 <code>student_no</code>、<code>student_name</code> 和 <code>student_age</code>。</p><p>在 MyBatis 的配置文件中添加以下配置：</p><pre><code>&lt;configuration&gt;  &lt;settings&gt;    &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;  &lt;/settings&gt;  &lt;!-- 其他配置 --&gt;&lt;/configuration&gt;</code></pre><p>通过设置 <code>mapUnderscoreToCamelCase</code> 为 <code>true</code>，MyBatis 将会自动将查询结果的字段按照驼峰命名规则映射到实体类的属性。</p><p>使用以下的映射配置：</p><pre><code>&lt;resultMap id=&quot;studentResultMap&quot; type=&quot;com.example.Student&quot;&gt;  &lt;id column=&quot;student_no&quot; property=&quot;studentNo&quot; /&gt;  &lt;result column=&quot;student_name&quot; property=&quot;studentName&quot; /&gt;  &lt;result column=&quot;student_age&quot; property=&quot;studentAge&quot; /&gt;  &lt;!-- 其他字段映射规则 --&gt;&lt;/resultMap&gt;&lt;select id=&quot;selectStudent&quot; resultMap=&quot;studentResultMap&quot;&gt;  SELECT student_no, student_name, student_age FROM your_table&lt;/select&gt;</code></pre><p>在这个示例中，查询结果的字段 <code>student_no</code> 将映射到实体类的属性 <code>studentNo</code>，<code>student_name</code> 映射到 <code>studentName</code>，<code>student_age</code> 映射到 <code>studentAge</code>。</p><p>因此，你可以直接将查询结果映射到实体类 <code>Student</code> 的对象中：</p><pre><code>Student student = sqlSession.selectOne(&quot;selectStudent&quot;);</code></pre><p>MyBatis 将会自动将查询结果的字段值赋值给实体类的属性，根据驼峰命名规则进行映射。</p><p>希望这次能够解答清楚你的疑问。如果还有其他问题，请随时提问。</p><h2 id="mybatis-plus"><a href="#mybatis-plus" class="headerlink" title="mybatis plus"></a>mybatis plus</h2><p><strong>约定大于配置</strong></p><p>默认</p><p>当我们要使用mybatisplus的时候 我们需要去集成mp提供的BaseMapper</p><p>public interface UserMapper extends BaseMapper<User> </User></p><h2 id="关于mybatisplus常用注解"><a href="#关于mybatisplus常用注解" class="headerlink" title="关于mybatisplus常用注解"></a>关于mybatisplus常用注解</h2><p><strong>注解到类上</strong></p><p>@TableName(“表名”) 用来解决 数据库表对应到java实体  符合驼峰命名</p><p><strong>注解到字段</strong></p><p>@TableId  默认是id为映射字段 可以自己指定  注意（一个实体对应一个表只有一个主键） </p><p>mybatisplus不支持联合主键</p><p>private Long id；</p><p>1.0@TableField（“isMarried”） </p><p> 作用 解决实体属性与数据库字段不一致情况</p><p><strong>作用二、</strong></p><p>@TableField（“isMarried”） </p><p>private Boolean isMarried 在对应到mybatisplus 查询语句时会自动去掉is 对应数据库 的Married字段</p><p><strong>作用三、</strong></p><p>@TableField（“order”）</p><p> private Stringi order；</p><p>实体名字与mysql的保留关键字冲突</p><p>@exist（）</p><p>是否是数据库字段</p><p>mybatisplus的配置可以替代mybatis的配置</p><p>mybatis-plus:<br>  type-aliases-package: com.itheima.mp.domain.po<br>  global-config:<br>    db-config:<br>      id-type: *auto<br>*      logic-delete-field: deleted <em>#</em> *逻辑删除字段<br>*  configuration:<br>    default-enum-type-handler: com.baomidou.mybatisplus.core.handlers.MybatisEnumTypeHandler</p><p>mybatis支持各种复杂的where条件</p><p><img src="/2023/09/03/mybatis-plus/personboke\blog\source_posts\mybatis-plus\image-20230903215353762.png" alt="image-20230903215353762"></p><p>demo</p><pre><code class="java">   @Test    public void test()&#123;        List&lt;User&gt; users = userMapper.queryUserByIds(List.of(1L, 2L, 3L));        users.forEach(System.out::println);    &#125;    @Test    public void testdemo01()&#123;        //1.构建查询条件        QueryWrapper&lt;User&gt; objectQueryWrapper = new QueryWrapper&lt;User&gt;()                .select(&quot;id&quot;, &quot;username&quot;,&quot;info&quot;,&quot;balance&quot;)                .like(&quot;username&quot;,&quot;o&quot;)                .ge(&quot;balance&quot;,1000);        List&lt;User&gt; users = userMapper.selectList(objectQueryWrapper);        for (User user : users) &#123;            System.out.println(user.toString());        &#125;    &#125;    @Test    public void testqueryWrapper()&#123;        User user = new User();        user.setBalance(2000);        //1.构建查询条件        QueryWrapper&lt;User&gt; objectQueryWrapper = new QueryWrapper&lt;User&gt;()                .eq(&quot;username&quot;,&quot;jack&quot;);        userMapper.update(user,objectQueryWrapper);    &#125;    @Test    public void testUpdateWrapper()&#123;        UpdateWrapper&lt;User&gt; in = new UpdateWrapper&lt;User&gt;().setSql(&quot;balance=balance-200&quot;)                .in(&quot;id&quot;,List.of(1L, 2L, 4L));        userMapper.update(null,in);    &#125;        @Test    public void testLamdaQueryWrapper()&#123;        //1.构建条件        QueryWrapper&lt;User&gt; objectQueryWrapper = new QueryWrapper&lt;&gt;();        LambdaQueryWrapper&lt;User&gt; userLambdaQueryWrapper = objectQueryWrapper.lambda().select(User::getId, User::getUsername, User::getBalance                        , User::getInfo).like(User::getUsername, &quot;0&quot;)                .ge(User::getBalance, 1000);        List&lt;User&gt; users = userMapper.selectList(userLambdaQueryWrapper);    &#125;&#125;</code></pre><h3 id="lamdaQueryWrapper"><a href="#lamdaQueryWrapper" class="headerlink" title="lamdaQueryWrapper"></a>lamdaQueryWrapper</h3><p>示例</p><pre><code>LambdaQueryWrapper&lt;User&gt; userLambdaQueryWrapper = lamdQueryWrapper.lambda().select(User::getId, User::getUsername, User::getBalance                        , User::getInfo).like(User::getUsername, &quot;0&quot;)                .ge(User::getBalance, 1000);</code></pre><p><strong>自定义sql</strong></p><p>思想就是 我们where之后的判断条件采用mtbatis构建的并且采用${} 拼接到我们自己的</p><p>示例</p><p>首先定义一个queryWrapper传给自己的方法 也就是定义在mapper中的方法</p><pre><code class="java">    //定义条件        QueryWrapper&lt;User&gt; objectQueryWrapper = new QueryWrapper&lt;&gt;();                objectQueryWrapper.lambda().in(User::getId,longs);        //2.执行更新        userMapper.updateBalanceByWrapper(200,objectQueryWrapper);</code></pre><p>mapper 注意mapper中只能用@Param(“ew”)  来接收自定义的条件 这是规定</p><pre><code class="java"> @Update(&quot;UPDATE user SET balance = balance - #&#123;amount&#125; $&#123;ew.customSqlSegment&#125;&quot;)    void updateBalanceByWrapper(@Param(&quot;amount&quot;) int amount, @Param(&quot;ew&quot;) QueryWrapper&lt;User&gt; wrapper);</code></pre><pre><code>    该方法对应到Mapper.xml   &lt;select id=&quot;queryUsersByWrapper&quot; resultType=&quot;com.itheima.mp.domain.po.User&quot;&gt;        SELECT u.*        FROM user u        INNER JOIN address a on u.id = a.user_id        $&#123;ew.customSqlSegment&#125;    &lt;/select&gt;</code></pre><p>因为mybatisplus没办法做多表查询 我们可以使用自定义sql来实现都多表查询</p><pre><code>       List&lt;Long&gt; longs = List.of(1L, 2L, 3L);        //定义条件        QueryWrapper&lt;User&gt; objectQueryWrapper = new QueryWrapper&lt;&gt;();            new QueryWrapper&lt;User&gt;().in(&quot;u.id&quot;,longs)                    .eq(&quot;a.city&quot;,&quot;中国&quot;);        //2.执行更新        List&lt;User&gt; users = userMapper.queryUsersByWrapper(objectQueryWrapper);</code></pre><p>xml文件</p><pre><code> &lt;select id=&quot;queryUsersByWrapper&quot; resultType=&quot;com.itheima.mp.domain.po.User&quot;&gt;        SELECT u.*        FROM user u        INNER JOIN address a on u.id = a.user_id        $&#123;ew.customSqlSegment&#125;    &lt;/select&gt;</code></pre><p> UPDATE user SET balance &#x3D; balance - #{amount} ${ew.customSqlSegment}</p><pre><code>    @Test    public void testCustomSql()&#123;        List&lt;Long&gt; longs = List.of(1L, 2L, 3L);        //定义条件        QueryWrapper&lt;User&gt; objectQueryWrapper = new QueryWrapper&lt;&gt;();                objectQueryWrapper.lambda().in(User::getId,longs);        //2.执行更新        userMapper.updateBalanceByWrapper(200,objectQueryWrapper);    &#125;        在UserMapper接口        @Update(&quot;UPDATE user SET balance = balance - #&#123;amount&#125; $&#123;ew.customSqlSegment&#125;&quot;)    void updateBalanceByWrapper(@Param(&quot;amount&quot;) int amount, @Param(&quot;ew&quot;) QueryWrapper&lt;User&gt; wrapper);            @Test    public void testJoinCustomSql()&#123;        List&lt;Long&gt; longs = List.of(1L, 2L, 3L);        //定义条件        QueryWrapper&lt;User&gt; objectQueryWrapper = new QueryWrapper&lt;&gt;();            new QueryWrapper&lt;User&gt;().in(&quot;u.id&quot;,longs)                    .eq(&quot;a.city&quot;,&quot;中国&quot;);        //2.执行更新        List&lt;User&gt; users = userMapper.queryUsersByWrapper(objectQueryWrapper);    &#125;    mapper接口       List&lt;User&gt; queryUsersByWrapper(@Param(&quot;ew&quot;) QueryWrapper&lt;User&gt; wrapper);              该方法对应到Mapper.xml   &lt;select id=&quot;queryUsersByWrapper&quot; resultType=&quot;com.itheima.mp.domain.po.User&quot;&gt;        SELECT u.*        FROM user u        INNER JOIN address a on u.id = a.user_id        $&#123;ew.customSqlSegment&#125;    &lt;/select&gt;</code></pre><h2 id="Service接口"><a href="#Service接口" class="headerlink" title="Service接口"></a>Service接口</h2><p>批处理记得开启mysql的 rewriteBatchedStatements&#x3D;true 重写批处理方案  oracle默认开启</p><p>如果不开启则是每次追加追加sql语句 即</p><p>insetinto tablename values（？？？？？）</p><p>每次insert都是把我们的数据填充到问号中 而不是 直接拼接后values（1，2，3，4，5），（1，2，3，4，5）</p><p>开启之后就是 values（1，2，3，4，5），（1，2，3，4，5）这种拼接 就是只执行一次sql</p><p>url: jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;mp?useUnicode&#x3D;true&amp;characterEncoding&#x3D;UTF-8&amp;autoReconnect&#x3D;true&amp;serverTimezone&#x3D;Asia&#x2F;Shanghai&amp;rewriteBatchedStatements&#x3D;true</p><h3 id="service层面-的lamdaQuery（）"><a href="#service层面-的lamdaQuery（）" class="headerlink" title="service层面 的lamdaQuery（）"></a>service层面 的lamdaQuery（）</h3><p>示例 注意在service层面写的lamdaQuery（）</p><p>或者lamdaUpdate  条件的最后要追加执行的动作</p><p>例如</p><p>.one();</p><p> .list();</p><p> .update(); &#x2F;&#x2F; 执行update</p><pre><code>userService.lambdaQuery().eq(User::getUsername,&quot;jack&quot;).one();</code></pre><pre><code class="java">   User user = userService.lambdaQuery()                .eq(User::getUsername, &quot;Rose&quot;)                .one();        System.out.println(&quot;user = &quot; + user);        List&lt;User&gt; list = userService.lambdaQuery()                .like(User::getUsername, &quot;o&quot;)                .list();        list.forEach(System.out::println);        Long count = userService.lambdaQuery()                .like(User::getUsername, &quot;o&quot;)                .count();        System.out.println(&quot;count = &quot; + count);</code></pre><p><strong>动态sql查询示例</strong></p><pre><code> return userService.lambdaQuery()                .like(username != null, User::getUsername, username)                .eq(status != null, User::getStatus, status)                .gt(min != null, User::getBalance, min)                .lt(max != null, User::getBalance, max)                .list();</code></pre><pre><code class="java">        userService.lambdaUpdate()                .set(User::getBalance, balance)                .set(balance == 0, User::getStatus, 2)                .eq(id != null, User::getId, id)                .eq(username != null, User::getUsername, username)                .update(); // 执行update    </code></pre><h3 id="问题-为了解决循环依赖问题-mybatisplus-提供了静态工具类-DB"><a href="#问题-为了解决循环依赖问题-mybatisplus-提供了静态工具类-DB" class="headerlink" title="问题 为了解决循环依赖问题 mybatisplus 提供了静态工具类 DB"></a>问题 为了解决循环依赖问题 mybatisplus 提供了静态工具类 DB</h3><h4 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h4><p>举例 </p><p>usersevice 需要adreeservice</p><p>adreevice又需要 uservice </p><p>我们在userservice注入addressservice</p><p>在addressvice 注入uservice 就会出现循环依赖问题</p><p>DB 类</p><pre><code>Db.save(user);   List&lt;User&gt; list = Db.list(new QueryWrapper&lt;User&gt;().like(&quot;username&quot;, &quot;o&quot;));User user = Db.lambdaQuery(User.class)                .eq(User::getUsername, &quot;Rose&quot;)                .one();                Long count = Db.lambdaQuery(User.class)                .like(User::getUsername, &quot;o&quot;)                .count();Db.lambdaQuery(User.class)                .like(username != null, User::getUsername, username)                .eq(status != null, User::getStatus, status)                .gt(min != null, User::getBalance, min)                .lt(max != null, User::getBalance, max)                .list();Db.lambdaUpdate(User.class)                .set(User::getBalance, balance)                .set(balance == 0, User::getStatus, 2)                .eq(id != null, User::getId, id)                .eq(username != null, User::getUsername, username)                .update(); // 执行update</code></pre><p>mybatisplus设置逻辑删除字段</p><p>mybatis会自动检测我们的删除字段</p><p>在我们执行删除操作的时候会替代成逻辑删除</p><pre><code>mybatis-plus:  type-aliases-package: com.itheima.mp.domain.po  global-config:    db-config:      id-type: auto      logic-delete-field: deleted # 逻辑删除字段  configuration:    default-enum-type-handler: com.baomidou.mybatisplus.core.handlers.MybatisEnumTypeHandler</code></pre><h3 id="枚举转换器-JSON处理器-不实用"><a href="#枚举转换器-JSON处理器-不实用" class="headerlink" title="枚举转换器  JSON处理器   不实用"></a>枚举转换器  JSON处理器   不实用</h3><p>需要配置mybatis的配置设置一个美剧转换器</p><p>并且在枚举类加上注解</p><p>​    @EnumValue</p><pre><code>@Getterpublic enum UserStatus &#123;    NORMAL(1, &quot;正常&quot;),    FREEZE(2, &quot;冻结&quot;),    ;    @EnumValue    private final int value;    @JsonValue    private final String desc;    UserStatus(int value, String desc) &#123;        this.value = value;        this.desc = desc;    &#125;&#125;</code></pre><pre><code>configuration:default-enum-type-handler: com.baomidou.mybatisplus.core.handlers.MybatisEnumTypeHandler</code></pre><p>JSON</p><pre><code>    @TableField(typeHandler = JacksonTypeHandler.class)    private UserInfo info;</code></pre><h2 id="myabatisplus分页插件"><a href="#myabatisplus分页插件" class="headerlink" title="myabatisplus分页插件"></a>myabatisplus分页插件</h2><p>CV 大法好</p><p>首先 mybatisplus的分页插件基于 mybatis的 interceptor</p><p>先注册好核心拦截器  配置好mp的拦截器配置</p><pre><code class="java">    @Bean    public MybatisPlusInterceptor mybatisPlusInterceptor()&#123;        // 1.创建核心拦截器        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();        // 2.创建插件        PaginationInnerInterceptor paginationInnerInterceptor = new PaginationInnerInterceptor(DbType.MYSQL);        paginationInnerInterceptor.setMaxLimit(1000L);        interceptor.addInnerInterceptor(paginationInnerInterceptor);        // 返回        return interceptor;    &#125;</code></pre><p>注意mybatis的分页插件条件时page对象</p><p>返回的数据也是page对象</p><pre><code>    @Test    void testPageQuery() &#123;        int pageNo = 1, pageSize = 5;        // 1.分页条件        Page&lt;User&gt; p = Page.of(pageNo, pageSize);        // 2.排序条件        p.addOrder(new OrderItem(&quot;balance&quot;, false));        // 3.查询        Page&lt;User&gt; page = userService.page(p);        // 4.分页结果        long total = page.getTotal();        System.out.println(&quot;total = &quot; + total);        long pages = page.getPages();        System.out.println(&quot;pages = &quot; + pages);        List&lt;User&gt; records = page.getRecords();        for (User record : records) &#123;            System.out.println(&quot;record = &quot; + record);        &#125;    &#125;</code></pre><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>List<User> users&#x3D;p.getRecords();</User></p><p>UserVO vo &#x3D; BeanUtil.<em>copyProperties</em>(user, UserVO.class);</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>mysql基于datetime得时间范围查询</title>
      <link href="/2023/08/29/mysql%E5%9F%BA%E4%BA%8Edatetime%E5%BE%97%E6%97%B6%E9%97%B4%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2/"/>
      <url>/2023/08/29/mysql%E5%9F%BA%E4%BA%8Edatetime%E5%BE%97%E6%97%B6%E9%97%B4%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="mysql-基于时间datetime得查询"><a href="#mysql-基于时间datetime得查询" class="headerlink" title="mysql 基于时间datetime得查询"></a>mysql 基于时间datetime得查询</h1><p><strong>#查询当日得数据</strong><br>select * from admins where TO_DAYS(createtime) &#x3D; TO_DAYS(NOW())<br><strong>#查询昨天的数据</strong><br>SELECT * FROM admins WHERE TO_DAYS(NOW()) - TO_DAYS(createtime) &#x3D; 1<br><strong>#查询近7天的数据（包含今天）</strong><br>SELECT * FROM admins WHERE DATE_SUB(CURDATE(), INTERVAL 7 DAY) &lt;&#x3D; createtime</p><p><strong>#查询本周的数据</strong><br>SELECT * FROM admins WHERE YEARWEEK(createtime,’%Y-%m-%d’) &#x3D; YEARWEEK(NOW());<br><strong>#查询上周的数据</strong><br>SELECT * FROM admins WHERE YEARWEEK(createtime,’%Y-%m-%d’) &#x3D; YEARWEEK(NOW())-1;<br>#查询近30天的数据（包含今天）<br>SELECT * FROM admins where DATE_SUB(CURDATE(), INTERVAL 30 DAY) &lt;&#x3D; createtime</p><p><strong>#查询本月的数据</strong><br>– SELECT * FROM table_name WHERE FROM_UNIXTIME(createtime, ‘%Y%m’) &#x3D; DATE_FORMAT(CURDATE(), ‘%Y%m’)<br>SELECT * FROM admins WHERE YEAR(createtime) &#x3D; YEAR(CURDATE()) AND MONTH(createtime) &#x3D; MONTH(CURDATE());</p><p><strong>#查询上月的数据</strong><br>– SELECT * FROM admins WHERE PERIOD_DIFF(DATE_FORMAT(NOW(),’%Y%m’), FROM_UNIXTIME(createtime,’%Y%m’)) &#x3D; 1<br>SELECT * FROM admins WHERE PERIOD_DIFF(DATE_FORMAT(NOW(), ‘%Y%m’), DATE_FORMAT(createtime, ‘%Y%m’)) &#x3D; 1;</p><p><strong>#查询本季度的数据</strong><br>– SELECT * FROM table_name WHERE QUARTER(FROM_UNIXTIME(create_time))&#x3D;QUARTER(NOW()) AND YEAR(FROM_UNIXTIME(create_time))&#x3D;YEAR(NOW())<br>SELECT * FROM admins WHERE QUARTER(createtime) &#x3D; QUARTER(NOW()) AND YEAR(createtime) &#x3D; YEAR(NOW());</p><p><strong>#查询上季度的数据</strong><br>– SELECT * FROM table_name WHERE QUARTER(FROM_UNIXTIME(create_time)) &#x3D; QUARTER(DATE_SUB(NOW(),INTERVAL 1 QUARTER)) AND YEAR(FROM_UNIXTIME(create_time))&#x3D;YEAR(NOW())<br>SELECT * FROM admins WHERE QUARTER(createtime) &#x3D; QUARTER(DATE_SUB(NOW(), INTERVAL 1 QUARTER)) AND YEAR(createtime) &#x3D; YEAR(NOW());</p><p><strong>#查询今年的数据</strong><br>– SELECT * FROM table_name WHERE YEAR(FROM_UNIXTIME(create_time))&#x3D;YEAR(NOW())<br>SELECT * FROM admins WHERE YEAR(createtime) &#x3D; YEAR(NOW());</p><p><strong>#查询去年的数据</strong><br>– SELECT * FROM table_name WHERE YEAR(FROM_UNIXTIME(create_time)) &#x3D; YEAR(DATE_SUB(NOW(),INTERVAL 1 YEAR))</p><p>SELECT * FROM admins WHERE YEAR(createtime) &#x3D; YEAR(DATE_SUB(NOW(), INTERVAL 1 YEAR));</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>swagger</title>
      <link href="/2023/08/19/Swagger2/"/>
      <url>/2023/08/19/Swagger2/</url>
      
        <content type="html"><![CDATA[<p><strong>学习目标：</strong></p><ul><li>了解Swagger的概念及作用</li><li>掌握在项目中集成Swagger自动生成API文档</li></ul><blockquote><h3 id="Swagger简介"><a href="#Swagger简介" class="headerlink" title="Swagger简介"></a>Swagger简介</h3></blockquote><p><strong>前后端分离</strong></p><ul><li>前端 -&gt; 前端控制层、视图层</li><li>后端 -&gt; 后端控制层、服务层、数据访问层</li><li>前后端通过API进行交互 </li><li>前后端相对独立且松耦合</li></ul><p><strong>产生的问题</strong></p><ul><li>前后端集成，前端或者后端无法做到“及时协商，尽早解决”，最终导致问题集中爆发</li></ul><p><strong>解决方案</strong></p><ul><li>首先定义schema [ 计划的提纲 ]，并实时跟踪最新的API，降低集成风险</li></ul><p><strong>Swagger</strong></p><ul><li>号称世界上最流行的API框架</li><li>Restful Api 文档在线自动生成器 &#x3D;&gt; <strong>API 文档 与API 定义同步更新</strong></li><li>直接运行，在线测试API</li><li>支持多种语言 （如：Java，PHP等）</li><li>官网：<a href="https://swagger.io/">https://swagger.io/</a></li></ul><blockquote><h3 id="SpringBoot集成Swagger"><a href="#SpringBoot集成Swagger" class="headerlink" title="SpringBoot集成Swagger"></a>SpringBoot集成Swagger</h3></blockquote><p><strong>SpringBoot集成Swagger</strong> &#x3D;&gt; <strong>springfox</strong>，两个jar包</p><ul><li><strong>Springfox-swagger2</strong></li><li>swagger-springmvc</li></ul><p><strong>使用Swagger</strong></p><p>要求：jdk 1.8 + 否则swagger2无法运行</p><p>步骤：</p><p>1、新建一个SpringBoot-web项目</p><p>2、添加Maven依赖</p><pre><code>&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger2 --&gt;&lt;dependency&gt;   &lt;groupId&gt;io.springfox&lt;/groupId&gt;   &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;   &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui --&gt;&lt;dependency&gt;   &lt;groupId&gt;io.springfox&lt;/groupId&gt;   &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;   &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>3、编写HelloController，测试确保运行成功！</p><p>4、要使用Swagger，我们需要编写一个配置类-SwaggerConfig来配置 Swagger</p><pre><code>@Configuration //配置类@EnableSwagger2// 开启Swagger2的自动配置public class SwaggerConfig &#123;  &#125;</code></pre><p>5、访问测试 ：<a href="http://localhost:8080/swagger-ui.html">http://localhost:8080/swagger-ui.html</a> ，可以看到swagger的界面；</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IExpkhknhzRFQicsic8yibm9ZzSgcwYhS2RhtRXv0Wfg9OkiaE6xDEQibt8TSJTt9OHzFzeq9NrQCJNZQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><blockquote><h3 id="配置Swagger"><a href="#配置Swagger" class="headerlink" title="配置Swagger"></a>配置Swagger</h3></blockquote><p>1、Swagger实例Bean是Docket，所以通过配置Docket实例来配置Swaggger。</p><pre><code>@Bean //配置docket以配置Swagger具体参数public Docket docket() &#123;   return new Docket(DocumentationType.SWAGGER_2);&#125;</code></pre><p>2、可以通过apiInfo()属性配置文档信息</p><pre><code>//配置文档信息private ApiInfo apiInfo() &#123;   Contact contact = new Contact(&quot;联系人名字&quot;, &quot;http://xxx.xxx.com/联系人访问链接&quot;, &quot;联系人邮箱&quot;);   return new ApiInfo(           &quot;Swagger学习&quot;, // 标题           &quot;学习演示如何配置Swagger&quot;, // 描述           &quot;v1.0&quot;, // 版本           &quot;http://terms.service.url/组织链接&quot;, // 组织链接           contact, // 联系人信息           &quot;Apach 2.0 许可&quot;, // 许可           &quot;许可链接&quot;, // 许可连接           new ArrayList&lt;&gt;()// 扩展  );&#125;</code></pre><p>3、Docket 实例关联上 apiInfo()</p><pre><code>@Beanpublic Docket docket() &#123;   return new Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo());&#125;</code></pre><p>4、重启项目，访问测试 <a href="http://localhost:8080/swagger-ui.html">http://localhost:8080/swagger-ui.html</a>  看下效果；</p><blockquote><h3 id="配置扫描接口"><a href="#配置扫描接口" class="headerlink" title="配置扫描接口"></a>配置扫描接口</h3></blockquote><p>1、构建Docket时通过select()方法配置怎么扫描接口。</p><pre><code>@Beanpublic Docket docket() &#123;   return new Docket(DocumentationType.SWAGGER_2)      .apiInfo(apiInfo())      .select()// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口      .apis(RequestHandlerSelectors.basePackage(&quot;com.kuang.swagger.controller&quot;))      .build();&#125;</code></pre><p>2、重启项目测试，由于我们配置根据包的路径扫描接口，所以我们只能看到一个类</p><p>3、除了通过包路径配置扫描接口外，还可以通过配置其他方式扫描接口，这里注释一下所有的配置方式：</p><pre><code>any() // 扫描所有，项目中的所有接口都会被扫描到none() // 不扫描接口// 通过方法上的注解扫描，如withMethodAnnotation(GetMapping.class)只扫描get请求withMethodAnnotation(final Class&lt;? extends Annotation&gt; annotation)// 通过类上的注解扫描，如.withClassAnnotation(Controller.class)只扫描有controller注解的类中的接口withClassAnnotation(final Class&lt;? extends Annotation&gt; annotation)basePackage(final String basePackage) // 根据包路径扫描接口</code></pre><p>4、除此之外，我们还可以配置接口扫描过滤：</p><pre><code>@Beanpublic Docket docket() &#123;   return new Docket(DocumentationType.SWAGGER_2)      .apiInfo(apiInfo())      .select()// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口      .apis(RequestHandlerSelectors.basePackage(&quot;com.kuang.swagger.controller&quot;))       // 配置如何通过path过滤,即这里只扫描请求以/kuang开头的接口      .paths(PathSelectors.ant(&quot;/kuang/**&quot;))      .build();&#125;</code></pre><p>5、这里的可选值还有</p><pre><code>any() // 任何请求都扫描none() // 任何请求都不扫描regex(final String pathRegex) // 通过正则表达式控制ant(final String antPattern) // 通过ant()控制</code></pre><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IExpkhknhzRFQicsic8yibm9Zbja0VwsQkjaNVC5GWsge3SlQeg0jmxdjBMLOoOsqqD6gc6jshv4Qdw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h3 id><a href="#" class="headerlink" title></a></h3><blockquote><h3 id="配置Swagger开关"><a href="#配置Swagger开关" class="headerlink" title="配置Swagger开关"></a>配置Swagger开关</h3></blockquote><p>1、通过enable()方法配置是否启用swagger，如果是false，swagger将不能在浏览器中访问了</p><pre><code>@Beanpublic Docket docket() &#123;   return new Docket(DocumentationType.SWAGGER_2)      .apiInfo(apiInfo())      .enable(false) //配置是否启用Swagger，如果是false，在浏览器将无法访问      .select()// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口      .apis(RequestHandlerSelectors.basePackage(&quot;com.kuang.swagger.controller&quot;))       // 配置如何通过path过滤,即这里只扫描请求以/kuang开头的接口      .paths(PathSelectors.ant(&quot;/kuang/**&quot;))      .build();&#125;</code></pre><p>2、如何动态配置当项目处于test、dev环境时显示swagger，处于prod时不显示？</p><pre><code>@Beanpublic Docket docket(Environment environment) &#123;   // 设置要显示swagger的环境   Profiles of = Profiles.of(&quot;dev&quot;, &quot;test&quot;);   // 判断当前是否处于该环境   // 通过 enable() 接收此参数判断是否要显示   boolean b = environment.acceptsProfiles(of);      return new Docket(DocumentationType.SWAGGER_2)      .apiInfo(apiInfo())      .enable(b) //配置是否启用Swagger，如果是false，在浏览器将无法访问      .select()// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口      .apis(RequestHandlerSelectors.basePackage(&quot;com.kuang.swagger.controller&quot;))       // 配置如何通过path过滤,即这里只扫描请求以/kuang开头的接口      .paths(PathSelectors.ant(&quot;/kuang/**&quot;))      .build();&#125;</code></pre><p>3、可以在项目中增加一个dev的配置文件查看效果！</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IExpkhknhzRFQicsic8yibm9Zf87yQGBYZKyqCsjP79C67S0NgdOmrQWJ7tkpPsdkrWQeQiaIZia7VD8w/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><blockquote><h3 id="配置API分组"><a href="#配置API分组" class="headerlink" title="配置API分组"></a>配置API分组</h3></blockquote><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IExpkhknhzRFQicsic8yibm9Z7k4Y8iaVnHtPd78o82ff8hItej9Cyf0wvbG8u8KgXic7gVh77NoZw4RQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>1、如果没有配置分组，默认是default。通过groupName()方法即可配置分组：</p><pre><code>@Beanpublic Docket docket(Environment environment) &#123;   return new Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo())      .groupName(&quot;hello&quot;) // 配置分组       // 省略配置....&#125;</code></pre><p>2、重启项目查看分组</p><p>3、如何配置多个分组？配置多个分组只需要配置多个docket即可：</p><pre><code>@Beanpublic Docket docket1()&#123;   return new Docket(DocumentationType.SWAGGER_2).groupName(&quot;group1&quot;);&#125;@Beanpublic Docket docket2()&#123;   return new Docket(DocumentationType.SWAGGER_2).groupName(&quot;group2&quot;);&#125;@Beanpublic Docket docket3()&#123;   return new Docket(DocumentationType.SWAGGER_2).groupName(&quot;group3&quot;);&#125;</code></pre><p>4、重启项目查看即可</p><blockquote><h3 id="实体配置"><a href="#实体配置" class="headerlink" title="实体配置"></a>实体配置</h3></blockquote><p>1、新建一个实体类</p><pre><code>@ApiModel(&quot;用户实体&quot;)public class User &#123;   @ApiModelProperty(&quot;用户名&quot;)   public String username;   @ApiModelProperty(&quot;密码&quot;)   public String password;&#125;</code></pre><p>2、只要这个实体在<strong>请求接口</strong>的返回值上（即使是泛型），都能映射到实体项中：</p><pre><code>@RequestMapping(&quot;/getUser&quot;)public User getUser()&#123;   return new User();&#125;</code></pre><p>3、重启查看测试</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IExpkhknhzRFQicsic8yibm9ZS0qBoaXrHX5r42ic5kUDzv5gaiaVqVeMBne4TDe5JLRPqRShgY3WiaQPg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>注：并不是因为@ApiModel这个注解让实体显示在这里了，而是只要出现在接口方法的返回值上的实体都会显示在这里，而@ApiModel和@ApiModelProperty这两个注解只是为实体添加注释的。</p><p>@ApiModel为类添加注释</p><p>@ApiModelProperty为类属性添加注释</p><blockquote><h3 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h3></blockquote><p>Swagger的所有注解定义在io.swagger.annotations包下</p><p>下面列一些经常用到的，未列举出来的可以另行查阅说明：</p><table><thead><tr><th>Swagger注解</th><th>简单说明</th></tr></thead><tbody><tr><td>@Api(tags &#x3D; “xxx模块说明”)</td><td>作用在模块类上</td></tr><tr><td>@ApiOperation(“xxx接口说明”)</td><td>作用在接口方法上</td></tr><tr><td>@ApiModel(“xxxPOJO说明”)</td><td>作用在模型类上：如VO、BO</td></tr><tr><td>@ApiModelProperty(value &#x3D; “xxx属性说明”,hidden &#x3D; true)</td><td>作用在类方法和属性上，hidden设置为true可以隐藏该属性</td></tr><tr><td>@ApiParam(“xxx参数说明”)</td><td>作用在参数、方法和字段上，类似@ApiModelProperty</td></tr></tbody></table><p>我们也可以给请求的接口配置一些注释</p><pre><code>@ApiOperation(&quot;狂神的接口&quot;)@PostMapping(&quot;/kuang&quot;)@ResponseBodypublic String kuang(@ApiParam(&quot;这个名字会被返回&quot;)String username)&#123;   return username;&#125;</code></pre><p>这样的话，可以给一些比较难理解的属性或者接口，增加一些配置信息，让人更容易阅读！</p><p>相较于传统的Postman或Curl方式测试接口，使用swagger简直就是傻瓜式操作，不需要额外说明文档(写得好本身就是文档)而且更不容易出错，只需要录入数据然后点击Execute，如果再配合自动化框架，可以说基本就不需要人为操作了。</p><p>Swagger是个优秀的工具，现在国内已经有很多的中小型互联网公司都在使用它，相较于传统的要先出Word接口文档再测试的方式，显然这样也更符合现在的快速迭代开发行情。当然了，提醒下大家在正式环境要记得关闭Swagger，一来出于安全考虑二来也可以节省运行时内存。</p><blockquote><h3 id="拓展：其他皮肤"><a href="#拓展：其他皮肤" class="headerlink" title="拓展：其他皮肤"></a>拓展：其他皮肤</h3></blockquote><p>我们可以导入不同的包实现不同的皮肤定义：</p><p>1、默认的  <strong>访问 <a href="http://localhost:8080/swagger-ui.html">http://localhost:8080/swagger-ui.html</a></strong></p><pre><code>&lt;dependency&gt;   &lt;groupId&gt;io.springfox&lt;/groupId&gt;   &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;   &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;</code></pre><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IExpkhknhzRFQicsic8yibm9ZrYUroibnsmILAYo1PyuaSDAkrqUvlNibxW9S9niaRomPFd9rrD6SY4wjA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>2、bootstrap-ui  <strong>访问 <a href="http://localhost:8080/doc.html">http://localhost:8080/doc.html</a></strong></p><pre><code>&lt;!-- 引入swagger-bootstrap-ui包 /doc.html--&gt;&lt;dependency&gt;   &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;   &lt;artifactId&gt;swagger-bootstrap-ui&lt;/artifactId&gt;   &lt;version&gt;1.9.1&lt;/version&gt;&lt;/dependency&gt;</code></pre><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IExpkhknhzRFQicsic8yibm9ZxQ9fXkPFt9TtX6PiaPDWWFSCJQK6H0ibiagM2w2f99zqHuOJffyRycCIg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>3、Layui-ui  <strong>访问 <a href="http://localhost:8080/docs.html">http://localhost:8080/docs.html</a></strong></p><pre><code>&lt;!-- 引入swagger-ui-layer包 /docs.html--&gt;&lt;dependency&gt;   &lt;groupId&gt;com.github.caspar-chen&lt;/groupId&gt;   &lt;artifactId&gt;swagger-ui-layer&lt;/artifactId&gt;   &lt;version&gt;1.1.3&lt;/version&gt;&lt;/dependency&gt;</code></pre><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IExpkhknhzRFQicsic8yibm9ZYA6g5VyspYIqFMokAGg7dbx47P2ibC8Z80saA7XdrByPFhgmrduSHbA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>4、mg-ui  <strong>访问 <a href="http://localhost:8080/document.html">http://localhost:8080/document.html</a></strong></p><pre><code>&lt;!-- 引入swagger-ui-layer包 /document.html--&gt;&lt;dependency&gt;   &lt;groupId&gt;com.zyplayer&lt;/groupId&gt;   &lt;artifactId&gt;swagger-mg-ui&lt;/artifactId&gt;   &lt;version&gt;1.0.6&lt;/version&gt;&lt;/dependency&gt;</code></pre><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IExpkhknhzRFQicsic8yibm9ZBJPCcHFicV2dklg3l88IuYia3OIFNfNVbWZXpppPS93jghTUJiaeJQx6Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/08/13/Redis%E5%AE%9E%E6%88%98%E7%AF%87/"/>
      <url>/2023/08/13/Redis%E5%AE%9E%E6%88%98%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="实战篇Redis"><a href="#实战篇Redis" class="headerlink" title="实战篇Redis"></a>实战篇Redis</h1><h2 id="开篇导读"><a href="#开篇导读" class="headerlink" title="开篇导读"></a>开篇导读</h2><p>亲爱的小伙伴们大家好，马上咱们就开始实战篇的内容了，相信通过本章的学习，小伙伴们就能理解各种redis的使用啦，接下来咱们来一起看看实战篇我们要学习一些什么样的内容</p><ul><li>短信登录</li></ul><p>这一块我们会使用redis共享session来实现</p><ul><li>商户查询缓存</li></ul><p>通过本章节，我们会理解缓存击穿，缓存穿透，缓存雪崩等问题，让小伙伴的对于这些概念的理解不仅仅是停留在概念上，更是能在代码中看到对应的内容</p><ul><li>优惠卷秒杀</li></ul><p>通过本章节，我们可以学会Redis的计数器功能， 结合Lua完成高性能的redis操作，同时学会Redis分布式锁的原理，包括Redis的三种消息队列</p><ul><li>附近的商户</li></ul><p>我们利用Redis的GEOHash来完成对于地理坐标的操作</p><ul><li>UV统计</li></ul><p>主要是使用Redis来完成统计功能</p><ul><li>用户签到</li></ul><p>使用Redis的BitMap数据统计功能</p><ul><li>好友关注</li></ul><p>基于Set集合的关注、取消关注，共同关注等等功能，这一块知识咱们之前就讲过，这次我们在项目中来使用一下</p><ul><li>打人探店</li></ul><p>基于List来完成点赞列表的操作，同时基于SortedSet来完成点赞的排行榜功能</p><p>以上这些内容咱们统统都会给小伙伴们讲解清楚，让大家充分理解如何使用Redis</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653056228879.png" alt="1653056228879"></p><h2 id="1、短信登录"><a href="#1、短信登录" class="headerlink" title="1、短信登录"></a>1、短信登录</h2><h3 id="1-1、导入黑马点评项目"><a href="#1-1、导入黑马点评项目" class="headerlink" title="1.1、导入黑马点评项目"></a>1.1、导入黑马点评项目</h3><h4 id="1-1-1-、导入SQL"><a href="#1-1-1-、导入SQL" class="headerlink" title="1.1.1 、导入SQL"></a>1.1.1 、导入SQL</h4><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653057872536.png" alt="1653057872536"></p><h4 id="1-1-2、有关当前模型"><a href="#1-1-2、有关当前模型" class="headerlink" title="1.1.2、有关当前模型"></a>1.1.2、有关当前模型</h4><p>手机或者app端发起请求，请求我们的nginx服务器，nginx基于七层模型走的事HTTP协议，可以实现基于Lua直接绕开tomcat访问redis，也可以作为静态资源服务器，轻松扛下上万并发， 负载均衡到下游tomcat服务器，打散流量，我们都知道一台4核8G的tomcat，在优化和处理简单业务的加持下，大不了就处理1000左右的并发， 经过nginx的负载均衡分流后，利用集群支撑起整个项目，同时nginx在部署了前端项目后，更是可以做到动静分离，进一步降低tomcat服务的压力，这些功能都得靠nginx起作用，所以nginx是整个项目中重要的一环。</p><p>在tomcat支撑起并发流量后，我们如果让tomcat直接去访问Mysql，根据经验Mysql企业级服务器只要上点并发，一般是16或32 核心cpu，32 或64G内存，像企业级mysql加上固态硬盘能够支撑的并发，大概就是4000起~7000左右，上万并发， 瞬间就会让Mysql服务器的cpu，硬盘全部打满，容易崩溃，所以我们在高并发场景下，会选择使用mysql集群，同时为了进一步降低Mysql的压力，同时增加访问的性能，我们也会加入Redis，同时使用Redis集群使得Redis对外提供更好的服务。</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653059409865.png" alt="1653059409865"></p><h4 id="1-1-3、导入后端项目"><a href="#1-1-3、导入后端项目" class="headerlink" title="1.1.3、导入后端项目"></a>1.1.3、导入后端项目</h4><p>在资料中提供了一个项目源码：</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653060237073.png" alt="1653060237073"></p><h4 id="1-1-4、导入前端工程"><a href="#1-1-4、导入前端工程" class="headerlink" title="1.1.4、导入前端工程"></a>1.1.4、导入前端工程</h4><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653060337562.png" alt="1653060337562"></p><h4 id="1-1-5-运行前端项目"><a href="#1-1-5-运行前端项目" class="headerlink" title="1.1.5 运行前端项目"></a>1.1.5 运行前端项目</h4><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653060588190.png" alt="1653060588190"></p><h3 id="1-2-、基于Session实现登录流程"><a href="#1-2-、基于Session实现登录流程" class="headerlink" title="1.2 、基于Session实现登录流程"></a>1.2 、基于Session实现登录流程</h3><p><strong>发送验证码：</strong></p><p>用户在提交手机号后，会校验手机号是否合法，如果不合法，则要求用户重新输入手机号</p><p>如果手机号合法，后台此时生成对应的验证码，同时将验证码进行保存，然后再通过短信的方式将验证码发送给用户</p><p><strong>短信验证码登录、注册：</strong></p><p>用户将验证码和手机号进行输入，后台从session中拿到当前验证码，然后和用户输入的验证码进行校验，如果不一致，则无法通过校验，如果一致，则后台根据手机号查询用户，如果用户不存在，则为用户创建账号信息，保存到数据库，无论是否存在，都会将用户信息保存到session中，方便后续获得当前登录信息</p><p><strong>校验登录状态:</strong></p><p>用户在请求时候，会从cookie中携带者JsessionId到后台，后台通过JsessionId从session中拿到用户信息，如果没有session信息，则进行拦截，如果有session信息，则将用户信息保存到threadLocal中，并且放行</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653066208144.png" alt="1653066208144"></p><h3 id="1-3-、实现发送短信验证码功能"><a href="#1-3-、实现发送短信验证码功能" class="headerlink" title="1.3 、实现发送短信验证码功能"></a>1.3 、实现发送短信验证码功能</h3><p><strong>页面流程</strong></p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653067054461.png" alt="1653067054461"></p><p><strong>具体代码如下</strong></p><p><strong>贴心小提示：</strong></p><p>具体逻辑上文已经分析，我们仅 仅只需要按照提示的逻辑写出代码即可。</p><ul><li>发送验证码</li></ul><pre><code class="java">    @Override    public Result sendCode(String phone, HttpSession session) &#123;        // 1.校验手机号        if (RegexUtils.isPhoneInvalid(phone)) &#123;            // 2.如果不符合，返回错误信息            return Result.fail(&quot;手机号格式错误！&quot;);        &#125;        // 3.符合，生成验证码        String code = RandomUtil.randomNumbers(6);        // 4.保存验证码到 session        session.setAttribute(&quot;code&quot;,code);        // 5.发送验证码        log.debug(&quot;发送短信验证码成功，验证码：&#123;&#125;&quot;, code);        // 返回ok        return Result.ok();    &#125;</code></pre><ul><li>登录</li></ul><pre><code class="java">    @Override    public Result login(LoginFormDTO loginForm, HttpSession session) &#123;        // 1.校验手机号        String phone = loginForm.getPhone();        if (RegexUtils.isPhoneInvalid(phone)) &#123;            // 2.如果不符合，返回错误信息            return Result.fail(&quot;手机号格式错误！&quot;);        &#125;        // 3.校验验证码        Object cacheCode = session.getAttribute(&quot;code&quot;);        String code = loginForm.getCode();        if(cacheCode == null || !cacheCode.toString().equals(code))&#123;             //3.不一致，报错            return Result.fail(&quot;验证码错误&quot;);        &#125;        //一致，根据手机号查询用户        User user = query().eq(&quot;phone&quot;, phone).one();        //5.判断用户是否存在        if(user == null)&#123;            //不存在，则创建            user =  createUserWithPhone(phone);        &#125;        //7.保存用户信息到session中        session.setAttribute(&quot;user&quot;,user);        return Result.ok();    &#125;</code></pre><h3 id="1-4、实现登录拦截功能"><a href="#1-4、实现登录拦截功能" class="headerlink" title="1.4、实现登录拦截功能"></a>1.4、实现登录拦截功能</h3><p><strong>温馨小贴士：tomcat的运行原理</strong></p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653068196656.png" alt="1653068196656"></p><p>当用户发起请求时，会访问我们像tomcat注册的端口，任何程序想要运行，都需要有一个线程对当前端口号进行监听，tomcat也不例外，当监听线程知道用户想要和tomcat连接连接时，那会由监听线程创建socket连接，socket都是成对出现的，用户通过socket像互相传递数据，当tomcat端的socket接受到数据后，此时监听线程会从tomcat的线程池中取出一个线程执行用户请求，在我们的服务部署到tomcat后，线程会找到用户想要访问的工程，然后用这个线程转发到工程中的controller，service，dao中，并且访问对应的DB，在用户执行完请求后，再统一返回，再找到tomcat端的socket，再将数据写回到用户端的socket，完成请求和响应</p><p>通过以上讲解，我们可以得知 每个用户其实对应都是去找tomcat线程池中的一个线程来完成工作的， 使用完成后再进行回收，既然每个请求都是独立的，所以在每个用户去访问我们的工程时，我们可以使用threadlocal来做到线程隔离，每个线程操作自己的一份数据</p><p><strong>温馨小贴士：关于threadlocal</strong></p><p>如果小伙伴们看过threadLocal的源码，你会发现在threadLocal中，无论是他的put方法和他的get方法， 都是先从获得当前用户的线程，然后从线程中取出线程的成员变量map，只要线程不一样，map就不一样，所以可以通过这种方式来做到线程隔离</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653068874258.png" alt="1653068874258"></p><p>拦截器代码</p><pre><code class="Java">public class LoginInterceptor implements HandlerInterceptor &#123;    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;       //1.获取session        HttpSession session = request.getSession();        //2.获取session中的用户        Object user = session.getAttribute(&quot;user&quot;);        //3.判断用户是否存在        if(user == null)&#123;              //4.不存在，拦截，返回401状态码              response.setStatus(401);              return false;        &#125;        //5.存在，保存用户信息到Threadlocal        UserHolder.saveUser((User)user);        //6.放行        return true;    &#125;&#125;</code></pre><p>让拦截器生效</p><pre><code class="java">@Configurationpublic class MvcConfig implements WebMvcConfigurer &#123;    @Resource    private StringRedisTemplate stringRedisTemplate;    @Override    public void addInterceptors(InterceptorRegistry registry) &#123;        // 登录拦截器        registry.addInterceptor(new LoginInterceptor())                .excludePathPatterns(                        &quot;/shop/**&quot;,                        &quot;/voucher/**&quot;,                        &quot;/shop-type/**&quot;,                        &quot;/upload/**&quot;,                        &quot;/blog/hot&quot;,                        &quot;/user/code&quot;,                        &quot;/user/login&quot;                ).order(1);        // token刷新的拦截器        registry.addInterceptor(new RefreshTokenInterceptor(stringRedisTemplate)).addPathPatterns(&quot;/**&quot;).order(0);    &#125;&#125;</code></pre><h3 id="1-5、隐藏用户敏感信息"><a href="#1-5、隐藏用户敏感信息" class="headerlink" title="1.5、隐藏用户敏感信息"></a>1.5、隐藏用户敏感信息</h3><p>我们通过浏览器观察到此时用户的全部信息都在，这样极为不靠谱，所以我们应当在返回用户信息之前，将用户的敏感信息进行隐藏，采用的核心思路就是书写一个UserDto对象，这个UserDto对象就没有敏感信息了，我们在返回前，将有用户敏感信息的User对象转化成没有敏感信息的UserDto对象，那么就能够避免这个尴尬的问题了</p><p><strong>在登录方法处修改</strong></p><pre><code class="java">//7.保存用户信息到session中session.setAttribute(&quot;user&quot;, BeanUtils.copyProperties(user,UserDTO.class));</code></pre><p><strong>在拦截器处：</strong></p><pre><code class="java">//5.存在，保存用户信息到ThreadlocalUserHolder.saveUser((UserDTO) user);</code></pre><p><strong>在UserHolder处：将user对象换成UserDTO</strong></p><pre><code class="java">public class UserHolder &#123;    private static final ThreadLocal&lt;UserDTO&gt; tl = new ThreadLocal&lt;&gt;();    public static void saveUser(UserDTO user)&#123;        tl.set(user);    &#125;    public static UserDTO getUser()&#123;        return tl.get();    &#125;    public static void removeUser()&#123;        tl.remove();    &#125;&#125;</code></pre><h3 id="1-6、session共享问题"><a href="#1-6、session共享问题" class="headerlink" title="1.6、session共享问题"></a>1.6、session共享问题</h3><p><strong>核心思路分析：</strong></p><p>每个tomcat中都有一份属于自己的session,假设用户第一次访问第一台tomcat，并且把自己的信息存放到第一台服务器的session中，但是第二次这个用户访问到了第二台tomcat，那么在第二台服务器上，肯定没有第一台服务器存放的session，所以此时 整个登录拦截功能就会出现问题，我们能如何解决这个问题呢？早期的方案是session拷贝，就是说虽然每个tomcat上都有不同的session，但是每当任意一台服务器的session修改时，都会同步给其他的Tomcat服务器的session，这样的话，就可以实现session的共享了</p><p>但是这种方案具有两个大问题</p><p>1、每台服务器中都有完整的一份session数据，服务器压力过大。</p><p>2、session拷贝数据时，可能会出现延迟</p><p>所以咱们后来采用的方案都是基于redis来完成，我们把session换成redis，redis数据本身就是共享的，就可以避免session共享的问题了</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653069893050.png" alt="1653069893050"></p><h3 id="1-7-Redis代替session的业务流程"><a href="#1-7-Redis代替session的业务流程" class="headerlink" title="1.7 Redis代替session的业务流程"></a>1.7 Redis代替session的业务流程</h3><h4 id="1-7-1、设计key的结构"><a href="#1-7-1、设计key的结构" class="headerlink" title="1.7.1、设计key的结构"></a>1.7.1、设计key的结构</h4><p>首先我们要思考一下利用redis来存储数据，那么到底使用哪种结构呢？由于存入的数据比较简单，我们可以考虑使用String，或者是使用哈希，如下图，如果使用String，同学们注意他的value，用多占用一点空间，如果使用哈希，则他的value中只会存储他数据本身，如果不是特别在意内存，其实使用String就可以啦。</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653319261433.png" alt="1653319261433"></p><h4 id="1-7-2、设计key的具体细节"><a href="#1-7-2、设计key的具体细节" class="headerlink" title="1.7.2、设计key的具体细节"></a>1.7.2、设计key的具体细节</h4><p>所以我们可以使用String结构，就是一个简单的key，value键值对的方式，但是关于key的处理，session他是每个用户都有自己的session，但是redis的key是共享的，咱们就不能使用code了</p><p>在设计这个key的时候，我们之前讲过需要满足两点</p><p>1、key要具有唯一性</p><p>2、key要方便携带</p><p>如果我们采用phone：手机号这个的数据来存储当然是可以的，但是如果把这样的敏感数据存储到redis中并且从页面中带过来毕竟不太合适，所以我们在后台生成一个随机串token，然后让前端带来这个token就能完成我们的整体逻辑了</p><h4 id="1-7-3、整体访问流程"><a href="#1-7-3、整体访问流程" class="headerlink" title="1.7.3、整体访问流程"></a>1.7.3、整体访问流程</h4><p>当注册完成后，用户去登录会去校验用户提交的手机号和验证码，是否一致，如果一致，则根据手机号查询用户信息，不存在则新建，最后将用户数据保存到redis，并且生成token作为redis的key，当我们校验用户是否登录时，会去携带着token进行访问，从redis中取出token对应的value，判断是否存在这个数据，如果没有则拦截，如果存在则将其保存到threadLocal中，并且放行。</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653319474181.png" alt="1653319474181"></p><h3 id="1-8-基于Redis实现短信登录"><a href="#1-8-基于Redis实现短信登录" class="headerlink" title="1.8 基于Redis实现短信登录"></a>1.8 基于Redis实现短信登录</h3><p>这里具体逻辑就不分析了，之前咱们已经重点分析过这个逻辑啦。</p><p><strong>UserServiceImpl代码</strong></p><pre><code class="java">@Overridepublic Result login(LoginFormDTO loginForm, HttpSession session) &#123;    // 1.校验手机号    String phone = loginForm.getPhone();    if (RegexUtils.isPhoneInvalid(phone)) &#123;        // 2.如果不符合，返回错误信息        return Result.fail(&quot;手机号格式错误！&quot;);    &#125;    // 3.从redis获取验证码并校验    String cacheCode = stringRedisTemplate.opsForValue().get(LOGIN_CODE_KEY + phone);    String code = loginForm.getCode();    if (cacheCode == null || !cacheCode.equals(code)) &#123;        // 不一致，报错        return Result.fail(&quot;验证码错误&quot;);    &#125;    // 4.一致，根据手机号查询用户 select * from tb_user where phone = ?    User user = query().eq(&quot;phone&quot;, phone).one();    // 5.判断用户是否存在    if (user == null) &#123;        // 6.不存在，创建新用户并保存        user = createUserWithPhone(phone);    &#125;    // 7.保存用户信息到 redis中    // 7.1.随机生成token，作为登录令牌    String token = UUID.randomUUID().toString(true);    // 7.2.将User对象转为HashMap存储    UserDTO userDTO = BeanUtil.copyProperties(user, UserDTO.class);    Map&lt;String, Object&gt; userMap = BeanUtil.beanToMap(userDTO, new HashMap&lt;&gt;(),            CopyOptions.create()                    .setIgnoreNullValue(true)                    .setFieldValueEditor((fieldName, fieldValue) -&gt; fieldValue.toString()));    // 7.3.存储    String tokenKey = LOGIN_USER_KEY + token;    stringRedisTemplate.opsForHash().putAll(tokenKey, userMap);    // 7.4.设置token有效期    stringRedisTemplate.expire(tokenKey, LOGIN_USER_TTL, TimeUnit.MINUTES);    // 8.返回token    return Result.ok(token);&#125;</code></pre><h3 id="1-9-解决状态登录刷新问题"><a href="#1-9-解决状态登录刷新问题" class="headerlink" title="1.9 解决状态登录刷新问题"></a>1.9 解决状态登录刷新问题</h3><h4 id="1-9-1-初始方案思路总结："><a href="#1-9-1-初始方案思路总结：" class="headerlink" title="1.9.1 初始方案思路总结："></a>1.9.1 初始方案思路总结：</h4><p>在这个方案中，他确实可以使用对应路径的拦截，同时刷新登录token令牌的存活时间，但是现在这个拦截器他只是拦截需要被拦截的路径，假设当前用户访问了一些不需要拦截的路径，那么这个拦截器就不会生效，所以此时令牌刷新的动作实际上就不会执行，所以这个方案他是存在问题的</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653320822964.png" alt="1653320822964"></p><h4 id="1-9-2-优化方案"><a href="#1-9-2-优化方案" class="headerlink" title="1.9.2 优化方案"></a>1.9.2 优化方案</h4><p>既然之前的拦截器无法对不需要拦截的路径生效，那么我们可以添加一个拦截器，在第一个拦截器中拦截所有的路径，把第二个拦截器做的事情放入到第一个拦截器中，同时刷新令牌，因为第一个拦截器有了threadLocal的数据，所以此时第二个拦截器只需要判断拦截器中的user对象是否存在即可，完成整体刷新功能。</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653320764547.png" alt="1653320764547"></p><h4 id="1-9-3-代码"><a href="#1-9-3-代码" class="headerlink" title="1.9.3 代码"></a>1.9.3 代码</h4><p><strong>RefreshTokenInterceptor</strong></p><pre><code class="java">public class RefreshTokenInterceptor implements HandlerInterceptor &#123;    private StringRedisTemplate stringRedisTemplate;    public RefreshTokenInterceptor(StringRedisTemplate stringRedisTemplate) &#123;        this.stringRedisTemplate = stringRedisTemplate;    &#125;    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;        // 1.获取请求头中的token        String token = request.getHeader(&quot;authorization&quot;);        if (StrUtil.isBlank(token)) &#123;            return true;        &#125;        // 2.基于TOKEN获取redis中的用户        String key  = LOGIN_USER_KEY + token;        Map&lt;Object, Object&gt; userMap = stringRedisTemplate.opsForHash().entries(key);        // 3.判断用户是否存在        if (userMap.isEmpty()) &#123;            return true;        &#125;        // 5.将查询到的hash数据转为UserDTO        UserDTO userDTO = BeanUtil.fillBeanWithMap(userMap, new UserDTO(), false);        // 6.存在，保存用户信息到 ThreadLocal        UserHolder.saveUser(userDTO);        // 7.刷新token有效期        stringRedisTemplate.expire(key, LOGIN_USER_TTL, TimeUnit.MINUTES);        // 8.放行        return true;    &#125;    @Override    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;        // 移除用户        UserHolder.removeUser();    &#125;&#125;    </code></pre><p><strong>LoginInterceptor</strong></p><pre><code class="java">public class LoginInterceptor implements HandlerInterceptor &#123;    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;        // 1.判断是否需要拦截（ThreadLocal中是否有用户）        if (UserHolder.getUser() == null) &#123;            // 没有，需要拦截，设置状态码            response.setStatus(401);            // 拦截            return false;        &#125;        // 有用户，则放行        return true;    &#125;&#125;</code></pre><h2 id="2、商户查询缓存"><a href="#2、商户查询缓存" class="headerlink" title="2、商户查询缓存"></a>2、商户查询缓存</h2><h3 id="2-1-什么是缓存"><a href="#2-1-什么是缓存" class="headerlink" title="2.1 什么是缓存?"></a>2.1 什么是缓存?</h3><p><strong>前言</strong>:<strong>什么是缓存?</strong></p><p>就像自行车,越野车的避震器<img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C%E9%81%BF%E9%9C%87%E5%99%A8.gif"></p><p>举个例子:越野车,山地自行车,都拥有”避震器”,<strong>防止</strong>车体加速后因惯性,在酷似”U”字母的地形上飞跃,硬着陆导致的<strong>损害</strong>,像个弹簧一样;</p><p>同样,实际开发中,系统也需要”避震器”,防止过高的数据访问猛冲系统,导致其操作线程无法及时处理信息而瘫痪;</p><p>这在实际开发中对企业讲,对产品口碑,用户评价都是致命的;所以企业非常重视缓存技术;</p><p><strong>缓存(<strong>Cache),就是数据交换的</strong>缓冲区</strong>,俗称的缓存就是<strong>缓冲区内的数据</strong>,一般从数据库中获取,存储于本地代码(例如:</p><pre><code class="java">例1:Static final ConcurrentHashMap&lt;K,V&gt; map = new ConcurrentHashMap&lt;&gt;(); 本地用于高并发例2:static final Cache&lt;K,V&gt; USER_CACHE = CacheBuilder.newBuilder().build(); 用于redis等缓存例3:Static final Map&lt;K,V&gt; map =  new HashMap(); 本地缓存</code></pre><p>由于其被<strong>Static</strong>修饰,所以随着类的加载而被加载到<strong>内存之中</strong>,作为本地缓存,由于其又被<strong>final</strong>修饰,所以其引用(例3:map)和对象(例3:new HashMap())之间的关系是固定的,不能改变,因此不用担心赋值(&#x3D;)导致缓存失效;</p><h4 id="2-1-1-为什么要使用缓存"><a href="#2-1-1-为什么要使用缓存" class="headerlink" title="2.1.1 为什么要使用缓存"></a>2.1.1 为什么要使用缓存</h4><p>一句话:因为<strong>速度快,好用</strong></p><p>缓存数据存储于代码中,而代码运行在内存中,内存的读写性能远高于磁盘,缓存可以大大降低<strong>用户访问并发量带来的</strong>服务器读写压力</p><p>实际开发过程中,企业的数据量,少则几十万,多则几千万,这么大数据量,如果没有缓存来作为”避震器”,系统是几乎撑不住的,所以企业会大量运用到缓存技术;</p><p>但是缓存也会增加代码复杂度和运营的成本:</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5Cimage-20220523214414123.png"></p><h4 id="2-1-2-如何使用缓存"><a href="#2-1-2-如何使用缓存" class="headerlink" title="2.1.2 如何使用缓存"></a>2.1.2 如何使用缓存</h4><p>实际开发中,会构筑多级缓存来使系统运行速度进一步提升,例如:本地缓存与redis中的缓存并发使用</p><p><strong>浏览器缓存</strong>：主要是存在于浏览器端的缓存</p><p><strong>应用层缓存：</strong>可以分为tomcat本地缓存，比如之前提到的map，或者是使用redis作为缓存</p><p><strong>数据库缓存：</strong>在数据库中有一片空间是 buffer pool，增改查数据都会先加载到mysql的缓存中</p><p><strong>CPU缓存：</strong>当代计算机最大的问题是 cpu性能提升了，但内存读写速度没有跟上，所以为了适应当下的情况，增加了cpu的L1，L2，L3级的缓存</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5Cimage-20220523212915666.png"></p><h3 id="2-2-添加商户缓存"><a href="#2-2-添加商户缓存" class="headerlink" title="2.2 添加商户缓存"></a>2.2 添加商户缓存</h3><p>在我们查询商户信息时，我们是直接操作从数据库中去进行查询的，大致逻辑是这样，直接查询数据库那肯定慢咯，所以我们需要增加缓存</p><pre><code>@GetMapping(&quot;/&#123;id&#125;&quot;)public Result queryShopById(@PathVariable(&quot;id&quot;) Long id) &#123;    //这里是直接查询数据库    return shopService.queryById(id);&#125;</code></pre><h4 id="2-2-1-、缓存模型和思路"><a href="#2-2-1-、缓存模型和思路" class="headerlink" title="2.2.1 、缓存模型和思路"></a>2.2.1 、缓存模型和思路</h4><p>标准的操作方式就是查询数据库之前先查询缓存，如果缓存数据存在，则直接从缓存中返回，如果缓存数据不存在，再查询数据库，然后将数据存入redis。</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653322097736.png" alt="1653322097736"></p><h4 id="2-1-2、代码如下"><a href="#2-1-2、代码如下" class="headerlink" title="2.1.2、代码如下"></a>2.1.2、代码如下</h4><p>代码思路：如果缓存有，则直接返回，如果缓存不存在，则查询数据库，然后存入redis。</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653322190155.png" alt="1653322190155"></p><h3 id="2-3-缓存更新策略"><a href="#2-3-缓存更新策略" class="headerlink" title="2.3 缓存更新策略"></a>2.3 缓存更新策略</h3><p>缓存更新是redis为了节约内存而设计出来的一个东西，主要是因为内存数据宝贵，当我们向redis插入太多数据，此时就可能会导致缓存中的数据过多，所以redis会对部分数据进行更新，或者把他叫为淘汰更合适。</p><p><strong>内存淘汰：</strong>redis自动进行，当redis内存达到咱们设定的max-memery的时候，会自动触发淘汰机制，淘汰掉一些不重要的数据(可以自己设置策略方式)</p><p><strong>超时剔除：</strong>当我们给redis设置了过期时间ttl之后，redis会将超时的数据进行删除，方便咱们继续使用缓存</p><p><strong>主动更新：</strong>我们可以手动调用方法把缓存删掉，通常用于解决缓存和数据库不一致问题</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653322506393.png" alt="1653322506393"></p><h4 id="2-3-1-、数据库缓存不一致解决方案："><a href="#2-3-1-、数据库缓存不一致解决方案：" class="headerlink" title="2.3.1 、数据库缓存不一致解决方案："></a>2.3.1 、数据库缓存不一致解决方案：</h4><p>由于我们的<strong>缓存的数据源来自于数据库</strong>,而数据库的<strong>数据是会发生变化的</strong>,因此,如果当数据库中<strong>数据发生变化,而缓存却没有同步</strong>,此时就会有<strong>一致性问题存在</strong>,其后果是:</p><p>用户使用缓存中的过时数据,就会产生类似多线程数据安全问题,从而影响业务,产品口碑等;怎么解决呢？有如下几种方案</p><p>Cache Aside Pattern 人工编码方式：缓存调用者在更新完数据库后再去更新缓存，也称之为双写方案</p><p>Read&#x2F;Write Through Pattern : 由系统本身完成，数据库与缓存的问题交由系统本身去处理</p><p>Write Behind Caching Pattern ：调用者只操作缓存，其他线程去异步处理数据库，实现最终一致</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653322857620.png" alt="1653322857620"></p><h4 id="2-3-2-、数据库和缓存不一致采用什么方案"><a href="#2-3-2-、数据库和缓存不一致采用什么方案" class="headerlink" title="2.3.2 、数据库和缓存不一致采用什么方案"></a>2.3.2 、数据库和缓存不一致采用什么方案</h4><p>综合考虑使用方案一，但是方案一调用者如何处理呢？这里有几个问题</p><p>操作缓存和数据库时有三个问题需要考虑：</p><p>如果采用第一个方案，那么假设我们每次操作数据库后，都操作缓存，但是中间如果没有人查询，那么这个更新动作实际上只有最后一次生效，中间的更新动作意义并不大，我们可以把缓存删除，等待再次查询时，将缓存中的数据加载出来</p><ul><li><p>删除缓存还是更新缓存？</p><ul><li>更新缓存：每次更新数据库都更新缓存，无效写操作较多</li><li>删除缓存：更新数据库时让缓存失效，查询时再更新缓存</li></ul></li><li><p>如何保证缓存与数据库的操作的同时成功或失败？</p><ul><li>单体系统，将缓存与数据库操作放在一个事务</li><li>分布式系统，利用TCC等分布式事务方案</li></ul></li></ul><p>应该具体操作缓存还是操作数据库，我们应当是先操作数据库，再删除缓存，原因在于，如果你选择第一种方案，在两个线程并发来访问时，假设线程1先来，他先把缓存删了，此时线程2过来，他查询缓存数据并不存在，此时他写入缓存，当他写入缓存后，线程1再执行更新动作时，实际上写入的就是旧的数据，新的数据被旧数据覆盖了。</p><ul><li>先操作缓存还是先操作数据库？<ul><li>先删除缓存，再操作数据库</li><li>先操作数据库，再删除缓存</li></ul></li></ul><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653323595206.png" alt="1653323595206"></p><h3 id="2-4-实现商铺和缓存与数据库双写一致"><a href="#2-4-实现商铺和缓存与数据库双写一致" class="headerlink" title="2.4 实现商铺和缓存与数据库双写一致"></a>2.4 实现商铺和缓存与数据库双写一致</h3><p>核心思路如下：</p><p>修改ShopController中的业务逻辑，满足下面的需求：</p><p>根据id查询店铺时，如果缓存未命中，则查询数据库，将数据库结果写入缓存，并设置超时时间</p><p>根据id修改店铺时，先修改数据库，再删除缓存</p><p><strong>修改重点代码1</strong>：修改<strong>ShopServiceImpl</strong>的queryById方法</p><p><strong>设置redis缓存时添加过期时间</strong></p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653325871232.png" alt="1653325871232"></p><p><strong>修改重点代码2</strong></p><p>代码分析：通过之前的淘汰，我们确定了采用删除策略，来解决双写问题，当我们修改了数据之后，然后把缓存中的数据进行删除，查询时发现缓存中没有数据，则会从mysql中加载最新的数据，从而避免数据库和缓存不一致的问题</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653325929549.png" alt="1653325929549"></p><h3 id="2-5-缓存穿透问题的解决思路"><a href="#2-5-缓存穿透问题的解决思路" class="headerlink" title="2.5 缓存穿透问题的解决思路"></a>2.5 缓存穿透问题的解决思路</h3><p>缓存穿透 ：缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。</p><p>常见的解决方案有两种：</p><ul><li>缓存空对象<ul><li>优点：实现简单，维护方便</li><li>缺点：<ul><li>额外的内存消耗</li><li>可能造成短期的不一致</li></ul></li></ul></li><li>布隆过滤<ul><li>优点：内存占用较少，没有多余key</li><li>缺点：<ul><li>实现复杂</li><li>存在误判可能</li></ul></li></ul></li></ul><p><strong>缓存空对象思路分析：</strong>当我们客户端访问不存在的数据时，先请求redis，但是此时redis中没有数据，此时会访问到数据库，但是数据库中也没有数据，这个数据穿透了缓存，直击数据库，我们都知道数据库能够承载的并发不如redis这么高，如果大量的请求同时过来访问这种不存在的数据，这些请求就都会访问到数据库，简单的解决方案就是哪怕这个数据在数据库中也不存在，我们也把这个数据存入到redis中去，这样，下次用户过来访问这个不存在的数据，那么在redis中也能找到这个数据就不会进入到缓存了</p><p><strong>布隆过滤：</strong>布隆过滤器其实采用的是哈希思想来解决这个问题，通过一个庞大的二进制数组，走哈希思想去判断当前这个要查询的这个数据是否存在，如果布隆过滤器判断存在，则放行，这个请求会去访问redis，哪怕此时redis中的数据过期了，但是数据库中一定存在这个数据，在数据库中查询出来这个数据后，再将其放入到redis中，</p><p>假设布隆过滤器判断这个数据不存在，则直接返回</p><p>这种方式优点在于节约内存空间，存在误判，误判原因在于：布隆过滤器走的是哈希思想，只要哈希思想，就可能存在哈希冲突</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653326156516.png" alt="1653326156516"></p><h3 id="2-6-编码解决商品查询的缓存穿透问题："><a href="#2-6-编码解决商品查询的缓存穿透问题：" class="headerlink" title="2.6 编码解决商品查询的缓存穿透问题："></a>2.6 编码解决商品查询的缓存穿透问题：</h3><p>核心思路如下：</p><p>在原来的逻辑中，我们如果发现这个数据在mysql中不存在，直接就返回404了，这样是会存在缓存穿透问题的</p><p>现在的逻辑中：如果这个数据不存在，我们不会返回404 ，还是会把这个数据写入到Redis中，并且将value设置为空，欧当再次发起查询时，我们如果发现命中之后，判断这个value是否是null，如果是null，则是之前写入的数据，证明是缓存穿透数据，如果不是，则直接返回数据。</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653327124561.png" alt="1653327124561"></p><p><strong>小总结：</strong></p><p>缓存穿透产生的原因是什么？</p><ul><li>用户请求的数据在缓存中和数据库中都不存在，不断发起这样的请求，给数据库带来巨大压力</li></ul><p>缓存穿透的解决方案有哪些？</p><ul><li>缓存null值</li><li>布隆过滤</li><li>增强id的复杂度，避免被猜测id规律</li><li>做好数据的基础格式校验</li><li>加强用户权限校验</li><li>做好热点参数的限流</li></ul><h3 id="2-7-缓存雪崩问题及解决思路"><a href="#2-7-缓存雪崩问题及解决思路" class="headerlink" title="2.7 缓存雪崩问题及解决思路"></a>2.7 缓存雪崩问题及解决思路</h3><p>缓存雪崩是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。</p><p>解决方案：</p><ul><li>给不同的Key的TTL添加随机值</li><li>利用Redis集群提高服务的可用性</li><li>给缓存业务添加降级限流策略</li><li>给业务添加多级缓存</li></ul><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653327884526.png" alt="1653327884526"></p><h3 id="2-8-缓存击穿问题及解决思路"><a href="#2-8-缓存击穿问题及解决思路" class="headerlink" title="2.8 缓存击穿问题及解决思路"></a>2.8 缓存击穿问题及解决思路</h3><p>缓存击穿问题也叫热点Key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。</p><p>常见的解决方案有两种：</p><ul><li>互斥锁</li><li>逻辑过期</li></ul><p>逻辑分析：假设线程1在查询缓存之后，本来应该去查询数据库，然后把这个数据重新加载到缓存的，此时只要线程1走完这个逻辑，其他线程就都能从缓存中加载这些数据了，但是假设在线程1没有走完的时候，后续的线程2，线程3，线程4同时过来访问当前这个方法， 那么这些线程都不能从缓存中查询到数据，那么他们就会同一时刻来访问查询缓存，都没查到，接着同一时间去访问数据库，同时的去执行数据库代码，对数据库访问压力过大</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653328022622.png" alt="1653328022622"></p><p>解决方案一、使用锁来解决：</p><p>因为锁能实现互斥性。假设线程过来，只能一个人一个人的来访问数据库，从而避免对于数据库访问压力过大，但这也会影响查询的性能，因为此时会让查询的性能从并行变成了串行，我们可以采用tryLock方法 + double check来解决这样的问题。</p><p>假设现在线程1过来访问，他查询缓存没有命中，但是此时他获得到了锁的资源，那么线程1就会一个人去执行逻辑，假设现在线程2过来，线程2在执行过程中，并没有获得到锁，那么线程2就可以进行到休眠，直到线程1把锁释放后，线程2获得到锁，然后再来执行逻辑，此时就能够从缓存中拿到数据了。</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653328288627.png" alt="1653328288627"></p><p>解决方案二、逻辑过期方案</p><p>方案分析：我们之所以会出现这个缓存击穿问题，主要原因是在于我们对key设置了过期时间，假设我们不设置过期时间，其实就不会有缓存击穿的问题，但是不设置过期时间，这样数据不就一直占用我们内存了吗，我们可以采用逻辑过期方案。</p><p>我们把过期时间设置在 redis的value中，注意：这个过期时间并不会直接作用于redis，而是我们后续通过逻辑去处理。假设线程1去查询缓存，然后从value中判断出来当前的数据已经过期了，此时线程1去获得互斥锁，那么其他线程会进行阻塞，获得了锁的线程他会开启一个 线程去进行 以前的重构数据的逻辑，直到新开的线程完成这个逻辑后，才释放锁， 而线程1直接进行返回，假设现在线程3过来访问，由于线程线程2持有着锁，所以线程3无法获得锁，线程3也直接返回数据，只有等到新开的线程2把重建数据构建完后，其他线程才能走返回正确的数据。</p><p>这种方案巧妙在于，异步的构建缓存，缺点在于在构建完缓存之前，返回的都是脏数据。</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653328663897.png" alt="1653328663897"></p><p>进行对比</p><p><strong>互斥锁方案：</strong>由于保证了互斥性，所以数据一致，且实现简单，因为仅仅只需要加一把锁而已，也没其他的事情需要操心，所以没有额外的内存消耗，缺点在于有锁就有死锁问题的发生，且只能串行执行性能肯定受到影响</p><p><strong>逻辑过期方案：</strong> 线程读取过程中不需要等待，性能好，有一个额外的线程持有锁去进行重构数据，但是在重构数据完成前，其他的线程只能返回之前的数据，且实现起来麻烦</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653357522914.png" alt="1653357522914"></p><h3 id="2-9-利用互斥锁解决缓存击穿问题"><a href="#2-9-利用互斥锁解决缓存击穿问题" class="headerlink" title="2.9 利用互斥锁解决缓存击穿问题"></a>2.9 利用互斥锁解决缓存击穿问题</h3><p>核心思路：相较于原来从缓存中查询不到数据后直接查询数据库而言，现在的方案是 进行查询之后，如果从缓存没有查询到数据，则进行互斥锁的获取，获取互斥锁后，判断是否获得到了锁，如果没有获得到，则休眠，过一会再进行尝试，直到获取到锁为止，才能进行查询</p><p>如果获取到了锁的线程，再去进行查询，查询后将数据写入redis，再释放锁，返回数据，利用互斥锁就能保证只有一个线程去执行操作数据库的逻辑，防止缓存击穿</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653357860001.png" alt="1653357860001"></p><p><strong>操作锁的代码：</strong></p><p>核心思路就是利用redis的setnx方法来表示获取锁，该方法含义是redis中如果没有这个key，则插入成功，返回1，在stringRedisTemplate中返回true，  如果有这个key则插入失败，则返回0，在stringRedisTemplate返回false，我们可以通过true，或者是false，来表示是否有线程成功插入key，成功插入的key的线程我们认为他就是获得到锁的线程。</p><pre><code class="java">private boolean tryLock(String key) &#123;    Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key, &quot;1&quot;, 10, TimeUnit.SECONDS);    return BooleanUtil.isTrue(flag);&#125;private void unlock(String key) &#123;    stringRedisTemplate.delete(key);&#125;</code></pre><p><strong>操作代码：</strong></p><pre><code class="java"> public Shop queryWithMutex(Long id)  &#123;        String key = CACHE_SHOP_KEY + id;        // 1、从redis中查询商铺缓存        String shopJson = stringRedisTemplate.opsForValue().get(&quot;key&quot;);        // 2、判断是否存在        if (StrUtil.isNotBlank(shopJson)) &#123;            // 存在,直接返回            return JSONUtil.toBean(shopJson, Shop.class);        &#125;        //判断命中的值是否是空值        if (shopJson != null) &#123;            //返回一个错误信息            return null;        &#125;        // 4.实现缓存重构        //4.1 获取互斥锁        String lockKey = &quot;lock:shop:&quot; + id;        Shop shop = null;        try &#123;            boolean isLock = tryLock(lockKey);            // 4.2 判断否获取成功            if(!isLock)&#123;                //4.3 失败，则休眠重试                Thread.sleep(50);                return queryWithMutex(id);            &#125;            //4.4 成功，根据id查询数据库             shop = getById(id);            // 5.不存在，返回错误            if(shop == null)&#123;                 //将空值写入redis                stringRedisTemplate.opsForValue().set(key,&quot;&quot;,CACHE_NULL_TTL,TimeUnit.MINUTES);                //返回错误信息                return null;            &#125;            //6.写入redis            stringRedisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(shop),CACHE_NULL_TTL,TimeUnit.MINUTES);        &#125;catch (Exception e)&#123;            throw new RuntimeException(e);        &#125;        finally &#123;            //7.释放互斥锁            unlock(lockKey);        &#125;        return shop;    &#125;</code></pre><h3 id="3-0-、利用逻辑过期解决缓存击穿问题"><a href="#3-0-、利用逻辑过期解决缓存击穿问题" class="headerlink" title="3.0 、利用逻辑过期解决缓存击穿问题"></a>3.0 、利用逻辑过期解决缓存击穿问题</h3><p><strong>需求：修改根据id查询商铺的业务，基于逻辑过期方式来解决缓存击穿问题</strong></p><p>思路分析：当用户开始查询redis时，判断是否命中，如果没有命中则直接返回空数据，不查询数据库，而一旦命中后，将value取出，判断value中的过期时间是否满足，如果没有过期，则直接返回redis中的数据，如果过期，则在开启独立线程后直接返回之前的数据，独立线程去重构数据，重构完成后释放互斥锁。</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653360308731.png" alt="1653360308731"></p><p>如果封装数据：因为现在redis中存储的数据的value需要带上过期时间，此时要么你去修改原来的实体类，要么你</p><p><strong>步骤一、</strong></p><p>新建一个实体类，我们采用第二个方案，这个方案，对原来代码没有侵入性。</p><pre><code>@Datapublic class RedisData &#123;    private LocalDateTime expireTime;    private Object data;&#125;</code></pre><p><strong>步骤二、</strong></p><p>在<strong>ShopServiceImpl</strong> 新增此方法，利用单元测试进行缓存预热</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653360807133.png" alt="1653360807133"></p><p><strong>在测试类中</strong></p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653360864839.png" alt="1653360864839"></p><p>步骤三：正式代码</p><p><strong>ShopServiceImpl</strong></p><pre><code class="java">private static final ExecutorService CACHE_REBUILD_EXECUTOR = Executors.newFixedThreadPool(10);public Shop queryWithLogicalExpire( Long id ) &#123;    String key = CACHE_SHOP_KEY + id;    // 1.从redis查询商铺缓存    String json = stringRedisTemplate.opsForValue().get(key);    // 2.判断是否存在    if (StrUtil.isBlank(json)) &#123;        // 3.存在，直接返回        return null;    &#125;    // 4.命中，需要先把json反序列化为对象    RedisData redisData = JSONUtil.toBean(json, RedisData.class);    Shop shop = JSONUtil.toBean((JSONObject) redisData.getData(), Shop.class);    LocalDateTime expireTime = redisData.getExpireTime();    // 5.判断是否过期    if(expireTime.isAfter(LocalDateTime.now())) &#123;        // 5.1.未过期，直接返回店铺信息        return shop;    &#125;    // 5.2.已过期，需要缓存重建    // 6.缓存重建    // 6.1.获取互斥锁    String lockKey = LOCK_SHOP_KEY + id;    boolean isLock = tryLock(lockKey);    // 6.2.判断是否获取锁成功    if (isLock)&#123;        CACHE_REBUILD_EXECUTOR.submit( ()-&gt;&#123;            try&#123;                //重建缓存                this.saveShop2Redis(id,20L);            &#125;catch (Exception e)&#123;                throw new RuntimeException(e);            &#125;finally &#123;                unlock(lockKey);            &#125;        &#125;);    &#125;    // 6.4.返回过期的商铺信息    return shop;&#125;</code></pre><h3 id="3-1、封装Redis工具类"><a href="#3-1、封装Redis工具类" class="headerlink" title="3.1、封装Redis工具类"></a>3.1、封装Redis工具类</h3><p>基于StringRedisTemplate封装一个缓存工具类，满足下列需求：</p><ul><li>方法1：将任意Java对象序列化为json并存储在string类型的key中，并且可以设置TTL过期时间</li><li>方法2：将任意Java对象序列化为json并存储在string类型的key中，并且可以设置逻辑过期时间，用于处理缓</li></ul><p>存击穿问题</p><ul><li>方法3：根据指定的key查询缓存，并反序列化为指定类型，利用缓存空值的方式解决缓存穿透问题</li><li>方法4：根据指定的key查询缓存，并反序列化为指定类型，需要利用逻辑过期解决缓存击穿问题</li></ul><p>将逻辑进行封装</p><pre><code class="java">@Slf4j@Componentpublic class CacheClient &#123;    private final StringRedisTemplate stringRedisTemplate;    private static final ExecutorService CACHE_REBUILD_EXECUTOR = Executors.newFixedThreadPool(10);    public CacheClient(StringRedisTemplate stringRedisTemplate) &#123;        this.stringRedisTemplate = stringRedisTemplate;    &#125;    public void set(String key, Object value, Long time, TimeUnit unit) &#123;        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), time, unit);    &#125;    public void setWithLogicalExpire(String key, Object value, Long time, TimeUnit unit) &#123;        // 设置逻辑过期        RedisData redisData = new RedisData();        redisData.setData(value);        redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(time)));        // 写入Redis        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));    &#125;    public &lt;R,ID&gt; R queryWithPassThrough(            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)&#123;        String key = keyPrefix + id;        // 1.从redis查询商铺缓存        String json = stringRedisTemplate.opsForValue().get(key);        // 2.判断是否存在        if (StrUtil.isNotBlank(json)) &#123;            // 3.存在，直接返回            return JSONUtil.toBean(json, type);        &#125;        // 判断命中的是否是空值        if (json != null) &#123;            // 返回一个错误信息            return null;        &#125;        // 4.不存在，根据id查询数据库        R r = dbFallback.apply(id);        // 5.不存在，返回错误        if (r == null) &#123;            // 将空值写入redis            stringRedisTemplate.opsForValue().set(key, &quot;&quot;, CACHE_NULL_TTL, TimeUnit.MINUTES);            // 返回错误信息            return null;        &#125;        // 6.存在，写入redis        this.set(key, r, time, unit);        return r;    &#125;    public &lt;R, ID&gt; R queryWithLogicalExpire(            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit) &#123;        String key = keyPrefix + id;        // 1.从redis查询商铺缓存        String json = stringRedisTemplate.opsForValue().get(key);        // 2.判断是否存在        if (StrUtil.isBlank(json)) &#123;            // 3.存在，直接返回            return null;        &#125;        // 4.命中，需要先把json反序列化为对象        RedisData redisData = JSONUtil.toBean(json, RedisData.class);        R r = JSONUtil.toBean((JSONObject) redisData.getData(), type);        LocalDateTime expireTime = redisData.getExpireTime();        // 5.判断是否过期        if(expireTime.isAfter(LocalDateTime.now())) &#123;            // 5.1.未过期，直接返回店铺信息            return r;        &#125;        // 5.2.已过期，需要缓存重建        // 6.缓存重建        // 6.1.获取互斥锁        String lockKey = LOCK_SHOP_KEY + id;        boolean isLock = tryLock(lockKey);        // 6.2.判断是否获取锁成功        if (isLock)&#123;            // 6.3.成功，开启独立线程，实现缓存重建            CACHE_REBUILD_EXECUTOR.submit(() -&gt; &#123;                try &#123;                    // 查询数据库                    R newR = dbFallback.apply(id);                    // 重建缓存                    this.setWithLogicalExpire(key, newR, time, unit);                &#125; catch (Exception e) &#123;                    throw new RuntimeException(e);                &#125;finally &#123;                    // 释放锁                    unlock(lockKey);                &#125;            &#125;);        &#125;        // 6.4.返回过期的商铺信息        return r;    &#125;    public &lt;R, ID&gt; R queryWithMutex(            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit) &#123;        String key = keyPrefix + id;        // 1.从redis查询商铺缓存        String shopJson = stringRedisTemplate.opsForValue().get(key);        // 2.判断是否存在        if (StrUtil.isNotBlank(shopJson)) &#123;            // 3.存在，直接返回            return JSONUtil.toBean(shopJson, type);        &#125;        // 判断命中的是否是空值        if (shopJson != null) &#123;            // 返回一个错误信息            return null;        &#125;        // 4.实现缓存重建        // 4.1.获取互斥锁        String lockKey = LOCK_SHOP_KEY + id;        R r = null;        try &#123;            boolean isLock = tryLock(lockKey);            // 4.2.判断是否获取成功            if (!isLock) &#123;                // 4.3.获取锁失败，休眠并重试                Thread.sleep(50);                return queryWithMutex(keyPrefix, id, type, dbFallback, time, unit);            &#125;            // 4.4.获取锁成功，根据id查询数据库            r = dbFallback.apply(id);            // 5.不存在，返回错误            if (r == null) &#123;                // 将空值写入redis                stringRedisTemplate.opsForValue().set(key, &quot;&quot;, CACHE_NULL_TTL, TimeUnit.MINUTES);                // 返回错误信息                return null;            &#125;            // 6.存在，写入redis            this.set(key, r, time, unit);        &#125; catch (InterruptedException e) &#123;            throw new RuntimeException(e);        &#125;finally &#123;            // 7.释放锁            unlock(lockKey);        &#125;        // 8.返回        return r;    &#125;    private boolean tryLock(String key) &#123;        Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key, &quot;1&quot;, 10, TimeUnit.SECONDS);        return BooleanUtil.isTrue(flag);    &#125;    private void unlock(String key) &#123;        stringRedisTemplate.delete(key);    &#125;&#125;</code></pre><p>在ShopServiceImpl 中</p><pre><code class="java">@Resourceprivate CacheClient cacheClient; @Override    public Result queryById(Long id) &#123;        // 解决缓存穿透        Shop shop = cacheClient                .queryWithPassThrough(CACHE_SHOP_KEY, id, Shop.class, this::getById, CACHE_SHOP_TTL, TimeUnit.MINUTES);        // 互斥锁解决缓存击穿        // Shop shop = cacheClient        //         .queryWithMutex(CACHE_SHOP_KEY, id, Shop.class, this::getById, CACHE_SHOP_TTL, TimeUnit.MINUTES);        // 逻辑过期解决缓存击穿        // Shop shop = cacheClient        //         .queryWithLogicalExpire(CACHE_SHOP_KEY, id, Shop.class, this::getById, 20L, TimeUnit.SECONDS);        if (shop == null) &#123;            return Result.fail(&quot;店铺不存在！&quot;);        &#125;        // 7.返回        return Result.ok(shop);    &#125;</code></pre><h2 id="3、优惠卷秒杀"><a href="#3、优惠卷秒杀" class="headerlink" title="3、优惠卷秒杀"></a>3、优惠卷秒杀</h2><h3 id="3-1-全局唯一ID"><a href="#3-1-全局唯一ID" class="headerlink" title="3.1 -全局唯一ID"></a>3.1 -全局唯一ID</h3><p>每个店铺都可以发布优惠券：</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653362612286.png" alt="1653362612286"></p><p>当用户抢购时，就会生成订单并保存到tb_voucher_order这张表中，而订单表如果使用数据库自增ID就存在一些问题：</p><ul><li>id的规律性太明显</li><li>受单表数据量的限制</li></ul><p>场景分析：如果我们的id具有太明显的规则，用户或者说商业对手很容易猜测出来我们的一些敏感信息，比如商城在一天时间内，卖出了多少单，这明显不合适。</p><p>场景分析二：随着我们商城规模越来越大，mysql的单表的容量不宜超过500W，数据量过大之后，我们要进行拆库拆表，但拆分表了之后，他们从逻辑上讲他们是同一张表，所以他们的id是不能一样的， 于是乎我们需要保证id的唯一性。</p><p><strong>全局ID生成器</strong>，是一种在分布式系统下用来生成全局唯一ID的工具，一般要满足下列特性：</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653363100502.png" alt="1653363100502"></p><p>为了增加ID的安全性，我们可以不直接使用Redis自增的数值，而是拼接一些其它信息：</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653363172079.png" alt="1653363172079">ID的组成部分：符号位：1bit，永远为0</p><p>时间戳：31bit，以秒为单位，可以使用69年</p><p>序列号：32bit，秒内的计数器，支持每秒产生2^32个不同ID</p><h3 id="3-2-Redis实现全局唯一Id"><a href="#3-2-Redis实现全局唯一Id" class="headerlink" title="3.2 -Redis实现全局唯一Id"></a>3.2 -Redis实现全局唯一Id</h3><pre><code class="java">@Componentpublic class RedisIdWorker &#123;    /**     * 开始时间戳     */    private static final long BEGIN_TIMESTAMP = 1640995200L;    /**     * 序列号的位数     */    private static final int COUNT_BITS = 32;    private StringRedisTemplate stringRedisTemplate;    public RedisIdWorker(StringRedisTemplate stringRedisTemplate) &#123;        this.stringRedisTemplate = stringRedisTemplate;    &#125;    public long nextId(String keyPrefix) &#123;        // 1.生成时间戳        LocalDateTime now = LocalDateTime.now();        long nowSecond = now.toEpochSecond(ZoneOffset.UTC);        long timestamp = nowSecond - BEGIN_TIMESTAMP;        // 2.生成序列号        // 2.1.获取当前日期，精确到天        String date = now.format(DateTimeFormatter.ofPattern(&quot;yyyy:MM:dd&quot;));        // 2.2.自增长        long count = stringRedisTemplate.opsForValue().increment(&quot;icr:&quot; + keyPrefix + &quot;:&quot; + date);        // 3.拼接并返回        return timestamp &lt;&lt; COUNT_BITS | count;    &#125;&#125;</code></pre><p>测试类</p><p>知识小贴士：关于countdownlatch</p><p>countdownlatch名为信号枪：主要的作用是同步协调在多线程的等待于唤醒问题</p><p>我们如果没有CountDownLatch ，那么由于程序是异步的，当异步程序没有执行完时，主线程就已经执行完了，然后我们期望的是分线程全部走完之后，主线程再走，所以我们此时需要使用到CountDownLatch</p><p>CountDownLatch 中有两个最重要的方法</p><p>1、countDown</p><p>2、await</p><p>await 方法 是阻塞方法，我们担心分线程没有执行完时，main线程就先执行，所以使用await可以让main线程阻塞，那么什么时候main线程不再阻塞呢？当CountDownLatch  内部维护的 变量变为0时，就不再阻塞，直接放行，那么什么时候CountDownLatch   维护的变量变为0 呢，我们只需要调用一次countDown ，内部变量就减少1，我们让分线程和变量绑定， 执行完一个分线程就减少一个变量，当分线程全部走完，CountDownLatch 维护的变量就是0，此时await就不再阻塞，统计出来的时间也就是所有分线程执行完后的时间。</p><pre><code class="java">@Testvoid testIdWorker() throws InterruptedException &#123;    CountDownLatch latch = new CountDownLatch(300);    Runnable task = () -&gt; &#123;        for (int i = 0; i &lt; 100; i++) &#123;            long id = redisIdWorker.nextId(&quot;order&quot;);            System.out.println(&quot;id = &quot; + id);        &#125;        latch.countDown();    &#125;;    long begin = System.currentTimeMillis();    for (int i = 0; i &lt; 300; i++) &#123;        es.submit(task);    &#125;    latch.await();    long end = System.currentTimeMillis();    System.out.println(&quot;time = &quot; + (end - begin));&#125;</code></pre><h3 id="3-3-添加优惠卷"><a href="#3-3-添加优惠卷" class="headerlink" title="3.3 添加优惠卷"></a>3.3 添加优惠卷</h3><p>每个店铺都可以发布优惠券，分为平价券和特价券。平价券可以任意购买，而特价券需要秒杀抢购：</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653365145124.png" alt="1653365145124"></p><p>tb_voucher：优惠券的基本信息，优惠金额、使用规则等<br>tb_seckill_voucher：优惠券的库存、开始抢购时间，结束抢购时间。特价优惠券才需要填写这些信息</p><p>平价卷由于优惠力度并不是很大，所以是可以任意领取</p><p>而代金券由于优惠力度大，所以像第二种卷，就得限制数量，从表结构上也能看出，特价卷除了具有优惠卷的基本信息以外，还具有库存，抢购时间，结束时间等等字段</p><p>**新增普通卷代码：  **VoucherController</p><pre><code class="java">@PostMappingpublic Result addVoucher(@RequestBody Voucher voucher) &#123;    voucherService.save(voucher);    return Result.ok(voucher.getId());&#125;</code></pre><p><strong>新增秒杀卷代码：</strong></p><p><strong>VoucherController</strong></p><pre><code class="java">@PostMapping(&quot;seckill&quot;)public Result addSeckillVoucher(@RequestBody Voucher voucher) &#123;    voucherService.addSeckillVoucher(voucher);    return Result.ok(voucher.getId());&#125;</code></pre><p><strong>VoucherServiceImpl</strong></p><pre><code class="java">@Override@Transactionalpublic void addSeckillVoucher(Voucher voucher) &#123;    // 保存优惠券    save(voucher);    // 保存秒杀信息    SeckillVoucher seckillVoucher = new SeckillVoucher();    seckillVoucher.setVoucherId(voucher.getId());    seckillVoucher.setStock(voucher.getStock());    seckillVoucher.setBeginTime(voucher.getBeginTime());    seckillVoucher.setEndTime(voucher.getEndTime());    seckillVoucherService.save(seckillVoucher);    // 保存秒杀库存到Redis中    stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString());&#125;</code></pre><h3 id="3-4-实现秒杀下单"><a href="#3-4-实现秒杀下单" class="headerlink" title="3.4 实现秒杀下单"></a>3.4 实现秒杀下单</h3><p>下单核心思路：当我们点击抢购时，会触发右侧的请求，我们只需要编写对应的controller即可</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653365839526.png" alt="1653365839526"></p><p>秒杀下单应该思考的内容：</p><p>下单时需要判断两点：</p><ul><li>秒杀是否开始或结束，如果尚未开始或已经结束则无法下单</li><li>库存是否充足，不足则无法下单</li></ul><p>下单核心逻辑分析：</p><p>当用户开始进行下单，我们应当去查询优惠卷信息，查询到优惠卷信息，判断是否满足秒杀条件</p><p>比如时间是否充足，如果时间充足，则进一步判断库存是否足够，如果两者都满足，则扣减库存，创建订单，然后返回订单id，如果有一个条件不满足则直接结束。</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653366238564.png" alt="1653366238564"></p><p>VoucherOrderServiceImpl</p><pre><code class="java">@Overridepublic Result seckillVoucher(Long voucherId) &#123;    // 1.查询优惠券    SeckillVoucher voucher = seckillVoucherService.getById(voucherId);    // 2.判断秒杀是否开始    if (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;        // 尚未开始        return Result.fail(&quot;秒杀尚未开始！&quot;);    &#125;    // 3.判断秒杀是否已经结束    if (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;        // 尚未开始        return Result.fail(&quot;秒杀已经结束！&quot;);    &#125;    // 4.判断库存是否充足    if (voucher.getStock() &lt; 1) &#123;        // 库存不足        return Result.fail(&quot;库存不足！&quot;);    &#125;    //5，扣减库存    boolean success = seckillVoucherService.update()            .setSql(&quot;stock= stock -1&quot;)            .eq(&quot;voucher_id&quot;, voucherId).update();    if (!success) &#123;        //扣减库存        return Result.fail(&quot;库存不足！&quot;);    &#125;    //6.创建订单    VoucherOrder voucherOrder = new VoucherOrder();    // 6.1.订单id    long orderId = redisIdWorker.nextId(&quot;order&quot;);    voucherOrder.setId(orderId);    // 6.2.用户id    Long userId = UserHolder.getUser().getId();    voucherOrder.setUserId(userId);    // 6.3.代金券id    voucherOrder.setVoucherId(voucherId);    save(voucherOrder);    return Result.ok(orderId);&#125;</code></pre><h3 id="3-5-库存超卖问题分析"><a href="#3-5-库存超卖问题分析" class="headerlink" title="3.5 库存超卖问题分析"></a>3.5 库存超卖问题分析</h3><p>有关超卖问题分析：在我们原有代码中是这么写的</p><pre><code class="java"> if (voucher.getStock() &lt; 1) &#123;        // 库存不足        return Result.fail(&quot;库存不足！&quot;);    &#125;    //5，扣减库存    boolean success = seckillVoucherService.update()            .setSql(&quot;stock= stock -1&quot;)            .eq(&quot;voucher_id&quot;, voucherId).update();    if (!success) &#123;        //扣减库存        return Result.fail(&quot;库存不足！&quot;);    &#125;</code></pre><p>假设线程1过来查询库存，判断出来库存大于1，正准备去扣减库存，但是还没有来得及去扣减，此时线程2过来，线程2也去查询库存，发现这个数量一定也大于1，那么这两个线程都会去扣减库存，最终多个线程相当于一起去扣减库存，此时就会出现库存的超卖问题。</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653368335155.png" alt="1653368335155"></p><p>超卖问题是典型的多线程安全问题，针对这一问题的常见解决方案就是加锁：而对于加锁，我们通常有两种解决方案：见下图：</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653368562591.png" alt="1653368562591"></p><p><strong>悲观锁：</strong></p><p> 悲观锁可以实现对于数据的串行化执行，比如syn，和lock都是悲观锁的代表，同时，悲观锁中又可以再细分为公平锁，非公平锁，可重入锁，等等</p><p><strong>乐观锁：</strong></p><p>  乐观锁：会有一个版本号，每次操作数据会对版本号+1，再提交回数据时，会去校验是否比之前的版本大1 ，如果大1 ，则进行操作成功，这套机制的核心逻辑在于，如果在操作过程中，版本号只比原来大1 ，那么就意味着操作过程中没有人对他进行过修改，他的操作就是安全的，如果不大1，则数据被修改过，当然乐观锁还有一些变种的处理方式比如cas</p><p>  乐观锁的典型代表：就是cas，利用cas进行无锁化机制加锁，var5 是操作前读取的内存值，while中的var1+var2 是预估值，如果预估值 &#x3D;&#x3D; 内存值，则代表中间没有被人修改过，此时就将新值去替换 内存值</p><p>  其中do while 是为了在操作失败时，再次进行自旋操作，即把之前的逻辑再操作一次。</p><pre><code class="java">int var5;do &#123;    var5 = this.getIntVolatile(var1, var2);&#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));return var5;</code></pre><p><strong>课程中的使用方式：</strong></p><p>课程中的使用方式是没有像cas一样带自旋的操作，也没有对version的版本号+1 ，他的操作逻辑是在操作时，对版本号进行+1 操作，然后要求version 如果是1 的情况下，才能操作，那么第一个线程在操作后，数据库中的version变成了2，但是他自己满足version&#x3D;1 ，所以没有问题，此时线程2执行，线程2 最后也需要加上条件version &#x3D;1 ，但是现在由于线程1已经操作过了，所以线程2，操作时就不满足version&#x3D;1 的条件了，所以线程2无法执行成功</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653369268550.png" alt="1653369268550"></p><h3 id="3-6-乐观锁解决超卖问题"><a href="#3-6-乐观锁解决超卖问题" class="headerlink" title="3.6 乐观锁解决超卖问题"></a>3.6 乐观锁解决超卖问题</h3><p><strong>修改代码方案一、</strong></p><p>VoucherOrderServiceImpl 在扣减库存时，改为：</p><pre><code class="java">boolean success = seckillVoucherService.update()            .setSql(&quot;stock= stock -1&quot;) //set stock = stock -1            .eq(&quot;voucher_id&quot;, voucherId).eq(&quot;stock&quot;,voucher.getStock()).update(); //where id = ？ and stock = ?</code></pre><p>以上逻辑的核心含义是：只要我扣减库存时的库存和之前我查询到的库存是一样的，就意味着没有人在中间修改过库存，那么此时就是安全的，但是以上这种方式通过测试发现会有很多失败的情况，失败的原因在于：在使用乐观锁过程中假设100个线程同时都拿到了100的库存，然后大家一起去进行扣减，但是100个人中只有1个人能扣减成功，其他的人在处理时，他们在扣减时，库存已经被修改过了，所以此时其他线程都会失败</p><p><strong>修改代码方案二、</strong></p><p>之前的方式要修改前后都保持一致，但是这样我们分析过，成功的概率太低，所以我们的乐观锁需要变一下，改成stock大于0 即可</p><pre><code class="java">boolean success = seckillVoucherService.update()            .setSql(&quot;stock= stock -1&quot;)            .eq(&quot;voucher_id&quot;, voucherId).update().gt(&quot;stock&quot;,0); //where id = ? and stock &gt; 0</code></pre><p><strong>知识小扩展：</strong></p><p>针对cas中的自旋压力过大，我们可以使用Longaddr这个类去解决</p><p>Java8 提供的一个对AtomicLong改进后的一个类，LongAdder</p><p>大量线程并发更新一个原子性的时候，天然的问题就是自旋，会导致并发性问题，当然这也比我们直接使用syn来的好</p><p>所以利用这么一个类，LongAdder来进行优化</p><p>如果获取某个值，则会对cell和base的值进行递增，最后返回一个完整的值</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653370271627.png" alt="1653370271627"></p><h3 id="3-6-优惠券秒杀-一人一单"><a href="#3-6-优惠券秒杀-一人一单" class="headerlink" title="3.6 优惠券秒杀-一人一单"></a>3.6 优惠券秒杀-一人一单</h3><p>需求：修改秒杀业务，要求同一个优惠券，一个用户只能下一单</p><p><strong>现在的问题在于：</strong></p><p>优惠卷是为了引流，但是目前的情况是，一个人可以无限制的抢这个优惠卷，所以我们应当增加一层逻辑，让一个用户只能下一个单，而不是让一个用户下多个单</p><p>具体操作逻辑如下：比如时间是否充足，如果时间充足，则进一步判断库存是否足够，然后再根据优惠卷id和用户id查询是否已经下过这个订单，如果下过这个订单，则不再下单，否则进行下单</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653371854389.png" alt="1653371854389"></p><p>VoucherOrderServiceImpl  </p><p><strong>初步代码：增加一人一单逻辑</strong></p><pre><code class="java">@Overridepublic Result seckillVoucher(Long voucherId) &#123;    // 1.查询优惠券    SeckillVoucher voucher = seckillVoucherService.getById(voucherId);    // 2.判断秒杀是否开始    if (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;        // 尚未开始        return Result.fail(&quot;秒杀尚未开始！&quot;);    &#125;    // 3.判断秒杀是否已经结束    if (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;        // 尚未开始        return Result.fail(&quot;秒杀已经结束！&quot;);    &#125;    // 4.判断库存是否充足    if (voucher.getStock() &lt; 1) &#123;        // 库存不足        return Result.fail(&quot;库存不足！&quot;);    &#125;    // 5.一人一单逻辑    // 5.1.用户id    Long userId = UserHolder.getUser().getId();    int count = query().eq(&quot;user_id&quot;, userId).eq(&quot;voucher_id&quot;, voucherId).count();    // 5.2.判断是否存在    if (count &gt; 0) &#123;        // 用户已经购买过了        return Result.fail(&quot;用户已经购买过一次！&quot;);    &#125;    //6，扣减库存    boolean success = seckillVoucherService.update()            .setSql(&quot;stock= stock -1&quot;)            .eq(&quot;voucher_id&quot;, voucherId).update();    if (!success) &#123;        //扣减库存        return Result.fail(&quot;库存不足！&quot;);    &#125;    //7.创建订单    VoucherOrder voucherOrder = new VoucherOrder();    // 7.1.订单id    long orderId = redisIdWorker.nextId(&quot;order&quot;);    voucherOrder.setId(orderId);    voucherOrder.setUserId(userId);    // 7.3.代金券id    voucherOrder.setVoucherId(voucherId);    save(voucherOrder);    return Result.ok(orderId);&#125;</code></pre><p><strong>存在问题：</strong>现在的问题还是和之前一样，并发过来，查询数据库，都不存在订单，所以我们还是需要加锁，但是乐观锁比较适合更新数据，而现在是插入数据，所以我们需要使用悲观锁操作</p><p><strong>注意：</strong>在这里提到了非常多的问题，我们需要慢慢的来思考，首先我们的初始方案是封装了一个createVoucherOrder方法，同时为了确保他线程安全，在方法上添加了一把synchronized 锁</p><pre><code class="java">@Transactionalpublic synchronized Result createVoucherOrder(Long voucherId) &#123;    Long userId = UserHolder.getUser().getId();         // 5.1.查询订单        int count = query().eq(&quot;user_id&quot;, userId).eq(&quot;voucher_id&quot;, voucherId).count();        // 5.2.判断是否存在        if (count &gt; 0) &#123;            // 用户已经购买过了            return Result.fail(&quot;用户已经购买过一次！&quot;);        &#125;        // 6.扣减库存        boolean success = seckillVoucherService.update()                .setSql(&quot;stock = stock - 1&quot;) // set stock = stock - 1                .eq(&quot;voucher_id&quot;, voucherId).gt(&quot;stock&quot;, 0) // where id = ? and stock &gt; 0                .update();        if (!success) &#123;            // 扣减失败            return Result.fail(&quot;库存不足！&quot;);        &#125;        // 7.创建订单        VoucherOrder voucherOrder = new VoucherOrder();        // 7.1.订单id        long orderId = redisIdWorker.nextId(&quot;order&quot;);        voucherOrder.setId(orderId);        // 7.2.用户id        voucherOrder.setUserId(userId);        // 7.3.代金券id        voucherOrder.setVoucherId(voucherId);        save(voucherOrder);        // 7.返回订单id        return Result.ok(orderId);&#125;</code></pre><p>，但是这样添加锁，锁的粒度太粗了，在使用锁过程中，控制<strong>锁粒度</strong> 是一个非常重要的事情，因为如果锁的粒度太大，会导致每个线程进来都会锁住，所以我们需要去控制锁的粒度，以下这段代码需要修改为：<br>intern() 这个方法是从常量池中拿到数据，如果我们直接使用userId.toString() 他拿到的对象实际上是不同的对象，new出来的对象，我们使用锁必须保证锁必须是同一把，所以我们需要使用intern()方法</p><pre><code class="java">@Transactionalpublic  Result createVoucherOrder(Long voucherId) &#123;    Long userId = UserHolder.getUser().getId();    synchronized(userId.toString().intern())&#123;         // 5.1.查询订单        int count = query().eq(&quot;user_id&quot;, userId).eq(&quot;voucher_id&quot;, voucherId).count();        // 5.2.判断是否存在        if (count &gt; 0) &#123;            // 用户已经购买过了            return Result.fail(&quot;用户已经购买过一次！&quot;);        &#125;        // 6.扣减库存        boolean success = seckillVoucherService.update()                .setSql(&quot;stock = stock - 1&quot;) // set stock = stock - 1                .eq(&quot;voucher_id&quot;, voucherId).gt(&quot;stock&quot;, 0) // where id = ? and stock &gt; 0                .update();        if (!success) &#123;            // 扣减失败            return Result.fail(&quot;库存不足！&quot;);        &#125;        // 7.创建订单        VoucherOrder voucherOrder = new VoucherOrder();        // 7.1.订单id        long orderId = redisIdWorker.nextId(&quot;order&quot;);        voucherOrder.setId(orderId);        // 7.2.用户id        voucherOrder.setUserId(userId);        // 7.3.代金券id        voucherOrder.setVoucherId(voucherId);        save(voucherOrder);        // 7.返回订单id        return Result.ok(orderId);    &#125;&#125;</code></pre><p>但是以上代码还是存在问题，问题的原因在于当前方法被spring的事务控制，如果你在方法内部加锁，可能会导致当前方法事务还没有提交，但是锁已经释放也会导致问题，所以我们选择将当前方法整体包裹起来，确保事务不会出现问题：如下：</p><p>在seckillVoucher 方法中，添加以下逻辑，这样就能保证事务的特性，同时也控制了锁的粒度</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653373434815.png" alt="1653373434815"></p><p>但是以上做法依然有问题，因为你调用的方法，其实是this.的方式调用的，事务想要生效，还得利用代理来生效，所以这个地方，我们需要获得原始的事务对象， 来操作事务</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653383810643.png" alt="1653383810643"></p><h3 id="3-7-集群环境下的并发问题"><a href="#3-7-集群环境下的并发问题" class="headerlink" title="3.7 集群环境下的并发问题"></a>3.7 集群环境下的并发问题</h3><p>通过加锁可以解决在单机情况下的一人一单安全问题，但是在集群模式下就不行了。</p><p>1、我们将服务启动两份，端口分别为8081和8082：</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653373887844.png" alt="1653373887844"></p><p>2、然后修改nginx的conf目录下的nginx.conf文件，配置反向代理和负载均衡：</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653373908620.png" alt="1653373908620"></p><p><strong>具体操作(略)</strong></p><p><strong>有关锁失效原因分析</strong></p><p>由于现在我们部署了多个tomcat，每个tomcat都有一个属于自己的jvm，那么假设在服务器A的tomcat内部，有两个线程，这两个线程由于使用的是同一份代码，那么他们的锁对象是同一个，是可以实现互斥的，但是如果现在是服务器B的tomcat内部，又有两个线程，但是他们的锁对象写的虽然和服务器A一样，但是锁对象却不是同一个，所以线程3和线程4可以实现互斥，但是却无法和线程1和线程2实现互斥，这就是 集群环境下，syn锁失效的原因，在这种情况下，我们就需要使用分布式锁来解决这个问题。</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653374044740.png" alt="1653374044740"></p><h2 id="4、分布式锁"><a href="#4、分布式锁" class="headerlink" title="4、分布式锁"></a>4、分布式锁</h2><h3 id="4-1-、基本原理和实现方式对比"><a href="#4-1-、基本原理和实现方式对比" class="headerlink" title="4.1 、基本原理和实现方式对比"></a>4.1 、基本原理和实现方式对比</h3><p>分布式锁：满足分布式系统或集群模式下多进程可见并且互斥的锁。</p><p>分布式锁的核心思想就是让大家都使用同一把锁，只要大家使用的是同一把锁，那么我们就能锁住线程，不让线程进行，让程序串行执行，这就是分布式锁的核心思路</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653374296906.png" alt="1653374296906"></p><p>那么分布式锁他应该满足一些什么样的条件呢？</p><p>可见性：多个线程都能看到相同的结果，注意：这个地方说的可见性并不是并发编程中指的内存可见性，只是说多个进程之间都能感知到变化的意思</p><p>互斥：互斥是分布式锁的最基本的条件，使得程序串行执行</p><p>高可用：程序不易崩溃，时时刻刻都保证较高的可用性</p><p>高性能：由于加锁本身就让性能降低，所有对于分布式锁本身需要他就较高的加锁性能和释放锁性能</p><p>安全性：安全也是程序中必不可少的一环</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653381992018.png" alt="1653381992018"></p><p>常见的分布式锁有三种</p><p>Mysql：mysql本身就带有锁机制，但是由于mysql性能本身一般，所以采用分布式锁的情况下，其实使用mysql作为分布式锁比较少见</p><p>Redis：redis作为分布式锁是非常常见的一种使用方式，现在企业级开发中基本都使用redis或者zookeeper作为分布式锁，利用setnx这个方法，如果插入key成功，则表示获得到了锁，如果有人插入成功，其他人插入失败则表示无法获得到锁，利用这套逻辑来实现分布式锁</p><p>Zookeeper：zookeeper也是企业级开发中较好的一个实现分布式锁的方案，由于本套视频并不讲解zookeeper的原理和分布式锁的实现，所以不过多阐述</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653382219377.png" alt="1653382219377"></p><h3 id="4-2-、Redis分布式锁的实现核心思路"><a href="#4-2-、Redis分布式锁的实现核心思路" class="headerlink" title="4.2 、Redis分布式锁的实现核心思路"></a>4.2 、Redis分布式锁的实现核心思路</h3><p>实现分布式锁时需要实现的两个基本方法：</p><ul><li><p>获取锁：</p><ul><li>互斥：确保只能有一个线程获取锁</li><li>非阻塞：尝试一次，成功返回true，失败返回false</li></ul></li><li><p>释放锁：</p><ul><li>手动释放</li><li>超时释放：获取锁时添加一个超时时间</li></ul><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653382669900.png" alt="1653382669900"></p></li></ul><p>核心思路：</p><p>我们利用redis 的setNx 方法，当有多个线程进入时，我们就利用该方法，第一个线程进入时，redis 中就有这个key 了，返回了1，如果结果是1，则表示他抢到了锁，那么他去执行业务，然后再删除锁，退出锁逻辑，没有抢到锁的哥们，等待一定时间后重试即可</p><p> <img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653382830810.png" alt="1653382830810"></p><h3 id="4-3-实现分布式锁版本一"><a href="#4-3-实现分布式锁版本一" class="headerlink" title="4.3 实现分布式锁版本一"></a>4.3 实现分布式锁版本一</h3><ul><li>加锁逻辑</li></ul><p><strong>锁的基本接口</strong></p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1656079017728.png" alt="1656079017728"></p><p><strong>SimpleRedisLock</strong></p><p>利用setnx方法进行加锁，同时增加过期时间，防止死锁，此方法可以保证加锁和增加过期时间具有原子性</p><pre><code class="java">private static final String KEY_PREFIX=&quot;lock:&quot;@Overridepublic boolean tryLock(long timeoutSec) &#123;    // 获取线程标示    String threadId = Thread.currentThread().getId()    // 获取锁    Boolean success = stringRedisTemplate.opsForValue()            .setIfAbsent(KEY_PREFIX + name, threadId + &quot;&quot;, timeoutSec, TimeUnit.SECONDS);    return Boolean.TRUE.equals(success);&#125;</code></pre><ul><li>释放锁逻辑</li></ul><p>SimpleRedisLock</p><p>释放锁，防止删除别人的锁</p><pre><code class="java">public void unlock() &#123;    //通过del删除锁    stringRedisTemplate.delete(KEY_PREFIX + name);&#125;</code></pre><ul><li>修改业务代码</li></ul><pre><code class="java">  @Override    public Result seckillVoucher(Long voucherId) &#123;        // 1.查询优惠券        SeckillVoucher voucher = seckillVoucherService.getById(voucherId);        // 2.判断秒杀是否开始        if (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;            // 尚未开始            return Result.fail(&quot;秒杀尚未开始！&quot;);        &#125;        // 3.判断秒杀是否已经结束        if (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;            // 尚未开始            return Result.fail(&quot;秒杀已经结束！&quot;);        &#125;        // 4.判断库存是否充足        if (voucher.getStock() &lt; 1) &#123;            // 库存不足            return Result.fail(&quot;库存不足！&quot;);        &#125;        Long userId = UserHolder.getUser().getId();        //创建锁对象(新增代码)        SimpleRedisLock lock = new SimpleRedisLock(&quot;order:&quot; + userId, stringRedisTemplate);        //获取锁对象        boolean isLock = lock.tryLock(1200);        //加锁失败        if (!isLock) &#123;            return Result.fail(&quot;不允许重复下单&quot;);        &#125;        try &#123;            //获取代理对象(事务)            IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();            return proxy.createVoucherOrder(voucherId);        &#125; finally &#123;            //释放锁            lock.unlock();        &#125;    &#125;</code></pre><h3 id="4-4-Redis分布式锁误删情况说明"><a href="#4-4-Redis分布式锁误删情况说明" class="headerlink" title="4.4 Redis分布式锁误删情况说明"></a>4.4 Redis分布式锁误删情况说明</h3><p>逻辑说明：</p><p>持有锁的线程在锁的内部出现了阻塞，导致他的锁自动释放，这时其他线程，线程2来尝试获得锁，就拿到了这把锁，然后线程2在持有锁执行过程中，线程1反应过来，继续执行，而线程1执行过程中，走到了删除锁逻辑，此时就会把本应该属于线程2的锁进行删除，这就是误删别人锁的情况说明</p><p>解决方案：解决方案就是在每个线程释放锁的时候，去判断一下当前这把锁是否属于自己，如果属于自己，则不进行锁的删除，假设还是上边的情况，线程1卡顿，锁自动释放，线程2进入到锁的内部执行逻辑，此时线程1反应过来，然后删除锁，但是线程1，一看当前这把锁不是属于自己，于是不进行删除锁逻辑，当线程2走到删除锁逻辑时，如果没有卡过自动释放锁的时间点，则判断当前这把锁是属于自己的，于是删除这把锁。</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653385920025.png" alt="1653385920025"></p><h3 id="4-5-解决Redis分布式锁误删问题"><a href="#4-5-解决Redis分布式锁误删问题" class="headerlink" title="4.5 解决Redis分布式锁误删问题"></a>4.5 解决Redis分布式锁误删问题</h3><p>需求：修改之前的分布式锁实现，满足：在获取锁时存入线程标示（可以用UUID表示）<br>在释放锁时先获取锁中的线程标示，判断是否与当前线程标示一致</p><ul><li>如果一致则释放锁</li><li>如果不一致则不释放锁</li></ul><p>核心逻辑：在存入锁时，放入自己线程的标识，在删除锁时，判断当前这把锁的标识是不是自己存入的，如果是，则进行删除，如果不是，则不进行删除。</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653387398820.png" alt="1653387398820"></p><p>具体代码如下：加锁</p><pre><code class="java">private static final String ID_PREFIX = UUID.randomUUID().toString(true) + &quot;-&quot;;@Overridepublic boolean tryLock(long timeoutSec) &#123;   // 获取线程标示   String threadId = ID_PREFIX + Thread.currentThread().getId();   // 获取锁   Boolean success = stringRedisTemplate.opsForValue()                .setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS);   return Boolean.TRUE.equals(success);&#125;</code></pre><p>释放锁</p><pre><code class="java">public void unlock() &#123;    // 获取线程标示    String threadId = ID_PREFIX + Thread.currentThread().getId();    // 获取锁中的标示    String id = stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);    // 判断标示是否一致    if(threadId.equals(id)) &#123;        // 释放锁        stringRedisTemplate.delete(KEY_PREFIX + name);    &#125;&#125;</code></pre><p><strong>有关代码实操说明：</strong></p><p>在我们修改完此处代码后，我们重启工程，然后启动两个线程，第一个线程持有锁后，手动释放锁，第二个线程 此时进入到锁内部，再放行第一个线程，此时第一个线程由于锁的value值并非是自己，所以不能释放锁，也就无法删除别人的锁，此时第二个线程能够正确释放锁，通过这个案例初步说明我们解决了锁误删的问题。</p><h3 id="4-6-分布式锁的原子性问题"><a href="#4-6-分布式锁的原子性问题" class="headerlink" title="4.6 分布式锁的原子性问题"></a>4.6 分布式锁的原子性问题</h3><p>更为极端的误删逻辑说明：</p><p>线程1现在持有锁之后，在执行业务逻辑过程中，他正准备删除锁，而且已经走到了条件判断的过程中，比如他已经拿到了当前这把锁确实是属于他自己的，正准备删除锁，但是此时他的锁到期了，那么此时线程2进来，但是线程1他会接着往后执行，当他卡顿结束后，他直接就会执行删除锁那行代码，相当于条件判断并没有起到作用，这就是删锁时的原子性问题，之所以有这个问题，是因为线程1的拿锁，比锁，删锁，实际上并不是原子性的，我们要防止刚才的情况发生，</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653387764938.png" alt="1653387764938"></p><h3 id="4-7-Lua脚本解决多条命令原子性问题"><a href="#4-7-Lua脚本解决多条命令原子性问题" class="headerlink" title="4.7 Lua脚本解决多条命令原子性问题"></a>4.7 Lua脚本解决多条命令原子性问题</h3><p>Redis提供了Lua脚本功能，在一个脚本中编写多条Redis命令，确保多条命令执行时的原子性。Lua是一种编程语言，它的基本语法大家可以参考网站：<a href="https://www.runoob.com/lua/lua-tutorial.html%EF%BC%8C%E8%BF%99%E9%87%8C%E9%87%8D%E7%82%B9%E4%BB%8B%E7%BB%8DRedis%E6%8F%90%E4%BE%9B%E7%9A%84%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8lua%E5%8E%BB%E6%93%8D%E4%BD%9Credis%EF%BC%8C%E5%8F%88%E8%83%BD%E4%BF%9D%E8%AF%81%E4%BB%96%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%8C%E8%BF%99%E6%A0%B7%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E6%8B%BF%E9%94%81%E6%AF%94%E9%94%81%E5%88%A0%E9%94%81%E6%98%AF%E4%B8%80%E4%B8%AA%E5%8E%9F%E5%AD%90%E6%80%A7%E5%8A%A8%E4%BD%9C%E4%BA%86%EF%BC%8C%E4%BD%9C%E4%B8%BAJava%E7%A8%8B%E5%BA%8F%E5%91%98%E8%BF%99%E4%B8%80%E5%9D%97%E5%B9%B6%E4%B8%8D%E4%BD%9C%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E8%A6%81%E6%B1%82%EF%BC%8C%E5%B9%B6%E4%B8%8D%E9%9C%80%E8%A6%81%E5%A4%A7%E5%AE%B6%E8%BF%87%E4%BA%8E%E7%B2%BE%E9%80%9A%EF%BC%8C%E5%8F%AA%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E4%BB%96%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%E5%8D%B3%E5%8F%AF%E3%80%82">https://www.runoob.com/lua/lua-tutorial.html，这里重点介绍Redis提供的调用函数，我们可以使用lua去操作redis，又能保证他的原子性，这样就可以实现拿锁比锁删锁是一个原子性动作了，作为Java程序员这一块并不作一个简单要求，并不需要大家过于精通，只需要知道他有什么作用即可。</a></p><p>这里重点介绍Redis提供的调用函数，语法如下：</p><pre><code class="lua">redis.call(&#39;命令名称&#39;, &#39;key&#39;, &#39;其它参数&#39;, ...)</code></pre><p>例如，我们要执行set name jack，则脚本是这样：</p><pre><code class="lua"># 执行 set name jackredis.call(&#39;set&#39;, &#39;name&#39;, &#39;jack&#39;)</code></pre><p>例如，我们要先执行set name Rose，再执行get name，则脚本如下：</p><pre><code class="lua"># 先执行 set name jackredis.call(&#39;set&#39;, &#39;name&#39;, &#39;Rose&#39;)# 再执行 get namelocal name = redis.call(&#39;get&#39;, &#39;name&#39;)# 返回return name</code></pre><p>写好脚本以后，需要用Redis命令来调用脚本，调用脚本的常见命令如下：</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653392181413.png" alt="1653392181413"></p><p>例如，我们要执行 redis.call(‘set’, ‘name’, ‘jack’) 这个脚本，语法如下：</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653392218531.png" alt="1653392218531"></p><p>如果脚本中的key、value不想写死，可以作为参数传递。key类型参数会放入KEYS数组，其它参数会放入ARGV数组，在脚本中可以从KEYS和ARGV数组获取这些参数：</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653392438917.png" alt="1653392438917"></p><p>接下来我们来回一下我们释放锁的逻辑：</p><p>释放锁的业务流程是这样的</p><p>​1、获取锁中的线程标示</p><p>​2、判断是否与指定的标示（当前线程标示）一致</p><p>​3、如果一致则释放锁（删除）</p><p>​4、如果不一致则什么都不做</p><p>如果用Lua脚本来表示则是这样的：</p><p>最终我们操作redis的拿锁比锁删锁的lua脚本就会变成这样</p><pre><code class="lua">-- 这里的 KEYS[1] 就是锁的key，这里的ARGV[1] 就是当前线程标示-- 获取锁中的标示，判断是否与当前线程标示一致if (redis.call(&#39;GET&#39;, KEYS[1]) == ARGV[1]) then  -- 一致，则删除锁  return redis.call(&#39;DEL&#39;, KEYS[1])end-- 不一致，则直接返回return 0</code></pre><h3 id="4-8-利用Java代码调用Lua脚本改造分布式锁"><a href="#4-8-利用Java代码调用Lua脚本改造分布式锁" class="headerlink" title="4.8 利用Java代码调用Lua脚本改造分布式锁"></a>4.8 利用Java代码调用Lua脚本改造分布式锁</h3><p>lua脚本本身并不需要大家花费太多时间去研究，只需要知道如何调用，大致是什么意思即可，所以在笔记中并不会详细的去解释这些lua表达式的含义。</p><p>我们的RedisTemplate中，可以利用execute方法去执行lua脚本，参数对应关系就如下图股</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653393304844.png" alt="1653393304844"></p><p><strong>Java代码</strong></p><pre><code class="java">private static final DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT;    static &#123;        UNLOCK_SCRIPT = new DefaultRedisScript&lt;&gt;();        UNLOCK_SCRIPT.setLocation(new ClassPathResource(&quot;unlock.lua&quot;));        UNLOCK_SCRIPT.setResultType(Long.class);    &#125;public void unlock() &#123;    // 调用lua脚本    stringRedisTemplate.execute(            UNLOCK_SCRIPT,            Collections.singletonList(KEY_PREFIX + name),            ID_PREFIX + Thread.currentThread().getId());&#125;经过以上代码改造后，我们就能够实现 拿锁比锁删锁的原子性动作了~</code></pre><p>小总结：</p><p>基于Redis的分布式锁实现思路：</p><ul><li>利用set nx ex获取锁，并设置过期时间，保存线程标示</li><li>释放锁时先判断线程标示是否与自己一致，一致则删除锁<ul><li>特性：<ul><li>利用set nx满足互斥性</li><li>利用set ex保证故障时锁依然能释放，避免死锁，提高安全性</li><li>利用Redis集群保证高可用和高并发特性</li></ul></li></ul></li></ul><p>笔者总结：我们一路走来，利用添加过期时间，防止死锁问题的发生，但是有了过期时间之后，可能出现误删别人锁的问题，这个问题我们开始是利用删之前 通过拿锁，比锁，删锁这个逻辑来解决的，也就是删之前判断一下当前这把锁是否是属于自己的，但是现在还有原子性问题，也就是我们没法保证拿锁比锁删锁是一个原子性的动作，最后通过lua表达式来解决这个问题</p><p>但是目前还剩下一个问题锁不住，什么是锁不住呢，你想一想，如果当过期时间到了之后，我们可以给他续期一下，比如续个30s，就好像是网吧上网， 网费到了之后，然后说，来，网管，再给我来10块的，是不是后边的问题都不会发生了，那么续期问题怎么解决呢，可以依赖于我们接下来要学习redission啦</p><p><strong>测试逻辑：</strong></p><p>第一个线程进来，得到了锁，手动删除锁，模拟锁超时了，其他线程会执行lua来抢锁，当第一天线程利用lua删除锁时，lua能保证他不能删除他的锁，第二个线程删除锁时，利用lua同样可以保证不会删除别人的锁，同时还能保证原子性。</p><h2 id="5、分布式锁-redission"><a href="#5、分布式锁-redission" class="headerlink" title="5、分布式锁-redission"></a>5、分布式锁-redission</h2><h3 id="5-1-分布式锁-redission功能介绍"><a href="#5-1-分布式锁-redission功能介绍" class="headerlink" title="5.1 分布式锁-redission功能介绍"></a>5.1 分布式锁-redission功能介绍</h3><p>基于setnx实现的分布式锁存在下面的问题：</p><p><strong>重入问题</strong>：重入问题是指 获得锁的线程可以再次进入到相同的锁的代码块中，可重入锁的意义在于防止死锁，比如HashTable这样的代码中，他的方法都是使用synchronized修饰的，假如他在一个方法内，调用另一个方法，那么此时如果是不可重入的，不就死锁了吗？所以可重入锁他的主要意义是防止死锁，我们的synchronized和Lock锁都是可重入的。</p><p><strong>不可重试</strong>：是指目前的分布式只能尝试一次，我们认为合理的情况是：当线程在获得锁失败后，他应该能再次尝试获得锁。</p><p><strong>超时释放：</strong>我们在加锁时增加了过期时间，这样的我们可以防止死锁，但是如果卡顿的时间超长，虽然我们采用了lua表达式防止删锁的时候，误删别人的锁，但是毕竟没有锁住，有安全隐患</p><p><strong>主从一致性：</strong> 如果Redis提供了主从集群，当我们向集群写数据时，主机需要异步的将数据同步给从机，而万一在同步过去之前，主机宕机了，就会出现死锁问题。</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653546070602.png" alt="1653546070602"></p><p>那么什么是Redission呢</p><p>Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。</p><p>Redission提供了分布式锁的多种多样的功能</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653546736063.png" alt="1653546736063"></p><h3 id="5-2-分布式锁-Redission快速入门"><a href="#5-2-分布式锁-Redission快速入门" class="headerlink" title="5.2 分布式锁-Redission快速入门"></a>5.2 分布式锁-Redission快速入门</h3><p>引入依赖：</p><pre><code class="java">&lt;dependency&gt;    &lt;groupId&gt;org.redisson&lt;/groupId&gt;    &lt;artifactId&gt;redisson&lt;/artifactId&gt;    &lt;version&gt;3.13.6&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>配置Redisson客户端：</p><pre><code class="java">@Configurationpublic class RedissonConfig &#123;    @Bean    public RedissonClient redissonClient()&#123;        // 配置        Config config = new Config();        config.useSingleServer().setAddress(&quot;redis://192.168.150.101:6379&quot;)            .setPassword(&quot;123321&quot;);        // 创建RedissonClient对象        return Redisson.create(config);    &#125;&#125;</code></pre><p>如何使用Redission的分布式锁</p><pre><code class="java">@Resourceprivate RedissionClient redissonClient;@Testvoid testRedisson() throws Exception&#123;    //获取锁(可重入)，指定锁的名称    RLock lock = redissonClient.getLock(&quot;anyLock&quot;);    //尝试获取锁，参数分别是：获取锁的最大等待时间(期间会重试)，锁自动释放时间，时间单位    boolean isLock = lock.tryLock(1,10,TimeUnit.SECONDS);    //判断获取锁成功    if(isLock)&#123;        try&#123;            System.out.println(&quot;执行业务&quot;);                  &#125;finally&#123;            //释放锁            lock.unlock();        &#125;            &#125;            &#125;</code></pre><p>在 VoucherOrderServiceImpl</p><p>注入RedissonClient</p><pre><code class="java">@Resourceprivate RedissonClient redissonClient;@Overridepublic Result seckillVoucher(Long voucherId) &#123;        // 1.查询优惠券        SeckillVoucher voucher = seckillVoucherService.getById(voucherId);        // 2.判断秒杀是否开始        if (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;            // 尚未开始            return Result.fail(&quot;秒杀尚未开始！&quot;);        &#125;        // 3.判断秒杀是否已经结束        if (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;            // 尚未开始            return Result.fail(&quot;秒杀已经结束！&quot;);        &#125;        // 4.判断库存是否充足        if (voucher.getStock() &lt; 1) &#123;            // 库存不足            return Result.fail(&quot;库存不足！&quot;);        &#125;        Long userId = UserHolder.getUser().getId();        //创建锁对象 这个代码不用了，因为我们现在要使用分布式锁        //SimpleRedisLock lock = new SimpleRedisLock(&quot;order:&quot; + userId, stringRedisTemplate);        RLock lock = redissonClient.getLock(&quot;lock:order:&quot; + userId);        //获取锁对象        boolean isLock = lock.tryLock();               //加锁失败        if (!isLock) &#123;            return Result.fail(&quot;不允许重复下单&quot;);        &#125;        try &#123;            //获取代理对象(事务)            IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();            return proxy.createVoucherOrder(voucherId);        &#125; finally &#123;            //释放锁            lock.unlock();        &#125; &#125;</code></pre><h3 id="5-3-分布式锁-redission可重入锁原理"><a href="#5-3-分布式锁-redission可重入锁原理" class="headerlink" title="5.3 分布式锁-redission可重入锁原理"></a>5.3 分布式锁-redission可重入锁原理</h3><p>在Lock锁中，他是借助于底层的一个voaltile的一个state变量来记录重入的状态的，比如当前没有人持有这把锁，那么state&#x3D;0，假如有人持有这把锁，那么state&#x3D;1，如果持有这把锁的人再次持有这把锁，那么state就会+1 ，如果是对于synchronized而言，他在c语言代码中会有一个count，原理和state类似，也是重入一次就加一，释放一次就-1 ，直到减少成0 时，表示当前这把锁没有被人持有。  </p><p>在redission中，我们的也支持支持可重入锁</p><p>在分布式锁中，他采用hash结构用来存储锁，其中大key表示表示这把锁是否存在，用小key表示当前这把锁被哪个线程持有，所以接下来我们一起分析一下当前的这个lua表达式</p><p>这个地方一共有3个参数</p><p><strong>KEYS[1] ： 锁名称</strong></p><p><strong>ARGV[1]：  锁失效时间</strong></p><p><strong>ARGV[2]：  id + “:” + threadId; 锁的小key</strong></p><p>exists: 判断数据是否存在  name：是lock是否存在,如果&#x3D;&#x3D;0，就表示当前这把锁不存在</p><p>redis.call(‘hset’, KEYS[1], ARGV[2], 1);此时他就开始往redis里边去写数据 ，写成一个hash结构</p><p>Lock{</p><p>​    id + <strong>“:”</strong> + threadId :  1</p><p>}</p><p>如果当前这把锁存在，则第一个条件不满足，再判断</p><p>redis.call(‘hexists’, KEYS[1], ARGV[2]) &#x3D;&#x3D; 1</p><p>此时需要通过大key+小key判断当前这把锁是否是属于自己的，如果是自己的，则进行</p><p>redis.call(‘hincrby’, KEYS[1], ARGV[2], 1)</p><p>将当前这个锁的value进行+1 ，redis.call(‘pexpire’, KEYS[1], ARGV[1]); 然后再对其设置过期时间，如果以上两个条件都不满足，则表示当前这把锁抢锁失败，最后返回pttl，即为当前这把锁的失效时间</p><p>如果小伙帮们看了前边的源码， 你会发现他会去判断当前这个方法的返回值是否为null，如果是null，则对应则前两个if对应的条件，退出抢锁逻辑，如果返回的不是null，即走了第三个分支，在源码处会进行while(true)的自旋抢锁。</p><pre><code class="lua">&quot;if (redis.call(&#39;exists&#39;, KEYS[1]) == 0) then &quot; +                  &quot;redis.call(&#39;hset&#39;, KEYS[1], ARGV[2], 1); &quot; +                  &quot;redis.call(&#39;pexpire&#39;, KEYS[1], ARGV[1]); &quot; +                  &quot;return nil; &quot; +              &quot;end; &quot; +              &quot;if (redis.call(&#39;hexists&#39;, KEYS[1], ARGV[2]) == 1) then &quot; +                  &quot;redis.call(&#39;hincrby&#39;, KEYS[1], ARGV[2], 1); &quot; +                  &quot;redis.call(&#39;pexpire&#39;, KEYS[1], ARGV[1]); &quot; +                  &quot;return nil; &quot; +              &quot;end; &quot; +              &quot;return redis.call(&#39;pttl&#39;, KEYS[1]);&quot;</code></pre><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653548087334.png" alt="1653548087334"></p><h3 id="5-4-分布式锁-redission锁重试和WatchDog机制"><a href="#5-4-分布式锁-redission锁重试和WatchDog机制" class="headerlink" title="5.4 分布式锁-redission锁重试和WatchDog机制"></a>5.4 分布式锁-redission锁重试和WatchDog机制</h3><p><strong>说明</strong>：由于课程中已经说明了有关tryLock的源码解析以及其看门狗原理，所以笔者在这里给大家分析lock()方法的源码解析，希望大家在学习过程中，能够掌握更多的知识</p><p>抢锁过程中，获得当前线程，通过tryAcquire进行抢锁，该抢锁逻辑和之前逻辑相同</p><p>1、先判断当前这把锁是否存在，如果不存在，插入一把锁，返回null</p><p>2、判断当前这把锁是否是属于当前线程，如果是，则返回null</p><p>所以如果返回是null，则代表着当前这哥们已经抢锁完毕，或者可重入完毕，但是如果以上两个条件都不满足，则进入到第三个条件，返回的是锁的失效时间，同学们可以自行往下翻一点点，你能发现有个while( true) 再次进行tryAcquire进行抢锁</p><pre><code class="java">long threadId = Thread.currentThread().getId();Long ttl = tryAcquire(-1, leaseTime, unit, threadId);// lock acquiredif (ttl == null) &#123;    return;&#125;</code></pre><p>接下来会有一个条件分支，因为lock方法有重载方法，一个是带参数，一个是不带参数，如果带带参数传入的值是-1，如果传入参数，则leaseTime是他本身，所以如果传入了参数，此时leaseTime !&#x3D; -1 则会进去抢锁，抢锁的逻辑就是之前说的那三个逻辑</p><pre><code class="java">if (leaseTime != -1) &#123;    return tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_LONG);&#125;</code></pre><p>如果是没有传入时间，则此时也会进行抢锁， 而且抢锁时间是默认看门狗时间 commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout()</p><p>ttlRemainingFuture.onComplete((ttlRemaining, e) 这句话相当于对以上抢锁进行了监听，也就是说当上边抢锁完毕后，此方法会被调用，具体调用的逻辑就是去后台开启一个线程，进行续约逻辑，也就是看门狗线程</p><pre><code class="java">RFuture&lt;Long&gt; ttlRemainingFuture = tryLockInnerAsync(waitTime,                                        commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(),                                        TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;    if (e != null) &#123;        return;    &#125;    // lock acquired    if (ttlRemaining == null) &#123;        scheduleExpirationRenewal(threadId);    &#125;&#125;);return ttlRemainingFuture;</code></pre><p>此逻辑就是续约逻辑，注意看commandExecutor.getConnectionManager().newTimeout（） 此方法</p><p>Method(  <strong>new</strong> TimerTask() {},参数2 ，参数3  )</p><p>指的是：通过参数2，参数3 去描述什么时候去做参数1的事情，现在的情况是：10s之后去做参数一的事情</p><p>因为锁的失效时间是30s，当10s之后，此时这个timeTask 就触发了，他就去进行续约，把当前这把锁续约成30s，如果操作成功，那么此时就会递归调用自己，再重新设置一个timeTask()，于是再过10s后又再设置一个timerTask，完成不停的续约</p><p>那么大家可以想一想，假设我们的线程出现了宕机他还会续约吗？当然不会，因为没有人再去调用renewExpiration这个方法，所以等到时间之后自然就释放了。</p><pre><code class="java">private void renewExpiration() &#123;    ExpirationEntry ee = EXPIRATION_RENEWAL_MAP.get(getEntryName());    if (ee == null) &#123;        return;    &#125;        Timeout task = commandExecutor.getConnectionManager().newTimeout(new TimerTask() &#123;        @Override        public void run(Timeout timeout) throws Exception &#123;            ExpirationEntry ent = EXPIRATION_RENEWAL_MAP.get(getEntryName());            if (ent == null) &#123;                return;            &#125;            Long threadId = ent.getFirstThreadId();            if (threadId == null) &#123;                return;            &#125;                        RFuture&lt;Boolean&gt; future = renewExpirationAsync(threadId);            future.onComplete((res, e) -&gt; &#123;                if (e != null) &#123;                    log.error(&quot;Can&#39;t update lock &quot; + getName() + &quot; expiration&quot;, e);                    return;                &#125;                                if (res) &#123;                    // reschedule itself                    renewExpiration();                &#125;            &#125;);        &#125;    &#125;, internalLockLeaseTime / 3, TimeUnit.MILLISECONDS);        ee.setTimeout(task);&#125;</code></pre><h3 id="5-5-分布式锁-redission锁的MutiLock原理"><a href="#5-5-分布式锁-redission锁的MutiLock原理" class="headerlink" title="5.5 分布式锁-redission锁的MutiLock原理"></a>5.5 分布式锁-redission锁的MutiLock原理</h3><p>为了提高redis的可用性，我们会搭建集群或者主从，现在以主从为例</p><p>此时我们去写命令，写在主机上， 主机会将数据同步给从机，但是假设在主机还没有来得及把数据写入到从机去的时候，此时主机宕机，哨兵会发现主机宕机，并且选举一个slave变成master，而此时新的master中实际上并没有锁信息，此时锁信息就已经丢掉了。</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653553998403.png" alt="1653553998403"></p><p>为了解决这个问题，redission提出来了MutiLock锁，使用这把锁咱们就不使用主从了，每个节点的地位都是一样的， 这把锁加锁的逻辑需要写入到每一个主丛节点上，只有所有的服务器都写入成功，此时才是加锁成功，假设现在某个节点挂了，那么他去获得锁的时候，只要有一个节点拿不到，都不能算是加锁成功，就保证了加锁的可靠性。</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653554055048.png" alt="1653554055048"></p><p>那么MutiLock 加锁原理是什么呢？笔者画了一幅图来说明</p><p>当我们去设置了多个锁时，redission会将多个锁添加到一个集合中，然后用while循环去不停去尝试拿锁，但是会有一个总共的加锁时间，这个时间是用需要加锁的个数 * 1500ms ，假设有3个锁，那么时间就是4500ms，假设在这4500ms内，所有的锁都加锁成功， 那么此时才算是加锁成功，如果在4500ms有线程加锁失败，则会再次去进行重试.</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653553093967.png" alt="1653553093967"></p><h2 id="6、秒杀优化"><a href="#6、秒杀优化" class="headerlink" title="6、秒杀优化"></a>6、秒杀优化</h2><h3 id="6-1-秒杀优化-异步秒杀思路"><a href="#6-1-秒杀优化-异步秒杀思路" class="headerlink" title="6.1 秒杀优化-异步秒杀思路"></a>6.1 秒杀优化-异步秒杀思路</h3><p>我们来回顾一下下单流程</p><p>当用户发起请求，此时会请求nginx，nginx会访问到tomcat，而tomcat中的程序，会进行串行操作，分成如下几个步骤</p><p>1、查询优惠卷</p><p>2、判断秒杀库存是否足够</p><p>3、查询订单</p><p>4、校验是否是一人一单</p><p>5、扣减库存</p><p>6、创建订单</p><p>在这六步操作中，又有很多操作是要去操作数据库的，而且还是一个线程串行执行， 这样就会导致我们的程序执行的很慢，所以我们需要异步程序执行，那么如何加速呢？</p><p>在这里笔者想给大家分享一下课程内没有的思路，看看有没有小伙伴这么想，比如，我们可以不可以使用异步编排来做，或者说我开启N多线程，N多个线程，一个线程执行查询优惠卷，一个执行判断扣减库存，一个去创建订单等等，然后再统一做返回，这种做法和课程中有哪种好呢？答案是课程中的好，因为如果你采用我刚说的方式，如果访问的人很多，那么线程池中的线程可能一下子就被消耗完了，而且你使用上述方案，最大的特点在于，你觉得时效性会非常重要，但是你想想是吗？并不是，比如我只要确定他能做这件事，然后我后边慢慢做就可以了，我并不需要他一口气做完这件事，所以我们应当采用的是课程中，类似消息队列的方式来完成我们的需求，而不是使用线程池或者是异步编排的方式来完成这个需求</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653560986599.png" alt="1653560986599"></p><p>优化方案：我们将耗时比较短的逻辑判断放入到redis中，比如是否库存足够，比如是否一人一单，这样的操作，只要这种逻辑可以完成，就意味着我们是一定可以下单完成的，我们只需要进行快速的逻辑判断，根本就不用等下单逻辑走完，我们直接给用户返回成功， 再在后台开一个线程，后台线程慢慢的去执行queue里边的消息，这样程序不就超级快了吗？而且也不用担心线程池消耗殆尽的问题，因为这里我们的程序中并没有手动使用任何线程池，当然这里边有两个难点</p><p>第一个难点是我们怎么在redis中去快速校验一人一单，还有库存判断</p><p>第二个难点是由于我们校验和tomct下单是两个线程，那么我们如何知道到底哪个单他最后是否成功，或者是下单完成，为了完成这件事我们在redis操作完之后，我们会将一些信息返回给前端，同时也会把这些信息丢到异步queue中去，后续操作中，可以通过这个id来查询我们tomcat中的下单逻辑是否完成了。</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653561657295.png" alt="1653561657295"></p><p>我们现在来看看整体思路：当用户下单之后，判断库存是否充足只需要导redis中去根据key找对应的value是否大于0即可，如果不充足，则直接结束，如果充足，继续在redis中判断用户是否可以下单，如果set集合中没有这条数据，说明他可以下单，如果set集合中没有这条记录，则将userId和优惠卷存入到redis中，并且返回0，整个过程需要保证是原子性的，我们可以使用lua来操作</p><p>当以上判断逻辑走完之后，我们可以判断当前redis中返回的结果是否是0 ，如果是0，则表示可以下单，则将之前说的信息存入到到queue中去，然后返回，然后再来个线程异步的下单，前端可以通过返回的订单id来判断是否下单成功。</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653562234886.png" alt="1653562234886"></p><h3 id="6-2-秒杀优化-Redis完成秒杀资格判断"><a href="#6-2-秒杀优化-Redis完成秒杀资格判断" class="headerlink" title="6.2 秒杀优化-Redis完成秒杀资格判断"></a>6.2 秒杀优化-Redis完成秒杀资格判断</h3><p>需求：</p><ul><li><p>新增秒杀优惠券的同时，将优惠券信息保存到Redis中</p></li><li><p>基于Lua脚本，判断秒杀库存、一人一单，决定用户是否抢购成功</p></li><li><p>如果抢购成功，将优惠券id和用户id封装后存入阻塞队列</p></li><li><p>开启线程任务，不断从阻塞队列中获取信息，实现异步下单功能</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1656080546603.png" alt="1656080546603"></p></li></ul><p>VoucherServiceImpl</p><pre><code class="java">@Override@Transactionalpublic void addSeckillVoucher(Voucher voucher) &#123;    // 保存优惠券    save(voucher);    // 保存秒杀信息    SeckillVoucher seckillVoucher = new SeckillVoucher();    seckillVoucher.setVoucherId(voucher.getId());    seckillVoucher.setStock(voucher.getStock());    seckillVoucher.setBeginTime(voucher.getBeginTime());    seckillVoucher.setEndTime(voucher.getEndTime());    seckillVoucherService.save(seckillVoucher);    // 保存秒杀库存到Redis中    //SECKILL_STOCK_KEY 这个变量定义在RedisConstans中    //private static final String SECKILL_STOCK_KEY =&quot;seckill:stock:&quot;    stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString());&#125;</code></pre><p>完整lua表达式</p><pre><code class="lua">-- 1.参数列表-- 1.1.优惠券idlocal voucherId = ARGV[1]-- 1.2.用户idlocal userId = ARGV[2]-- 1.3.订单idlocal orderId = ARGV[3]-- 2.数据key-- 2.1.库存keylocal stockKey = &#39;seckill:stock:&#39; .. voucherId-- 2.2.订单keylocal orderKey = &#39;seckill:order:&#39; .. voucherId-- 3.脚本业务-- 3.1.判断库存是否充足 get stockKeyif(tonumber(redis.call(&#39;get&#39;, stockKey)) &lt;= 0) then    -- 3.2.库存不足，返回1    return 1end-- 3.2.判断用户是否下单 SISMEMBER orderKey userIdif(redis.call(&#39;sismember&#39;, orderKey, userId) == 1) then    -- 3.3.存在，说明是重复下单，返回2    return 2end-- 3.4.扣库存 incrby stockKey -1redis.call(&#39;incrby&#39;, stockKey, -1)-- 3.5.下单（保存用户）sadd orderKey userIdredis.call(&#39;sadd&#39;, orderKey, userId)-- 3.6.发送消息到队列中， XADD stream.orders * k1 v1 k2 v2 ...redis.call(&#39;xadd&#39;, &#39;stream.orders&#39;, &#39;*&#39;, &#39;userId&#39;, userId, &#39;voucherId&#39;, voucherId, &#39;id&#39;, orderId)return 0</code></pre><p>当以上lua表达式执行完毕后，剩下的就是根据步骤3,4来执行我们接下来的任务了</p><p>VoucherOrderServiceImpl</p><pre><code class="java">@Overridepublic Result seckillVoucher(Long voucherId) &#123;    //获取用户    Long userId = UserHolder.getUser().getId();    long orderId = redisIdWorker.nextId(&quot;order&quot;);    // 1.执行lua脚本    Long result = stringRedisTemplate.execute(            SECKILL_SCRIPT,            Collections.emptyList(),            voucherId.toString(), userId.toString(), String.valueOf(orderId)    );    int r = result.intValue();    // 2.判断结果是否为0    if (r != 0) &#123;        // 2.1.不为0 ，代表没有购买资格        return Result.fail(r == 1 ? &quot;库存不足&quot; : &quot;不能重复下单&quot;);    &#125;    //TODO 保存阻塞队列    // 3.返回订单id    return Result.ok(orderId);&#125;</code></pre><h3 id="6-3-秒杀优化-基于阻塞队列实现秒杀优化"><a href="#6-3-秒杀优化-基于阻塞队列实现秒杀优化" class="headerlink" title="6.3 秒杀优化-基于阻塞队列实现秒杀优化"></a>6.3 秒杀优化-基于阻塞队列实现秒杀优化</h3><p>VoucherOrderServiceImpl</p><p>修改下单动作，现在我们去下单时，是通过lua表达式去原子执行判断逻辑，如果判断我出来不为0 ，则要么是库存不足，要么是重复下单，返回错误信息，如果是0，则把下单的逻辑保存到队列中去，然后异步执行</p><pre><code class="java">//异步处理线程池private static final ExecutorService SECKILL_ORDER_EXECUTOR = Executors.newSingleThreadExecutor();//在类初始化之后执行，因为当这个类初始化好了之后，随时都是有可能要执行的@PostConstructprivate void init() &#123;   SECKILL_ORDER_EXECUTOR.submit(new VoucherOrderHandler());&#125;// 用于线程池处理的任务// 当初始化完毕后，就会去从对列中去拿信息 private class VoucherOrderHandler implements Runnable&#123;        @Override        public void run() &#123;            while (true)&#123;                try &#123;                    // 1.获取队列中的订单信息                    VoucherOrder voucherOrder = orderTasks.take();                    // 2.创建订单                    handleVoucherOrder(voucherOrder);                &#125; catch (Exception e) &#123;                    log.error(&quot;处理订单异常&quot;, e);                &#125;               &#125;        &#125;            private void handleVoucherOrder(VoucherOrder voucherOrder) &#123;            //1.获取用户            Long userId = voucherOrder.getUserId();            // 2.创建锁对象            RLock redisLock = redissonClient.getLock(&quot;lock:order:&quot; + userId);            // 3.尝试获取锁            boolean isLock = redisLock.lock();            // 4.判断是否获得锁成功            if (!isLock) &#123;                // 获取锁失败，直接返回失败或者重试                log.error(&quot;不允许重复下单！&quot;);                return;            &#125;            try &#123;                //注意：由于是spring的事务是放在threadLocal中，此时的是多线程，事务会失效                proxy.createVoucherOrder(voucherOrder);            &#125; finally &#123;                // 释放锁                redisLock.unlock();            &#125;    &#125;     //a    private BlockingQueue&lt;VoucherOrder&gt; orderTasks =new  ArrayBlockingQueue&lt;&gt;(1024 * 1024);    @Override    public Result seckillVoucher(Long voucherId) &#123;        Long userId = UserHolder.getUser().getId();        long orderId = redisIdWorker.nextId(&quot;order&quot;);        // 1.执行lua脚本        Long result = stringRedisTemplate.execute(                SECKILL_SCRIPT,                Collections.emptyList(),                voucherId.toString(), userId.toString(), String.valueOf(orderId)        );        int r = result.intValue();        // 2.判断结果是否为0        if (r != 0) &#123;            // 2.1.不为0 ，代表没有购买资格            return Result.fail(r == 1 ? &quot;库存不足&quot; : &quot;不能重复下单&quot;);        &#125;        VoucherOrder voucherOrder = new VoucherOrder();        // 2.3.订单id        long orderId = redisIdWorker.nextId(&quot;order&quot;);        voucherOrder.setId(orderId);        // 2.4.用户id        voucherOrder.setUserId(userId);        // 2.5.代金券id        voucherOrder.setVoucherId(voucherId);        // 2.6.放入阻塞队列        orderTasks.add(voucherOrder);        //3.获取代理对象         proxy = (IVoucherOrderService)AopContext.currentProxy();        //4.返回订单id        return Result.ok(orderId);    &#125;           @Transactional    public  void createVoucherOrder(VoucherOrder voucherOrder) &#123;        Long userId = voucherOrder.getUserId();        // 5.1.查询订单        int count = query().eq(&quot;user_id&quot;, userId).eq(&quot;voucher_id&quot;, voucherOrder.getVoucherId()).count();        // 5.2.判断是否存在        if (count &gt; 0) &#123;            // 用户已经购买过了           log.error(&quot;用户已经购买过了&quot;);           return ;        &#125;        // 6.扣减库存        boolean success = seckillVoucherService.update()                .setSql(&quot;stock = stock - 1&quot;) // set stock = stock - 1                .eq(&quot;voucher_id&quot;, voucherOrder.getVoucherId()).gt(&quot;stock&quot;, 0) // where id = ? and stock &gt; 0                .update();        if (!success) &#123;            // 扣减失败            log.error(&quot;库存不足&quot;);            return ;        &#125;        save(voucherOrder);     &#125;</code></pre><p><strong>小总结：</strong></p><p>秒杀业务的优化思路是什么？</p><ul><li>先利用Redis完成库存余量、一人一单判断，完成抢单业务</li><li>再将下单业务放入阻塞队列，利用独立线程异步下单</li><li>基于阻塞队列的异步秒杀存在哪些问题？<ul><li>内存限制问题</li><li>数据安全问题</li></ul></li></ul><h2 id="7、Redis消息队列"><a href="#7、Redis消息队列" class="headerlink" title="7、Redis消息队列"></a>7、Redis消息队列</h2><h3 id="7-1-Redis消息队列-认识消息队列"><a href="#7-1-Redis消息队列-认识消息队列" class="headerlink" title="7.1 Redis消息队列-认识消息队列"></a>7.1 Redis消息队列-认识消息队列</h3><p>什么是消息队列：字面意思就是存放消息的队列。最简单的消息队列模型包括3个角色：</p><ul><li>消息队列：存储和管理消息，也被称为消息代理（Message Broker）</li><li>生产者：发送消息到消息队列</li><li>消费者：从消息队列获取消息并处理消息</li></ul><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653574849336.png" alt="1653574849336"></p><p>使用队列的好处在于 <strong>解耦：</strong>所谓解耦，举一个生活中的例子就是：快递员(生产者)把快递放到快递柜里边(Message Queue)去，我们(消费者)从快递柜里边去拿东西，这就是一个异步，如果耦合，那么这个快递员相当于直接把快递交给你，这事固然好，但是万一你不在家，那么快递员就会一直等你，这就浪费了快递员的时间，所以这种思想在我们日常开发中，是非常有必要的。</p><p>这种场景在我们秒杀中就变成了：我们下单之后，利用redis去进行校验下单条件，再通过队列把消息发送出去，然后再启动一个线程去消费这个消息，完成解耦，同时也加快我们的响应速度。</p><p>这里我们可以使用一些现成的mq，比如kafka，rabbitmq等等，但是呢，如果没有安装mq，我们也可以直接使用redis提供的mq方案，降低我们的部署和学习成本。</p><h3 id="7-2-Redis消息队列-基于List实现消息队列"><a href="#7-2-Redis消息队列-基于List实现消息队列" class="headerlink" title="7.2 Redis消息队列-基于List实现消息队列"></a>7.2 Redis消息队列-基于List实现消息队列</h3><p><strong>基于List结构模拟消息队列</strong></p><p>消息队列（Message Queue），字面意思就是存放消息的队列。而Redis的list数据结构是一个双向链表，很容易模拟出队列效果。</p><p>队列是入口和出口不在一边，因此我们可以利用：LPUSH 结合 RPOP、或者 RPUSH 结合 LPOP来实现。<br>不过要注意的是，当队列中没有消息时RPOP或LPOP操作会返回null，并不像JVM的阻塞队列那样会阻塞并等待消息。因此这里应该使用BRPOP或者BLPOP来实现阻塞效果。</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653575176451.png" alt="1653575176451"></p><p>基于List的消息队列有哪些优缺点？<br>优点：</p><ul><li>利用Redis存储，不受限于JVM内存上限</li><li>基于Redis的持久化机制，数据安全性有保证</li><li>可以满足消息有序性</li></ul><p>缺点：</p><ul><li>无法避免消息丢失</li><li>只支持单消费者</li></ul><h3 id="7-3-Redis消息队列-基于PubSub的消息队列"><a href="#7-3-Redis消息队列-基于PubSub的消息队列" class="headerlink" title="7.3 Redis消息队列-基于PubSub的消息队列"></a>7.3 Redis消息队列-基于PubSub的消息队列</h3><p>PubSub（发布订阅）是Redis2.0版本引入的消息传递模型。顾名思义，消费者可以订阅一个或多个channel，生产者向对应channel发送消息后，所有订阅者都能收到相关消息。</p><p> SUBSCRIBE channel [channel] ：订阅一个或多个频道<br> PUBLISH channel msg ：向一个频道发送消息<br> PSUBSCRIBE pattern[pattern] ：订阅与pattern格式匹配的所有频道</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653575506373.png" alt="1653575506373"></p><p>基于PubSub的消息队列有哪些优缺点？<br>优点：</p><ul><li>采用发布订阅模型，支持多生产、多消费</li></ul><p>缺点：</p><ul><li>不支持数据持久化</li><li>无法避免消息丢失</li><li>消息堆积有上限，超出时数据丢失</li></ul><h3 id="7-4-Redis消息队列-基于Stream的消息队列"><a href="#7-4-Redis消息队列-基于Stream的消息队列" class="headerlink" title="7.4 Redis消息队列-基于Stream的消息队列"></a>7.4 Redis消息队列-基于Stream的消息队列</h3><p>Stream 是 Redis 5.0 引入的一种新数据类型，可以实现一个功能非常完善的消息队列。</p><p>发送消息的命令：</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653577301737.png" alt="1653577301737"></p><p>例如：</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653577349691.png" alt="1653577349691"></p><p>读取消息的方式之一：XREAD</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653577445413.png" alt="1653577445413"></p><p>例如，使用XREAD读取第一个消息：</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653577643629.png" alt="1653577643629"></p><p>XREAD阻塞方式，读取最新的消息：</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653577659166.png" alt="1653577659166"></p><p>在业务开发中，我们可以循环的调用XREAD阻塞方式来查询最新消息，从而实现持续监听队列的效果，伪代码如下</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653577689129.png" alt="1653577689129"></p><p>注意：当我们指定起始ID为$时，代表读取最新的消息，如果我们处理一条消息的过程中，又有超过1条以上的消息到达队列，则下次获取时也只能获取到最新的一条，会出现漏读消息的问题</p><p>STREAM类型消息队列的XREAD命令特点：</p><ul><li>消息可回溯</li><li>一个消息可以被多个消费者读取</li><li>可以阻塞读取</li><li>有消息漏读的风险</li></ul><h3 id="7-5-Redis消息队列-基于Stream的消息队列-消费者组"><a href="#7-5-Redis消息队列-基于Stream的消息队列-消费者组" class="headerlink" title="7.5 Redis消息队列-基于Stream的消息队列-消费者组"></a>7.5 Redis消息队列-基于Stream的消息队列-消费者组</h3><p>消费者组（Consumer Group）：将多个消费者划分到一个组中，监听同一个队列。具备下列特点：</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653577801668.png" alt="1653577801668"></p><p>创建消费者组：<br><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653577984924.png" alt="1653577984924"><br>key：队列名称<br>groupName：消费者组名称<br>ID：起始ID标示，$代表队列中最后一个消息，0则代表队列中第一个消息<br>MKSTREAM：队列不存在时自动创建队列<br>其它常见命令：</p><p> <strong>删除指定的消费者组</strong></p><pre><code class="java">XGROUP DESTORY key groupName</code></pre><p> <strong>给指定的消费者组添加消费者</strong></p><pre><code class="java">XGROUP CREATECONSUMER key groupname consumername</code></pre><p> <strong>删除消费者组中的指定消费者</strong></p><pre><code class="java">XGROUP DELCONSUMER key groupname consumername</code></pre><p>从消费者组读取消息：</p><pre><code class="java">XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] ID [ID ...]</code></pre><ul><li>group：消费组名称</li><li>consumer：消费者名称，如果消费者不存在，会自动创建一个消费者</li><li>count：本次查询的最大数量</li><li>BLOCK milliseconds：当没有消息时最长等待时间</li><li>NOACK：无需手动ACK，获取到消息后自动确认</li><li>STREAMS key：指定队列名称</li><li>ID：获取消息的起始ID：</li></ul><p>“&gt;”：从下一个未消费的消息开始<br>其它：根据指定id从pending-list中获取已消费但未确认的消息，例如0，是从pending-list中的第一个消息开始</p><p>消费者监听消息的基本思路：</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653578211854.png" alt="1653578211854">STREAM类型消息队列的XREADGROUP命令特点：</p><ul><li>消息可回溯</li><li>可以多消费者争抢消息，加快消费速度</li><li>可以阻塞读取</li><li>没有消息漏读的风险</li><li>有消息确认机制，保证消息至少被消费一次</li></ul><p>最后我们来个小对比</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653578560691.png" alt="1653578560691"></p><h3 id="7-6-基于Redis的Stream结构作为消息队列，实现异步秒杀下单"><a href="#7-6-基于Redis的Stream结构作为消息队列，实现异步秒杀下单" class="headerlink" title="7.6 基于Redis的Stream结构作为消息队列，实现异步秒杀下单"></a>7.6 基于Redis的Stream结构作为消息队列，实现异步秒杀下单</h3><p>需求：</p><ul><li>创建一个Stream类型的消息队列，名为stream.orders</li><li>修改之前的秒杀下单Lua脚本，在认定有抢购资格后，直接向stream.orders中添加消息，内容包含voucherId、userId、orderId</li><li>项目启动时，开启一个线程任务，尝试获取stream.orders中的消息，完成下单\</li></ul><p>修改lua表达式,新增3.6 </p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1656082824939.png" alt="1656082824939"></p><p>VoucherOrderServiceImpl</p><pre><code class="java">private class VoucherOrderHandler implements Runnable &#123;    @Override    public void run() &#123;        while (true) &#123;            try &#123;                // 1.获取消息队列中的订单信息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 &gt;                List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(                    Consumer.from(&quot;g1&quot;, &quot;c1&quot;),                    StreamReadOptions.empty().count(1).block(Duration.ofSeconds(2)),                    StreamOffset.create(&quot;stream.orders&quot;, ReadOffset.lastConsumed())                );                // 2.判断订单信息是否为空                if (list == null || list.isEmpty()) &#123;                    // 如果为null，说明没有消息，继续下一次循环                    continue;                &#125;                // 解析数据                MapRecord&lt;String, Object, Object&gt; record = list.get(0);                Map&lt;Object, Object&gt; value = record.getValue();                VoucherOrder voucherOrder = BeanUtil.fillBeanWithMap(value, new VoucherOrder(), true);                // 3.创建订单                createVoucherOrder(voucherOrder);                // 4.确认消息 XACK                stringRedisTemplate.opsForStream().acknowledge(&quot;s1&quot;, &quot;g1&quot;, record.getId());            &#125; catch (Exception e) &#123;                log.error(&quot;处理订单异常&quot;, e);                //处理异常消息                handlePendingList();            &#125;        &#125;    &#125;    private void handlePendingList() &#123;        while (true) &#123;            try &#123;                // 1.获取pending-list中的订单信息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 0                List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(                    Consumer.from(&quot;g1&quot;, &quot;c1&quot;),                    StreamReadOptions.empty().count(1),                    StreamOffset.create(&quot;stream.orders&quot;, ReadOffset.from(&quot;0&quot;))                );                // 2.判断订单信息是否为空                if (list == null || list.isEmpty()) &#123;                    // 如果为null，说明没有异常消息，结束循环                    break;                &#125;                // 解析数据                MapRecord&lt;String, Object, Object&gt; record = list.get(0);                Map&lt;Object, Object&gt; value = record.getValue();                VoucherOrder voucherOrder = BeanUtil.fillBeanWithMap(value, new VoucherOrder(), true);                // 3.创建订单                createVoucherOrder(voucherOrder);                // 4.确认消息 XACK                stringRedisTemplate.opsForStream().acknowledge(&quot;s1&quot;, &quot;g1&quot;, record.getId());            &#125; catch (Exception e) &#123;                log.error(&quot;处理pendding订单异常&quot;, e);                try&#123;                    Thread.sleep(20);                &#125;catch(Exception e)&#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><h2 id="8、达人探店"><a href="#8、达人探店" class="headerlink" title="8、达人探店"></a>8、达人探店</h2><h3 id="8-1、达人探店-发布探店笔记"><a href="#8-1、达人探店-发布探店笔记" class="headerlink" title="8.1、达人探店-发布探店笔记"></a>8.1、达人探店-发布探店笔记</h3><p>发布探店笔记</p><p>探店笔记类似点评网站的评价，往往是图文结合。对应的表有两个：<br>tb_blog：探店笔记表，包含笔记中的标题、文字、图片等<br>tb_blog_comments：其他用户对探店笔记的评价</p><p><strong>具体发布流程</strong></p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653578992639.png" alt="1653578992639"></p><p>上传接口</p><pre><code class="java">@Slf4j@RestController@RequestMapping(&quot;upload&quot;)public class UploadController &#123;    @PostMapping(&quot;blog&quot;)    public Result uploadImage(@RequestParam(&quot;file&quot;) MultipartFile image) &#123;        try &#123;            // 获取原始文件名称            String originalFilename = image.getOriginalFilename();            // 生成新文件名            String fileName = createNewFileName(originalFilename);            // 保存文件            image.transferTo(new File(SystemConstants.IMAGE_UPLOAD_DIR, fileName));            // 返回结果            log.debug(&quot;文件上传成功，&#123;&#125;&quot;, fileName);            return Result.ok(fileName);        &#125; catch (IOException e) &#123;            throw new RuntimeException(&quot;文件上传失败&quot;, e);        &#125;    &#125;&#125;</code></pre><p>注意：同学们在操作时，需要修改SystemConstants.IMAGE_UPLOAD_DIR 自己图片所在的地址，在实际开发中图片一般会放在nginx上或者是云存储上。</p><p>BlogController</p><pre><code class="java">@RestController@RequestMapping(&quot;/blog&quot;)public class BlogController &#123;    @Resource    private IBlogService blogService;    @PostMapping    public Result saveBlog(@RequestBody Blog blog) &#123;        //获取登录用户        UserDTO user = UserHolder.getUser();        blog.setUpdateTime(user.getId());        //保存探店博文        blogService.saveBlog(blog);        //返回id        return Result.ok(blog.getId());    &#125;&#125;</code></pre><h3 id="8-2-达人探店-查看探店笔记"><a href="#8-2-达人探店-查看探店笔记" class="headerlink" title="8.2 达人探店-查看探店笔记"></a>8.2 达人探店-查看探店笔记</h3><p>实现查看发布探店笔记的接口</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653579931626.png" alt="1653579931626"></p><p>实现代码：</p><p>BlogServiceImpl</p><pre><code class="java">@Overridepublic Result queryBlogById(Long id) &#123;    // 1.查询blog    Blog blog = getById(id);    if (blog == null) &#123;        return Result.fail(&quot;笔记不存在！&quot;);    &#125;    // 2.查询blog有关的用户    queryBlogUser(blog);      return Result.ok(blog);&#125;</code></pre><h3 id="8-3-达人探店-点赞功能"><a href="#8-3-达人探店-点赞功能" class="headerlink" title="8.3 达人探店-点赞功能"></a>8.3 达人探店-点赞功能</h3><p>初始代码</p><pre><code class="java">@GetMapping(&quot;/likes/&#123;id&#125;&quot;)public Result queryBlogLikes(@PathVariable(&quot;id&quot;) Long id) &#123;    //修改点赞数量    blogService.update().setSql(&quot;liked = liked +1 &quot;).eq(&quot;id&quot;,id).update();    return Result.ok();&#125;</code></pre><p>问题分析：这种方式会导致一个用户无限点赞，明显是不合理的</p><p>造成这个问题的原因是，我们现在的逻辑，发起请求只是给数据库+1，所以才会出现这个问题</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653581590453.png" alt="1653581590453"></p><p>完善点赞功能</p><p>需求：</p><ul><li>同一个用户只能点赞一次，再次点击则取消点赞</li><li>如果当前用户已经点赞，则点赞按钮高亮显示（前端已实现，判断字段Blog类的isLike属性）</li></ul><p>实现步骤：</p><ul><li>给Blog类中添加一个isLike字段，标示是否被当前用户点赞</li><li>修改点赞功能，利用Redis的set集合判断是否点赞过，未点赞过则点赞数+1，已点赞过则点赞数-1</li><li>修改根据id查询Blog的业务，判断当前登录用户是否点赞过，赋值给isLike字段</li><li>修改分页查询Blog业务，判断当前登录用户是否点赞过，赋值给isLike字段</li></ul><p>为什么采用set集合：</p><p>因为我们的数据是不能重复的，当用户操作过之后，无论他怎么操作，都是</p><p>具体步骤：</p><p>1、在Blog 添加一个字段</p><pre><code class="java">@TableField(exist = false)private Boolean isLike;</code></pre><p>2、修改代码</p><pre><code class="java"> @Override    public Result likeBlog(Long id)&#123;        // 1.获取登录用户        Long userId = UserHolder.getUser().getId();        // 2.判断当前登录用户是否已经点赞        String key = BLOG_LIKED_KEY + id;        Boolean isMember = stringRedisTemplate.opsForSet().isMember(key, userId.toString());        if(BooleanUtil.isFalse(isMember))&#123;             //3.如果未点赞，可以点赞            //3.1 数据库点赞数+1            boolean isSuccess = update().setSql(&quot;liked = liked + 1&quot;).eq(&quot;id&quot;, id).update();            //3.2 保存用户到Redis的set集合            if(isSuccess)&#123;                stringRedisTemplate.opsForSet().add(key,userId.toString());            &#125;        &#125;else&#123;             //4.如果已点赞，取消点赞            //4.1 数据库点赞数-1            boolean isSuccess = update().setSql(&quot;liked = liked - 1&quot;).eq(&quot;id&quot;, id).update();            //4.2 把用户从Redis的set集合移除            if(isSuccess)&#123;                stringRedisTemplate.opsForSet().remove(key,userId.toString());            &#125;        &#125;</code></pre><h3 id="8-4-达人探店-点赞排行榜"><a href="#8-4-达人探店-点赞排行榜" class="headerlink" title="8.4 达人探店-点赞排行榜"></a>8.4 达人探店-点赞排行榜</h3><p>在探店笔记的详情页面，应该把给该笔记点赞的人显示出来，比如最早点赞的TOP5，形成点赞排行榜：</p><p>之前的点赞是放到set集合，但是set集合是不能排序的，所以这个时候，咱们可以采用一个可以排序的set集合，就是咱们的sortedSet</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653805077118.png" alt="1653805077118"></p><p>我们接下来来对比一下这些集合的区别是什么</p><p>所有点赞的人，需要是唯一的，所以我们应当使用set或者是sortedSet</p><p>其次我们需要排序，就可以直接锁定使用sortedSet啦</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653805203758.png" alt="1653805203758"></p><p>修改代码</p><p>BlogServiceImpl</p><p>点赞逻辑代码</p><pre><code class="java">   @Override    public Result likeBlog(Long id) &#123;        // 1.获取登录用户        Long userId = UserHolder.getUser().getId();        // 2.判断当前登录用户是否已经点赞        String key = BLOG_LIKED_KEY + id;        Double score = stringRedisTemplate.opsForZSet().score(key, userId.toString());        if (score == null) &#123;            // 3.如果未点赞，可以点赞            // 3.1.数据库点赞数 + 1            boolean isSuccess = update().setSql(&quot;liked = liked + 1&quot;).eq(&quot;id&quot;, id).update();            // 3.2.保存用户到Redis的set集合  zadd key value score            if (isSuccess) &#123;                stringRedisTemplate.opsForZSet().add(key, userId.toString(), System.currentTimeMillis());            &#125;        &#125; else &#123;            // 4.如果已点赞，取消点赞            // 4.1.数据库点赞数 -1            boolean isSuccess = update().setSql(&quot;liked = liked - 1&quot;).eq(&quot;id&quot;, id).update();            // 4.2.把用户从Redis的set集合移除            if (isSuccess) &#123;                stringRedisTemplate.opsForZSet().remove(key, userId.toString());            &#125;        &#125;        return Result.ok();    &#125;    private void isBlogLiked(Blog blog) &#123;        // 1.获取登录用户        UserDTO user = UserHolder.getUser();        if (user == null) &#123;            // 用户未登录，无需查询是否点赞            return;        &#125;        Long userId = user.getId();        // 2.判断当前登录用户是否已经点赞        String key = &quot;blog:liked:&quot; + blog.getId();        Double score = stringRedisTemplate.opsForZSet().score(key, userId.toString());        blog.setIsLike(score != null);    &#125;</code></pre><p>点赞列表查询列表</p><p>BlogController</p><pre><code class="java">@GetMapping(&quot;/likes/&#123;id&#125;&quot;)public Result queryBlogLikes(@PathVariable(&quot;id&quot;) Long id) &#123;    return blogService.queryBlogLikes(id);&#125;</code></pre><p>BlogService</p><pre><code class="java">@Overridepublic Result queryBlogLikes(Long id) &#123;    String key = BLOG_LIKED_KEY + id;    // 1.查询top5的点赞用户 zrange key 0 4    Set&lt;String&gt; top5 = stringRedisTemplate.opsForZSet().range(key, 0, 4);    if (top5 == null || top5.isEmpty()) &#123;        return Result.ok(Collections.emptyList());    &#125;    // 2.解析出其中的用户id    List&lt;Long&gt; ids = top5.stream().map(Long::valueOf).collect(Collectors.toList());    String idStr = StrUtil.join(&quot;,&quot;, ids);    // 3.根据用户id查询用户 WHERE id IN ( 5 , 1 ) ORDER BY FIELD(id, 5, 1)    List&lt;UserDTO&gt; userDTOS = userService.query()            .in(&quot;id&quot;, ids).last(&quot;ORDER BY FIELD(id,&quot; + idStr + &quot;)&quot;).list()            .stream()            .map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class))            .collect(Collectors.toList());    // 4.返回    return Result.ok(userDTOS);&#125;</code></pre><h2 id="9、好友关注"><a href="#9、好友关注" class="headerlink" title="9、好友关注"></a>9、好友关注</h2><h3 id="9-1-好友关注-关注和取消关注"><a href="#9-1-好友关注-关注和取消关注" class="headerlink" title="9.1 好友关注-关注和取消关注"></a>9.1 好友关注-关注和取消关注</h3><p>针对用户的操作：可以对用户进行关注和取消关注功能。</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653806140822.png" alt="1653806140822"></p><p>实现思路：</p><p>需求：基于该表数据结构，实现两个接口：</p><ul><li>关注和取关接口</li><li>判断是否关注的接口</li></ul><p>关注是User之间的关系，是博主与粉丝的关系，数据库中有一张tb_follow表来标示：</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653806253817.png" alt="1653806253817"></p><p>注意: 这里需要把主键修改为自增长，简化开发。</p><p>FollowController</p><pre><code class="java">//关注@PutMapping(&quot;/&#123;id&#125;/&#123;isFollow&#125;&quot;)public Result follow(@PathVariable(&quot;id&quot;) Long followUserId, @PathVariable(&quot;isFollow&quot;) Boolean isFollow) &#123;    return followService.follow(followUserId, isFollow);&#125;//取消关注@GetMapping(&quot;/or/not/&#123;id&#125;&quot;)public Result isFollow(@PathVariable(&quot;id&quot;) Long followUserId) &#123;      return followService.isFollow(followUserId);&#125;</code></pre><p>FollowService</p><pre><code class="java">取消关注service@Overridepublic Result isFollow(Long followUserId) &#123;        // 1.获取登录用户        Long userId = UserHolder.getUser().getId();        // 2.查询是否关注 select count(*) from tb_follow where user_id = ? and follow_user_id = ?        Integer count = query().eq(&quot;user_id&quot;, userId).eq(&quot;follow_user_id&quot;, followUserId).count();        // 3.判断        return Result.ok(count &gt; 0);    &#125; 关注service @Override    public Result follow(Long followUserId, Boolean isFollow) &#123;        // 1.获取登录用户        Long userId = UserHolder.getUser().getId();        String key = &quot;follows:&quot; + userId;        // 1.判断到底是关注还是取关        if (isFollow) &#123;            // 2.关注，新增数据            Follow follow = new Follow();            follow.setUserId(userId);            follow.setFollowUserId(followUserId);            boolean isSuccess = save(follow);        &#125; else &#123;            // 3.取关，删除 delete from tb_follow where user_id = ? and follow_user_id = ?            remove(new QueryWrapper&lt;Follow&gt;()                    .eq(&quot;user_id&quot;, userId).eq(&quot;follow_user_id&quot;, followUserId));        &#125;        return Result.ok();    &#125;</code></pre><h3 id="9-2-好友关注-共同关注"><a href="#9-2-好友关注-共同关注" class="headerlink" title="9.2 好友关注-共同关注"></a>9.2 好友关注-共同关注</h3><p>想要去看共同关注的好友，需要首先进入到这个页面，这个页面会发起两个请求</p><p>1、去查询用户的详情</p><p>2、去查询用户的笔记</p><p>以上两个功能和共同关注没有什么关系，大家可以自行将笔记中的代码拷贝到idea中就可以实现这两个功能了，我们的重点在于共同关注功能。</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653806706296.png" alt="1653806706296"></p><pre><code class="java">// UserController 根据id查询用户@GetMapping(&quot;/&#123;id&#125;&quot;)public Result queryUserById(@PathVariable(&quot;id&quot;) Long userId)&#123;    // 查询详情    User user = userService.getById(userId);    if (user == null) &#123;        return Result.ok();    &#125;    UserDTO userDTO = BeanUtil.copyProperties(user, UserDTO.class);    // 返回    return Result.ok(userDTO);&#125;// BlogController  根据id查询博主的探店笔记@GetMapping(&quot;/of/user&quot;)public Result queryBlogByUserId(        @RequestParam(value = &quot;current&quot;, defaultValue = &quot;1&quot;) Integer current,        @RequestParam(&quot;id&quot;) Long id) &#123;    // 根据用户查询    Page&lt;Blog&gt; page = blogService.query()            .eq(&quot;user_id&quot;, id).page(new Page&lt;&gt;(current, SystemConstants.MAX_PAGE_SIZE));    // 获取当前页数据    List&lt;Blog&gt; records = page.getRecords();    return Result.ok(records);&#125;</code></pre><p>接下来我们来看看共同关注如何实现：</p><p>需求：利用Redis中恰当的数据结构，实现共同关注功能。在博主个人页面展示出当前用户与博主的共同关注呢。</p><p>当然是使用我们之前学习过的set集合咯，在set集合中，有交集并集补集的api，我们可以把两人的关注的人分别放入到一个set集合中，然后再通过api去查看这两个set集合中的交集数据。</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653806973212.png" alt="1653806973212"></p><p>我们先来改造当前的关注列表</p><p>改造原因是因为我们需要在用户关注了某位用户后，需要将数据放入到set集合中，方便后续进行共同关注，同时当取消关注时，也需要从set集合中进行删除</p><p>FollowServiceImpl</p><pre><code class="java">@Overridepublic Result follow(Long followUserId, Boolean isFollow) &#123;    // 1.获取登录用户    Long userId = UserHolder.getUser().getId();    String key = &quot;follows:&quot; + userId;    // 1.判断到底是关注还是取关    if (isFollow) &#123;        // 2.关注，新增数据        Follow follow = new Follow();        follow.setUserId(userId);        follow.setFollowUserId(followUserId);        boolean isSuccess = save(follow);        if (isSuccess) &#123;            // 把关注用户的id，放入redis的set集合 sadd userId followerUserId            stringRedisTemplate.opsForSet().add(key, followUserId.toString());        &#125;    &#125; else &#123;        // 3.取关，删除 delete from tb_follow where user_id = ? and follow_user_id = ?        boolean isSuccess = remove(new QueryWrapper&lt;Follow&gt;()                .eq(&quot;user_id&quot;, userId).eq(&quot;follow_user_id&quot;, followUserId));        if (isSuccess) &#123;            // 把关注用户的id从Redis集合中移除            stringRedisTemplate.opsForSet().remove(key, followUserId.toString());        &#125;    &#125;    return Result.ok();&#125;</code></pre><p><strong>具体的关注代码：</strong></p><p>FollowServiceImpl</p><pre><code class="java">@Overridepublic Result followCommons(Long id) &#123;    // 1.获取当前用户    Long userId = UserHolder.getUser().getId();    String key = &quot;follows:&quot; + userId;    // 2.求交集    String key2 = &quot;follows:&quot; + id;    Set&lt;String&gt; intersect = stringRedisTemplate.opsForSet().intersect(key, key2);    if (intersect == null || intersect.isEmpty()) &#123;        // 无交集        return Result.ok(Collections.emptyList());    &#125;    // 3.解析id集合    List&lt;Long&gt; ids = intersect.stream().map(Long::valueOf).collect(Collectors.toList());    // 4.查询用户    List&lt;UserDTO&gt; users = userService.listByIds(ids)            .stream()            .map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class))            .collect(Collectors.toList());    return Result.ok(users);&#125;</code></pre><h3 id="9-3-好友关注-Feed流实现方案"><a href="#9-3-好友关注-Feed流实现方案" class="headerlink" title="9.3 好友关注-Feed流实现方案"></a>9.3 好友关注-Feed流实现方案</h3><p>当我们关注了用户后，这个用户发了动态，那么我们应该把这些数据推送给用户，这个需求，其实我们又把他叫做Feed流，关注推送也叫做Feed流，直译为投喂。为用户持续的提供“沉浸式”的体验，通过无限下拉刷新获取新的信息。</p><p>对于传统的模式的内容解锁：我们是需要用户去通过搜索引擎或者是其他的方式去解锁想要看的内容</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653808641260.png" alt="1653808641260"></p><p>对于新型的Feed流的的效果：不需要我们用户再去推送信息，而是系统分析用户到底想要什么，然后直接把内容推送给用户，从而使用户能够更加的节约时间，不用主动去寻找。</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653808993693.png" alt="1653808993693"></p><p>Feed流的实现有两种模式：</p><p>Feed流产品有两种常见模式：<br>Timeline：不做内容筛选，简单的按照内容发布时间排序，常用于好友或关注。例如朋友圈</p><ul><li>优点：信息全面，不会有缺失。并且实现也相对简单</li><li>缺点：信息噪音较多，用户不一定感兴趣，内容获取效率低</li></ul><p>智能排序：利用智能算法屏蔽掉违规的、用户不感兴趣的内容。推送用户感兴趣信息来吸引用户</p><ul><li>优点：投喂用户感兴趣信息，用户粘度很高，容易沉迷</li><li>缺点：如果算法不精准，可能起到反作用<br>本例中的个人页面，是基于关注的好友来做Feed流，因此采用Timeline的模式。该模式的实现方案有三种：</li></ul><p>我们本次针对好友的操作，采用的就是Timeline的方式，只需要拿到我们关注用户的信息，然后按照时间排序即可</p><p>，因此采用Timeline的模式。该模式的实现方案有三种：</p><ul><li>拉模式</li><li>推模式</li><li>推拉结合</li></ul><p><strong>拉模式</strong>：也叫做读扩散</p><p>该模式的核心含义就是：当张三和李四和王五发了消息后，都会保存在自己的邮箱中，假设赵六要读取信息，那么他会从读取他自己的收件箱，此时系统会从他关注的人群中，把他关注人的信息全部都进行拉取，然后在进行排序</p><p>优点：比较节约空间，因为赵六在读信息时，并没有重复读取，而且读取完之后可以把他的收件箱进行清楚。</p><p>缺点：比较延迟，当用户读取数据时才去关注的人里边去读取数据，假设用户关注了大量的用户，那么此时就会拉取海量的内容，对服务器压力巨大。</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653809450816.png" alt="1653809450816"></p><p><strong>推模式</strong>：也叫做写扩散。</p><p>推模式是没有写邮箱的，当张三写了一个内容，此时会主动的把张三写的内容发送到他的粉丝收件箱中去，假设此时李四再来读取，就不用再去临时拉取了</p><p>优点：时效快，不用临时拉取</p><p>缺点：内存压力大，假设一个大V写信息，很多人关注他， 就会写很多分数据到粉丝那边去</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653809875208.png" alt="1653809875208"></p><p><strong>推拉结合模式</strong>：也叫做读写混合，兼具推和拉两种模式的优点。</p><p>推拉模式是一个折中的方案，站在发件人这一段，如果是个普通的人，那么我们采用写扩散的方式，直接把数据写入到他的粉丝中去，因为普通的人他的粉丝关注量比较小，所以这样做没有压力，如果是大V，那么他是直接将数据先写入到一份到发件箱里边去，然后再直接写一份到活跃粉丝收件箱里边去，现在站在收件人这端来看，如果是活跃粉丝，那么大V和普通的人发的都会直接写入到自己收件箱里边来，而如果是普通的粉丝，由于他们上线不是很频繁，所以等他们上线时，再从发件箱里边去拉信息。</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653812346852.png" alt="1653812346852"></p><h3 id="9-4-好友关注-推送到粉丝收件箱"><a href="#9-4-好友关注-推送到粉丝收件箱" class="headerlink" title="9.4 好友关注-推送到粉丝收件箱"></a>9.4 好友关注-推送到粉丝收件箱</h3><p>需求：</p><ul><li>修改新增探店笔记的业务，在保存blog到数据库的同时，推送到粉丝的收件箱</li><li>收件箱满足可以根据时间戳排序，必须用Redis的数据结构实现</li><li>查询收件箱数据时，可以实现分页查询</li></ul><p>Feed流中的数据会不断更新，所以数据的角标也在变化，因此不能采用传统的分页模式。</p><p>传统了分页在feed流是不适用的，因为我们的数据会随时发生变化</p><p>假设在t1 时刻，我们去读取第一页，此时page &#x3D; 1 ，size &#x3D; 5 ，那么我们拿到的就是10<del>6 这几条记录，假设现在t2时候又发布了一条记录，此时t3 时刻，我们来读取第二页，读取第二页传入的参数是page&#x3D;2 ，size&#x3D;5 ，那么此时读取到的第二页实际上是从6 开始，然后是6</del>2 ，那么我们就读取到了重复的数据，所以feed流的分页，不能采用原始方案来做。</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653813047671.png" alt="1653813047671"></p><p>Feed流的滚动分页</p><p>我们需要记录每次操作的最后一条，然后从这个位置开始去读取数据</p><p>举个例子：我们从t1时刻开始，拿第一页数据，拿到了10~6，然后记录下当前最后一次拿取的记录，就是6，t2时刻发布了新的记录，此时这个11放到最顶上，但是不会影响我们之前记录的6，此时t3时刻来拿第二页，第二页这个时候拿数据，还是从6后一点的5去拿，就拿到了5-1的记录。我们这个地方可以采用sortedSet来做，可以进行范围查询，并且还可以记录当前获取数据时间戳最小值，就可以实现滚动分页了</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653813462834.png" alt="1653813462834"></p><p>核心的意思：就是我们在保存完探店笔记后，获得到当前笔记的粉丝，然后把数据推送到粉丝的redis中去。</p><pre><code class="java">@Overridepublic Result saveBlog(Blog blog) &#123;    // 1.获取登录用户    UserDTO user = UserHolder.getUser();    blog.setUserId(user.getId());    // 2.保存探店笔记    boolean isSuccess = save(blog);    if(!isSuccess)&#123;        return Result.fail(&quot;新增笔记失败!&quot;);    &#125;    // 3.查询笔记作者的所有粉丝 select * from tb_follow where follow_user_id = ?    List&lt;Follow&gt; follows = followService.query().eq(&quot;follow_user_id&quot;, user.getId()).list();    // 4.推送笔记id给所有粉丝    for (Follow follow : follows) &#123;        // 4.1.获取粉丝id        Long userId = follow.getUserId();        // 4.2.推送        String key = FEED_KEY + userId;        stringRedisTemplate.opsForZSet().add(key, blog.getId().toString(), System.currentTimeMillis());    &#125;    // 5.返回id    return Result.ok(blog.getId());&#125;</code></pre><h3 id="9-5好友关注-实现分页查询收邮箱"><a href="#9-5好友关注-实现分页查询收邮箱" class="headerlink" title="9.5好友关注-实现分页查询收邮箱"></a>9.5好友关注-实现分页查询收邮箱</h3><p>需求：在个人主页的“关注”卡片中，查询并展示推送的Blog信息：</p><p>具体操作如下：</p><p>1、每次查询完成后，我们要分析出查询出数据的最小时间戳，这个值会作为下一次查询的条件</p><p>2、我们需要找到与上一次查询相同的查询个数作为偏移量，下次查询时，跳过这些查询过的数据，拿到我们需要的数据</p><p>综上：我们的请求参数中就需要携带 lastId：上一次查询的最小时间戳 和偏移量这两个参数。</p><p>这两个参数第一次会由前端来指定，以后的查询就根据后台结果作为条件，再次传递到后台。</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653819821591.png" alt="1653819821591"></p><p>一、定义出来具体的返回值实体类</p><pre><code class="java">@Datapublic class ScrollResult &#123;    private List&lt;?&gt; list;    private Long minTime;    private Integer offset;&#125;</code></pre><p>BlogController</p><p>注意：RequestParam 表示接受url地址栏传参的注解，当方法上参数的名称和url地址栏不相同时，可以通过RequestParam 来进行指定</p><pre><code class="java">@GetMapping(&quot;/of/follow&quot;)public Result queryBlogOfFollow(    @RequestParam(&quot;lastId&quot;) Long max, @RequestParam(value = &quot;offset&quot;, defaultValue = &quot;0&quot;) Integer offset)&#123;    return blogService.queryBlogOfFollow(max, offset);&#125;</code></pre><p>BlogServiceImpl</p><pre><code class="java">@Overridepublic Result queryBlogOfFollow(Long max, Integer offset) &#123;    // 1.获取当前用户    Long userId = UserHolder.getUser().getId();    // 2.查询收件箱 ZREVRANGEBYSCORE key Max Min LIMIT offset count    String key = FEED_KEY + userId;    Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; typedTuples = stringRedisTemplate.opsForZSet()        .reverseRangeByScoreWithScores(key, 0, max, offset, 2);    // 3.非空判断    if (typedTuples == null || typedTuples.isEmpty()) &#123;        return Result.ok();    &#125;    // 4.解析数据：blogId、minTime（时间戳）、offset    List&lt;Long&gt; ids = new ArrayList&lt;&gt;(typedTuples.size());    long minTime = 0; // 2    int os = 1; // 2    for (ZSetOperations.TypedTuple&lt;String&gt; tuple : typedTuples) &#123; // 5 4 4 2 2        // 4.1.获取id        ids.add(Long.valueOf(tuple.getValue()));        // 4.2.获取分数(时间戳）        long time = tuple.getScore().longValue();        if(time == minTime)&#123;            os++;        &#125;else&#123;            minTime = time;            os = 1;        &#125;    &#125;    os = minTime == max ? os : os + offset;    // 5.根据id查询blog    String idStr = StrUtil.join(&quot;,&quot;, ids);    List&lt;Blog&gt; blogs = query().in(&quot;id&quot;, ids).last(&quot;ORDER BY FIELD(id,&quot; + idStr + &quot;)&quot;).list();    for (Blog blog : blogs) &#123;        // 5.1.查询blog有关的用户        queryBlogUser(blog);        // 5.2.查询blog是否被点赞        isBlogLiked(blog);    &#125;    // 6.封装并返回    ScrollResult r = new ScrollResult();    r.setList(blogs);    r.setOffset(os);    r.setMinTime(minTime);    return Result.ok(r);&#125;</code></pre><h2 id="10、附近商户"><a href="#10、附近商户" class="headerlink" title="10、附近商户"></a>10、附近商户</h2><h3 id="10-1、附近商户-GEO数据结构的基本用法"><a href="#10-1、附近商户-GEO数据结构的基本用法" class="headerlink" title="10.1、附近商户-GEO数据结构的基本用法"></a>10.1、附近商户-GEO数据结构的基本用法</h3><p>GEO就是Geolocation的简写形式，代表地理坐标。Redis在3.2版本中加入了对GEO的支持，允许存储地理坐标信息，帮助我们根据经纬度来检索数据。常见的命令有：</p><ul><li>GEOADD：添加一个地理空间信息，包含：经度（longitude）、纬度（latitude）、值（member）</li><li>GEODIST：计算指定的两个点之间的距离并返回</li><li>GEOHASH：将指定member的坐标转为hash字符串形式并返回</li><li>GEOPOS：返回指定member的坐标</li><li>GEORADIUS：指定圆心、半径，找到该圆内包含的所有member，并按照与圆心之间的距离排序后返回。6.以后已废弃</li><li>GEOSEARCH：在指定范围内搜索member，并按照与指定点之间的距离排序后返回。范围可以是圆形或矩形。6.2.新功能</li><li>GEOSEARCHSTORE：与GEOSEARCH功能一致，不过可以把结果存储到一个指定的key。 6.2.新功能</li></ul><h3 id="10-2、-附近商户-导入店铺数据到GEO"><a href="#10-2、-附近商户-导入店铺数据到GEO" class="headerlink" title="10.2、 附近商户-导入店铺数据到GEO"></a>10.2、 附近商户-导入店铺数据到GEO</h3><p>具体场景说明：</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653822036941.png" alt="1653822036941"></p><p>当我们点击美食之后，会出现一系列的商家，商家中可以按照多种排序方式，我们此时关注的是距离，这个地方就需要使用到我们的GEO，向后台传入当前app收集的地址(我们此处是写死的) ，以当前坐标作为圆心，同时绑定相同的店家类型type，以及分页信息，把这几个条件传入后台，后台查询出对应的数据再返回。</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653822021827.png" alt="1653822021827"></p><p>我们要做的事情是：将数据库表中的数据导入到redis中去，redis中的GEO，GEO在redis中就一个menber和一个经纬度，我们把x和y轴传入到redis做的经纬度位置去，但我们不能把所有的数据都放入到menber中去，毕竟作为redis是一个内存级数据库，如果存海量数据，redis还是力不从心，所以我们在这个地方存储他的id即可。</p><p>但是这个时候还有一个问题，就是在redis中并没有存储type，所以我们无法根据type来对数据进行筛选，所以我们可以按照商户类型做分组，类型相同的商户作为同一组，以typeId为key存入同一个GEO集合中即可</p><p>代码</p><p>HmDianPingApplicationTests</p><pre><code class="java">@Testvoid loadShopData() &#123;    // 1.查询店铺信息    List&lt;Shop&gt; list = shopService.list();    // 2.把店铺分组，按照typeId分组，typeId一致的放到一个集合    Map&lt;Long, List&lt;Shop&gt;&gt; map = list.stream().collect(Collectors.groupingBy(Shop::getTypeId));    // 3.分批完成写入Redis    for (Map.Entry&lt;Long, List&lt;Shop&gt;&gt; entry : map.entrySet()) &#123;        // 3.1.获取类型id        Long typeId = entry.getKey();        String key = SHOP_GEO_KEY + typeId;        // 3.2.获取同类型的店铺的集合        List&lt;Shop&gt; value = entry.getValue();        List&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; locations = new ArrayList&lt;&gt;(value.size());        // 3.3.写入redis GEOADD key 经度 纬度 member        for (Shop shop : value) &#123;            // stringRedisTemplate.opsForGeo().add(key, new Point(shop.getX(), shop.getY()), shop.getId().toString());            locations.add(new RedisGeoCommands.GeoLocation&lt;&gt;(                    shop.getId().toString(),                    new Point(shop.getX(), shop.getY())            ));        &#125;        stringRedisTemplate.opsForGeo().add(key, locations);    &#125;&#125;</code></pre><h3 id="10-3-附近商户-实现附近商户功能"><a href="#10-3-附近商户-实现附近商户功能" class="headerlink" title="10.3 附近商户-实现附近商户功能"></a>10.3 附近商户-实现附近商户功能</h3><p>SpringDataRedis的2.3.9版本并不支持Redis 6.2提供的GEOSEARCH命令，因此我们需要提示其版本，修改自己的POM</p><p>第一步：导入pom</p><pre><code class="java">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;    &lt;exclusions&gt;        &lt;exclusion&gt;            &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt;            &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;        &lt;/exclusion&gt;        &lt;exclusion&gt;            &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt;            &lt;groupId&gt;io.lettuce&lt;/groupId&gt;        &lt;/exclusion&gt;    &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;    &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt;    &lt;version&gt;2.6.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;io.lettuce&lt;/groupId&gt;    &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt;    &lt;version&gt;6.1.6.RELEASE&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>第二步：</p><p>ShopController</p><pre><code class="java">@GetMapping(&quot;/of/type&quot;)public Result queryShopByType(        @RequestParam(&quot;typeId&quot;) Integer typeId,        @RequestParam(value = &quot;current&quot;, defaultValue = &quot;1&quot;) Integer current,        @RequestParam(value = &quot;x&quot;, required = false) Double x,        @RequestParam(value = &quot;y&quot;, required = false) Double y) &#123;   return shopService.queryShopByType(typeId, current, x, y);&#125;</code></pre><p>ShopServiceImpl</p><pre><code class="java">@Override    public Result queryShopByType(Integer typeId, Integer current, Double x, Double y) &#123;        // 1.判断是否需要根据坐标查询        if (x == null || y == null) &#123;            // 不需要坐标查询，按数据库查询            Page&lt;Shop&gt; page = query()                    .eq(&quot;type_id&quot;, typeId)                    .page(new Page&lt;&gt;(current, SystemConstants.DEFAULT_PAGE_SIZE));            // 返回数据            return Result.ok(page.getRecords());        &#125;        // 2.计算分页参数        int from = (current - 1) * SystemConstants.DEFAULT_PAGE_SIZE;        int end = current * SystemConstants.DEFAULT_PAGE_SIZE;        // 3.查询redis、按照距离排序、分页。结果：shopId、distance        String key = SHOP_GEO_KEY + typeId;        GeoResults&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; results = stringRedisTemplate.opsForGeo() // GEOSEARCH key BYLONLAT x y BYRADIUS 10 WITHDISTANCE                .search(                        key,                        GeoReference.fromCoordinate(x, y),                        new Distance(5000),                        RedisGeoCommands.GeoSearchCommandArgs.newGeoSearchArgs().includeDistance().limit(end)                );        // 4.解析出id        if (results == null) &#123;            return Result.ok(Collections.emptyList());        &#125;        List&lt;GeoResult&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt;&gt; list = results.getContent();        if (list.size() &lt;= from) &#123;            // 没有下一页了，结束            return Result.ok(Collections.emptyList());        &#125;        // 4.1.截取 from ~ end的部分        List&lt;Long&gt; ids = new ArrayList&lt;&gt;(list.size());        Map&lt;String, Distance&gt; distanceMap = new HashMap&lt;&gt;(list.size());        list.stream().skip(from).forEach(result -&gt; &#123;            // 4.2.获取店铺id            String shopIdStr = result.getContent().getName();            ids.add(Long.valueOf(shopIdStr));            // 4.3.获取距离            Distance distance = result.getDistance();            distanceMap.put(shopIdStr, distance);        &#125;);        // 5.根据id查询Shop        String idStr = StrUtil.join(&quot;,&quot;, ids);        List&lt;Shop&gt; shops = query().in(&quot;id&quot;, ids).last(&quot;ORDER BY FIELD(id,&quot; + idStr + &quot;)&quot;).list();        for (Shop shop : shops) &#123;            shop.setDistance(distanceMap.get(shop.getId().toString()).getValue());        &#125;        // 6.返回        return Result.ok(shops);    &#125;</code></pre><h2 id="11、用户签到"><a href="#11、用户签到" class="headerlink" title="11、用户签到"></a>11、用户签到</h2><h4 id="11-1、用户签到-BitMap功能演示"><a href="#11-1、用户签到-BitMap功能演示" class="headerlink" title="11.1、用户签到-BitMap功能演示"></a>11.1、用户签到-BitMap功能演示</h4><p>我们针对签到功能完全可以通过mysql来完成，比如说以下这张表</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653823145495.png" alt="1653823145495"></p><p>用户一次签到，就是一条记录，假如有1000万用户，平均每人每年签到次数为10次，则这张表一年的数据量为 1亿条</p><p>每签到一次需要使用（8 + 8 + 1 + 1 + 3 + 1）共22 字节的内存，一个月则最多需要600多字节</p><p>我们如何能够简化一点呢？其实可以考虑小时候一个挺常见的方案，就是小时候，咱们准备一张小小的卡片，你只要签到就打上一个勾，我最后判断你是否签到，其实只需要到小卡片上看一看就知道了</p><p>我们可以采用类似这样的方案来实现我们的签到需求。</p><p>我们按月来统计用户签到信息，签到记录为1，未签到则记录为0.</p><p>把每一个bit位对应当月的每一天，形成了映射关系。用0和1标示业务状态，这种思路就称为位图（BitMap）。这样我们就用极小的空间，来实现了大量数据的表示</p><p>Redis中是利用string类型数据结构实现BitMap，因此最大上限是512M，转换为bit则是 2^32个bit位。</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653824498278.png" alt="1653824498278"></p><p>BitMap的操作命令有：</p><ul><li>SETBIT：向指定位置（offset）存入一个0或1</li><li>GETBIT ：获取指定位置（offset）的bit值</li><li>BITCOUNT ：统计BitMap中值为1的bit位的数量</li><li>BITFIELD ：操作（查询、修改、自增）BitMap中bit数组中的指定位置（offset）的值</li><li>BITFIELD_RO ：获取BitMap中bit数组，并以十进制形式返回</li><li>BITOP ：将多个BitMap的结果做位运算（与 、或、异或）</li><li>BITPOS ：查找bit数组中指定范围内第一个0或1出现的位置</li></ul><h4 id="11-2-、用户签到-实现签到功能"><a href="#11-2-、用户签到-实现签到功能" class="headerlink" title="11.2 、用户签到-实现签到功能"></a>11.2 、用户签到-实现签到功能</h4><p>需求：实现签到接口，将当前用户当天签到信息保存到Redis中</p><p>思路：我们可以把年和月作为bitMap的key，然后保存到一个bitMap中，每次签到就到对应的位上把数字从0变成1，只要对应是1，就表明说明这一天已经签到了，反之则没有签到。</p><p>我们通过接口文档发现，此接口并没有传递任何的参数，没有参数怎么确实是哪一天签到呢？这个很容易，可以通过后台代码直接获取即可，然后到对应的地址上去修改bitMap。</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653833970361.png" alt="1653833970361"></p><p><strong>代码</strong></p><p>UserController</p><pre><code class="java"> @PostMapping(&quot;/sign&quot;) public Result sign()&#123;    return userService.sign(); &#125;</code></pre><p>UserServiceImpl</p><pre><code class="java">@Overridepublic Result sign() &#123;    // 1.获取当前登录用户    Long userId = UserHolder.getUser().getId();    // 2.获取日期    LocalDateTime now = LocalDateTime.now();    // 3.拼接key    String keySuffix = now.format(DateTimeFormatter.ofPattern(&quot;:yyyyMM&quot;));    String key = USER_SIGN_KEY + userId + keySuffix;    // 4.获取今天是本月的第几天    int dayOfMonth = now.getDayOfMonth();    // 5.写入Redis SETBIT key offset 1    stringRedisTemplate.opsForValue().setBit(key, dayOfMonth - 1, true);    return Result.ok();&#125;</code></pre><h4 id="11-3-用户签到-签到统计"><a href="#11-3-用户签到-签到统计" class="headerlink" title="11.3 用户签到-签到统计"></a>11.3 用户签到-签到统计</h4><p><strong>问题1：</strong>什么叫做连续签到天数？<br>从最后一次签到开始向前统计，直到遇到第一次未签到为止，计算总的签到次数，就是连续签到天数。</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653834455899.png" alt="1653834455899"></p><p>Java逻辑代码：获得当前这个月的最后一次签到数据，定义一个计数器，然后不停的向前统计，直到获得第一个非0的数字即可，每得到一个非0的数字计数器+1，直到遍历完所有的数据，就可以获得当前月的签到总天数了</p><p><strong>问题2：</strong>如何得到本月到今天为止的所有签到数据？</p><p>  BITFIELD key GET u[dayOfMonth] 0</p><p>假设今天是10号，那么我们就可以从当前月的第一天开始，获得到当前这一天的位数，是10号，那么就是10位，去拿这段时间的数据，就能拿到所有的数据了，那么这10天里边签到了多少次呢？统计有多少个1即可。</p><p><strong>问题3：如何从后向前遍历每个bit位？</strong></p><p>注意：bitMap返回的数据是10进制，哪假如说返回一个数字8，那么我哪儿知道到底哪些是0，哪些是1呢？我们只需要让得到的10进制数字和1做与运算就可以了，因为1只有遇见1 才是1，其他数字都是0 ，我们把签到结果和1进行与操作，每与一次，就把签到结果向右移动一位，依次内推，我们就能完成逐个遍历的效果了。</p><p>需求：实现下面接口，统计当前用户截止当前时间在本月的连续签到天数</p><p>有用户有时间我们就可以组织出对应的key，此时就能找到这个用户截止这天的所有签到记录，再根据这套算法，就能统计出来他连续签到的次数了</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653835784444.png" alt="1653835784444"></p><p>代码</p><p><strong>UserController</strong></p><pre><code class="java">@GetMapping(&quot;/sign/count&quot;)public Result signCount()&#123;    return userService.signCount();&#125;</code></pre><p><strong>UserServiceImpl</strong></p><pre><code class="java">@Overridepublic Result signCount() &#123;    // 1.获取当前登录用户    Long userId = UserHolder.getUser().getId();    // 2.获取日期    LocalDateTime now = LocalDateTime.now();    // 3.拼接key    String keySuffix = now.format(DateTimeFormatter.ofPattern(&quot;:yyyyMM&quot;));    String key = USER_SIGN_KEY + userId + keySuffix;    // 4.获取今天是本月的第几天    int dayOfMonth = now.getDayOfMonth();    // 5.获取本月截止今天为止的所有的签到记录，返回的是一个十进制的数字 BITFIELD sign:5:202203 GET u14 0    List&lt;Long&gt; result = stringRedisTemplate.opsForValue().bitField(            key,            BitFieldSubCommands.create()                    .get(BitFieldSubCommands.BitFieldType.unsigned(dayOfMonth)).valueAt(0)    );    if (result == null || result.isEmpty()) &#123;        // 没有任何签到结果        return Result.ok(0);    &#125;    Long num = result.get(0);    if (num == null || num == 0) &#123;        return Result.ok(0);    &#125;    // 6.循环遍历    int count = 0;    while (true) &#123;        // 6.1.让这个数字与1做与运算，得到数字的最后一个bit位  // 判断这个bit位是否为0        if ((num &amp; 1) == 0) &#123;            // 如果为0，说明未签到，结束            break;        &#125;else &#123;            // 如果不为0，说明已签到，计数器+1            count++;        &#125;        // 把数字右移一位，抛弃最后一个bit位，继续下一个bit位        num &gt;&gt;&gt;= 1;    &#125;    return Result.ok(count);&#125;</code></pre><h4 id="11-4-额外加餐-关于使用bitmap来解决缓存穿透的方案"><a href="#11-4-额外加餐-关于使用bitmap来解决缓存穿透的方案" class="headerlink" title="11.4 额外加餐-关于使用bitmap来解决缓存穿透的方案"></a>11.4 额外加餐-关于使用bitmap来解决缓存穿透的方案</h4><p>回顾<strong>缓存穿透</strong>：</p><p>发起了一个数据库不存在的，redis里边也不存在的数据，通常你可以把他看成一个攻击</p><p>解决方案：</p><ul><li><p>判断id&lt;0</p></li><li><p>如果数据库是空，那么就可以直接往redis里边把这个空数据缓存起来</p></li></ul><p>第一种解决方案：遇到的问题是如果用户访问的是id不存在的数据，则此时就无法生效</p><p>第二种解决方案：遇到的问题是：如果是不同的id那就可以防止下次过来直击数据</p><p>所以我们如何解决呢？</p><p>我们可以将数据库的数据，所对应的id写入到一个list集合中，当用户过来访问的时候，我们直接去判断list中是否包含当前的要查询的数据，如果说用户要查询的id数据并不在list集合中，则直接返回，如果list中包含对应查询的id数据，则说明不是一次缓存穿透数据，则直接放行。</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653836416586.png" alt="1653836416586"></p><p>现在的问题是这个主键其实并没有那么短，而是很长的一个 主键</p><p>哪怕你单独去提取这个主键，但是在11年左右，淘宝的商品总量就已经超过10亿个</p><p>所以如果采用以上方案，这个list也会很大，所以我们可以使用bitmap来减少list的存储空间</p><p>我们可以把list数据抽象成一个非常大的bitmap，我们不再使用list，而是将db中的id数据利用哈希思想，比如：</p><p>id % bitmap.size  &#x3D; 算出当前这个id对应应该落在bitmap的哪个索引上，然后将这个值从0变成1，然后当用户来查询数据时，此时已经没有了list，让用户用他查询的id去用相同的哈希算法， 算出来当前这个id应当落在bitmap的哪一位，然后判断这一位是0，还是1，如果是0则表明这一位上的数据一定不存在，  采用这种方式来处理，需要重点考虑一个事情，就是误差率，所谓的误差率就是指当发生哈希冲突的时候，产生的误差。</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653836578970.png" alt="1653836578970"></p><h2 id="12、UV统计"><a href="#12、UV统计" class="headerlink" title="12、UV统计"></a>12、UV统计</h2><h3 id="12-1-、UV统计-HyperLogLog"><a href="#12-1-、UV统计-HyperLogLog" class="headerlink" title="12.1 、UV统计-HyperLogLog"></a>12.1 、UV统计-HyperLogLog</h3><p>首先我们搞懂两个概念：</p><ul><li>UV：全称Unique Visitor，也叫独立访客量，是指通过互联网访问、浏览这个网页的自然人。1天内同一个用户多次访问该网站，只记录1次。</li><li>PV：全称Page View，也叫页面访问量或点击量，用户每访问网站的一个页面，记录1次PV，用户多次打开页面，则记录多次PV。往往用来衡量网站的流量。</li></ul><p>通常来说UV会比PV大很多，所以衡量同一个网站的访问量，我们需要综合考虑很多因素，所以我们只是单纯的把这两个值作为一个参考值</p><p>UV统计在服务端做会比较麻烦，因为要判断该用户是否已经统计过了，需要将统计过的用户信息保存。但是如果每个访问的用户都保存到Redis中，数据量会非常恐怖，那怎么处理呢？</p><p>Hyperloglog(HLL)是从Loglog算法派生的概率算法，用于确定非常大的集合的基数，而不需要存储其所有值。相关算法原理大家可以参考：<a href="https://juejin.cn/post/6844903785744056333#heading-0">https://juejin.cn/post/6844903785744056333#heading-0</a><br>Redis中的HLL是基于string结构实现的，单个HLL的内存<strong>永远小于16kb</strong>，<strong>内存占用低</strong>的令人发指！作为代价，其测量结果是概率性的，<strong>有小于0.81％的误差</strong>。不过对于UV统计来说，这完全可以忽略。</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653837988985.png" alt="1653837988985"></p><h3 id="12-2-UV统计-测试百万数据的统计"><a href="#12-2-UV统计-测试百万数据的统计" class="headerlink" title="12.2 UV统计-测试百万数据的统计"></a>12.2 UV统计-测试百万数据的统计</h3><p>测试思路：我们直接利用单元测试，向HyperLogLog中添加100万条数据，看看内存占用和统计效果如何</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653838053608.png" alt="1653838053608"></p><p>经过测试：我们会发生他的误差是在允许范围内，并且内存占用极小</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>黑马点评redis实战</title>
      <link href="/2023/08/13/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84redis%E5%AE%9E%E6%88%98/"/>
      <url>/2023/08/13/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84redis%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h1 id="开篇-redis实战-黑马点评"><a href="#开篇-redis实战-黑马点评" class="headerlink" title="开篇 redis实战 黑马点评"></a>开篇 redis实战 黑马点评</h1><h2 id="1-0-redis项目部署hmdp"><a href="#1-0-redis项目部署hmdp" class="headerlink" title="1.0 redis项目部署hmdp"></a>1.0 redis项目部署hmdp</h2><ul><li><p>前端采用nginx直接运行即可 注意*** 前端不要有中文路径***</p></li><li><p>后端导入项目修改redis配置 虚拟机ip 端口 redis是否有密码 mysql账号密码 maven配置</p></li></ul><h4 id="功能1发送短信验证码-采用session做"><a href="#功能1发送短信验证码-采用session做" class="headerlink" title="功能1发送短信验证码 采用session做"></a>功能1发送短信验证码 采用session做</h4><p>记录小功能</p><ul><li><em><strong>ctrl+h开启所有类展示图</strong></em></li></ul><p><strong>工具类正则校验</strong></p><pre><code>/** * @author 虎哥 */public abstract class RegexPatterns &#123;    /**     * 手机号正则     */    public static final String PHONE_REGEX = &quot;^1([38][0-9]|4[579]|5[0-3,5-9]|6[6]|7[0135678]|9[89])\\d&#123;8&#125;$&quot;;    /**     * 邮箱正则     */    public static final String EMAIL_REGEX = &quot;^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\\.[a-zA-Z0-9_-]+)+$&quot;;    /**     * 密码正则。4~32位的字母、数字、下划线     */    public static final String PASSWORD_REGEX = &quot;^\\w&#123;4,32&#125;$&quot;;    /**     * 验证码正则, 6位数字或字母     */    public static final String VERIFY_CODE_REGEX = &quot;^[a-zA-Z\\d]&#123;6&#125;$&quot;;&#125;</code></pre><h3 id="初期方案"><a href="#初期方案" class="headerlink" title="初期方案"></a>初期方案</h3><h3 id="1-2-、基于Session实现登录流程"><a href="#1-2-、基于Session实现登录流程" class="headerlink" title="1.2 、基于Session实现登录流程"></a>1.2 、基于Session实现登录流程</h3><p><strong>发送验证码：</strong></p><p>用户在提交手机号后，会校验手机号是否合法，如果不合法，则要求用户重新输入手机号</p><p>如果手机号合法，后台此时生成对应的验证码，同时将验证码进行保存，然后再通过短信的方式将验证码发送给用户</p><p><strong>短信验证码登录、注册：</strong></p><p>用户将验证码和手机号进行输入，后台从session中拿到当前验证码，然后和用户输入的验证码进行校验，如果不一致，则无法通过校验，如果一致，则后台根据手机号查询用户，如果用户不存在，则为用户创建账号信息，保存到数据库，无论是否存在，都会将用户信息保存到session中，方便后续获得当前登录信息</p><p><strong>校验登录状态:</strong></p><p>用户在请求时候，会从cookie中携带者JsessionId到后台，后台通过JsessionId从session中拿到用户信息，如果没有session信息，则进行拦截，如果有session信息，则将用户信息保存到threadLocal中，并且放行</p><p><img src="/2023/08/13/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84redis%E5%AE%9E%E6%88%98/personboke/blog/source/_posts/Redis实战篇.assets/1653066208144.png" alt="1653066208144"></p><h3 id="1-3-、实现发送短信验证码功能"><a href="#1-3-、实现发送短信验证码功能" class="headerlink" title="1.3 、实现发送短信验证码功能"></a>1.3 、实现发送短信验证码功能</h3><p><strong>页面流程</strong></p><p><img src="/2023/08/13/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84redis%E5%AE%9E%E6%88%98/personboke/blog/source/_posts/Redis实战篇.assets/1653067054461.png" alt="1653067054461"></p><p><strong>具体代码如下</strong></p><p><strong>贴心小提示：</strong></p><p>具体逻辑上文已经分析，我们仅 仅只需要按照提示的逻辑写出代码即可。</p><ul><li>发送验证码</li></ul><pre><code class="java">    @Override    public Result sendCode(String phone, HttpSession session) &#123;        // 1.校验手机号        if (RegexUtils.isPhoneInvalid(phone)) &#123;            // 2.如果不符合，返回错误信息            return Result.fail(&quot;手机号格式错误！&quot;);        &#125;        // 3.符合，生成验证码        String code = RandomUtil.randomNumbers(6);        // 4.保存验证码到 session        session.setAttribute(&quot;code&quot;,code);        // 5.发送验证码        log.debug(&quot;发送短信验证码成功，验证码：&#123;&#125;&quot;, code);        // 返回ok        return Result.ok();    &#125;</code></pre><ul><li>登录</li></ul><pre><code class="java">    @Override    public Result login(LoginFormDTO loginForm, HttpSession session) &#123;        // 1.校验手机号        String phone = loginForm.getPhone();        if (RegexUtils.isPhoneInvalid(phone)) &#123;            // 2.如果不符合，返回错误信息            return Result.fail(&quot;手机号格式错误！&quot;);        &#125;        // 3.校验验证码        Object cacheCode = session.getAttribute(&quot;code&quot;);        String code = loginForm.getCode();        if(cacheCode == null || !cacheCode.toString().equals(code))&#123;             //3.不一致，报错            return Result.fail(&quot;验证码错误&quot;);        &#125;        //一致，根据手机号查询用户        User user = query().eq(&quot;phone&quot;, phone).one();        //5.判断用户是否存在        if(user == null)&#123;            //不存在，则创建            user =  createUserWithPhone(phone);        &#125;        //7.保存用户信息到session中        session.setAttribute(&quot;user&quot;,user);        return Result.ok();    &#125;</code></pre><h3 id="1-4、实现登录拦截功能"><a href="#1-4、实现登录拦截功能" class="headerlink" title="1.4、实现登录拦截功能"></a>1.4、实现登录拦截功能</h3><p><strong>温馨小贴士：tomcat的运行原理</strong></p><p><img src="/2023/08/13/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84redis%E5%AE%9E%E6%88%98/personboke/blog/source/_posts/Redis实战篇.assets/1653068196656.png" alt="1653068196656"></p><p>当用户发起请求时，会访问我们像tomcat注册的端口，任何程序想要运行，都需要有一个线程对当前端口号进行监听，tomcat也不例外，当监听线程知道用户想要和tomcat连接连接时，那会由监听线程创建socket连接，socket都是成对出现的，用户通过socket像互相传递数据，当tomcat端的socket接受到数据后，此时监听线程会从tomcat的线程池中取出一个线程执行用户请求，在我们的服务部署到tomcat后，线程会找到用户想要访问的工程，然后用这个线程转发到工程中的controller，service，dao中，并且访问对应的DB，在用户执行完请求后，再统一返回，再找到tomcat端的socket，再将数据写回到用户端的socket，完成请求和响应</p><p>通过以上讲解，我们可以得知 每个用户其实对应都是去找tomcat线程池中的一个线程来完成工作的， 使用完成后再进行回收，既然每个请求都是独立的，所以在每个用户去访问我们的工程时，我们可以使用threadlocal来做到线程隔离，每个线程操作自己的一份数据</p><p><strong>温馨小贴士：关于threadlocal</strong></p><p>如果小伙伴们看过threadLocal的源码，你会发现在threadLocal中，无论是他的put方法和他的get方法， 都是先从获得当前用户的线程，然后从线程中取出线程的成员变量map，只要线程不一样，map就不一样，所以可以通过这种方式来做到线程隔离</p><p><img src="/2023/08/13/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84redis%E5%AE%9E%E6%88%98/personboke/blog/source/_posts/Redis实战篇.assets/1653068874258.png" alt="1653068874258"></p><p>拦截器代码</p><pre><code class="Java">public class LoginInterceptor implements HandlerInterceptor &#123;    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;       //1.获取session        HttpSession session = request.getSession();        //2.获取session中的用户        Object user = session.getAttribute(&quot;user&quot;);        //3.判断用户是否存在        if(user == null)&#123;              //4.不存在，拦截，返回401状态码              response.setStatus(401);              return false;        &#125;        //5.存在，保存用户信息到Threadlocal        UserHolder.saveUser((User)user);        //6.放行        return true;    &#125;&#125;</code></pre><p>让拦截器生效</p><pre><code class="java">@Configurationpublic class MvcConfig implements WebMvcConfigurer &#123;    @Resource    private StringRedisTemplate stringRedisTemplate;    @Override    public void addInterceptors(InterceptorRegistry registry) &#123;        // 登录拦截器        registry.addInterceptor(new LoginInterceptor())                .excludePathPatterns(                        &quot;/shop/**&quot;,                        &quot;/voucher/**&quot;,                        &quot;/shop-type/**&quot;,                        &quot;/upload/**&quot;,                        &quot;/blog/hot&quot;,                        &quot;/user/code&quot;,                        &quot;/user/login&quot;                ).order(1);        // token刷新的拦截器        registry.addInterceptor(new RefreshTokenInterceptor(stringRedisTemplate)).addPathPatterns(&quot;/**&quot;).order(0);    &#125;&#125;</code></pre><h3 id="1-5、隐藏用户敏感信息"><a href="#1-5、隐藏用户敏感信息" class="headerlink" title="1.5、隐藏用户敏感信息"></a>1.5、隐藏用户敏感信息</h3><p>我们通过浏览器观察到此时用户的全部信息都在，这样极为不靠谱，所以我们应当在返回用户信息之前，将用户的敏感信息进行隐藏，采用的核心思路就是书写一个UserDto对象，这个UserDto对象就没有敏感信息了，我们在返回前，将有用户敏感信息的User对象转化成没有敏感信息的UserDto对象，那么就能够避免这个尴尬的问题了</p><p><strong>在登录方法处修改</strong></p><pre><code class="java">//7.保存用户信息到session中session.setAttribute(&quot;user&quot;, BeanUtils.copyProperties(user,UserDTO.class));</code></pre><p><strong>在拦截器处：</strong></p><pre><code class="java">//5.存在，保存用户信息到ThreadlocalUserHolder.saveUser((UserDTO) user);</code></pre><p><strong>在UserHolder处：将user对象换成UserDTO</strong></p><pre><code class="java">public class UserHolder &#123;    private static final ThreadLocal&lt;UserDTO&gt; tl = new ThreadLocal&lt;&gt;();    public static void saveUser(UserDTO user)&#123;        tl.set(user);    &#125;    public static UserDTO getUser()&#123;        return tl.get();    &#125;    public static void removeUser()&#123;        tl.remove();    &#125;&#125;</code></pre><h3 id="1-6、session共享问题"><a href="#1-6、session共享问题" class="headerlink" title="1.6、session共享问题"></a>1.6、session共享问题</h3><p><strong>核心思路分析：</strong></p><p>每个tomcat中都有一份属于自己的session,假设用户第一次访问第一台tomcat，并且把自己的信息存放到第一台服务器的session中，但是第二次这个用户访问到了第二台tomcat，那么在第二台服务器上，肯定没有第一台服务器存放的session，所以此时 整个登录拦截功能就会出现问题，我们能如何解决这个问题呢？早期的方案是session拷贝，就是说虽然每个tomcat上都有不同的session，但是每当任意一台服务器的session修改时，都会同步给其他的Tomcat服务器的session，这样的话，就可以实现session的共享了</p><p>但是这种方案具有两个大问题</p><p>1、每台服务器中都有完整的一份session数据，服务器压力过大。</p><p>2、session拷贝数据时，可能会出现延迟</p><p>所以咱们后来采用的方案都是基于redis来完成，我们把session换成redis，redis数据本身就是共享的，就可以避免session共享的问题了</p><p><img src="/2023/08/13/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84redis%E5%AE%9E%E6%88%98/personboke/blog/source/_posts/Redis实战篇.assets/1653069893050.png" alt="1653069893050"></p><h3 id="1-7-Redis代替session的业务流程"><a href="#1-7-Redis代替session的业务流程" class="headerlink" title="1.7 Redis代替session的业务流程"></a>1.7 Redis代替session的业务流程</h3><h4 id="1-7-1、设计key的结构"><a href="#1-7-1、设计key的结构" class="headerlink" title="1.7.1、设计key的结构"></a>1.7.1、设计key的结构</h4><p>首先我们要思考一下利用redis来存储数据，那么到底使用哪种结构呢？由于存入的数据比较简单，我们可以考虑使用String，或者是使用哈希，如下图，如果使用String，同学们注意他的value，用多占用一点空间，如果使用哈希，则他的value中只会存储他数据本身，如果不是特别在意内存，其实使用String就可以啦。</p><p><img src="/2023/08/13/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84redis%E5%AE%9E%E6%88%98/personboke/blog/source/_posts/Redis实战篇.assets/1653319261433.png" alt="1653319261433"></p><h4 id="1-7-2、设计key的具体细节"><a href="#1-7-2、设计key的具体细节" class="headerlink" title="1.7.2、设计key的具体细节"></a>1.7.2、设计key的具体细节</h4><p>所以我们可以使用String结构，就是一个简单的key，value键值对的方式，但是关于key的处理，session他是每个用户都有自己的session，但是redis的key是共享的，咱们就不能使用code了</p><p>在设计这个key的时候，我们之前讲过需要满足两点</p><p>1、key要具有唯一性</p><p>2、key要方便携带</p><p>如果我们采用phone：手机号这个的数据来存储当然是可以的，但是如果把这样的敏感数据存储到redis中并且从页面中带过来毕竟不太合适，所以我们在后台生成一个随机串token，然后让前端带来这个token就能完成我们的整体逻辑了</p><h4 id="1-7-3、整体访问流程"><a href="#1-7-3、整体访问流程" class="headerlink" title="1.7.3、整体访问流程"></a>1.7.3、整体访问流程</h4><p>当注册完成后，用户去登录会去校验用户提交的手机号和验证码，是否一致，如果一致，则根据手机号查询用户信息，不存在则新建，最后将用户数据保存到redis，并且生成token作为redis的key，当我们校验用户是否登录时，会去携带着token进行访问，从redis中取出token对应的value，判断是否存在这个数据，如果没有则拦截，如果存在则将其保存到threadLocal中，并且放行。</p><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><p>关于用户信息 这里保存为hash结构并且关键细节为 设置用户信息30分钟当超过30分支清除用户信息</p><p>但是当用户处于登陆状态时操作 会刷新用户信息保存时长30分钟</p><h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1><pre><code class="java">package com.hmdp.service.impl;import cn.hutool.core.collection.ListUtil;import cn.hutool.json.JSONUtil;import com.hmdp.dto.Result;import com.hmdp.entity.ShopType;import com.hmdp.mapper.ShopTypeMapper;import com.hmdp.service.IShopTypeService;import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;import java.util.ArrayList;import java.util.List;import java.util.stream.Collectors;import javax.annotation.Resource;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.stereotype.Service;import static com.hmdp.utils.RedisConstants.CACHE_SHOPTYPE_KEY;/** * &lt;p&gt; *  服务实现类 * &lt;/p&gt; * * @author 李开恩 * @since  */@Servicepublic class ShopTypeServiceImpl extends ServiceImpl&lt;ShopTypeMapper, ShopType&gt; implements IShopTypeService &#123;    @Resource    private RedisTemplate redisTemplate;    @Override//    @Cacheable(value = CACHE_SHOPTYPE_KEY,key = &quot;typeList&quot;)    public Result getShopTypeList() &#123;        //1.从redis中查询数据库        List&lt;ShopType&gt; TypeList = redisTemplate.opsForList().range(CACHE_SHOPTYPE_KEY, 0, -1);        //2.判断是否有元素        if (TypeList.size() != 0) &#123;            //3.不存在查询数据库存在直接返回            return Result.ok(TypeList);        &#125;        //4.不存在查询数据库        List&lt;ShopType&gt; shoptypeList = query().orderByAsc(&quot;sort&quot;).list();       //5.不存在返回错误        if (shoptypeList.size()==0)&#123;            return Result.fail(&quot;Please select is null&quot;);        &#125;        //6.存在写入到redis注解实现        redisTemplate.opsForList().rightPushAll(CACHE_SHOPTYPE_KEY, shoptypeList);        return Result.ok(shoptypeList);    &#125;&#125;</code></pre><h2 id="问题-数据库与缓存不一致性"><a href="#问题-数据库与缓存不一致性" class="headerlink" title="问题 数据库与缓存不一致性"></a>问题 数据库与缓存不一致性</h2><p>先删除缓存在操作数据库</p><p>可能会出现线程1 删除缓存 更新数据库 在更新期间</p><p>线程2查询缓存未命中（已删除） 查询数据库未修改 缓存旧数据 </p><p>线程1更新数据库完成 </p><p>此时出现缓存与数据库不一致性</p><p>先操作数据库在删除缓存</p><p>该操作比较可靠</p><h3 id="2-3-缓存更新策略"><a href="#2-3-缓存更新策略" class="headerlink" title="2.3 缓存更新策略"></a>2.3 缓存更新策略</h3><p>缓存更新是redis为了节约内存而设计出来的一个东西，主要是因为内存数据宝贵，当我们向redis插入太多数据，此时就可能会导致缓存中的数据过多，所以redis会对部分数据进行更新，或者把他叫为淘汰更合适。</p><p><strong>内存淘汰：</strong>redis自动进行，当redis内存达到咱们设定的max-memery的时候，会自动触发淘汰机制，淘汰掉一些不重要的数据(可以自己设置策略方式)</p><p><strong>超时剔除：</strong>当我们给redis设置了过期时间ttl之后，redis会将超时的数据进行删除，方便咱们继续使用缓存</p><p><strong>主动更新：</strong>我们可以手动调用方法把缓存删掉，通常用于解决缓存和数据库不一致问题</p><p><img src="/2023/08/13/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84redis%E5%AE%9E%E6%88%98/personboke/blog/source/_posts/Redis实战篇.assets/1653322506393.png" alt="1653322506393"></p><h4 id="2-3-1-、数据库缓存不一致解决方案："><a href="#2-3-1-、数据库缓存不一致解决方案：" class="headerlink" title="2.3.1 、数据库缓存不一致解决方案："></a>2.3.1 、数据库缓存不一致解决方案：</h4><p>由于我们的<strong>缓存的数据源来自于数据库</strong>,而数据库的<strong>数据是会发生变化的</strong>,因此,如果当数据库中<strong>数据发生变化,而缓存却没有同步</strong>,此时就会有<strong>一致性问题存在</strong>,其后果是:</p><p>用户使用缓存中的过时数据,就会产生类似多线程数据安全问题,从而影响业务,产品口碑等;怎么解决呢？有如下几种方案</p><p>Cache Aside Pattern 人工编码方式：缓存调用者在更新完数据库后再去更新缓存，也称之为双写方案</p><p>Read&#x2F;Write Through Pattern : 由系统本身完成，数据库与缓存的问题交由系统本身去处理</p><p>Write Behind Caching Pattern ：调用者只操作缓存，其他线程去异步处理数据库，实现最终一致</p><p><img src="/2023/08/13/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84redis%E5%AE%9E%E6%88%98/personboke/blog/source/_posts/Redis实战篇.assets/1653322857620.png" alt="1653322857620"></p><h4 id="2-3-2-、数据库和缓存不一致采用什么方案"><a href="#2-3-2-、数据库和缓存不一致采用什么方案" class="headerlink" title="2.3.2 、数据库和缓存不一致采用什么方案"></a>2.3.2 、数据库和缓存不一致采用什么方案</h4><p>综合考虑使用方案一，但是方案一调用者如何处理呢？这里有几个问题</p><p>操作缓存和数据库时有三个问题需要考虑：</p><p>如果采用第一个方案，那么假设我们每次操作数据库后，都操作缓存，但是中间如果没有人查询，那么这个更新动作实际上只有最后一次生效，中间的更新动作意义并不大，我们可以把缓存删除，等待再次查询时，将缓存中的数据加载出来</p><ul><li><p>删除缓存还是更新缓存？</p><ul><li>更新缓存：每次更新数据库都更新缓存，无效写操作较多</li><li>删除缓存：更新数据库时让缓存失效，查询时再更新缓存</li></ul></li><li><p>如何保证缓存与数据库的操作的同时成功或失败？</p><ul><li>单体系统，将缓存与数据库操作放在一个事务</li><li>分布式系统，利用TCC等分布式事务方案</li></ul></li></ul><p>应该具体操作缓存还是操作数据库，我们应当是先操作数据库，再删除缓存，原因在于，如果你选择第一种方案，在两个线程并发来访问时，假设线程1先来，他先把缓存删了，此时线程2过来，他查询缓存数据并不存在，此时他写入缓存，当他写入缓存后，线程1再执行更新动作时，实际上写入的就是旧的数据，新的数据被旧数据覆盖了。</p><ul><li>先操作缓存还是先操作数据库？<ul><li>先删除缓存，再操作数据库</li><li>先操作数据库，再删除缓存</li></ul></li></ul><p><img src="/2023/08/13/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84redis%E5%AE%9E%E6%88%98/personboke/blog/source/_posts/Redis实战篇.assets/1653323595206.png" alt="1653323595206"></p><h3 id="2-4-实现商铺和缓存与数据库双写一致"><a href="#2-4-实现商铺和缓存与数据库双写一致" class="headerlink" title="2.4 实现商铺和缓存与数据库双写一致"></a>2.4 实现商铺和缓存与数据库双写一致</h3><p>核心思路如下：</p><p>修改ShopController中的业务逻辑，满足下面的需求：</p><p>根据id查询店铺时，如果缓存未命中，则查询数据库，将数据库结果写入缓存，并设置超时时间</p><p>根据id修改店铺时，先修改数据库，再删除缓存</p><p><strong>修改重点代码1</strong>：修改<strong>ShopServiceImpl</strong>的queryById方法</p><p><strong>设置redis缓存时添加过期时间</strong></p><p><img src="/2023/08/13/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84redis%E5%AE%9E%E6%88%98/personboke/blog/source/_posts/Redis实战篇.assets/1653325871232.png" alt="1653325871232"></p><p><strong>修改重点代码2</strong></p><p>代码分析：通过之前的淘汰，我们确定了采用删除策略，来解决双写问题，当我们修改了数据之后，然后把缓存中的数据进行删除，查询时发现缓存中没有数据，则会从mysql中加载最新的数据，从而避免数据库和缓存不一致的问题</p><p><img src="/2023/08/13/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84redis%E5%AE%9E%E6%88%98/personboke/blog/source/_posts/Redis实战篇.assets/1653325929549.png" alt="1653325929549"></p><h3 id="2-5-缓存穿透问题的解决思路"><a href="#2-5-缓存穿透问题的解决思路" class="headerlink" title="2.5 缓存穿透问题的解决思路"></a>2.5 缓存穿透问题的解决思路</h3><p>缓存穿透 ：缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。</p><p>常见的解决方案有两种：</p><ul><li>缓存空对象<ul><li>优点：实现简单，维护方便</li><li>缺点：<ul><li>额外的内存消耗</li><li>可能造成短期的不一致</li></ul></li></ul></li><li>布隆过滤<ul><li>优点：内存占用较少，没有多余key</li><li>缺点：<ul><li>实现复杂</li><li>存在误判可能</li></ul></li></ul></li></ul><p><strong>缓存空对象思路分析：</strong>当我们客户端访问不存在的数据时，先请求redis，但是此时redis中没有数据，此时会访问到数据库，但是数据库中也没有数据，这个数据穿透了缓存，直击数据库，我们都知道数据库能够承载的并发不如redis这么高，如果大量的请求同时过来访问这种不存在的数据，这些请求就都会访问到数据库，简单的解决方案就是哪怕这个数据在数据库中也不存在，我们也把这个数据存入到redis中去，这样，下次用户过来访问这个不存在的数据，那么在redis中也能找到这个数据就不会进入到缓存了</p><p><strong>布隆过滤：</strong>布隆过滤器其实采用的是哈希思想来解决这个问题，通过一个庞大的二进制数组，走哈希思想去判断当前这个要查询的这个数据是否存在，如果布隆过滤器判断存在，则放行，这个请求会去访问redis，哪怕此时redis中的数据过期了，但是数据库中一定存在这个数据，在数据库中查询出来这个数据后，再将其放入到redis中，</p><p>假设布隆过滤器判断这个数据不存在，则直接返回</p><p>这种方式优点在于节约内存空间，存在误判，误判原因在于：布隆过滤器走的是哈希思想，只要哈希思想，就可能存在哈希冲突</p><p><img src="/2023/08/13/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84redis%E5%AE%9E%E6%88%98/personboke/blog/source/_posts/Redis实战篇.assets/1653326156516.png" alt="1653326156516"></p><h2 id="redis热点问题"><a href="#redis热点问题" class="headerlink" title="redis热点问题"></a>redis热点问题</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p><strong>指的是缓存中没有数据&#x2F;数据库中没有此数据不会做缓存的情况下 但是却有大量请求请求到数据库并且不会缓存就很可怕</strong>  </p><p><strong>解决方案</strong> </p><p>  <strong>1.缓存空数据 对于请求的数据如果没查到就缓存空数据 前端再次请求从缓存中去拿 拿出来判断为空则没有该数据</strong>  </p><p><strong>2.布隆过滤器 了解 可以设置布隆过滤器 他存储的是数据库中数据的哈希值 一种算法 可以对比请求的数据进行对比请求过滤 但是这中情况可能会有哈希冲突（了解）误判为存在实际上不存在</strong></p><p><strong>3.对于查询的id做复杂化处理 比如设置更长的id更复杂的配合</strong> </p><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p><strong>大量的缓存数据同一时间失效 或者redis服务器宕机</strong></p><p><strong>解决方案 1.设置不同的过期时间</strong></p><p><strong>2.集群模式 高可用配置</strong></p><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>热点数据失效 一些热点数据被大量访问 同时缓存失效 请求就会打在数据库上导致数据库崩溃</p><p>互斥锁</p><p>1.多个线程同时在请求数据</p><p>只会有一个线程构建缓存数据 其他数据请求锁 如果请求不到就等待 休眠一会在请求</p><p>2.设置逻辑过期 </p><p>设置缓存数据的逻辑过期时间</p><p>第一个线程获取数据 发现缓存实现 开启一个新线程 重建缓存 自己返回旧数据 在重建过程中 所有线程都是旧数据  不保证一致性 有额外内存消耗 保证了高可用用户交互性比较好 </p><h3 id="添加商户缓存"><a href="#添加商户缓存" class="headerlink" title="添加商户缓存"></a>添加商户缓存</h3><p>在我们查询商户信息时，我们是直接操作从数据库中去进行查询的，大致逻辑是这样，直接查询数据库那肯定慢咯，所以我们需要增加缓存</p><pre><code>@GetMapping(&quot;/&#123;id&#125;&quot;)public Result queryShopById(@PathVariable(&quot;id&quot;) Long id) &#123;    //这里是直接查询数据库    return shopService.queryById(id);&#125;</code></pre><h4 id="2-2-1-、缓存模型和思路"><a href="#2-2-1-、缓存模型和思路" class="headerlink" title="2.2.1 、缓存模型和思路"></a>2.2.1 、缓存模型和思路</h4><p>标准的操作方式就是查询数据库之前先查询缓存，如果缓存数据存在，则直接从缓存中返回，如果缓存数据不存在，再查询数据库，然后将数据存入redis。</p><p><img src="/2023/08/13/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84redis%E5%AE%9E%E6%88%98/personboke/blog/source/_posts/Redis实战篇.assets/1653322097736.png" alt="1653322097736"></p><h4 id="2-1-2、代码如下"><a href="#2-1-2、代码如下" class="headerlink" title="2.1.2、代码如下"></a>2.1.2、代码如下</h4><p>代码思路：如果缓存有，则直接返回，如果缓存不存在，则查询数据库，然后存入redis。</p><p><img src="/2023/08/13/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84redis%E5%AE%9E%E6%88%98/personboke/blog/source/_posts/Redis实战篇.assets/1653322190155.png" alt="1653322190155"></p><h3 id="2-3-缓存更新策略-1"><a href="#2-3-缓存更新策略-1" class="headerlink" title="2.3 缓存更新策略"></a>2.3 缓存更新策略</h3><p>缓存更新是redis为了节约内存而设计出来的一个东西，主要是因为内存数据宝贵，当我们向redis插入太多数据，此时就可能会导致缓存中的数据过多，所以redis会对部分数据进行更新，或者把他叫为淘汰更合适。</p><p><strong>内存淘汰：</strong>redis自动进行，当redis内存达到咱们设定的max-memery的时候，会自动触发淘汰机制，淘汰掉一些不重要的数据(可以自己设置策略方式)</p><p><strong>超时剔除：</strong>当我们给redis设置了过期时间ttl之后，redis会将超时的数据进行删除，方便咱们继续使用缓存</p><p><strong>主动更新：</strong>我们可以手动调用方法把缓存删掉，通常用于解决缓存和数据库不一致问题</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653322506393.png" alt="1653322506393"></p><h4 id="2-3-1-、数据库缓存不一致解决方案：-1"><a href="#2-3-1-、数据库缓存不一致解决方案：-1" class="headerlink" title="2.3.1 、数据库缓存不一致解决方案："></a>2.3.1 、数据库缓存不一致解决方案：</h4><p>由于我们的<strong>缓存的数据源来自于数据库</strong>,而数据库的<strong>数据是会发生变化的</strong>,因此,如果当数据库中<strong>数据发生变化,而缓存却没有同步</strong>,此时就会有<strong>一致性问题存在</strong>,其后果是:</p><p>用户使用缓存中的过时数据,就会产生类似多线程数据安全问题,从而影响业务,产品口碑等;怎么解决呢？有如下几种方案</p><p>Cache Aside Pattern 人工编码方式：缓存调用者在更新完数据库后再去更新缓存，也称之为双写方案</p><p>Read&#x2F;Write Through Pattern : 由系统本身完成，数据库与缓存的问题交由系统本身去处理</p><p>Write Behind Caching Pattern ：调用者只操作缓存，其他线程去异步处理数据库，实现最终一致</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653322857620.png" alt="1653322857620"></p><h4 id="2-3-2-、数据库和缓存不一致采用什么方案-1"><a href="#2-3-2-、数据库和缓存不一致采用什么方案-1" class="headerlink" title="2.3.2 、数据库和缓存不一致采用什么方案"></a>2.3.2 、数据库和缓存不一致采用什么方案</h4><p>综合考虑使用方案一，但是方案一调用者如何处理呢？这里有几个问题</p><p>操作缓存和数据库时有三个问题需要考虑：</p><p>如果采用第一个方案，那么假设我们每次操作数据库后，都操作缓存，但是中间如果没有人查询，那么这个更新动作实际上只有最后一次生效，中间的更新动作意义并不大，我们可以把缓存删除，等待再次查询时，将缓存中的数据加载出来</p><ul><li><p>删除缓存还是更新缓存？</p><ul><li>更新缓存：每次更新数据库都更新缓存，无效写操作较多</li><li>删除缓存：更新数据库时让缓存失效，查询时再更新缓存</li></ul></li><li><p>如何保证缓存与数据库的操作的同时成功或失败？</p><ul><li>单体系统，将缓存与数据库操作放在一个事务</li><li>分布式系统，利用TCC等分布式事务方案</li></ul></li></ul><p>应该具体操作缓存还是操作数据库，我们应当是先操作数据库，再删除缓存，原因在于，如果你选择第一种方案，在两个线程并发来访问时，假设线程1先来，他先把缓存删了，此时线程2过来，他查询缓存数据并不存在，此时他写入缓存，当他写入缓存后，线程1再执行更新动作时，实际上写入的就是旧的数据，新的数据被旧数据覆盖了。</p><ul><li>先操作缓存还是先操作数据库？<ul><li>先删除缓存，再操作数据库</li><li>先操作数据库，再删除缓存</li></ul></li></ul><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653323595206.png" alt="1653323595206"></p><h3 id="2-4-实现商铺和缓存与数据库双写一致-1"><a href="#2-4-实现商铺和缓存与数据库双写一致-1" class="headerlink" title="2.4 实现商铺和缓存与数据库双写一致"></a>2.4 实现商铺和缓存与数据库双写一致</h3><p>核心思路如下：</p><p>修改ShopController中的业务逻辑，满足下面的需求：</p><p>根据id查询店铺时，如果缓存未命中，则查询数据库，将数据库结果写入缓存，并设置超时时间</p><p>根据id修改店铺时，先修改数据库，再删除缓存</p><p><strong>修改重点代码1</strong>：修改<strong>ShopServiceImpl</strong>的queryById方法</p><p><strong>设置redis缓存时添加过期时间</strong></p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653325871232.png" alt="1653325871232"></p><p><strong>修改重点代码2</strong></p><p>代码分析：通过之前的淘汰，我们确定了采用删除策略，来解决双写问题，当我们修改了数据之后，然后把缓存中的数据进行删除，查询时发现缓存中没有数据，则会从mysql中加载最新的数据，从而避免数据库和缓存不一致的问题</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653325929549.png" alt="1653325929549"></p><h3 id="2-5-缓存穿透问题的解决思路-1"><a href="#2-5-缓存穿透问题的解决思路-1" class="headerlink" title="2.5 缓存穿透问题的解决思路"></a>2.5 缓存穿透问题的解决思路</h3><p>缓存穿透 ：缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。</p><p>常见的解决方案有两种：</p><ul><li>缓存空对象<ul><li>优点：实现简单，维护方便</li><li>缺点：<ul><li>额外的内存消耗</li><li>可能造成短期的不一致</li></ul></li></ul></li><li>布隆过滤<ul><li>优点：内存占用较少，没有多余key</li><li>缺点：<ul><li>实现复杂</li><li>存在误判可能</li></ul></li></ul></li></ul><p><strong>缓存空对象思路分析：</strong>当我们客户端访问不存在的数据时，先请求redis，但是此时redis中没有数据，此时会访问到数据库，但是数据库中也没有数据，这个数据穿透了缓存，直击数据库，我们都知道数据库能够承载的并发不如redis这么高，如果大量的请求同时过来访问这种不存在的数据，这些请求就都会访问到数据库，简单的解决方案就是哪怕这个数据在数据库中也不存在，我们也把这个数据存入到redis中去，这样，下次用户过来访问这个不存在的数据，那么在redis中也能找到这个数据就不会进入到缓存了</p><p><strong>布隆过滤：</strong>布隆过滤器其实采用的是哈希思想来解决这个问题，通过一个庞大的二进制数组，走哈希思想去判断当前这个要查询的这个数据是否存在，如果布隆过滤器判断存在，则放行，这个请求会去访问redis，哪怕此时redis中的数据过期了，但是数据库中一定存在这个数据，在数据库中查询出来这个数据后，再将其放入到redis中，</p><p>假设布隆过滤器判断这个数据不存在，则直接返回</p><p>这种方式优点在于节约内存空间，存在误判，误判原因在于：布隆过滤器走的是哈希思想，只要哈希思想，就可能存在哈希冲突</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653326156516.png" alt="1653326156516"></p><h3 id="2-6-编码解决商品查询的缓存穿透问题："><a href="#2-6-编码解决商品查询的缓存穿透问题：" class="headerlink" title="2.6 编码解决商品查询的缓存穿透问题："></a>2.6 编码解决商品查询的缓存穿透问题：</h3><p>核心思路如下：</p><p>在原来的逻辑中，我们如果发现这个数据在mysql中不存在，直接就返回404了，这样是会存在缓存穿透问题的</p><p>现在的逻辑中：如果这个数据不存在，我们不会返回404 ，还是会把这个数据写入到Redis中，并且将value设置为空，欧当再次发起查询时，我们如果发现命中之后，判断这个value是否是null，如果是null，则是之前写入的数据，证明是缓存穿透数据，如果不是，则直接返回数据。</p><p><img src="/2023/08/13/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84redis%E5%AE%9E%E6%88%98/personboke/blog/source/_posts/Redis实战篇.assets/1653327124561.png" alt="1653327124561"></p><p><strong>小总结：</strong></p><p>缓存穿透产生的原因是什么？</p><ul><li>用户请求的数据在缓存中和数据库中都不存在，不断发起这样的请求，给数据库带来巨大压力</li></ul><p>缓存穿透的解决方案有哪些？</p><ul><li>缓存null值</li><li>布隆过滤</li><li>增强id的复杂度，避免被猜测id规律</li><li>做好数据的基础格式校验</li><li>加强用户权限校验</li><li>做好热点参数的限流</li></ul><h3 id="2-7-缓存雪崩问题及解决思路"><a href="#2-7-缓存雪崩问题及解决思路" class="headerlink" title="2.7 缓存雪崩问题及解决思路"></a>2.7 缓存雪崩问题及解决思路</h3><p>缓存雪崩是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。</p><p>解决方案：</p><ul><li>给不同的Key的TTL添加随机值</li><li>利用Redis集群提高服务的可用性</li><li>给缓存业务添加降级限流策略</li><li>给业务添加多级缓存</li></ul><p><img src="/2023/08/13/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84redis%E5%AE%9E%E6%88%98/personboke/blog/source/_posts/Redis实战篇.assets/1653327884526.png" alt="1653327884526"></p><h3 id="2-8-缓存击穿问题及解决思路"><a href="#2-8-缓存击穿问题及解决思路" class="headerlink" title="2.8 缓存击穿问题及解决思路"></a>2.8 缓存击穿问题及解决思路</h3><p>缓存击穿问题也叫热点Key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。</p><p>常见的解决方案有两种：</p><ul><li>互斥锁</li><li>逻辑过期</li></ul><p>逻辑分析：假设线程1在查询缓存之后，本来应该去查询数据库，然后把这个数据重新加载到缓存的，此时只要线程1走完这个逻辑，其他线程就都能从缓存中加载这些数据了，但是假设在线程1没有走完的时候，后续的线程2，线程3，线程4同时过来访问当前这个方法， 那么这些线程都不能从缓存中查询到数据，那么他们就会同一时刻来访问查询缓存，都没查到，接着同一时间去访问数据库，同时的去执行数据库代码，对数据库访问压力过大</p><p><img src="/2023/08/13/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84redis%E5%AE%9E%E6%88%98/personboke/blog/source/_posts/Redis实战篇.assets/1653328022622.png" alt="1653328022622"></p><p>解决方案一、使用锁来解决：</p><p>因为锁能实现互斥性。假设线程过来，只能一个人一个人的来访问数据库，从而避免对于数据库访问压力过大，但这也会影响查询的性能，因为此时会让查询的性能从并行变成了串行，我们可以采用tryLock方法 + double check来解决这样的问题。</p><p>假设现在线程1过来访问，他查询缓存没有命中，但是此时他获得到了锁的资源，那么线程1就会一个人去执行逻辑，假设现在线程2过来，线程2在执行过程中，并没有获得到锁，那么线程2就可以进行到休眠，直到线程1把锁释放后，线程2获得到锁，然后再来执行逻辑，此时就能够从缓存中拿到数据了。</p><p><img src="/2023/08/13/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84redis%E5%AE%9E%E6%88%98/personboke/blog/source/_posts/Redis实战篇.assets/1653328288627.png" alt="1653328288627"></p><p>解决方案二、逻辑过期方案</p><p>方案分析：我们之所以会出现这个缓存击穿问题，主要原因是在于我们对key设置了过期时间，假设我们不设置过期时间，其实就不会有缓存击穿的问题，但是不设置过期时间，这样数据不就一直占用我们内存了吗，我们可以采用逻辑过期方案。</p><p>我们把过期时间设置在 redis的value中，注意：这个过期时间并不会直接作用于redis，而是我们后续通过逻辑去处理。假设线程1去查询缓存，然后从value中判断出来当前的数据已经过期了，此时线程1去获得互斥锁，那么其他线程会进行阻塞，获得了锁的线程他会开启一个 线程去进行 以前的重构数据的逻辑，直到新开的线程完成这个逻辑后，才释放锁， 而线程1直接进行返回，假设现在线程3过来访问，由于线程线程2持有着锁，所以线程3无法获得锁，线程3也直接返回数据，只有等到新开的线程2把重建数据构建完后，其他线程才能走返回正确的数据。</p><p>这种方案巧妙在于，异步的构建缓存，缺点在于在构建完缓存之前，返回的都是脏数据。</p><p><img src="/2023/08/13/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84redis%E5%AE%9E%E6%88%98/personboke/blog/source/_posts/Redis实战篇.assets/1653328663897.png" alt="1653328663897"></p><p>进行对比</p><p><strong>互斥锁方案：</strong>由于保证了互斥性，所以数据一致，且实现简单，因为仅仅只需要加一把锁而已，也没其他的事情需要操心，所以没有额外的内存消耗，缺点在于有锁就有死锁问题的发生，且只能串行执行性能肯定受到影响</p><p><strong>逻辑过期方案：</strong> 线程读取过程中不需要等待，性能好，有一个额外的线程持有锁去进行重构数据，但是在重构数据完成前，其他的线程只能返回之前的数据，且实现起来麻烦</p><p><img src="/2023/08/13/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84redis%E5%AE%9E%E6%88%98/personboke/blog/source/_posts/Redis实战篇.assets/1653357522914.png" alt="1653357522914"></p><h3 id="2-9-利用互斥锁解决缓存击穿问题"><a href="#2-9-利用互斥锁解决缓存击穿问题" class="headerlink" title="2.9 利用互斥锁解决缓存击穿问题"></a>2.9 利用互斥锁解决缓存击穿问题</h3><p>核心思路：相较于原来从缓存中查询不到数据后直接查询数据库而言，现在的方案是 进行查询之后，如果从缓存没有查询到数据，则进行互斥锁的获取，获取互斥锁后，判断是否获得到了锁，如果没有获得到，则休眠，过一会再进行尝试，直到获取到锁为止，才能进行查询</p><p>如果获取到了锁的线程，再去进行查询，查询后将数据写入redis，再释放锁，返回数据，利用互斥锁就能保证只有一个线程去执行操作数据库的逻辑，防止缓存击穿</p><p><img src="/2023/08/13/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84redis%E5%AE%9E%E6%88%98/personboke/blog/source/_posts/Redis实战篇.assets/1653357860001.png" alt="1653357860001"></p><p><strong>操作锁的代码：</strong></p><p>核心思路就是利用redis的setnx方法来表示获取锁，该方法含义是redis中如果没有这个key，则插入成功，返回1，在stringRedisTemplate中返回true，  如果有这个key则插入失败，则返回0，在stringRedisTemplate返回false，我们可以通过true，或者是false，来表示是否有线程成功插入key，成功插入的key的线程我们认为他就是获得到锁的线程。</p><pre><code>@Override    public Result queryByid(Long id) &#123;        //缓存穿透//        Shop shop = queryWithPassThrough(id);        //互斥锁解决缓存击穿        Shop shop = queryWithMutex(id);        if (shop == null) &#123;            return Result.fail(&quot;店铺不存在&quot;);        &#125;        return Result.ok(shop);    &#125;////    @Override//    public Result queryByid(Long id) &#123;//        //1.从redis查询商铺缓存//        String shopJson = stringRedisTemplate.opsForValue().get(CACHE_SHOP_KEY+ id);//        //2.判断是否存在//        if (StrUtil.isNotBlank(shopJson)) &#123;//            //3.存在直接返回//            Shop shop = JSONUtil.toBean(shopJson, Shop.class);//            return  Result.ok(shop);//        &#125;//        //判断命中的是否是空值//        if(shopJson != null) &#123;//            //返回一个错误信息//            return Result.fail(&quot;店铺信息不存在&quot;);//        &#125;//        //4.不存在根据id查询数据库//        Shop shop=getById(id);//        //5.不存在返回错误//        if (shop == null) &#123;//            //将空值写入到redis//            stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY+ id,&quot;&quot;,CACHE_NULL_TTL,TimeUnit.MINUTES);//            return Result.fail(&quot;Shop not found&quot;);//        &#125;//        //6.存在写入到redis//        stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY+id,JSONUtil.toJsonStr(shop),30L, TimeUnit.MINUTES);//        return Result.ok(shop);//    &#125;    //缓存穿透    public Shop queryWithPassThrough(Long id)&#123;        //1.从redis查询商铺缓存        String shopJson = stringRedisTemplate.opsForValue().get(CACHE_SHOP_KEY+ id);        //2.判断是否存在        if (StrUtil.isNotBlank(shopJson)) &#123;            //3.存在直接返回            return  JSONUtil.toBean(shopJson, Shop.class);        &#125;        //判断命中的是否是空值        if(shopJson != null) &#123;            //返回一个错误信息           return null;        &#125;        //4.不存在根据id查询数据库        Shop shop=getById(id);        //5.不存在返回错误        if (shop == null) &#123;            //将空值写入到redis            stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY+ id,&quot;&quot;,CACHE_NULL_TTL,TimeUnit.MINUTES);            return null;        &#125;        //6.存在写入到redis        stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY+id,JSONUtil.toJsonStr(shop),30L, TimeUnit.MINUTES);        return shop;    &#125;    public Shop queryWithMutex(Long id) &#123;        String locKey=&quot;lock:shop&quot;+id;        Shop shop=null;        try &#123;//1.从redis查询商铺缓存        String shopJson = stringRedisTemplate.opsForValue().get(CACHE_SHOP_KEY+ id);        //2.判断是否存在        if (StrUtil.isNotBlank(shopJson)) &#123;            //3.存在直接返回            return  JSONUtil.toBean(shopJson, Shop.class);        &#125;        //判断命中的是否是空值        if(shopJson != null) &#123;            //返回一个错误信息            return null;        &#125;        //4.不存在根据id查询数据库        //4.1获取互斥锁        boolean isLock=tryLock(locKey);        //4.2判断是否成功        if (!isLock)&#123;            //4.3失败则休眠并重试                Thread.sleep(50);            return queryWithMutex(id);        &#125;        //4.4成功根据id查询数据库      shop=getById(id);        //5.不存在返回错误        if (shop == null) &#123;            //将空值写入到redis            stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY+ id,&quot;&quot;,CACHE_NULL_TTL,TimeUnit.MINUTES);            return null;        &#125;        //6.存在写入到redis        stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY+id,JSONUtil.toJsonStr(shop),30L, TimeUnit.MINUTES);        &#125; catch (InterruptedException e) &#123;            throw new RuntimeException(e);        &#125;finally &#123;            //7.释放互斥锁            unlock(locKey);        &#125;        return shop;    &#125;    private boolean tryLock(String key)&#123;        Boolean aBoolean = stringRedisTemplate.opsForValue().setIfAbsent(key, &quot;1&quot;, 10, TimeUnit.SECONDS);        return BooleanUtil.isTrue(aBoolean);    &#125;    private void unlock(String key)&#123;            stringRedisTemplate.delete(key);    &#125;    @Override    @Transactional    public Result updateShop(Shop shop) &#123;        //1.更新数据库        updateById(shop);        if (shop.getId() ==null)&#123;            return Result.fail(&quot;Shop not found&quot;);        &#125;        //2.删除缓存        stringRedisTemplate.delete(CACHE_SHOP_KEY+shop.getId());        return Result.ok();    &#125;&#125;</code></pre><h1 id="redis解决缓存穿透缓存击穿-工具类"><a href="#redis解决缓存穿透缓存击穿-工具类" class="headerlink" title="redis解决缓存穿透缓存击穿 工具类"></a>redis解决缓存穿透缓存击穿 工具类</h1><pre><code>package com.hmdp.utils;import cn.hutool.core.util.BooleanUtil;import cn.hutool.core.util.StrUtil;import cn.hutool.json.JSONObject;import cn.hutool.json.JSONUtil;import lombok.extern.slf4j.Slf4j;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.stereotype.Component;import java.time.LocalDateTime;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.TimeUnit;import java.util.function.Function;import static com.hmdp.utils.RedisConstants.CACHE_NULL_TTL;import static com.hmdp.utils.RedisConstants.LOCK_SHOP_KEY;@Slf4j@Componentpublic class CacheClient &#123;    private final StringRedisTemplate stringRedisTemplate;    private static final ExecutorService CACHE_REBUILD_EXECUTOR = Executors.newFixedThreadPool(10);    public CacheClient(StringRedisTemplate stringRedisTemplate) &#123;        this.stringRedisTemplate = stringRedisTemplate;    &#125;    public void set(String key, Object value, Long time, TimeUnit unit) &#123;        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), time, unit);    &#125;    public void setWithLogicalExpire(String key, Object value, Long time, TimeUnit unit) &#123;        // 设置逻辑过期        RedisData redisData = new RedisData();        redisData.setData(value);        redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(time)));        // 写入Redis        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));    &#125;    public &lt;R,ID&gt; R queryWithPassThrough(            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)&#123;        String key = keyPrefix + id;        // 1.从redis查询商铺缓存        String json = stringRedisTemplate.opsForValue().get(key);        // 2.判断是否存在        if (StrUtil.isNotBlank(json)) &#123;            // 3.存在，直接返回            return JSONUtil.toBean(json, type);        &#125;        // 判断命中的是否是空值        if (json != null) &#123;            // 返回一个错误信息            return null;        &#125;        // 4.不存在，根据id查询数据库        R r = dbFallback.apply(id);        // 5.不存在，返回错误        if (r == null) &#123;            // 将空值写入redis            stringRedisTemplate.opsForValue().set(key, &quot;&quot;, CACHE_NULL_TTL, TimeUnit.MINUTES);            // 返回错误信息            return null;        &#125;        // 6.存在，写入redis        this.set(key, r, time, unit);        return r;    &#125;    public &lt;R, ID&gt; R queryWithLogicalExpire(            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit) &#123;        String key = keyPrefix + id;        // 1.从redis查询商铺缓存        String json = stringRedisTemplate.opsForValue().get(key);        // 2.判断是否存在        if (StrUtil.isBlank(json)) &#123;            // 3.存在，直接返回            return null;        &#125;        // 4.命中，需要先把json反序列化为对象        RedisData redisData = JSONUtil.toBean(json, RedisData.class);        R r = JSONUtil.toBean((JSONObject) redisData.getData(), type);        LocalDateTime expireTime = redisData.getExpireTime();        // 5.判断是否过期        if(expireTime.isAfter(LocalDateTime.now())) &#123;            // 5.1.未过期，直接返回店铺信息            return r;        &#125;        // 5.2.已过期，需要缓存重建        // 6.缓存重建        // 6.1.获取互斥锁        String lockKey = LOCK_SHOP_KEY + id;        boolean isLock = tryLock(lockKey);        // 6.2.判断是否获取锁成功        if (isLock)&#123;            // 6.3.成功，开启独立线程，实现缓存重建            CACHE_REBUILD_EXECUTOR.submit(() -&gt; &#123;                try &#123;                    // 查询数据库                    R newR = dbFallback.apply(id);                    // 重建缓存                    this.setWithLogicalExpire(key, newR, time, unit);                &#125; catch (Exception e) &#123;                    throw new RuntimeException(e);                &#125;finally &#123;                    // 释放锁                    unlock(lockKey);                &#125;            &#125;);        &#125;        // 6.4.返回过期的商铺信息        return r;    &#125;    public &lt;R, ID&gt; R queryWithMutex(            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit) &#123;        String key = keyPrefix + id;        // 1.从redis查询商铺缓存        String shopJson = stringRedisTemplate.opsForValue().get(key);        // 2.判断是否存在        if (StrUtil.isNotBlank(shopJson)) &#123;            // 3.存在，直接返回            return JSONUtil.toBean(shopJson, type);        &#125;        // 判断命中的是否是空值        if (shopJson != null) &#123;            // 返回一个错误信息            return null;        &#125;        // 4.实现缓存重建        // 4.1.获取互斥锁        String lockKey = LOCK_SHOP_KEY + id;        R r = null;        try &#123;            boolean isLock = tryLock(lockKey);            // 4.2.判断是否获取成功            if (!isLock) &#123;                // 4.3.获取锁失败，休眠并重试                Thread.sleep(50);                return queryWithMutex(keyPrefix, id, type, dbFallback, time, unit);            &#125;            // 4.4.获取锁成功，根据id查询数据库            r = dbFallback.apply(id);            // 5.不存在，返回错误            if (r == null) &#123;                // 将空值写入redis                stringRedisTemplate.opsForValue().set(key, &quot;&quot;, CACHE_NULL_TTL, TimeUnit.MINUTES);                // 返回错误信息                return null;            &#125;            // 6.存在，写入redis            this.set(key, r, time, unit);        &#125; catch (InterruptedException e) &#123;            throw new RuntimeException(e);        &#125;finally &#123;            // 7.释放锁            unlock(lockKey);        &#125;        // 8.返回        return r;    &#125;    private boolean tryLock(String key) &#123;        Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key, &quot;1&quot;, 10, TimeUnit.SECONDS);        return BooleanUtil.isTrue(flag);    &#125;    private void unlock(String key) &#123;        stringRedisTemplate.delete(key);    &#125;&#125;</code></pre><h2 id="redis实现秒杀问题解决"><a href="#redis实现秒杀问题解决" class="headerlink" title="redis实现秒杀问题解决"></a>redis实现秒杀问题解决</h2><h3 id="3-3-添加优惠卷"><a href="#3-3-添加优惠卷" class="headerlink" title="3.3 添加优惠卷"></a>3.3 添加优惠卷</h3><p>每个店铺都可以发布优惠券，分为平价券和特价券。平价券可以任意购买，而特价券需要秒杀抢购：</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653365145124.png" alt="1653365145124"></p><p>tb_voucher：优惠券的基本信息，优惠金额、使用规则等<br>tb_seckill_voucher：优惠券的库存、开始抢购时间，结束抢购时间。特价优惠券才需要填写这些信息</p><p>平价卷由于优惠力度并不是很大，所以是可以任意领取</p><p>而代金券由于优惠力度大，所以像第二种卷，就得限制数量，从表结构上也能看出，特价卷除了具有优惠卷的基本信息以外，还具有库存，抢购时间，结束时间等等字段</p><p>**新增普通卷代码：  **VoucherController</p><pre><code class="java">@PostMappingpublic Result addVoucher(@RequestBody Voucher voucher) &#123;    voucherService.save(voucher);    return Result.ok(voucher.getId());&#125;</code></pre><p><strong>新增秒杀卷代码：</strong></p><p><strong>VoucherController</strong></p><pre><code class="java">@PostMapping(&quot;seckill&quot;)public Result addSeckillVoucher(@RequestBody Voucher voucher) &#123;    voucherService.addSeckillVoucher(voucher);    return Result.ok(voucher.getId());&#125;</code></pre><p><strong>VoucherServiceImpl</strong></p><pre><code class="java">@Override@Transactionalpublic void addSeckillVoucher(Voucher voucher) &#123;    // 保存优惠券    save(voucher);    // 保存秒杀信息    SeckillVoucher seckillVoucher = new SeckillVoucher();    seckillVoucher.setVoucherId(voucher.getId());    seckillVoucher.setStock(voucher.getStock());    seckillVoucher.setBeginTime(voucher.getBeginTime());    seckillVoucher.setEndTime(voucher.getEndTime());    seckillVoucherService.save(seckillVoucher);    // 保存秒杀库存到Redis中    stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString());&#125;</code></pre><h3 id="3-4-实现秒杀下单"><a href="#3-4-实现秒杀下单" class="headerlink" title="3.4 实现秒杀下单"></a>3.4 实现秒杀下单</h3><p>下单核心思路：当我们点击抢购时，会触发右侧的请求，我们只需要编写对应的controller即可</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653365839526.png" alt="1653365839526"></p><p>秒杀下单应该思考的内容：</p><p>下单时需要判断两点：</p><ul><li>秒杀是否开始或结束，如果尚未开始或已经结束则无法下单</li><li>库存是否充足，不足则无法下单</li></ul><p>下单核心逻辑分析：</p><p>当用户开始进行下单，我们应当去查询优惠卷信息，查询到优惠卷信息，判断是否满足秒杀条件</p><p>比如时间是否充足，如果时间充足，则进一步判断库存是否足够，如果两者都满足，则扣减库存，创建订单，然后返回订单id，如果有一个条件不满足则直接结束。</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653366238564.png" alt="1653366238564"></p><p>VoucherOrderServiceImpl</p><pre><code class="java">@Overridepublic Result seckillVoucher(Long voucherId) &#123;    // 1.查询优惠券    SeckillVoucher voucher = seckillVoucherService.getById(voucherId);    // 2.判断秒杀是否开始    if (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;        // 尚未开始        return Result.fail(&quot;秒杀尚未开始！&quot;);    &#125;    // 3.判断秒杀是否已经结束    if (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;        // 尚未开始        return Result.fail(&quot;秒杀已经结束！&quot;);    &#125;    // 4.判断库存是否充足    if (voucher.getStock() &lt; 1) &#123;        // 库存不足        return Result.fail(&quot;库存不足！&quot;);    &#125;    //5，扣减库存    boolean success = seckillVoucherService.update()            .setSql(&quot;stock= stock -1&quot;)            .eq(&quot;voucher_id&quot;, voucherId).update();    if (!success) &#123;        //扣减库存        return Result.fail(&quot;库存不足！&quot;);    &#125;    //6.创建订单    VoucherOrder voucherOrder = new VoucherOrder();    // 6.1.订单id    long orderId = redisIdWorker.nextId(&quot;order&quot;);    voucherOrder.setId(orderId);    // 6.2.用户id    Long userId = UserHolder.getUser().getId();    voucherOrder.setUserId(userId);    // 6.3.代金券id    voucherOrder.setVoucherId(voucherId);    save(voucherOrder);    return Result.ok(orderId);&#125;</code></pre><h3 id="3-5-库存超卖问题分析"><a href="#3-5-库存超卖问题分析" class="headerlink" title="3.5 库存超卖问题分析"></a>3.5 库存超卖问题分析</h3><p>有关超卖问题分析：在我们原有代码中是这么写的</p><pre><code class="java"> if (voucher.getStock() &lt; 1) &#123;        // 库存不足        return Result.fail(&quot;库存不足！&quot;);    &#125;    //5，扣减库存    boolean success = seckillVoucherService.update()            .setSql(&quot;stock= stock -1&quot;)            .eq(&quot;voucher_id&quot;, voucherId).update();    if (!success) &#123;        //扣减库存        return Result.fail(&quot;库存不足！&quot;);    &#125;</code></pre><p>假设线程1过来查询库存，判断出来库存大于1，正准备去扣减库存，但是还没有来得及去扣减，此时线程2过来，线程2也去查询库存，发现这个数量一定也大于1，那么这两个线程都会去扣减库存，最终多个线程相当于一起去扣减库存，此时就会出现库存的超卖问题。</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653368335155.png" alt="1653368335155"></p><p>超卖问题是典型的多线程安全问题，针对这一问题的常见解决方案就是加锁：而对于加锁，我们通常有两种解决方案：见下图：</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653368562591.png" alt="1653368562591"></p><p><strong>悲观锁：</strong></p><p> 悲观锁可以实现对于数据的串行化执行，比如syn，和lock都是悲观锁的代表，同时，悲观锁中又可以再细分为公平锁，非公平锁，可重入锁，等等</p><p><strong>乐观锁：</strong></p><p>  乐观锁：会有一个版本号，每次操作数据会对版本号+1，再提交回数据时，会去校验是否比之前的版本大1 ，如果大1 ，则进行操作成功，这套机制的核心逻辑在于，如果在操作过程中，版本号只比原来大1 ，那么就意味着操作过程中没有人对他进行过修改，他的操作就是安全的，如果不大1，则数据被修改过，当然乐观锁还有一些变种的处理方式比如cas</p><p>  乐观锁的典型代表：就是cas，利用cas进行无锁化机制加锁，var5 是操作前读取的内存值，while中的var1+var2 是预估值，如果预估值 &#x3D;&#x3D; 内存值，则代表中间没有被人修改过，此时就将新值去替换 内存值</p><p>  其中do while 是为了在操作失败时，再次进行自旋操作，即把之前的逻辑再操作一次。</p><pre><code class="java">int var5;do &#123;    var5 = this.getIntVolatile(var1, var2);&#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));return var5;</code></pre><p><strong>课程中的使用方式：</strong></p><p>课程中的使用方式是没有像cas一样带自旋的操作，也没有对version的版本号+1 ，他的操作逻辑是在操作时，对版本号进行+1 操作，然后要求version 如果是1 的情况下，才能操作，那么第一个线程在操作后，数据库中的version变成了2，但是他自己满足version&#x3D;1 ，所以没有问题，此时线程2执行，线程2 最后也需要加上条件version &#x3D;1 ，但是现在由于线程1已经操作过了，所以线程2，操作时就不满足version&#x3D;1 的条件了，所以线程2无法执行成功</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653369268550.png" alt="1653369268550"></p><h3 id="3-6-乐观锁解决超卖问题"><a href="#3-6-乐观锁解决超卖问题" class="headerlink" title="3.6 乐观锁解决超卖问题"></a>3.6 乐观锁解决超卖问题</h3><p><strong>修改代码方案一、</strong></p><p>VoucherOrderServiceImpl 在扣减库存时，改为：</p><pre><code class="java">boolean success = seckillVoucherService.update()            .setSql(&quot;stock= stock -1&quot;) //set stock = stock -1            .eq(&quot;voucher_id&quot;, voucherId).eq(&quot;stock&quot;,voucher.getStock()).update(); //where id = ？ and stock = ?</code></pre><p>以上逻辑的核心含义是：只要我扣减库存时的库存和之前我查询到的库存是一样的，就意味着没有人在中间修改过库存，那么此时就是安全的，但是以上这种方式通过测试发现会有很多失败的情况，失败的原因在于：在使用乐观锁过程中假设100个线程同时都拿到了100的库存，然后大家一起去进行扣减，但是100个人中只有1个人能扣减成功，其他的人在处理时，他们在扣减时，库存已经被修改过了，所以此时其他线程都会失败</p><p><strong>修改代码方案二、</strong></p><p>之前的方式要修改前后都保持一致，但是这样我们分析过，成功的概率太低，所以我们的乐观锁需要变一下，改成stock大于0 即可</p><pre><code class="java">boolean success = seckillVoucherService.update()            .setSql(&quot;stock= stock -1&quot;)            .eq(&quot;voucher_id&quot;, voucherId).update().gt(&quot;stock&quot;,0); //where id = ? and stock &gt; 0</code></pre><p><strong>知识小扩展：</strong></p><p>针对cas中的自旋压力过大，我们可以使用Longaddr这个类去解决</p><p>Java8 提供的一个对AtomicLong改进后的一个类，LongAdder</p><p>大量线程并发更新一个原子性的时候，天然的问题就是自旋，会导致并发性问题，当然这也比我们直接使用syn来的好</p><p>所以利用这么一个类，LongAdder来进行优化</p><p>如果获取某个值，则会对cell和base的值进行递增，最后返回一个完整的值</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653370271627.png" alt="1653370271627"></p><h3 id="3-6-优惠券秒杀-一人一单"><a href="#3-6-优惠券秒杀-一人一单" class="headerlink" title="3.6 优惠券秒杀-一人一单"></a>3.6 优惠券秒杀-一人一单</h3><p>需求：修改秒杀业务，要求同一个优惠券，一个用户只能下一单</p><p><strong>现在的问题在于：</strong></p><p>优惠卷是为了引流，但是目前的情况是，一个人可以无限制的抢这个优惠卷，所以我们应当增加一层逻辑，让一个用户只能下一个单，而不是让一个用户下多个单</p><p>具体操作逻辑如下：比如时间是否充足，如果时间充足，则进一步判断库存是否足够，然后再根据优惠卷id和用户id查询是否已经下过这个订单，如果下过这个订单，则不再下单，否则进行下单</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653371854389.png" alt="1653371854389"></p><p>VoucherOrderServiceImpl  </p><p><strong>初步代码：增加一人一单逻辑</strong></p><pre><code class="java">@Overridepublic Result seckillVoucher(Long voucherId) &#123;    // 1.查询优惠券    SeckillVoucher voucher = seckillVoucherService.getById(voucherId);    // 2.判断秒杀是否开始    if (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;        // 尚未开始        return Result.fail(&quot;秒杀尚未开始！&quot;);    &#125;    // 3.判断秒杀是否已经结束    if (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;        // 尚未开始        return Result.fail(&quot;秒杀已经结束！&quot;);    &#125;    // 4.判断库存是否充足    if (voucher.getStock() &lt; 1) &#123;        // 库存不足        return Result.fail(&quot;库存不足！&quot;);    &#125;    // 5.一人一单逻辑    // 5.1.用户id    Long userId = UserHolder.getUser().getId();    int count = query().eq(&quot;user_id&quot;, userId).eq(&quot;voucher_id&quot;, voucherId).count();    // 5.2.判断是否存在    if (count &gt; 0) &#123;        // 用户已经购买过了        return Result.fail(&quot;用户已经购买过一次！&quot;);    &#125;    //6，扣减库存    boolean success = seckillVoucherService.update()            .setSql(&quot;stock= stock -1&quot;)            .eq(&quot;voucher_id&quot;, voucherId).update();    if (!success) &#123;        //扣减库存        return Result.fail(&quot;库存不足！&quot;);    &#125;    //7.创建订单    VoucherOrder voucherOrder = new VoucherOrder();    // 7.1.订单id    long orderId = redisIdWorker.nextId(&quot;order&quot;);    voucherOrder.setId(orderId);    voucherOrder.setUserId(userId);    // 7.3.代金券id    voucherOrder.setVoucherId(voucherId);    save(voucherOrder);    return Result.ok(orderId);&#125;</code></pre><p><strong>存在问题：</strong>现在的问题还是和之前一样，并发过来，查询数据库，都不存在订单，所以我们还是需要加锁，但是乐观锁比较适合更新数据，而现在是插入数据，所以我们需要使用悲观锁操作</p><p><strong>注意：</strong>在这里提到了非常多的问题，我们需要慢慢的来思考，首先我们的初始方案是封装了一个createVoucherOrder方法，同时为了确保他线程安全，在方法上添加了一把synchronized 锁</p><pre><code class="java">@Transactionalpublic synchronized Result createVoucherOrder(Long voucherId) &#123;    Long userId = UserHolder.getUser().getId();         // 5.1.查询订单        int count = query().eq(&quot;user_id&quot;, userId).eq(&quot;voucher_id&quot;, voucherId).count();        // 5.2.判断是否存在        if (count &gt; 0) &#123;            // 用户已经购买过了            return Result.fail(&quot;用户已经购买过一次！&quot;);        &#125;        // 6.扣减库存        boolean success = seckillVoucherService.update()                .setSql(&quot;stock = stock - 1&quot;) // set stock = stock - 1                .eq(&quot;voucher_id&quot;, voucherId).gt(&quot;stock&quot;, 0) // where id = ? and stock &gt; 0                .update();        if (!success) &#123;            // 扣减失败            return Result.fail(&quot;库存不足！&quot;);        &#125;        // 7.创建订单        VoucherOrder voucherOrder = new VoucherOrder();        // 7.1.订单id        long orderId = redisIdWorker.nextId(&quot;order&quot;);        voucherOrder.setId(orderId);        // 7.2.用户id        voucherOrder.setUserId(userId);        // 7.3.代金券id        voucherOrder.setVoucherId(voucherId);        save(voucherOrder);        // 7.返回订单id        return Result.ok(orderId);&#125;</code></pre><p>，但是这样添加锁，锁的粒度太粗了，在使用锁过程中，控制<strong>锁粒度</strong> 是一个非常重要的事情，因为如果锁的粒度太大，会导致每个线程进来都会锁住，所以我们需要去控制锁的粒度，以下这段代码需要修改为：<br>intern() 这个方法是从常量池中拿到数据，如果我们直接使用userId.toString() 他拿到的对象实际上是不同的对象，new出来的对象，我们使用锁必须保证锁必须是同一把，所以我们需要使用intern()方法</p><pre><code class="java">@Transactionalpublic  Result createVoucherOrder(Long voucherId) &#123;    Long userId = UserHolder.getUser().getId();    synchronized(userId.toString().intern())&#123;         // 5.1.查询订单        int count = query().eq(&quot;user_id&quot;, userId).eq(&quot;voucher_id&quot;, voucherId).count();        // 5.2.判断是否存在        if (count &gt; 0) &#123;            // 用户已经购买过了            return Result.fail(&quot;用户已经购买过一次！&quot;);        &#125;        // 6.扣减库存        boolean success = seckillVoucherService.update()                .setSql(&quot;stock = stock - 1&quot;) // set stock = stock - 1                .eq(&quot;voucher_id&quot;, voucherId).gt(&quot;stock&quot;, 0) // where id = ? and stock &gt; 0                .update();        if (!success) &#123;            // 扣减失败            return Result.fail(&quot;库存不足！&quot;);        &#125;        // 7.创建订单        VoucherOrder voucherOrder = new VoucherOrder();        // 7.1.订单id        long orderId = redisIdWorker.nextId(&quot;order&quot;);        voucherOrder.setId(orderId);        // 7.2.用户id        voucherOrder.setUserId(userId);        // 7.3.代金券id        voucherOrder.setVoucherId(voucherId);        save(voucherOrder);        // 7.返回订单id        return Result.ok(orderId);    &#125;&#125;</code></pre><p>但是以上代码还是存在问题，问题的原因在于当前方法被spring的事务控制，如果你在方法内部加锁，可能会导致当前方法事务还没有提交，但是锁已经释放也会导致问题，所以我们选择将当前方法整体包裹起来，确保事务不会出现问题：如下：</p><p>在seckillVoucher 方法中，添加以下逻辑，这样就能保证事务的特性，同时也控制了锁的粒度</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653373434815.png" alt="1653373434815"></p><p>但是以上做法依然有问题，因为你调用的方法，其实是this.的方式调用的，事务想要生效，还得利用代理来生效，所以这个地方，我们需要获得原始的事务对象， 来操作事务</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653383810643.png" alt="1653383810643"></p><h3 id="3-7-集群环境下的并发问题"><a href="#3-7-集群环境下的并发问题" class="headerlink" title="3.7 集群环境下的并发问题"></a>3.7 集群环境下的并发问题</h3><p>通过加锁可以解决在单机情况下的一人一单安全问题，但是在集群模式下就不行了。</p><p>1、我们将服务启动两份，端口分别为8081和8082：</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653373887844.png" alt="1653373887844"></p><p>2、然后修改nginx的conf目录下的nginx.conf文件，配置反向代理和负载均衡：</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653373908620.png" alt="1653373908620"></p><p><strong>具体操作(略)</strong></p><p><strong>有关锁失效原因分析</strong></p><p>由于现在我们部署了多个tomcat，每个tomcat都有一个属于自己的jvm，那么假设在服务器A的tomcat内部，有两个线程，这两个线程由于使用的是同一份代码，那么他们的锁对象是同一个，是可以实现互斥的，但是如果现在是服务器B的tomcat内部，又有两个线程，但是他们的锁对象写的虽然和服务器A一样，但是锁对象却不是同一个，所以线程3和线程4可以实现互斥，但是却无法和线程1和线程2实现互斥，这就是 集群环境下，syn锁失效的原因，在这种情况下，我们就需要使用分布式锁来解决这个问题。</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653374044740.png" alt="1653374044740"></p><h2 id="4、分布式锁"><a href="#4、分布式锁" class="headerlink" title="4、分布式锁"></a>4、分布式锁</h2><h3 id="4-1-、基本原理和实现方式对比"><a href="#4-1-、基本原理和实现方式对比" class="headerlink" title="4.1 、基本原理和实现方式对比"></a>4.1 、基本原理和实现方式对比</h3><p>分布式锁：满足分布式系统或集群模式下多进程可见并且互斥的锁。</p><p>分布式锁的核心思想就是让大家都使用同一把锁，只要大家使用的是同一把锁，那么我们就能锁住线程，不让线程进行，让程序串行执行，这就是分布式锁的核心思路</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653374296906.png" alt="1653374296906"></p><p>那么分布式锁他应该满足一些什么样的条件呢？</p><p>可见性：多个线程都能看到相同的结果，注意：这个地方说的可见性并不是并发编程中指的内存可见性，只是说多个进程之间都能感知到变化的意思</p><p>互斥：互斥是分布式锁的最基本的条件，使得程序串行执行</p><p>高可用：程序不易崩溃，时时刻刻都保证较高的可用性</p><p>高性能：由于加锁本身就让性能降低，所有对于分布式锁本身需要他就较高的加锁性能和释放锁性能</p><p>安全性：安全也是程序中必不可少的一环</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653381992018.png" alt="1653381992018"></p><p>常见的分布式锁有三种</p><p>Mysql：mysql本身就带有锁机制，但是由于mysql性能本身一般，所以采用分布式锁的情况下，其实使用mysql作为分布式锁比较少见</p><p>Redis：redis作为分布式锁是非常常见的一种使用方式，现在企业级开发中基本都使用redis或者zookeeper作为分布式锁，利用setnx这个方法，如果插入key成功，则表示获得到了锁，如果有人插入成功，其他人插入失败则表示无法获得到锁，利用这套逻辑来实现分布式锁</p><p>Zookeeper：zookeeper也是企业级开发中较好的一个实现分布式锁的方案，由于本套视频并不讲解zookeeper的原理和分布式锁的实现，所以不过多阐述</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653382219377.png" alt="1653382219377"></p><h3 id="4-2-、Redis分布式锁的实现核心思路"><a href="#4-2-、Redis分布式锁的实现核心思路" class="headerlink" title="4.2 、Redis分布式锁的实现核心思路"></a>4.2 、Redis分布式锁的实现核心思路</h3><p>实现分布式锁时需要实现的两个基本方法：</p><ul><li><p>获取锁：</p><ul><li>互斥：确保只能有一个线程获取锁</li><li>非阻塞：尝试一次，成功返回true，失败返回false</li></ul></li><li><p>释放锁：</p><ul><li>手动释放</li><li>超时释放：获取锁时添加一个超时时间</li></ul><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653382669900.png" alt="1653382669900"></p></li></ul><p>核心思路：</p><p>我们利用redis 的setNx 方法，当有多个线程进入时，我们就利用该方法，第一个线程进入时，redis 中就有这个key 了，返回了1，如果结果是1，则表示他抢到了锁，那么他去执行业务，然后再删除锁，退出锁逻辑，没有抢到锁的哥们，等待一定时间后重试即可</p><p> <img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653382830810.png" alt="1653382830810"></p><h3 id="4-3-实现分布式锁版本一"><a href="#4-3-实现分布式锁版本一" class="headerlink" title="4.3 实现分布式锁版本一"></a>4.3 实现分布式锁版本一</h3><ul><li>加锁逻辑</li></ul><p><strong>锁的基本接口</strong></p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1656079017728.png" alt="1656079017728"></p><p><strong>SimpleRedisLock</strong></p><p>利用setnx方法进行加锁，同时增加过期时间，防止死锁，此方法可以保证加锁和增加过期时间具有原子性</p><pre><code class="java">private static final String KEY_PREFIX=&quot;lock:&quot;@Overridepublic boolean tryLock(long timeoutSec) &#123;    // 获取线程标示    String threadId = Thread.currentThread().getId()    // 获取锁    Boolean success = stringRedisTemplate.opsForValue()            .setIfAbsent(KEY_PREFIX + name, threadId + &quot;&quot;, timeoutSec, TimeUnit.SECONDS);    return Boolean.TRUE.equals(success);&#125;</code></pre><ul><li>释放锁逻辑</li></ul><p>SimpleRedisLock</p><p>释放锁，防止删除别人的锁</p><pre><code class="java">public void unlock() &#123;    //通过del删除锁    stringRedisTemplate.delete(KEY_PREFIX + name);&#125;</code></pre><ul><li>修改业务代码</li></ul><pre><code class="java">  @Override    public Result seckillVoucher(Long voucherId) &#123;        // 1.查询优惠券        SeckillVoucher voucher = seckillVoucherService.getById(voucherId);        // 2.判断秒杀是否开始        if (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;            // 尚未开始            return Result.fail(&quot;秒杀尚未开始！&quot;);        &#125;        // 3.判断秒杀是否已经结束        if (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;            // 尚未开始            return Result.fail(&quot;秒杀已经结束！&quot;);        &#125;        // 4.判断库存是否充足        if (voucher.getStock() &lt; 1) &#123;            // 库存不足            return Result.fail(&quot;库存不足！&quot;);        &#125;        Long userId = UserHolder.getUser().getId();        //创建锁对象(新增代码)        SimpleRedisLock lock = new SimpleRedisLock(&quot;order:&quot; + userId, stringRedisTemplate);        //获取锁对象        boolean isLock = lock.tryLock(1200);        //加锁失败        if (!isLock) &#123;            return Result.fail(&quot;不允许重复下单&quot;);        &#125;        try &#123;            //获取代理对象(事务)            IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();            return proxy.createVoucherOrder(voucherId);        &#125; finally &#123;            //释放锁            lock.unlock();        &#125;    &#125;</code></pre><h3 id="4-4-Redis分布式锁误删情况说明"><a href="#4-4-Redis分布式锁误删情况说明" class="headerlink" title="4.4 Redis分布式锁误删情况说明"></a>4.4 Redis分布式锁误删情况说明</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue3 状态管理 - Pinia</title>
      <link href="/2023/08/08/Pinia/"/>
      <url>/2023/08/08/Pinia/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue3-状态管理-Pinia"><a href="#Vue3-状态管理-Pinia" class="headerlink" title="Vue3 状态管理 - Pinia"></a>Vue3 状态管理 - Pinia</h1><h2 id="1-什么是Pinia"><a href="#1-什么是Pinia" class="headerlink" title="1. 什么是Pinia"></a>1. 什么是Pinia</h2><p>Pinia 是 Vue 的专属的最新状态管理库 ，是 Vuex 状态管理工具的替代品<br><img src="/assets/31.png" alt="image.png"></p><h2 id="2-手动添加Pinia到Vue项目"><a href="#2-手动添加Pinia到Vue项目" class="headerlink" title="2. 手动添加Pinia到Vue项目"></a>2. 手动添加Pinia到Vue项目</h2><p>后面在实际开发项目的时候，Pinia可以在项目创建时自动添加，现在我们初次学习，从零开始：</p><ol><li>使用 Vite 创建一个空的 Vue3项目</li></ol><pre><code class="bash">npm init vite@latest</code></pre><ol start="2"><li>按照官方文档安装 pinia 到项目中</li></ol><h2 id="3-Pinia基础使用"><a href="#3-Pinia基础使用" class="headerlink" title="3. Pinia基础使用"></a>3. Pinia基础使用</h2><ol><li>定义store</li><li>组件使用store</li></ol><p><img src="/assets/32.png" alt="image.png"></p><h2 id="4-getters实现"><a href="#4-getters实现" class="headerlink" title="4. getters实现"></a>4. getters实现</h2><p>Pinia中的 getters 直接使用 computed函数 进行模拟, 组件中需要使用需要把 getters return出去</p><p><img src="/assets/33.png" alt="image.png"></p><h2 id="5-action异步实现"><a href="#5-action异步实现" class="headerlink" title="5. action异步实现"></a>5. action异步实现</h2><p>方式：异步action函数的写法和组件中获取异步数据的写法完全一致</p><ul><li><p>接口地址：<a href="http://geek.itheima.net/v1_0/channels">http://geek.itheima.net/v1_0/channels</a></p></li><li><p>请求方式：get</p></li><li><p>请求参数：无</p></li></ul><p><img src="/assets/34.png" alt="image.png"></p><p>需求：在Pinia中获取频道列表数据并把数据渲染App组件的模板中<br><img src="/assets/35.png" alt="image.png"></p><h2 id="6-storeToRefs工具函数"><a href="#6-storeToRefs工具函数" class="headerlink" title="6. storeToRefs工具函数"></a>6. storeToRefs工具函数</h2><p>使用storeToRefs函数可以辅助保持数据（state + getter）的响应式解构<br><img src="/assets/36.png" alt="image.png"></p><h2 id="7-Pinia的调试"><a href="#7-Pinia的调试" class="headerlink" title="7. Pinia的调试"></a>7. Pinia的调试</h2><p>Vue官方的 dev-tools 调试工具 对 Pinia直接支持，可以直接进行调试<br><img src="/assets/37.png" alt="image.png"></p><h2 id="8-Pinia持久化插件"><a href="#8-Pinia持久化插件" class="headerlink" title="8. Pinia持久化插件"></a>8. Pinia持久化插件</h2><p>官方文档：<a href="https://prazdevs.github.io/pinia-plugin-persistedstate/zh/">https://prazdevs.github.io/pinia-plugin-persistedstate/zh/</a></p><ol><li>安装插件 pinia-plugin-persistedstate</li></ol><pre><code class="jsx">npm i pinia-plugin-persistedstate</code></pre><ol start="2"><li>使用 main.js</li></ol><pre><code class="jsx">import persist from &#39;pinia-plugin-persistedstate&#39;...app.use(createPinia().use(persist))</code></pre><ol start="3"><li>配置 store&#x2F;counter.js</li></ol><pre><code class="jsx">import &#123; defineStore &#125; from &#39;pinia&#39;import &#123; computed, ref &#125; from &#39;vue&#39;export const useCounterStore = defineStore(&#39;counter&#39;, () =&gt; &#123;  ...  return &#123;    count,    doubleCount,    increment  &#125;&#125;, &#123;  persist: true&#125;)</code></pre><ol start="4"><li>其他配置，看官网文档即可</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/08/08/Vue3%E5%85%A5%E9%97%A8/"/>
      <url>/2023/08/08/Vue3%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="认识Vue3"><a href="#认识Vue3" class="headerlink" title="认识Vue3"></a>认识Vue3</h1><h2 id="1-Vue2-选项式-API-vs-Vue3-组合式API"><a href="#1-Vue2-选项式-API-vs-Vue3-组合式API" class="headerlink" title="1. Vue2 选项式 API vs Vue3 组合式API"></a>1. Vue2 选项式 API vs Vue3 组合式API</h2><pre><code class="vue">&lt;script&gt;export default &#123;  data()&#123;    return &#123;      count:0    &#125;  &#125;,  methods:&#123;    addCount()&#123;      this.count++    &#125;  &#125;&#125;&lt;/script&gt;</code></pre><pre><code class="vue">&lt;script setup&gt;import &#123; ref &#125; from &#39;vue&#39;const count = ref(0)const addCount = ()=&gt; count.value++&lt;/script&gt;</code></pre><p>特点：</p><ol><li>代码量变少</li><li>分散式维护变成集中式维护</li></ol><h2 id="2-Vue3的优势"><a href="#2-Vue3的优势" class="headerlink" title="2. Vue3的优势"></a>2. Vue3的优势</h2><p><img src="/assets/01.png" alt="image.png"></p><h1 id="使用create-vue搭建Vue3项目"><a href="#使用create-vue搭建Vue3项目" class="headerlink" title="使用create-vue搭建Vue3项目"></a>使用create-vue搭建Vue3项目</h1><h2 id="1-认识create-vue"><a href="#1-认识create-vue" class="headerlink" title="1. 认识create-vue"></a>1. 认识create-vue</h2><blockquote><p>create-vue是Vue官方新的脚手架工具，底层切换到了 vite （下一代前端工具链），为开发提供极速响应</p></blockquote><p><img src="/assets/2.png" alt="image.png"></p><h2 id="2-使用create-vue创建项目"><a href="#2-使用create-vue创建项目" class="headerlink" title="2. 使用create-vue创建项目"></a>2. 使用create-vue创建项目</h2><blockquote><p>前置条件 - 已安装16.0或更高版本的Node.js</p></blockquote><p>执行如下命令，这一指令将会安装并执行 create-vue</p><pre><code class="bash">npm init vue@latest</code></pre><p><img src="/assets/3.png" alt="image.png"></p><h1 id="熟悉项目和关键文件"><a href="#熟悉项目和关键文件" class="headerlink" title="熟悉项目和关键文件"></a>熟悉项目和关键文件</h1><p><img src="/assets/4.png" alt="image.png"></p><h1 id="组合式API-setup选项"><a href="#组合式API-setup选项" class="headerlink" title="组合式API - setup选项"></a>组合式API - setup选项</h1><h2 id="1-setup选项的写法和执行时机"><a href="#1-setup选项的写法和执行时机" class="headerlink" title="1. setup选项的写法和执行时机"></a>1. setup选项的写法和执行时机</h2><p>写法</p><pre><code class="vue">&lt;script&gt;  export default &#123;    setup()&#123;          &#125;,    beforeCreate()&#123;          &#125;  &#125;&lt;/script&gt;</code></pre><p>执行时机</p><blockquote><p>在beforeCreate钩子之前执行</p></blockquote><p><img src="/assets/5.png" alt="image.png"></p><h2 id="2-setup中写代码的特点"><a href="#2-setup中写代码的特点" class="headerlink" title="2. setup中写代码的特点"></a>2. setup中写代码的特点</h2><blockquote><p>在setup函数中写的数据和方法需要在末尾以对象的方式return，才能给模版使用</p></blockquote><pre><code class="vue">&lt;script&gt;  export default &#123;    setup()&#123;      const message = &#39;this is message&#39;      const logMessage = ()=&gt;&#123;        console.log(message)      &#125;      // 必须return才可以      return &#123;        message,        logMessage      &#125;    &#125;  &#125;&lt;/script&gt;</code></pre><h2 id="3-语法糖"><a href="#3-语法糖" class="headerlink" title="3. 语法糖"></a>3. <script setup>语法糖</h2><blockquote><p>script标签添加 setup标记，不需要再写导出语句，默认会添加导出语句</p></blockquote><pre><code class="vue">&lt;script setup&gt;  const message = &#39;this is message&#39;  const logMessage = ()=&gt;&#123;    console.log(message)  &#125;&lt;/script&gt;</code></pre><h1 id="组合式API-reactive和ref函数"><a href="#组合式API-reactive和ref函数" class="headerlink" title="组合式API - reactive和ref函数"></a>组合式API - reactive和ref函数</h1><h2 id="1-reactive"><a href="#1-reactive" class="headerlink" title="1. reactive"></a>1. reactive</h2><blockquote><p>接受对象类型数据的参数传入并返回一个响应式的对象</p></blockquote><pre><code class="vue">&lt;script setup&gt; // 导入 import &#123; reactive &#125; from &#39;vue&#39; // 执行函数 传入参数 变量接收 const state = reactive(&#123;   msg:&#39;this is msg&#39; &#125;) const setSate = ()=&gt;&#123;   // 修改数据更新视图   state.msg = &#39;this is new msg&#39; &#125;&lt;/script&gt;&lt;template&gt;  &#123;&#123; state.msg &#125;&#125;  &lt;button @click=&quot;setState&quot;&gt;change msg&lt;/button&gt;&lt;/template&gt;</code></pre><h2 id="2-ref"><a href="#2-ref" class="headerlink" title="2. ref"></a>2. ref</h2><blockquote><p>接收简单类型或者对象类型的数据传入并返回一个响应式的对象</p></blockquote><pre><code class="vue">&lt;script setup&gt; // 导入 import &#123; ref &#125; from &#39;vue&#39; // 执行函数 传入参数 变量接收 const count = ref(0) const setCount = ()=&gt;&#123;   // 修改数据更新视图必须加上.value   count.value++ &#125;&lt;/script&gt;&lt;template&gt;  &lt;button @click=&quot;setCount&quot;&gt;&#123;&#123;count&#125;&#125;&lt;/button&gt;&lt;/template&gt;</code></pre><h2 id="3-reactive-对比-ref"><a href="#3-reactive-对比-ref" class="headerlink" title="3. reactive 对比 ref"></a>3. reactive 对比 ref</h2><ol><li>都是用来生成响应式数据</li><li>不同点<ol><li>reactive不能处理简单类型的数据</li><li>ref参数类型支持更好，但是必须通过.value做访问修改</li><li>ref函数内部的实现依赖于reactive函数</li></ol></li><li>在实际工作中的推荐<ol><li>推荐使用ref函数，减少记忆负担，小兔鲜项目都使用ref</li></ol></li></ol><h1 id="组合式API-computed"><a href="#组合式API-computed" class="headerlink" title="组合式API - computed"></a>组合式API - computed</h1><blockquote><p>计算属性基本思想和Vue2保持一致，组合式API下的计算属性只是修改了API写法</p></blockquote><pre><code class="vue">&lt;script setup&gt;// 导入import &#123;ref, computed &#125; from &#39;vue&#39;// 原始数据const count = ref(0)// 计算属性const doubleCount = computed(()=&gt;count.value * 2)// 原始数据const list = ref([1,2,3,4,5,6,7,8])// 计算属性listconst filterList = computed(item=&gt;item &gt; 2)&lt;/script&gt;</code></pre><h1 id="组合式API-watch"><a href="#组合式API-watch" class="headerlink" title="组合式API - watch"></a>组合式API - watch</h1><blockquote><p>侦听一个或者多个数据的变化，数据变化时执行回调函数，俩个额外参数 immediate控制立刻执行，deep开启深度侦听</p></blockquote><h2 id="1-侦听单个数据"><a href="#1-侦听单个数据" class="headerlink" title="1. 侦听单个数据"></a>1. 侦听单个数据</h2><pre><code class="vue">&lt;script setup&gt;  // 1. 导入watch  import &#123; ref, watch &#125; from &#39;vue&#39;  const count = ref(0)  // 2. 调用watch 侦听变化  watch(count, (newValue, oldValue)=&gt;&#123;    console.log(`count发生了变化，老值为$&#123;oldValue&#125;,新值为$&#123;newValue&#125;`)  &#125;)&lt;/script&gt;</code></pre><h2 id="2-侦听多个数据"><a href="#2-侦听多个数据" class="headerlink" title="2. 侦听多个数据"></a>2. 侦听多个数据</h2><blockquote><p>侦听多个数据，第一个参数可以改写成数组的写法</p></blockquote><pre><code class="vue">&lt;script setup&gt;  // 1. 导入watch  import &#123; ref, watch &#125; from &#39;vue&#39;  const count = ref(0)  const name = ref(&#39;cp&#39;)  // 2. 调用watch 侦听变化  watch([count, name], ([newCount, newName],[oldCount,oldName])=&gt;&#123;    console.log(`count或者name变化了，[newCount, newName],[oldCount,oldName])  &#125;)&lt;/script&gt;</code></pre><h2 id="3-immediate"><a href="#3-immediate" class="headerlink" title="3. immediate"></a>3. immediate</h2><blockquote><p>在侦听器创建时立即出发回调，响应式数据变化之后继续执行回调</p></blockquote><pre><code class="vue">&lt;script setup&gt;  // 1. 导入watch  import &#123; ref, watch &#125; from &#39;vue&#39;  const count = ref(0)  // 2. 调用watch 侦听变化  watch(count, (newValue, oldValue)=&gt;&#123;    console.log(`count发生了变化，老值为$&#123;oldValue&#125;,新值为$&#123;newValue&#125;`)  &#125;,&#123;    immediate: true  &#125;)&lt;/script&gt;</code></pre><h2 id="4-deep"><a href="#4-deep" class="headerlink" title="4. deep"></a>4. deep</h2><blockquote><p>通过watch监听的ref对象默认是浅层侦听的，直接修改嵌套的对象属性不会触发回调执行，需要开启deep</p></blockquote><pre><code class="vue">&lt;script setup&gt;  // 1. 导入watch  import &#123; ref, watch &#125; from &#39;vue&#39;  const state = ref(&#123; count: 0 &#125;)  // 2. 监听对象state  watch(state, ()=&gt;&#123;    console.log(&#39;数据变化了&#39;)  &#125;)  const changeStateByCount = ()=&gt;&#123;    // 直接修改不会引发回调执行    state.value.count++  &#125;&lt;/script&gt;&lt;script setup&gt;  // 1. 导入watch  import &#123; ref, watch &#125; from &#39;vue&#39;  const state = ref(&#123; count: 0 &#125;)  // 2. 监听对象state 并开启deep  watch(state, ()=&gt;&#123;    console.log(&#39;数据变化了&#39;)  &#125;,&#123;deep:true&#125;)  const changeStateByCount = ()=&gt;&#123;    // 此时修改可以触发回调    state.value.count++  &#125;&lt;/script&gt;</code></pre><h1 id="组合式API-生命周期函数"><a href="#组合式API-生命周期函数" class="headerlink" title="组合式API - 生命周期函数"></a>组合式API - 生命周期函数</h1><h2 id="1-选项式对比组合式"><a href="#1-选项式对比组合式" class="headerlink" title="1. 选项式对比组合式"></a>1. 选项式对比组合式</h2><p><img src="/assets/6.png" alt="image.png"></p><h2 id="2-生命周期函数基本使用"><a href="#2-生命周期函数基本使用" class="headerlink" title="2. 生命周期函数基本使用"></a>2. 生命周期函数基本使用</h2><blockquote><ol><li>导入生命周期函数</li><li>执行生命周期函数，传入回调</li></ol></blockquote><pre><code class="vue">&lt;scirpt setup&gt;import &#123; onMounted &#125; from &#39;vue&#39;onMounted(()=&gt;&#123;  // 自定义逻辑&#125;)&lt;/script&gt;</code></pre><h2 id="3-执行多次"><a href="#3-执行多次" class="headerlink" title="3. 执行多次"></a>3. 执行多次</h2><blockquote><p>生命周期函数执行多次的时候，会按照顺序依次执行</p></blockquote><pre><code class="vue">&lt;scirpt setup&gt;import &#123; onMounted &#125; from &#39;vue&#39;onMounted(()=&gt;&#123;  // 自定义逻辑&#125;)onMounted(()=&gt;&#123;  // 自定义逻辑&#125;)&lt;/script&gt;</code></pre><h1 id="组合式API-父子通信"><a href="#组合式API-父子通信" class="headerlink" title="组合式API - 父子通信"></a>组合式API - 父子通信</h1><h2 id="1-父传子"><a href="#1-父传子" class="headerlink" title="1. 父传子"></a>1. 父传子</h2><blockquote><p>基本思想</p><ol><li>父组件中给子组件绑定属性</li><li>子组件内部通过props选项接收数据</li></ol></blockquote><p><img src="/assets/7.png" alt="image.png"></p><h2 id="2-子传父"><a href="#2-子传父" class="headerlink" title="2. 子传父"></a>2. 子传父</h2><blockquote><p>基本思想</p><ol><li>父组件中给子组件标签通过@绑定事件</li><li>子组件内部通过 emit 方法触发事件</li></ol></blockquote><p><img src="/assets/8.png" alt="image.png"></p><h1 id="组合式API-模版引用"><a href="#组合式API-模版引用" class="headerlink" title="组合式API - 模版引用"></a>组合式API - 模版引用</h1><blockquote><p>概念：通过 ref标识 获取真实的 dom对象或者组件实例对象</p></blockquote><h2 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1. 基本使用"></a>1. 基本使用</h2><blockquote><p>实现步骤：</p><ol><li>调用ref函数生成一个ref对象</li><li>通过ref标识绑定ref对象到标签</li></ol></blockquote><p><img src="/assets/9.png" alt="image.png"></p><h2 id="2-defineExpose"><a href="#2-defineExpose" class="headerlink" title="2. defineExpose"></a>2. defineExpose</h2><blockquote><p>默认情况下在 <script setup>语法糖下组件内部的属性和方法是不开放给父组件访问的，可以通过defineExpose编译宏指定哪些属性和方法容许访问<br>说明：指定testMessage属性可以被访问到</p></blockquote><p><img src="/assets/10.png" alt="image.png"></p><h1 id="组合式API-provide和inject"><a href="#组合式API-provide和inject" class="headerlink" title="组合式API - provide和inject"></a>组合式API - provide和inject</h1><h2 id="1-作用和场景"><a href="#1-作用和场景" class="headerlink" title="1. 作用和场景"></a>1. 作用和场景</h2><blockquote><p>顶层组件向任意的底层组件传递数据和方法，实现跨层组件通信</p></blockquote><p><img src="/assets/11.png" alt="image.png"></p><h2 id="2-跨层传递普通数据"><a href="#2-跨层传递普通数据" class="headerlink" title="2. 跨层传递普通数据"></a>2. 跨层传递普通数据</h2><blockquote><p>实现步骤</p><ol><li>顶层组件通过 <code>provide</code> 函数提供数据</li><li>底层组件通过 <code>inject</code> 函数提供数据</li></ol></blockquote><p><img src="/assets/12.png" alt="image.png"></p><h2 id="3-跨层传递响应式数据"><a href="#3-跨层传递响应式数据" class="headerlink" title="3. 跨层传递响应式数据"></a>3. 跨层传递响应式数据</h2><blockquote><p>在调用provide函数时，第二个参数设置为ref对象</p></blockquote><p><img src="/assets/13.png" alt="image.png"></p><h2 id="4-跨层传递方法"><a href="#4-跨层传递方法" class="headerlink" title="4. 跨层传递方法"></a>4. 跨层传递方法</h2><blockquote><p>顶层组件可以向底层组件传递方法，底层组件调用方法修改顶层组件的数据</p></blockquote><p><img src="/assets/14.png" alt="image.png"></p><h1 id="Vue3-3-新特性-defineOptions"><a href="#Vue3-3-新特性-defineOptions" class="headerlink" title="Vue3.3 新特性-defineOptions"></a>Vue3.3 新特性-defineOptions</h1><p>背景说明：</p><p>有 <script setup> 之前，如果要定义 props, emits 可以轻而易举地添加一个与 setup 平级的属性。 </p><p>但是用了 <script setup> 后，就没法这么干了 setup 属性已经没有了，自然无法添加与其平级的属性。</p><hr><p>为了解决这一问题，引入了 defineProps 与 defineEmits 这两个宏。但这只解决了 props 与 emits 这两个属性。</p><p>如果我们要定义组件的 name 或其他自定义的属性，还是得回到最原始的用法——再添加一个普通的 <script> 标签。</p><p>这样就会存在两个 <script> 标签。让人无法接受。</p><hr><p>所以在 Vue 3.3 中新引入了 defineOptions 宏。顾名思义，主要是用来定义 Options API 的选项。可以用 defineOptions 定义任意的选项， props, emits, expose, slots 除外（因为这些可以使用 defineXXX 来做到）</p><p><img src="/assets/image-20230704082955748.png" alt="image-20230704082955748"></p><h1 id="Vue3-3新特性-defineModel"><a href="#Vue3-3新特性-defineModel" class="headerlink" title="Vue3.3新特性-defineModel"></a>Vue3.3新特性-defineModel</h1><p>在Vue3中，自定义组件上使用v-model, 相当于传递一个modelValue属性，同时触发 update:modelValue 事件</p><p><img src="/assets/image-20230704083027349.png" alt="image-20230704083027349"></p><p>我们需要先定义 props，再定义 emits 。其中有许多重复的代码。如果需要修改此值，还需要手动调用 emit 函数。</p><p>于是乎 defineModel 诞生了。</p><p><img src="/assets/image-20230704083056549.png" alt="image-20230704083056549"></p><p>生效需要配置 vite.config.js</p><pre><code class="jsx">import &#123; fileURLToPath, URL &#125; from &#39;node:url&#39;import &#123; defineConfig &#125; from &#39;vite&#39;import vue from &#39;@vitejs/plugin-vue&#39;// https://vitejs.dev/config/export default defineConfig(&#123;  plugins: [    vue(&#123;      script: &#123;        defineModel: true      &#125;    &#125;),  ],  resolve: &#123;    alias: &#123;      &#39;@&#39;: fileURLToPath(new URL(&#39;./src&#39;, import.meta.url))    &#125;  &#125;&#125;)</code></pre></script></h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/08/08/%E5%A4%A7%E4%BA%8B%E4%BB%B6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
      <url>/2023/08/08/%E5%A4%A7%E4%BA%8B%E4%BB%B6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="后台数据管理系统-项目架构设计"><a href="#后台数据管理系统-项目架构设计" class="headerlink" title="后台数据管理系统 - 项目架构设计"></a>后台数据管理系统 - 项目架构设计</h1><p>在线演示：<a href="https://fe-bigevent-web.itheima.net/login">https://fe-bigevent-web.itheima.net/login</a></p><p>接口文档:   <a href="https://apifox.com/apidoc/shared-26c67aee-0233-4d23-aab7-08448fdf95ff/api-93850835">https://apifox.com/apidoc/shared-26c67aee-0233-4d23-aab7-08448fdf95ff/api-93850835</a></p><p><strong>接口根路径：</strong>  <a href="http://big-event-vue-api-t.itheima.net/">http://big-event-vue-api-t.itheima.net</a></p><p>本项目的技术栈 本项目技术栈基于 <a href="http://es6.ruanyifeng.com/">ES6</a>、<a href="https://cn.vuejs.org/index.html">vue3</a>、<a href="https://pinia.web3doc.top/">pinia</a>、<a href="https://router.vuejs.org/">vue-router</a> 、vite 、axios 和 <a href="https://element-plus.org/">element-plus</a></p><p><img src="/assets/image-20230711003405635.png" alt="image-20230711003405635"></p><h2 id="项目页面介绍"><a href="#项目页面介绍" class="headerlink" title="项目页面介绍"></a>项目页面介绍</h2><p><img src="/assets/image-20230706205300370.png" alt="image-20230706205300370"></p><p><img src="/assets/image-20230706210947086.png" alt="image-20230706210947086"></p><p><img src="/assets/image-20230706211055251.png" alt="image-20230706211055251"></p><p><img src="/assets/image-20230706211033589.png" alt="image-20230706211033589"></p><h2 id="pnpm-包管理器-创建项目"><a href="#pnpm-包管理器-创建项目" class="headerlink" title="pnpm 包管理器 - 创建项目"></a>pnpm 包管理器 - 创建项目</h2><p>一些优势：比同类工具快 2倍 左右、节省磁盘空间… <a href="https://www.pnpm.cn/">https://www.pnpm.cn/</a></p><p>安装方式：</p><pre><code>npm install -g pnpm</code></pre><p>创建项目：</p><pre><code>pnpm create vue</code></pre><p><img src="/assets/image-20230710172832242.png" alt="image-20230710172832242"></p><h2 id="ESLint-amp-prettier-配置代码风格"><a href="#ESLint-amp-prettier-配置代码风格" class="headerlink" title="ESLint &amp; prettier 配置代码风格"></a>ESLint &amp; prettier 配置代码风格</h2><p><strong>环境同步：</strong></p><ol><li><strong>安装了插件 ESlint，开启保存自动修复</strong></li><li><strong>禁用了插件 Prettier，并关闭保存自动格式化</strong></li></ol><pre><code class="jsx">// ESlint插件 + Vscode配置 实现自动格式化修复&quot;editor.codeActionsOnSave&quot;: &#123;    &quot;source.fixAll&quot;: true&#125;,&quot;editor.formatOnSave&quot;: false,</code></pre><p><strong>配置文件 .eslintrc.cjs</strong></p><ol><li><p>prettier 风格配置 <a href="https://prettier.io/docs/en/options.html">https://prettier.io</a></p><ol><li><p>单引号</p></li><li><p>不使用分号</p></li><li><p>每行宽度至多80字符</p></li><li><p>不加对象|数组最后逗号</p></li><li><p>换行符号不限制（win mac 不一致）</p></li></ol></li><li><p>vue组件名称多单词组成（忽略index.vue）</p></li><li><p>props解构（关闭）</p></li></ol><pre><code class="jsx">  rules: &#123;    &#39;prettier/prettier&#39;: [      &#39;warn&#39;,      &#123;        singleQuote: true, // 单引号        semi: false, // 无分号        printWidth: 80, // 每行宽度至多80字符        trailingComma: &#39;none&#39;, // 不加对象|数组最后逗号        endOfLine: &#39;auto&#39; // 换行符号不限制（win mac 不一致）      &#125;    ],    &#39;vue/multi-word-component-names&#39;: [      &#39;warn&#39;,      &#123;        ignores: [&#39;index&#39;] // vue组件名称多单词组成（忽略index.vue）      &#125;    ],    &#39;vue/no-setup-props-destructure&#39;: [&#39;off&#39;], // 关闭 props 解构的校验    // 💡 添加未定义变量错误提示，create-vue@3.6.3 关闭，这里加上是为了支持下一个章节演示。    &#39;no-undef&#39;: &#39;error&#39;  &#125;</code></pre><h2 id="基于-husky-的代码检查工作流"><a href="#基于-husky-的代码检查工作流" class="headerlink" title="基于 husky  的代码检查工作流"></a>基于 husky  的代码检查工作流</h2><p>husky 是一个 git hooks 工具  ( git的钩子工具，可以在特定时机执行特定的命令 )</p><p><strong>husky 配置</strong></p><ol><li><p>git初始化 git init</p></li><li><p>初始化 husky 工具配置  <a href="https://typicode.github.io/husky/">https://typicode.github.io/husky/</a></p></li></ol><pre><code class="jsx">pnpm dlx husky-init &amp;&amp; pnpm install</code></pre><ol start="3"><li>修改 .husky&#x2F;pre-commit 文件</li></ol><pre><code class="jsx">pnpm lint</code></pre><p><strong>问题：</strong>默认进行的是全量检查，耗时问题，历史问题。</p><p><strong>lint-staged 配置</strong></p><ol><li>安装</li></ol><pre><code class="jsx">pnpm i lint-staged -D</code></pre><ol start="2"><li>配置 <code>package.json</code></li></ol><pre><code class="jsx">&#123;  // ... 省略 ...  &quot;lint-staged&quot;: &#123;    &quot;*.&#123;js,ts,vue&#125;&quot;: [      &quot;eslint --fix&quot;    ]  &#125;&#125;&#123;  &quot;scripts&quot;: &#123;    // ... 省略 ...    &quot;lint-staged&quot;: &quot;lint-staged&quot;  &#125;&#125;</code></pre><ol start="3"><li>修改 .husky&#x2F;pre-commit 文件</li></ol><pre><code class="jsx">pnpm lint-staged</code></pre><h2 id="调整项目目录"><a href="#调整项目目录" class="headerlink" title="调整项目目录"></a>调整项目目录</h2><p>默认生成的目录结构不满足我们的开发需求，所以这里需要做一些自定义改动。主要是两个工作：</p><ul><li>删除初始化的默认文件</li><li>修改剩余代码内容</li><li>新增调整我们需要的目录结构</li><li>拷贝初始化资源文件，安装预处理器插件</li></ul><ol><li><p>删除文件</p></li><li><p>修改内容</p></li></ol><p><code>src/router/index.js</code></p><pre><code class="jsx">import &#123; createRouter, createWebHistory &#125; from &#39;vue-router&#39;const router = createRouter(&#123;  history: createWebHistory(import.meta.env.BASE_URL),  routes: []&#125;)export default router</code></pre><p><code>src/App.vue</code></p><pre><code class="jsx">&lt;script setup&gt;&lt;/script&gt;&lt;template&gt;  &lt;div&gt;    &lt;router-view&gt;&lt;/router-view&gt;  &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;&lt;/style&gt;</code></pre><p><code>src/main.js</code></p><pre><code class="jsx">import &#123; createApp &#125; from &#39;vue&#39;import &#123; createPinia &#125; from &#39;pinia&#39;import App from &#39;./App.vue&#39;import router from &#39;./router&#39;const app = createApp(App)app.use(createPinia())app.use(router)app.mount(&#39;#app&#39;)</code></pre><ol start="3"><li>新增需要目录 api  utils</li></ol><p><img src="/assets/image-20230710215822678.png" alt="image-20230710215822678"></p><ol start="4"><li>将项目需要的全局样式 和 图片文件，复制到 assets 文件夹中,  并将全局样式在main.js中引入</li></ol><pre><code class="jsx">import &#39;@/assets/main.scss&#39;</code></pre><ul><li>安装 sass 依赖</li></ul><pre><code class="jsx">pnpm add sass -D</code></pre><h2 id="VueRouter4-路由代码解析"><a href="#VueRouter4-路由代码解析" class="headerlink" title="VueRouter4 路由代码解析"></a>VueRouter4 路由代码解析</h2><p>基础代码解析</p><pre><code class="jsx">import &#123; createRouter, createWebHistory &#125; from &#39;vue-router&#39;// createRouter 创建路由实例，===&gt; new VueRouter()// 1. history模式: createWebHistory()   http://xxx/user// 2. hash模式: createWebHashHistory()  http://xxx/#/user// vite 的配置 import.meta.env.BASE_URL 是路由的基准地址，默认是 ’/‘// https://vitejs.dev/guide/build.html#public-base-path// 如果将来你部署的域名路径是：http://xxx/my-path/user// vite.config.ts  添加配置  base: my-path，路由这就会加上 my-path 前缀了const router = createRouter(&#123;  history: createWebHistory(import.meta.env.BASE_URL),  routes: []&#125;)export default router</code></pre><p>import.meta.env.BASE_URL 是Vite 环境变量：<a href="https://cn.vitejs.dev/guide/env-and-mode.html">https://cn.vitejs.dev/guide/env-and-mode.html</a></p><h2 id="引入-element-ui-组件库"><a href="#引入-element-ui-组件库" class="headerlink" title="引入 element-ui 组件库"></a>引入 element-ui 组件库</h2><p><strong>官方文档：</strong> <a href="https://element-plus.org/zh-CN/">https://element-plus.org/zh-CN/</a></p><ul><li>安装</li></ul><pre><code class="jsx">$ pnpm add element-plus</code></pre><p><strong>自动按需：</strong></p><ol><li>安装插件</li></ol><pre><code class="jsx">pnpm add -D unplugin-vue-components unplugin-auto-import</code></pre><ol start="2"><li>然后把下列代码插入到你的 <code>Vite</code> 或 <code>Webpack</code> 的配置文件中</li></ol><pre><code class="jsx">...import AutoImport from &#39;unplugin-auto-import/vite&#39;import Components from &#39;unplugin-vue-components/vite&#39;import &#123; ElementPlusResolver &#125; from &#39;unplugin-vue-components/resolvers&#39;// https://vitejs.dev/config/export default defineConfig(&#123;  plugins: [    ...    AutoImport(&#123;      resolvers: [ElementPlusResolver()]    &#125;),    Components(&#123;      resolvers: [ElementPlusResolver()]    &#125;)  ]&#125;)</code></pre><ol start="3"><li>直接使用</li></ol><pre><code class="jsx">&lt;template&gt;  &lt;div&gt;    &lt;el-button type=&quot;primary&quot;&gt;Primary&lt;/el-button&gt;    &lt;el-button type=&quot;success&quot;&gt;Success&lt;/el-button&gt;    &lt;el-button type=&quot;info&quot;&gt;Info&lt;/el-button&gt;    &lt;el-button type=&quot;warning&quot;&gt;Warning&lt;/el-button&gt;    &lt;el-button type=&quot;danger&quot;&gt;Danger&lt;/el-button&gt;    ...  &lt;/div&gt;&lt;/template&gt;</code></pre><p><img src="/assets/image-20230710225018162.png" alt="image-20230710225018162"></p><p><strong>彩蛋：</strong>默认 components 下的文件也会被自动注册~</p><h2 id="Pinia-构建用户仓库-和-持久化"><a href="#Pinia-构建用户仓库-和-持久化" class="headerlink" title="Pinia - 构建用户仓库 和 持久化"></a>Pinia - 构建用户仓库 和 持久化</h2><p>官方文档：<a href="https://prazdevs.github.io/pinia-plugin-persistedstate/zh/">https://prazdevs.github.io/pinia-plugin-persistedstate/zh/</a></p><ol><li>安装插件 pinia-plugin-persistedstate</li></ol><pre><code class="jsx">pnpm add pinia-plugin-persistedstate -D</code></pre><ol start="2"><li>使用 main.js</li></ol><pre><code class="jsx">import persist from &#39;pinia-plugin-persistedstate&#39;...app.use(createPinia().use(persist))</code></pre><ol start="3"><li>配置 stores&#x2F;user.js</li></ol><pre><code class="jsx">import &#123; defineStore &#125; from &#39;pinia&#39;import &#123; ref &#125; from &#39;vue&#39;// 用户模块export const useUserStore = defineStore(  &#39;big-user&#39;,  () =&gt; &#123;    const token = ref(&#39;&#39;) // 定义 token    const setToken = (t) =&gt; (token.value = t) // 设置 token    return &#123; token, setToken &#125;  &#125;,  &#123;    persist: true // 持久化  &#125;)</code></pre><h2 id="Pinia-配置仓库统一管理"><a href="#Pinia-配置仓库统一管理" class="headerlink" title="Pinia - 配置仓库统一管理"></a>Pinia - 配置仓库统一管理</h2><p>pinia 独立维护</p><p>- 现在：初始化代码在 main.js 中，仓库代码在 stores 中，代码分散职能不单一</p><p>- 优化：由 stores 统一维护，在 stores&#x2F;index.js 中完成 pinia 初始化，交付 main.js 使用</p><p>仓库 统一导出</p><p>- 现在：使用一个仓库 import { useUserStore } from <code>./stores/user.js</code> 不同仓库路径不一致</p><p>- 优化：由 stores&#x2F;index.js 统一导出，导入路径统一 <code>./stores</code>，而且仓库维护在 stores&#x2F;modules 中</p><h2 id="数据交互-请求工具设计"><a href="#数据交互-请求工具设计" class="headerlink" title="数据交互 - 请求工具设计"></a>数据交互 - 请求工具设计</h2><p><img src="/assets/image-20230711071913061.png" alt="image-20230711071913061"></p><h3 id="1-创建-axios-实例"><a href="#1-创建-axios-实例" class="headerlink" title="1. 创建 axios 实例"></a>1. 创建 axios 实例</h3><p>们会使用 axios 来请求后端接口, 一般都会对 axios 进行一些配置 (比如: 配置基础地址等)</p><p>一般项目开发中, 都会对 axios 进行基本的二次封装, 单独封装到一个模块中, 便于使用</p><ol><li>安装 axios</li></ol><pre><code>pnpm add axios</code></pre><ol start="2"><li><p>新建 <code>utils/request.js</code> 封装 axios 模块</p><p>利用 axios.create 创建一个自定义的 axios 来使用</p><p><a href="http://www.axios-js.com/zh-cn/docs/#axios-create-config">http://www.axios-js.com/zh-cn/docs/#axios-create-config</a></p></li></ol><pre><code class="js">import axios from &#39;axios&#39;const baseURL = &#39;http://big-event-vue-api-t.itheima.net&#39;const instance = axios.create(&#123;  // TODO 1. 基础地址，超时时间&#125;)instance.interceptors.request.use(  (config) =&gt; &#123;    // TODO 2. 携带token    return config  &#125;,  (err) =&gt; Promise.reject(err))instance.interceptors.response.use(  (res) =&gt; &#123;    // TODO 3. 处理业务失败    // TODO 4. 摘取核心响应数据    return res  &#125;,  (err) =&gt; &#123;    // TODO 5. 处理401错误    return Promise.reject(err)  &#125;)export default instance</code></pre><h3 id="2-完成-axios-基本配置"><a href="#2-完成-axios-基本配置" class="headerlink" title="2. 完成 axios 基本配置"></a>2. 完成 axios 基本配置</h3><pre><code class="jsx">import &#123; useUserStore &#125; from &#39;@/stores/user&#39;import axios from &#39;axios&#39;import router from &#39;@/router&#39;import &#123; ElMessage &#125; from &#39;element-plus&#39;const baseURL = &#39;http://big-event-vue-api-t.itheima.net&#39;const instance = axios.create(&#123;  baseURL,  timeout: 100000&#125;)instance.interceptors.request.use(  (config) =&gt; &#123;    const userStore = useUserStore()    if (userStore.token) &#123;      config.headers.Authorization = userStore.token    &#125;    return config  &#125;,  (err) =&gt; Promise.reject(err))instance.interceptors.response.use(  (res) =&gt; &#123;    if (res.data.code === 0) &#123;      return res    &#125;    ElMessage(&#123; message: res.data.message || &#39;服务异常&#39;, type: &#39;error&#39; &#125;)    return Promise.reject(res.data)  &#125;,  (err) =&gt; &#123;    ElMessage(&#123; message: err.response.data.message || &#39;服务异常&#39;, type: &#39;error&#39; &#125;)    console.log(err)    if (err.response?.status === 401) &#123;      router.push(&#39;/login&#39;)    &#125;    return Promise.reject(err)  &#125;)export default instanceexport &#123; baseURL &#125;</code></pre><h2 id="首页整体路由设计"><a href="#首页整体路由设计" class="headerlink" title="首页整体路由设计"></a>首页整体路由设计</h2><p><strong>实现目标:</strong></p><ul><li>完成整体路由规划【搞清楚要做几个页面，它们分别在哪个路由下面，怎么跳转的…..】</li><li>通过观察,  点击左侧导航,  右侧区域在切换,  那右侧区域内容一直在变,  那这个地方就是一个路由的出口</li><li>我们需要搭建嵌套路由</li></ul><p>目标：</p><ul><li>把项目中所有用到的组件及路由表, 约定下来</li></ul><p><strong>约定路由规则</strong></p><table><thead><tr><th>path</th><th>文件</th><th>功能</th><th>组件名</th><th>路由级别</th></tr></thead><tbody><tr><td>&#x2F;login</td><td>views&#x2F;login&#x2F;LoginPage.vue</td><td>登录&amp;注册</td><td>LoginPage</td><td>一级路由</td></tr><tr><td>&#x2F;</td><td>views&#x2F;layout&#x2F;LayoutContainer.vue</td><td>布局架子</td><td>LayoutContainer</td><td>一级路由</td></tr><tr><td>├─ &#x2F;article&#x2F;manage</td><td>views&#x2F;article&#x2F;ArticleManage.vue</td><td>文章管理</td><td>ArticleManage</td><td>二级路由</td></tr><tr><td>├─ &#x2F;article&#x2F;channel</td><td>views&#x2F;article&#x2F;ArticleChannel.vue</td><td>频道管理</td><td>ArticleChannel</td><td>二级路由</td></tr><tr><td>├─ &#x2F;user&#x2F;profile</td><td>views&#x2F;user&#x2F;UserProfile.vue</td><td>个人详情</td><td>UserProfile</td><td>二级路由</td></tr><tr><td>├─ &#x2F;user&#x2F;avatar</td><td>views&#x2F;user&#x2F;UserAvatar.vue</td><td>更换头像</td><td>UserAvatar</td><td>二级路由</td></tr><tr><td>├─ &#x2F;user&#x2F;password</td><td>views&#x2F;user&#x2F;UserPassword.vue</td><td>重置密码</td><td>UserPassword</td><td>二级路由</td></tr></tbody></table><p>明确了路由规则，可以全部配完，也可以边写边配。</p><h1 id="登录注册页面-element-plus-表单-amp-表单校验"><a href="#登录注册页面-element-plus-表单-amp-表单校验" class="headerlink" title="登录注册页面 [element-plus 表单 &amp; 表单校验]"></a>登录注册页面 [element-plus 表单 &amp; 表单校验]</h1><h2 id="注册登录-静态结构-amp-基本切换"><a href="#注册登录-静态结构-amp-基本切换" class="headerlink" title="注册登录 静态结构 &amp; 基本切换"></a>注册登录 静态结构 &amp; 基本切换</h2><ol><li>安装 element-plus 图标库</li></ol><pre><code class="jsx">pnpm i @element-plus/icons-vue</code></pre><ol start="2"><li>静态结构准备</li></ol><pre><code class="jsx">&lt;script setup&gt;import &#123; User, Lock &#125; from &#39;@element-plus/icons-vue&#39;import &#123; ref &#125; from &#39;vue&#39;const isRegister = ref(true)&lt;/script&gt;&lt;template&gt;  &lt;el-row class=&quot;login-page&quot;&gt;    &lt;el-col :span=&quot;12&quot; class=&quot;bg&quot;&gt;&lt;/el-col&gt;    &lt;el-col :span=&quot;6&quot; :offset=&quot;3&quot; class=&quot;form&quot;&gt;      &lt;el-form ref=&quot;form&quot; size=&quot;large&quot; autocomplete=&quot;off&quot; v-if=&quot;isRegister&quot;&gt;        &lt;el-form-item&gt;          &lt;h1&gt;注册&lt;/h1&gt;        &lt;/el-form-item&gt;        &lt;el-form-item&gt;          &lt;el-input :prefix-icon=&quot;User&quot; placeholder=&quot;请输入用户名&quot;&gt;&lt;/el-input&gt;        &lt;/el-form-item&gt;        &lt;el-form-item&gt;          &lt;el-input            :prefix-icon=&quot;Lock&quot;            type=&quot;password&quot;            placeholder=&quot;请输入密码&quot;          &gt;&lt;/el-input&gt;        &lt;/el-form-item&gt;        &lt;el-form-item&gt;          &lt;el-input            :prefix-icon=&quot;Lock&quot;            type=&quot;password&quot;            placeholder=&quot;请输入再次密码&quot;          &gt;&lt;/el-input&gt;        &lt;/el-form-item&gt;        &lt;el-form-item&gt;          &lt;el-button class=&quot;button&quot; type=&quot;primary&quot; auto-insert-space&gt;            注册          &lt;/el-button&gt;        &lt;/el-form-item&gt;        &lt;el-form-item class=&quot;flex&quot;&gt;          &lt;el-link type=&quot;info&quot; :underline=&quot;false&quot; @click=&quot;isRegister = false&quot;&gt;            ← 返回          &lt;/el-link&gt;        &lt;/el-form-item&gt;      &lt;/el-form&gt;      &lt;el-form ref=&quot;form&quot; size=&quot;large&quot; autocomplete=&quot;off&quot; v-else&gt;        &lt;el-form-item&gt;          &lt;h1&gt;登录&lt;/h1&gt;        &lt;/el-form-item&gt;        &lt;el-form-item&gt;          &lt;el-input :prefix-icon=&quot;User&quot; placeholder=&quot;请输入用户名&quot;&gt;&lt;/el-input&gt;        &lt;/el-form-item&gt;        &lt;el-form-item&gt;          &lt;el-input            name=&quot;password&quot;            :prefix-icon=&quot;Lock&quot;            type=&quot;password&quot;            placeholder=&quot;请输入密码&quot;          &gt;&lt;/el-input&gt;        &lt;/el-form-item&gt;        &lt;el-form-item class=&quot;flex&quot;&gt;          &lt;div class=&quot;flex&quot;&gt;            &lt;el-checkbox&gt;记住我&lt;/el-checkbox&gt;            &lt;el-link type=&quot;primary&quot; :underline=&quot;false&quot;&gt;忘记密码？&lt;/el-link&gt;          &lt;/div&gt;        &lt;/el-form-item&gt;        &lt;el-form-item&gt;          &lt;el-button class=&quot;button&quot; type=&quot;primary&quot; auto-insert-space            &gt;登录&lt;/el-button          &gt;        &lt;/el-form-item&gt;        &lt;el-form-item class=&quot;flex&quot;&gt;          &lt;el-link type=&quot;info&quot; :underline=&quot;false&quot; @click=&quot;isRegister = true&quot;&gt;            注册 →          &lt;/el-link&gt;        &lt;/el-form-item&gt;      &lt;/el-form&gt;    &lt;/el-col&gt;  &lt;/el-row&gt;&lt;/template&gt;&lt;style lang=&quot;scss&quot; scoped&gt;.login-page &#123;  height: 100vh;  background-color: #fff;  .bg &#123;    background: url(&#39;@/assets/logo2.png&#39;) no-repeat 60% center / 240px auto,      url(&#39;@/assets/login_bg.jpg&#39;) no-repeat center / cover;    border-radius: 0 20px 20px 0;  &#125;  .form &#123;    display: flex;    flex-direction: column;    justify-content: center;    user-select: none;    .title &#123;      margin: 0 auto;    &#125;    .button &#123;      width: 100%;    &#125;    .flex &#123;      width: 100%;      display: flex;      justify-content: space-between;    &#125;  &#125;&#125;&lt;/style&gt;</code></pre><h2 id="注册功能"><a href="#注册功能" class="headerlink" title="注册功能"></a>注册功能</h2><h3 id="实现注册校验"><a href="#实现注册校验" class="headerlink" title="实现注册校验"></a>实现注册校验</h3><p>【需求】注册页面基本校验</p><ol><li>用户名非空，长度校验5-10位</li><li>密码非空，长度校验6-15位</li><li>再次输入密码，非空，长度校验6-15位</li></ol><p>【进阶】再次输入密码需要自定义校验规则，和密码框值一致（可选）</p><p>注意：</p><ol><li>model 属性绑定 form 数据对象</li></ol><pre><code class="jsx">const formModel = ref(&#123;  username: &#39;&#39;,  password: &#39;&#39;,  repassword: &#39;&#39;&#125;)&lt;el-form :model=&quot;formModel&quot; &gt;</code></pre><ol start="2"><li>v-model 绑定 form 数据对象的子属性</li></ol><pre><code class="jsx">&lt;el-input  v-model=&quot;formModel.username&quot;  :prefix-icon=&quot;User&quot;  placeholder=&quot;请输入用户名&quot;&gt;&lt;/el-input&gt;... (其他两个也要绑定)</code></pre><ol start="3"><li>rules 配置校验规则</li></ol><pre><code class="jsx">&lt;el-form :rules=&quot;rules&quot; &gt;    const rules = &#123;  username: [    &#123; required: true, message: &#39;请输入用户名&#39;, trigger: &#39;blur&#39; &#125;,    &#123; min: 5, max: 10, message: &#39;用户名必须是5-10位的字符&#39;, trigger: &#39;blur&#39; &#125;  ],  password: [    &#123; required: true, message: &#39;请输入密码&#39;, trigger: &#39;blur&#39; &#125;,    &#123;      pattern: /^\S&#123;6,15&#125;$/,      message: &#39;密码必须是6-15位的非空字符&#39;,      trigger: &#39;blur&#39;    &#125;  ],  repassword: [    &#123; required: true, message: &#39;请再次输入密码&#39;, trigger: &#39;blur&#39; &#125;,    &#123;      pattern: /^\S&#123;6,15&#125;$/,      message: &#39;密码必须是6-15的非空字符&#39;,      trigger: &#39;blur&#39;    &#125;,    &#123;      validator: (rule, value, callback) =&gt; &#123;        if (value !== formModel.value.password) &#123;          callback(new Error(&#39;两次输入密码不一致!&#39;))        &#125; else &#123;          callback()        &#125;      &#125;,      trigger: &#39;blur&#39;    &#125;  ]&#125;</code></pre><ol start="4"><li>prop 绑定校验规则</li></ol><pre><code class="jsx">&lt;el-form-item prop=&quot;username&quot;&gt;  &lt;el-input    v-model=&quot;formModel.username&quot;    :prefix-icon=&quot;User&quot;    placeholder=&quot;请输入用户名&quot;  &gt;&lt;/el-input&gt;&lt;/el-form-item&gt;... (其他两个也要绑定prop)</code></pre><h3 id="注册前的预校验"><a href="#注册前的预校验" class="headerlink" title="注册前的预校验"></a>注册前的预校验</h3><p>需求：点击注册按钮，注册之前，需要先校验</p><ol><li>通过 ref 获取到 表单组件</li></ol><pre><code class="jsx">const form = ref()&lt;el-form ref=&quot;form&quot;&gt;</code></pre><ol start="2"><li>注册之前进行校验</li></ol><pre><code class="jsx">&lt;el-button  @click=&quot;register&quot;  class=&quot;button&quot;  type=&quot;primary&quot;  auto-insert-space&gt;  注册&lt;/el-button&gt;const register = async () =&gt; &#123;  await form.value.validate()  console.log(&#39;开始注册请求&#39;)&#125;</code></pre><h3 id="封装-api-实现注册功能"><a href="#封装-api-实现注册功能" class="headerlink" title="封装 api 实现注册功能"></a>封装 api 实现注册功能</h3><p>需求：封装注册api，进行注册，注册成功切换到登录</p><ol><li>新建 api&#x2F;user.js 封装</li></ol><pre><code class="jsx">import request from &#39;@/utils/request&#39;export const userRegisterService = (&#123; username, password, repassword &#125;) =&gt;  request.post(&#39;/api/reg&#39;, &#123; username, password, repassword &#125;)</code></pre><ol start="2"><li>页面中调用</li></ol><pre><code class="jsx">const register = async () =&gt; &#123;  await form.value.validate()  await userRegisterService(formModel.value)  ElMessage.success(&#39;注册成功&#39;)  // 切换到登录  isRegister.value = false&#125;</code></pre><ol start="3"><li>eslintrc 中声明全局变量名,  解决 ElMessage 报错问题</li></ol><pre><code class="jsx">module.exports = &#123;  ...  globals: &#123;    ElMessage: &#39;readonly&#39;,    ElMessageBox: &#39;readonly&#39;,    ElLoading: &#39;readonly&#39;  &#125;&#125;</code></pre><h2 id="登录功能"><a href="#登录功能" class="headerlink" title="登录功能"></a>登录功能</h2><h3 id="实现登录校验"><a href="#实现登录校验" class="headerlink" title="实现登录校验"></a>实现登录校验</h3><p>【需求说明】给输入框添加表单校验</p><ol><li>用户名不能为空，用户名必须是5-10位的字符，失去焦点 和 修改内容时触发校验</li><li>密码不能为空，密码必须是6-15位的字符，失去焦点 和 修改内容时触发校验</li></ol><p>操作步骤：</p><ol><li>model 属性绑定 form 数据对象，直接绑定之前提供好的数据对象即可</li></ol><pre><code class="jsx">&lt;el-form :model=&quot;formModel&quot; &gt;</code></pre><ol start="2"><li>rules 配置校验规则，共用注册的规则即可</li></ol><pre><code class="jsx">&lt;el-form :rules=&quot;rules&quot; &gt;</code></pre><ol start="3"><li>v-model 绑定 form 数据对象的子属性</li></ol><pre><code class="jsx">&lt;el-input  v-model=&quot;formModel.username&quot;  :prefix-icon=&quot;User&quot;  placeholder=&quot;请输入用户名&quot;&gt;&lt;/el-input&gt;&lt;el-input  v-model=&quot;formModel.password&quot;  name=&quot;password&quot;  :prefix-icon=&quot;Lock&quot;  type=&quot;password&quot;  placeholder=&quot;请输入密码&quot;&gt;&lt;/el-input&gt;</code></pre><ol start="4"><li>prop 绑定校验规则</li></ol><pre><code class="jsx">&lt;el-form-item prop=&quot;username&quot;&gt;  &lt;el-input    v-model=&quot;formModel.username&quot;    :prefix-icon=&quot;User&quot;    placeholder=&quot;请输入用户名&quot;  &gt;&lt;/el-input&gt;&lt;/el-form-item&gt;... </code></pre><ol start="5"><li>切换的时候重置</li></ol><pre><code class="jsx">watch(isRegister, () =&gt; &#123;  formModel.value = &#123;    username: &#39;&#39;,    password: &#39;&#39;,    repassword: &#39;&#39;  &#125;&#125;)</code></pre><h3 id="登录前的预校验-amp-登录成功"><a href="#登录前的预校验-amp-登录成功" class="headerlink" title="登录前的预校验 &amp; 登录成功"></a>登录前的预校验 &amp; 登录成功</h3><p>【需求说明1】登录之前的预校验</p><ul><li>登录请求之前，需要对用户的输入内容，进行校验</li><li>校验通过才发送请求</li></ul><p>【需求说明2】<strong>登录功能</strong></p><ol><li>封装登录API，点击按钮发送登录请求</li><li>登录成功存储token，存入pinia 和 持久化本地storage</li><li>跳转到首页，给提示</li></ol><p>【测试账号】</p><ul><li><p>登录的测试账号:  shuaipeng</p></li><li><p>登录测试密码:  123456</p></li></ul><p>PS: 每天账号会重置，如果被重置了，可以去注册页，注册一个新号</p><p>实现步骤：</p><ol><li>注册事件，进行登录前的预校验 (获取到组件调用方法)</li></ol><pre><code class="jsx">&lt;el-form ref=&quot;form&quot;&gt;    const login = async () =&gt; &#123;  await form.value.validate()  console.log(&#39;开始登录&#39;)&#125;</code></pre><ol start="2"><li>封装接口 API</li></ol><pre><code class="jsx">export const userLoginService = (&#123; username, password &#125;) =&gt;  request.post(&#39;api/login&#39;, &#123; username, password &#125;)</code></pre><ol start="3"><li>调用方法将 token 存入 pinia 并 自动持久化本地</li></ol><pre><code class="jsx">const userStore = useUserStore()const router = useRouter()const login = async () =&gt; &#123;  await form.value.validate()  const res = await userLoginService(formModel.value)  userStore.setToken(res.data.token)  ElMessage.success(&#39;登录成功&#39;)  router.push(&#39;/&#39;)&#125;</code></pre><h1 id="首页-layout-架子-element-plus-菜单"><a href="#首页-layout-架子-element-plus-菜单" class="headerlink" title="首页 layout 架子 [element-plus 菜单]"></a>首页 layout 架子 [element-plus 菜单]</h1><h2 id="基本架子拆解"><a href="#基本架子拆解" class="headerlink" title="基本架子拆解"></a>基本架子拆解</h2><p><strong>架子组件列表：</strong></p><p>el-container</p><ul><li><p>el-aside 左侧</p><ul><li>el-menu 左侧边栏菜单</li></ul></li><li><p>el-container  右侧</p><ul><li>el-header  右侧头部<ul><li>el-dropdown</li></ul></li><li>el-main  右侧主体<ul><li>router-view</li></ul></li></ul></li></ul><pre><code class="jsx">&lt;script setup&gt;import &#123;  Management,  Promotion,  UserFilled,  User,  Crop,  EditPen,  SwitchButton,  CaretBottom&#125; from &#39;@element-plus/icons-vue&#39;import avatar from &#39;@/assets/default.png&#39;&lt;/script&gt;&lt;template&gt;  &lt;el-container class=&quot;layout-container&quot;&gt;    &lt;el-aside width=&quot;200px&quot;&gt;      &lt;div class=&quot;el-aside__logo&quot;&gt;&lt;/div&gt;      &lt;el-menu        active-text-color=&quot;#ffd04b&quot;        background-color=&quot;#232323&quot;        :default-active=&quot;$route.path&quot;        text-color=&quot;#fff&quot;        router      &gt;        &lt;el-menu-item index=&quot;/article/channel&quot;&gt;          &lt;el-icon&gt;&lt;Management /&gt;&lt;/el-icon&gt;          &lt;span&gt;文章分类&lt;/span&gt;        &lt;/el-menu-item&gt;        &lt;el-menu-item index=&quot;/article/manage&quot;&gt;          &lt;el-icon&gt;&lt;Promotion /&gt;&lt;/el-icon&gt;          &lt;span&gt;文章管理&lt;/span&gt;        &lt;/el-menu-item&gt;        &lt;el-sub-menu index=&quot;/user&quot;&gt;          &lt;template #title&gt;            &lt;el-icon&gt;&lt;UserFilled /&gt;&lt;/el-icon&gt;            &lt;span&gt;个人中心&lt;/span&gt;          &lt;/template&gt;          &lt;el-menu-item index=&quot;/user/profile&quot;&gt;            &lt;el-icon&gt;&lt;User /&gt;&lt;/el-icon&gt;            &lt;span&gt;基本资料&lt;/span&gt;          &lt;/el-menu-item&gt;          &lt;el-menu-item index=&quot;/user/avatar&quot;&gt;            &lt;el-icon&gt;&lt;Crop /&gt;&lt;/el-icon&gt;            &lt;span&gt;更换头像&lt;/span&gt;          &lt;/el-menu-item&gt;          &lt;el-menu-item index=&quot;/user/password&quot;&gt;            &lt;el-icon&gt;&lt;EditPen /&gt;&lt;/el-icon&gt;            &lt;span&gt;重置密码&lt;/span&gt;          &lt;/el-menu-item&gt;        &lt;/el-sub-menu&gt;      &lt;/el-menu&gt;    &lt;/el-aside&gt;    &lt;el-container&gt;      &lt;el-header&gt;        &lt;div&gt;黑马程序员：&lt;strong&gt;小帅鹏&lt;/strong&gt;&lt;/div&gt;        &lt;el-dropdown placement=&quot;bottom-end&quot;&gt;          &lt;span class=&quot;el-dropdown__box&quot;&gt;            &lt;el-avatar :src=&quot;avatar&quot; /&gt;            &lt;el-icon&gt;&lt;CaretBottom /&gt;&lt;/el-icon&gt;          &lt;/span&gt;          &lt;template #dropdown&gt;            &lt;el-dropdown-menu&gt;              &lt;el-dropdown-item command=&quot;profile&quot; :icon=&quot;User&quot;                &gt;基本资料&lt;/el-dropdown-item              &gt;              &lt;el-dropdown-item command=&quot;avatar&quot; :icon=&quot;Crop&quot;                &gt;更换头像&lt;/el-dropdown-item              &gt;              &lt;el-dropdown-item command=&quot;password&quot; :icon=&quot;EditPen&quot;                &gt;重置密码&lt;/el-dropdown-item              &gt;              &lt;el-dropdown-item command=&quot;logout&quot; :icon=&quot;SwitchButton&quot;                &gt;退出登录&lt;/el-dropdown-item              &gt;            &lt;/el-dropdown-menu&gt;          &lt;/template&gt;        &lt;/el-dropdown&gt;      &lt;/el-header&gt;      &lt;el-main&gt;        &lt;router-view&gt;&lt;/router-view&gt;      &lt;/el-main&gt;      &lt;el-footer&gt;大事件 ©2023 Created by 黑马程序员&lt;/el-footer&gt;    &lt;/el-container&gt;  &lt;/el-container&gt;&lt;/template&gt;&lt;style lang=&quot;scss&quot; scoped&gt;.layout-container &#123;  height: 100vh;  .el-aside &#123;    background-color: #232323;    &amp;__logo &#123;      height: 120px;      background: url(&#39;@/assets/logo.png&#39;) no-repeat center / 120px auto;    &#125;    .el-menu &#123;      border-right: none;    &#125;  &#125;  .el-header &#123;    background-color: #fff;    display: flex;    align-items: center;    justify-content: space-between;    .el-dropdown__box &#123;      display: flex;      align-items: center;      .el-icon &#123;        color: #999;        margin-left: 10px;      &#125;      &amp;:active,      &amp;:focus &#123;        outline: none;      &#125;    &#125;  &#125;  .el-footer &#123;    display: flex;    align-items: center;    justify-content: center;    font-size: 14px;    color: #666;  &#125;&#125;&lt;/style&gt;</code></pre><h2 id="登录访问拦截"><a href="#登录访问拦截" class="headerlink" title="登录访问拦截"></a>登录访问拦截</h2><p>需求：只有登录页，可以未授权的时候访问，其他所有页面，都需要先登录再访问</p><pre><code class="jsx">// 登录访问拦截router.beforeEach((to) =&gt; &#123;  const userStore = useUserStore()  if (!userStore.token &amp;&amp; to.path !== &#39;/login&#39;) return &#39;/login&#39;&#125;)</code></pre><h2 id="用户基本信息获取-amp-渲染"><a href="#用户基本信息获取-amp-渲染" class="headerlink" title="用户基本信息获取&amp;渲染"></a>用户基本信息获取&amp;渲染</h2><ol><li><code>api/user.js</code>封装接口</li></ol><pre><code class="jsx">export const userGetInfoService = () =&gt; request.get(&#39;/my/userinfo&#39;)</code></pre><ol start="2"><li>stores&#x2F;modules&#x2F;user.js 定义数据</li></ol><pre><code class="jsx">const user = ref(&#123;&#125;)const getUser = async () =&gt; &#123;  const res = await userGetInfoService() // 请求获取数据  user.value = res.data.data&#125;</code></pre><ol start="3"><li><code>layout/LayoutContainer</code>页面中调用</li></ol><pre><code class="js">import &#123; useUserStore &#125; from &#39;@/stores&#39;const userStore = useUserStore()onMounted(() =&gt; &#123;  userStore.getUser()&#125;)</code></pre><ol start="4"><li>动态渲染</li></ol><pre><code class="jsx">&lt;div&gt;  黑马程序员：&lt;strong&gt;&#123;&#123; userStore.user.nickname || userStore.user.username &#125;&#125;&lt;/strong&gt;&lt;/div&gt;&lt;el-avatar :src=&quot;userStore.user.user_pic || avatar&quot; /&gt;</code></pre><h2 id="退出功能-element-plus-确认框"><a href="#退出功能-element-plus-确认框" class="headerlink" title="退出功能 [element-plus 确认框]"></a>退出功能 [element-plus 确认框]</h2><ol><li>注册点击事件</li></ol><pre><code class="jsx">&lt;el-dropdown placement=&quot;bottom-end&quot; @command=&quot;onCommand&quot;&gt;&lt;el-dropdown-menu&gt;  &lt;el-dropdown-item command=&quot;profile&quot; :icon=&quot;User&quot;&gt;基本资料&lt;/el-dropdown-item&gt;  &lt;el-dropdown-item command=&quot;avatar&quot; :icon=&quot;Crop&quot;&gt;更换头像&lt;/el-dropdown-item&gt;  &lt;el-dropdown-item command=&quot;password&quot; :icon=&quot;EditPen&quot;&gt;重置密码&lt;/el-dropdown-item&gt;  &lt;el-dropdown-item command=&quot;logout&quot; :icon=&quot;SwitchButton&quot;&gt;退出登录&lt;/el-dropdown-item&gt;&lt;/el-dropdown-menu&gt;</code></pre><ol start="2"><li>添加退出功能</li></ol><pre><code class="jsx">const onCommand = async (command) =&gt; &#123;  if (command === &#39;logout&#39;) &#123;    await ElMessageBox.confirm(&#39;你确认退出大事件吗？&#39;, &#39;温馨提示&#39;, &#123;      type: &#39;warning&#39;,      confirmButtonText: &#39;确认&#39;,      cancelButtonText: &#39;取消&#39;    &#125;)    userStore.removeToken()    userStore.setUser(&#123;&#125;)    router.push(`/login`)  &#125; else &#123;    router.push(`/user/$&#123;command&#125;`)  &#125;&#125;</code></pre><ol start="3"><li>pinia  user.js 模块 提供 setUser 方法</li></ol><pre><code class="jsx">const setUser = (obj) =&gt; (user.value = obj)</code></pre><h1 id="文章分类页面-element-plus-表格"><a href="#文章分类页面-element-plus-表格" class="headerlink" title="文章分类页面 - [element-plus 表格]"></a>文章分类页面 - [element-plus 表格]</h1><h2 id="基本架子-PageContainer"><a href="#基本架子-PageContainer" class="headerlink" title="基本架子 - PageContainer"></a>基本架子 - PageContainer</h2><ol><li>基本结构样式，用到了 el-card 组件</li></ol><pre><code class="jsx">&lt;template&gt;  &lt;el-card class=&quot;page-container&quot;&gt;    &lt;template #header&gt;      &lt;div class=&quot;header&quot;&gt;        &lt;span&gt;文章分类&lt;/span&gt;        &lt;div class=&quot;extra&quot;&gt;          &lt;el-button type=&quot;primary&quot;&gt;添加分类&lt;/el-button&gt;        &lt;/div&gt;      &lt;/div&gt;    &lt;/template&gt;     ...  &lt;/el-card&gt;&lt;/template&gt;&lt;style lang=&quot;scss&quot; scoped&gt;.page-container &#123;  min-height: 100%;  box-sizing: border-box;  .header &#123;    display: flex;    align-items: center;    justify-content: space-between;  &#125;&#125;&lt;/style&gt;</code></pre><ol start="2"><li>考虑到多个页面复用，封装成组件<ul><li>props 定制标题</li><li>默认插槽 default 定制内容主体</li><li>具名插槽 extra  定制头部右侧额外的按钮</li></ul></li></ol><pre><code class="jsx">&lt;script setup&gt;defineProps(&#123;  title: &#123;    required: true,    type: String  &#125;&#125;)&lt;/script&gt;&lt;template&gt;  &lt;el-card class=&quot;page-container&quot;&gt;    &lt;template #header&gt;      &lt;div class=&quot;header&quot;&gt;        &lt;span&gt;&#123;&#123; title &#125;&#125;&lt;/span&gt;        &lt;div class=&quot;extra&quot;&gt;          &lt;slot name=&quot;extra&quot;&gt;&lt;/slot&gt;        &lt;/div&gt;      &lt;/div&gt;    &lt;/template&gt;    &lt;slot&gt;&lt;/slot&gt;  &lt;/el-card&gt;&lt;/template&gt;&lt;style lang=&quot;scss&quot; scoped&gt;.page-container &#123;  min-height: 100%;  box-sizing: border-box;  .header &#123;    display: flex;    align-items: center;    justify-content: space-between;  &#125;&#125;&lt;/style&gt;</code></pre><ol start="3"><li>页面中直接使用测试 ( unplugin-vue-components 会自动注册)</li></ol><ul><li>文章分类测试：</li></ul><pre><code class="jsx">&lt;template&gt;  &lt;page-container title=&quot;文章分类&quot;&gt;    &lt;template #extra&gt;      &lt;el-button type=&quot;primary&quot;&gt; 添加分类 &lt;/el-button&gt;    &lt;/template&gt;    主体部分  &lt;/page-container&gt;&lt;/template&gt;</code></pre><ul><li>文章管理测试：</li></ul><pre><code class="jsx">&lt;template&gt;  &lt;page-container title=&quot;文章管理&quot;&gt;    &lt;template #extra&gt;      &lt;el-button type=&quot;primary&quot;&gt;发布文章&lt;/el-button&gt;    &lt;/template&gt;    主体部分  &lt;/page-container&gt;&lt;/template&gt;</code></pre><h2 id="文章分类渲染"><a href="#文章分类渲染" class="headerlink" title="文章分类渲染"></a>文章分类渲染</h2><h3 id="封装API-请求获取表格数据"><a href="#封装API-请求获取表格数据" class="headerlink" title="封装API - 请求获取表格数据"></a>封装API - 请求获取表格数据</h3><ol><li>新建 <code>api/article.js</code> 封装获取频道列表的接口</li></ol><pre><code class="jsx">import request from &#39;@/utils/request&#39;export const artGetChannelsService = () =&gt; request.get(&#39;/my/cate/list&#39;)</code></pre><ol start="2"><li>页面中调用接口，获取数据存储</li></ol><pre><code class="jsx">const channelList = ref([])const getChannelList = async () =&gt; &#123;  const res = await artGetChannelsService()  channelList.value = res.data.data&#125;</code></pre><h3 id="el-table-表格动态渲染"><a href="#el-table-表格动态渲染" class="headerlink" title="el-table 表格动态渲染"></a>el-table 表格动态渲染</h3><pre><code class="jsx">&lt;el-table :data=&quot;channelList&quot; style=&quot;width: 100%&quot;&gt;  &lt;el-table-column label=&quot;序号&quot; width=&quot;100&quot; type=&quot;index&quot;&gt; &lt;/el-table-column&gt;  &lt;el-table-column label=&quot;分类名称&quot; prop=&quot;cate_name&quot;&gt;&lt;/el-table-column&gt;  &lt;el-table-column label=&quot;分类别名&quot; prop=&quot;cate_alias&quot;&gt;&lt;/el-table-column&gt;  &lt;el-table-column label=&quot;操作&quot; width=&quot;100&quot;&gt;    &lt;template #default=&quot;&#123; row &#125;&quot;&gt;      &lt;el-button        :icon=&quot;Edit&quot;        circle        plain        type=&quot;primary&quot;        @click=&quot;onEditChannel(row)&quot;      &gt;&lt;/el-button&gt;      &lt;el-button        :icon=&quot;Delete&quot;        circle        plain        type=&quot;danger&quot;        @click=&quot;onDelChannel(row)&quot;      &gt;&lt;/el-button&gt;    &lt;/template&gt;  &lt;/el-table-column&gt;  &lt;template #empty&gt;    &lt;el-empty description=&quot;没有数据&quot; /&gt;  &lt;/template&gt;&lt;/el-table&gt;const onEditChannel = (row) =&gt; &#123;  console.log(row)&#125;const onDelChannel = (row) =&gt; &#123;  console.log(row)&#125;</code></pre><h3 id="el-table-表格-loading-效果"><a href="#el-table-表格-loading-效果" class="headerlink" title="el-table 表格 loading 效果"></a>el-table 表格 loading 效果</h3><ol><li>定义变量，v-loading绑定</li></ol><pre><code class="jsx">const loading = ref(false)&lt;el-table v-loading=&quot;loading&quot;&gt;</code></pre><ol start="2"><li>发送请求前开启，请求结束关闭</li></ol><pre><code class="jsx">const getChannelList = async () =&gt; &#123;  loading.value = true  const res = await artGetChannelsService()  channelList.value = res.data.data  loading.value = false&#125;</code></pre><h2 id="文章分类添加编辑-element-plus-弹层"><a href="#文章分类添加编辑-element-plus-弹层" class="headerlink" title="文章分类添加编辑 [element-plus 弹层]"></a>文章分类添加编辑 [element-plus 弹层]</h2><h3 id="点击显示弹层"><a href="#点击显示弹层" class="headerlink" title="点击显示弹层"></a>点击显示弹层</h3><ol><li>准备弹层</li></ol><pre><code class="jsx">const dialogVisible = ref(false)&lt;el-dialog v-model=&quot;dialogVisible&quot; title=&quot;添加弹层&quot; width=&quot;30%&quot;&gt;  &lt;div&gt;我是内容部分&lt;/div&gt;  &lt;template #footer&gt;    &lt;span class=&quot;dialog-footer&quot;&gt;      &lt;el-button @click=&quot;dialogVisible = false&quot;&gt;取消&lt;/el-button&gt;      &lt;el-button type=&quot;primary&quot;&gt; 确认 &lt;/el-button&gt;    &lt;/span&gt;  &lt;/template&gt;&lt;/el-dialog&gt;</code></pre><ol start="2"><li>点击事件</li></ol><pre><code class="jsx">&lt;template #extra&gt;&lt;el-button type=&quot;primary&quot; @click=&quot;onAddChannel&quot;&gt;添加分类&lt;/el-button&gt;&lt;/template&gt;const onAddChannel = () =&gt; &#123;  dialogVisible.value = true&#125;</code></pre><h3 id="封装弹层组件-ChannelEdit"><a href="#封装弹层组件-ChannelEdit" class="headerlink" title="封装弹层组件 ChannelEdit"></a>封装弹层组件 ChannelEdit</h3><p>添加 和 编辑，可以共用一个弹层，所以可以将弹层封装成一个组件</p><p>组件对外暴露一个方法 open,  基于 open 的参数，初始化表单数据，并判断区分是添加 还是 编辑</p><ol><li>open({ })                   &#x3D;&gt;  添加操作，添加表单初始化无数据</li><li>open({ id: xx,  …  })  &#x3D;&gt;  编辑操作，编辑表单初始化需回显</li></ol><p>具体实现：</p><ol><li>封装组件 <code>article/components/ChannelEdit.vue</code></li></ol><pre><code class="jsx">&lt;script setup&gt;import &#123; ref &#125; from &#39;vue&#39;const dialogVisible = ref(false)const open = async (row) =&gt; &#123;  dialogVisible.value = true  console.log(row)&#125;defineExpose(&#123;  open&#125;)&lt;/script&gt;&lt;template&gt;  &lt;el-dialog v-model=&quot;dialogVisible&quot; title=&quot;添加弹层&quot; width=&quot;30%&quot;&gt;    &lt;div&gt;我是内容部分&lt;/div&gt;    &lt;template #footer&gt;      &lt;span class=&quot;dialog-footer&quot;&gt;        &lt;el-button @click=&quot;dialogVisible = false&quot;&gt;取消&lt;/el-button&gt;        &lt;el-button type=&quot;primary&quot;&gt; 确认 &lt;/el-button&gt;      &lt;/span&gt;    &lt;/template&gt;  &lt;/el-dialog&gt;&lt;/template&gt;</code></pre><ol start="2"><li>通过 ref 绑定</li></ol><pre><code class="jsx">const dialog = ref()&lt;!-- 弹窗 --&gt;&lt;channel-edit ref=&quot;dialog&quot;&gt;&lt;/channel-edit&gt;</code></pre><ol start="3"><li>点击调用方法显示弹窗</li></ol><pre><code class="jsx">const onAddChannel = () =&gt; &#123;  dialog.value.open(&#123;&#125;)&#125;const onEditChannel = (row) =&gt; &#123;  dialog.value.open(row)&#125;</code></pre><h3 id="准备弹层表单"><a href="#准备弹层表单" class="headerlink" title="准备弹层表单"></a>准备弹层表单</h3><ol><li>准备数据 和 校验规则</li></ol><pre><code class="jsx">const formModel = ref(&#123;  cate_name: &#39;&#39;,  cate_alias: &#39;&#39;&#125;)const rules = &#123;  cate_name: [    &#123; required: true, message: &#39;请输入分类名称&#39;, trigger: &#39;blur&#39; &#125;,    &#123;      pattern: /^\S&#123;1,10&#125;$/,      message: &#39;分类名必须是1-10位的非空字符&#39;,      trigger: &#39;blur&#39;    &#125;  ],  cate_alias: [    &#123; required: true, message: &#39;请输入分类别名&#39;, trigger: &#39;blur&#39; &#125;,    &#123;      pattern: /^[a-zA-Z0-9]&#123;1,15&#125;$/,      message: &#39;分类别名必须是1-15位的字母数字&#39;,      trigger: &#39;blur&#39;    &#125;  ]&#125;</code></pre><ol start="2"><li>准备表单</li></ol><pre><code class="jsx">&lt;el-form  :model=&quot;formModel&quot;  :rules=&quot;rules&quot;  label-width=&quot;100px&quot;  style=&quot;padding-right: 30px&quot;&gt;  &lt;el-form-item label=&quot;分类名称&quot; prop=&quot;cate_name&quot;&gt;    &lt;el-input      v-model=&quot;formModel.cate_name&quot;      minlength=&quot;1&quot;      maxlength=&quot;10&quot;    &gt;&lt;/el-input&gt;  &lt;/el-form-item&gt;  &lt;el-form-item label=&quot;分类别名&quot; prop=&quot;cate_alias&quot;&gt;    &lt;el-input      v-model=&quot;formModel.cate_alias&quot;      minlength=&quot;1&quot;      maxlength=&quot;15&quot;    &gt;&lt;/el-input&gt;  &lt;/el-form-item&gt;&lt;/el-form&gt;</code></pre><ol start="3"><li>编辑需要回显，表单数据需要初始化</li></ol><pre><code class="jsx">const open = async (row) =&gt; &#123;  dialogVisible.value = true  formModel.value = &#123; ...row &#125;&#125;</code></pre><ol start="4"><li>基于传过来的表单数据，进行标题控制，有 id 的是编辑</li></ol><pre><code class="jsx">:title=&quot;formModel.id ? &#39;编辑分类&#39; : &#39;添加分类&#39;&quot;</code></pre><h3 id="确认提交"><a href="#确认提交" class="headerlink" title="确认提交"></a>确认提交</h3><ol><li><code>api/article.js  </code>  封装请求 API</li></ol><pre><code class="jsx">// 添加文章分类export const artAddChannelService = (data) =&gt; request.post(&#39;/my/cate/add&#39;, data)// 编辑文章分类export const artEditChannelService = (data) =&gt;  request.put(&#39;/my/cate/info&#39;, data)</code></pre><ol start="2"><li>页面中校验，判断，提交请求</li></ol><pre><code class="jsx">&lt;el-form ref=&quot;formRef&quot;&gt;</code></pre><pre><code class="jsx">const formRef = ref()const onSubmit = async () =&gt; &#123;  await formRef.value.validate()  formModel.value.id    ? await artEditChannelService(formModel.value)    : await artAddChannelService(formModel.value)  ElMessage(&#123;    type: &#39;success&#39;,    message: formModel.value.id ? &#39;编辑成功&#39; : &#39;添加成功&#39;  &#125;)  dialogVisible.value = false&#125;</code></pre><ol start="3"><li>通知父组件进行回显</li></ol><pre><code class="jsx">const emit = defineEmits([&#39;success&#39;])const onSubmit = async () =&gt; &#123;  ...  emit(&#39;success&#39;)&#125;</code></pre><ol start="4"><li>父组件监听 success 事件，进行调用回显</li></ol><pre><code class="jsx">&lt;channel-edit ref=&quot;dialog&quot; @success=&quot;onSuccess&quot;&gt;&lt;/channel-edit&gt;const onSuccess = () =&gt; &#123;  getChannelList()&#125;</code></pre><h2 id="文章分类删除"><a href="#文章分类删除" class="headerlink" title="文章分类删除"></a>文章分类删除</h2><ol><li><code>api/article.js</code>封装接口 api</li></ol><pre><code class="jsx">// 删除文章分类export const artDelChannelService = (id) =&gt;  request.delete(&#39;/my/cate/del&#39;, &#123;    params: &#123; id &#125;  &#125;)</code></pre><ol start="2"><li>页面中添加确认框，调用接口进行提示</li></ol><pre><code class="jsx">const onDelChannel = async (row) =&gt; &#123;  await ElMessageBox.confirm(&#39;你确认删除该分类信息吗？&#39;, &#39;温馨提示&#39;, &#123;    type: &#39;warning&#39;,    confirmButtonText: &#39;确认&#39;,    cancelButtonText: &#39;取消&#39;  &#125;)  await artDelChannelService(row.id)  ElMessage(&#123; type: &#39;success&#39;, message: &#39;删除成功&#39; &#125;)  getChannelList()&#125;</code></pre><h1 id="文章管理页面-element-plus-强化"><a href="#文章管理页面-element-plus-强化" class="headerlink" title="文章管理页面 - [element-plus 强化]"></a>文章管理页面 - [element-plus 强化]</h1><h2 id="文章列表渲染"><a href="#文章列表渲染" class="headerlink" title="文章列表渲染"></a>文章列表渲染</h2><h3 id="基本架子搭建"><a href="#基本架子搭建" class="headerlink" title="基本架子搭建"></a>基本架子搭建</h3><p><img src="/assets/image-20230724224754131.png" alt="image-20230724224754131"></p><ol><li>搜索表单</li></ol><pre><code class="jsx">&lt;el-form inline&gt;  &lt;el-form-item label=&quot;文章分类：&quot;&gt;    &lt;el-select&gt;      &lt;el-option label=&quot;新闻&quot; value=&quot;111&quot;&gt;&lt;/el-option&gt;      &lt;el-option label=&quot;体育&quot; value=&quot;222&quot;&gt;&lt;/el-option&gt;    &lt;/el-select&gt;  &lt;/el-form-item&gt;  &lt;el-form-item label=&quot;发布状态：&quot;&gt;    &lt;el-select&gt;      &lt;el-option label=&quot;已发布&quot; value=&quot;已发布&quot;&gt;&lt;/el-option&gt;      &lt;el-option label=&quot;草稿&quot; value=&quot;草稿&quot;&gt;&lt;/el-option&gt;    &lt;/el-select&gt;  &lt;/el-form-item&gt;  &lt;el-form-item&gt;    &lt;el-button type=&quot;primary&quot;&gt;搜索&lt;/el-button&gt;    &lt;el-button&gt;重置&lt;/el-button&gt;  &lt;/el-form-item&gt;&lt;/el-form&gt;</code></pre><ol start="2"><li>表格准备，模拟假数据渲染</li></ol><pre><code class="jsx">import &#123; Delete, Edit &#125; from &#39;@element-plus/icons-vue&#39;import &#123; ref &#125; from &#39;vue&#39;// 假数据const articleList = ref([  &#123;    id: 5961,    title: &#39;新的文章啊&#39;,    pub_date: &#39;2022-07-10 14:53:52.604&#39;,    state: &#39;已发布&#39;,    cate_name: &#39;体育&#39;  &#125;,  &#123;    id: 5962,    title: &#39;新的文章啊&#39;,    pub_date: &#39;2022-07-10 14:54:30.904&#39;,    state: null,    cate_name: &#39;体育&#39;  &#125;])</code></pre><pre><code class="jsx">&lt;el-table :data=&quot;articleList&quot; style=&quot;width: 100%&quot;&gt;  &lt;el-table-column label=&quot;文章标题&quot; width=&quot;400&quot;&gt;    &lt;template #default=&quot;&#123; row &#125;&quot;&gt;      &lt;el-link type=&quot;primary&quot; :underline=&quot;false&quot;&gt;&#123;&#123; row.title &#125;&#125;&lt;/el-link&gt;    &lt;/template&gt;  &lt;/el-table-column&gt;  &lt;el-table-column label=&quot;分类&quot; prop=&quot;cate_name&quot;&gt;&lt;/el-table-column&gt;  &lt;el-table-column label=&quot;发表时间&quot; prop=&quot;pub_date&quot;&gt; &lt;/el-table-column&gt;  &lt;el-table-column label=&quot;状态&quot; prop=&quot;state&quot;&gt;&lt;/el-table-column&gt;  &lt;el-table-column label=&quot;操作&quot; width=&quot;100&quot;&gt;    &lt;template #default=&quot;&#123; row &#125;&quot;&gt;      &lt;el-button        :icon=&quot;Edit&quot;        circle        plain        type=&quot;primary&quot;        @click=&quot;onEditArticle(row)&quot;      &gt;&lt;/el-button&gt;      &lt;el-button        :icon=&quot;Delete&quot;        circle        plain        type=&quot;danger&quot;        @click=&quot;onDeleteArticle(row)&quot;      &gt;&lt;/el-button&gt;    &lt;/template&gt;  &lt;/el-table-column&gt;  &lt;template #empty&gt;    &lt;el-empty description=&quot;没有数据&quot; /&gt;  &lt;/template&gt;&lt;/el-table&gt;const onEditArticle = (row) =&gt; &#123;  console.log(row)&#125;const onDeleteArticle = (row) =&gt; &#123;  console.log(row)&#125;</code></pre><h3 id="中英国际化处理"><a href="#中英国际化处理" class="headerlink" title="中英国际化处理"></a>中英国际化处理</h3><p>默认是英文的，由于这里不涉及切换， 所以在 App.vue 中直接导入设置成中文即可，</p><pre><code class="jsx">&lt;script setup&gt;import zh from &#39;element-plus/es/locale/lang/zh-cn.mjs&#39;&lt;/script&gt;&lt;template&gt;  &lt;!-- 国际化处理 --&gt;  &lt;el-config-provider :locale=&quot;zh&quot;&gt;    &lt;router-view /&gt;  &lt;/el-config-provider&gt;&lt;/template&gt;</code></pre><h3 id="文章分类选择"><a href="#文章分类选择" class="headerlink" title="文章分类选择"></a>文章分类选择</h3><p>为了便于维护，直接拆分成一个小组件 ChannelSelect.vue</p><ol><li>新建 article&#x2F;components&#x2F;ChannelSelect.vue</li></ol><pre><code class="jsx">&lt;template&gt;  &lt;el-select&gt;    &lt;el-option label=&quot;新闻&quot; value=&quot;新闻&quot;&gt;&lt;/el-option&gt;    &lt;el-option label=&quot;体育&quot; value=&quot;体育&quot;&gt;&lt;/el-option&gt;  &lt;/el-select&gt;&lt;/template&gt;</code></pre><ol start="2"><li>页面中导入渲染</li></ol><pre><code class="vue">import ChannelSelect from &#39;./components/ChannelSelect.vue&#39;&lt;el-form-item label=&quot;文章分类：&quot;&gt;  &lt;channel-select&gt;&lt;/channel-select&gt;&lt;/el-form-item&gt;</code></pre><ol start="3"><li>调用接口，动态渲染下拉分类，设计成 v-model 的使用方式</li></ol><pre><code class="jsx">&lt;script setup&gt;import &#123; artGetChannelsService &#125; from &#39;@/api/article&#39;import &#123; ref &#125; from &#39;vue&#39;defineProps(&#123;  modelValue: &#123;    type: [Number, String]  &#125;&#125;)const emit = defineEmits([&#39;update:modelValue&#39;])const channelList = ref([])const getChannelList = async () =&gt; &#123;  const res = await artGetChannelsService()  channelList.value = res.data.data&#125;getChannelList()&lt;/script&gt;&lt;template&gt;  &lt;el-select    :modelValue=&quot;modelValue&quot;    @update:modelValue=&quot;emit(&#39;update:modelValue&#39;, $event)&quot;  &gt;    &lt;el-option      v-for=&quot;channel in channelList&quot;      :key=&quot;channel.id&quot;      :label=&quot;channel.cate_name&quot;      :value=&quot;channel.id&quot;    &gt;&lt;/el-option&gt;  &lt;/el-select&gt;&lt;/template&gt;</code></pre><ol start="4"><li>父组件定义参数绑定</li></ol><pre><code class="jsx">const params = ref(&#123;  pagenum: 1,  pagesize: 5,  cate_id: &#39;&#39;,  state: &#39;&#39;&#125;)&lt;channel-select v-model=&quot;params.cate_id&quot;&gt;&lt;/channel-select&gt;</code></pre><ol start="5"><li>发布状态，也绑定一下，便于将来提交表单</li></ol><pre><code class="jsx">&lt;el-select v-model=&quot;params.state&quot;&gt;  &lt;el-option label=&quot;已发布&quot; value=&quot;已发布&quot;&gt;&lt;/el-option&gt;  &lt;el-option label=&quot;草稿&quot; value=&quot;草稿&quot;&gt;&lt;/el-option&gt;&lt;/el-select&gt;</code></pre><h3 id="封装-API-接口，请求渲染"><a href="#封装-API-接口，请求渲染" class="headerlink" title="封装 API 接口，请求渲染"></a>封装 API 接口，请求渲染</h3><p><strong>没有数据，可以登录已完成的系统，添加几条数据</strong></p><ol><li><code>api/article.js</code>封装接口</li></ol><pre><code class="jsx">export const artGetListService = (params) =&gt;  request.get(&#39;/my/article/list&#39;, &#123; params &#125;)</code></pre><ol start="2"><li>页面中调用保存数据</li></ol><pre><code class="jsx">const articleList = ref([])const total = ref(0)const getArticleList = async () =&gt; &#123;  const res = await artGetListService(params.value)  articleList.value = res.data.data  total.value = res.data.total&#125;getArticleList()</code></pre><ol start="3"><li>新建 <code>utils/format.js</code> 封装格式化日期函数</li></ol><pre><code class="jsx">import &#123; dayjs &#125; from &#39;element-plus&#39;export const formatTime = (time) =&gt; dayjs(time).format(&#39;YYYY年MM月DD日&#39;)</code></pre><ol start="4"><li>导入使用</li></ol><pre><code class="vue">import &#123; formatTime &#125; from &#39;@/utils/format&#39;&lt;el-table-column label=&quot;发表时间&quot;&gt;  &lt;template #default=&quot;&#123; row &#125;&quot;&gt;    &#123;&#123; formatTime(row.pub_date) &#125;&#125;  &lt;/template&gt;&lt;/el-table-column&gt;</code></pre><h3 id="分页渲染-element-plus-分页"><a href="#分页渲染-element-plus-分页" class="headerlink" title="分页渲染 [element-plus 分页]"></a>分页渲染 [element-plus 分页]</h3><ol><li>分页组件</li></ol><pre><code class="jsx">&lt;el-pagination  v-model:current-page=&quot;params.pagenum&quot;  v-model:page-size=&quot;params.pagesize&quot;  :page-sizes=&quot;[2, 3, 4, 5, 10]&quot;  layout=&quot;jumper, total, sizes, prev, pager, next&quot;  background  :total=&quot;total&quot;  @size-change=&quot;onSizeChange&quot;  @current-change=&quot;onCurrentChange&quot;  style=&quot;margin-top: 20px; justify-content: flex-end&quot;/&gt;</code></pre><ol start="2"><li>提供分页修改逻辑</li></ol><pre><code class="jsx">const onSizeChange = (size) =&gt; &#123;  params.value.pagenum = 1  params.value.pagesize = size  getArticleList()&#125;const onCurrentChange = (page) =&gt; &#123;  params.value.pagenum = page  getArticleList()&#125;</code></pre><h3 id="添加-loading-处理"><a href="#添加-loading-处理" class="headerlink" title="添加 loading 处理"></a>添加 loading 处理</h3><ol><li>准备数据</li></ol><pre><code class="jsx">const loading = ref(false)</code></pre><ol start="2"><li>el-table上面绑定</li></ol><pre><code class="jsx">&lt;el-table v-loading=&quot;loading&quot; &gt; ... &lt;/el-table&gt;</code></pre><ol start="3"><li>发送请求时添加 loading</li></ol><pre><code class="jsx">const getArticleList = async () =&gt; &#123;  loading.value = true      ...    loading.value = false&#125;getArticleList()</code></pre><h3 id="搜索-和-重置功能"><a href="#搜索-和-重置功能" class="headerlink" title="搜索 和 重置功能"></a>搜索 和 重置功能</h3><ol><li>注册事件</li></ol><pre><code class="jsx">&lt;el-form-item&gt;  &lt;el-button @click=&quot;onSearch&quot; type=&quot;primary&quot;&gt;搜索&lt;/el-button&gt;  &lt;el-button @click=&quot;onReset&quot;&gt;重置&lt;/el-button&gt;&lt;/el-form-item&gt;</code></pre><ol start="2"><li>绑定处理</li></ol><pre><code class="jsx">const onSearch = () =&gt; &#123;  params.value.pagenum = 1  getArticleList()&#125;const onReset = () =&gt; &#123;  params.value.pagenum = 1  params.value.cate_id = &#39;&#39;  params.value.state = &#39;&#39;  getArticleList()&#125;</code></pre><h2 id="文章发布-amp-修改-element-plus-抽屉"><a href="#文章发布-amp-修改-element-plus-抽屉" class="headerlink" title="文章发布&amp;修改 [element-plus - 抽屉]"></a>文章发布&amp;修改 [element-plus - 抽屉]</h2><h3 id="点击显示抽屉"><a href="#点击显示抽屉" class="headerlink" title="点击显示抽屉"></a>点击显示抽屉</h3><ol><li>准备数据</li></ol><pre><code class="jsx">import &#123; ref &#125; from &#39;vue&#39;const visibleDrawer = ref(false)</code></pre><ol start="2"><li>准备抽屉容器</li></ol><pre><code class="jsx">&lt;el-drawer  v-model=&quot;visibleDrawer&quot;  title=&quot;大标题&quot;  direction=&quot;rtl&quot;  size=&quot;50%&quot;&gt;  &lt;span&gt;Hi there!&lt;/span&gt;&lt;/el-drawer&gt;</code></pre><ol start="3"><li>点击修改布尔值显示抽屉</li></ol><pre><code class="jsx">&lt;el-button type=&quot;primary&quot; @click=&quot;onAddArticle&quot;&gt;发布文章&lt;/el-button&gt;const visibleDrawer = ref(false)const onAddArticle = () =&gt; &#123;  visibleDrawer.value = true&#125;</code></pre><h3 id="封装抽屉组件-ArticleEdit"><a href="#封装抽屉组件-ArticleEdit" class="headerlink" title="封装抽屉组件 ArticleEdit"></a>封装抽屉组件 ArticleEdit</h3><p>添加 和 编辑，可以共用一个抽屉，所以可以将抽屉封装成一个组件</p><p>组件对外暴露一个方法 open,  基于 open 的参数，初始化表单数据，并判断区分是添加 还是 编辑</p><ol><li>open({ })                   &#x3D;&gt;  添加操作，添加表单初始化无数据</li><li>open({ id: xx,  …  })  &#x3D;&gt;  编辑操作，编辑表单初始化需回显</li></ol><p>具体实现：</p><ol><li>封装组件 <code>article/components/ArticleEdit.vue</code></li></ol><pre><code class="jsx">&lt;script setup&gt;import &#123; ref &#125; from &#39;vue&#39;const visibleDrawer = ref(false)const open = (row) =&gt; &#123;  visibleDrawer.value = true  console.log(row)&#125;defineExpose(&#123;  open&#125;)&lt;/script&gt;&lt;template&gt;  &lt;!-- 抽屉 --&gt;  &lt;el-drawer v-model=&quot;visibleDrawer&quot; title=&quot;大标题&quot; direction=&quot;rtl&quot; size=&quot;50%&quot;&gt;    &lt;span&gt;Hi there!&lt;/span&gt;  &lt;/el-drawer&gt;&lt;/template&gt;</code></pre><ol start="2"><li>通过 ref 绑定</li></ol><pre><code class="jsx">const articleEditRef = ref()&lt;!-- 弹窗 --&gt;&lt;article-edit ref=&quot;articleEditRef&quot;&gt;&lt;/article-edit&gt;</code></pre><ol start="3"><li>点击调用方法显示弹窗</li></ol><pre><code class="jsx">// 编辑新增逻辑const onAddArticle = () =&gt; &#123;  articleEditRef.value.open(&#123;&#125;)&#125;const onEditArticle = (row) =&gt; &#123;  articleEditRef.value.open(row)&#125;</code></pre><h3 id="完善抽屉表单结构"><a href="#完善抽屉表单结构" class="headerlink" title="完善抽屉表单结构"></a>完善抽屉表单结构</h3><ol><li>准备数据</li></ol><pre><code class="jsx">const formModel = ref(&#123;  title: &#39;&#39;,  cate_id: &#39;&#39;,  cover_img: &#39;&#39;,  content: &#39;&#39;,  state: &#39;&#39;&#125;)const open = async (row) =&gt; &#123;  visibleDrawer.value = true  if (row.id) &#123;    console.log(&#39;编辑回显&#39;)  &#125; else &#123;    console.log(&#39;添加功能&#39;)  &#125;&#125;</code></pre><ol start="2"><li>准备 form 表单结构</li></ol><pre><code class="jsx">import ChannelSelect from &#39;./ChannelSelect.vue&#39;&lt;template&gt;  &lt;el-drawer    v-model=&quot;visibleDrawer&quot;    :title=&quot;formModel.id ? &#39;编辑文章&#39; : &#39;添加文章&#39;&quot;    direction=&quot;rtl&quot;    size=&quot;50%&quot;  &gt;    &lt;!-- 发表文章表单 --&gt;    &lt;el-form :model=&quot;formModel&quot; ref=&quot;formRef&quot; label-width=&quot;100px&quot;&gt;      &lt;el-form-item label=&quot;文章标题&quot; prop=&quot;title&quot;&gt;        &lt;el-input v-model=&quot;formModel.title&quot; placeholder=&quot;请输入标题&quot;&gt;&lt;/el-input&gt;      &lt;/el-form-item&gt;      &lt;el-form-item label=&quot;文章分类&quot; prop=&quot;cate_id&quot;&gt;        &lt;channel-select          v-model=&quot;formModel.cate_id&quot;          width=&quot;100%&quot;        &gt;&lt;/channel-select&gt;      &lt;/el-form-item&gt;      &lt;el-form-item label=&quot;文章封面&quot; prop=&quot;cover_img&quot;&gt; 文件上传 &lt;/el-form-item&gt;      &lt;el-form-item label=&quot;文章内容&quot; prop=&quot;content&quot;&gt;        &lt;div class=&quot;editor&quot;&gt;富文本编辑器&lt;/div&gt;      &lt;/el-form-item&gt;      &lt;el-form-item&gt;        &lt;el-button type=&quot;primary&quot;&gt;发布&lt;/el-button&gt;        &lt;el-button type=&quot;info&quot;&gt;草稿&lt;/el-button&gt;      &lt;/el-form-item&gt;    &lt;/el-form&gt;  &lt;/el-drawer&gt;&lt;/template&gt;</code></pre><ol start="3"><li>一打开默认重置添加的 form 表单数据</li></ol><pre><code class="jsx">const defaultForm = &#123;  title: &#39;&#39;,  cate_id: &#39;&#39;,  cover_img: &#39;&#39;,  content: &#39;&#39;,  state: &#39;&#39;&#125;const formModel = ref(&#123; ...defaultForm &#125;)const open = async (row) =&gt; &#123;  visibleDrawer.value = true  if (row.id) &#123;    console.log(&#39;编辑回显&#39;)  &#125; else &#123;    console.log(&#39;添加功能&#39;)    formModel.value = &#123; ...defaultForm &#125;  &#125;&#125;</code></pre><ol start="4"><li>扩展 下拉菜单 width props</li></ol><pre><code class="jsx">defineProps(&#123;  modelValue: &#123;    type: [Number, String]  &#125;,  width: &#123;    type: String  &#125;&#125;)&lt;el-select ... :style=&quot;&#123; width &#125;&quot;&gt;</code></pre><h3 id="上传文件-element-plus-文件预览"><a href="#上传文件-element-plus-文件预览" class="headerlink" title="上传文件 [element-plus - 文件预览]"></a>上传文件 [element-plus - 文件预览]</h3><ol><li>关闭自动上传，准备结构</li></ol><pre><code class="jsx">import &#123; Plus &#125; from &#39;@element-plus/icons-vue&#39;&lt;el-upload  class=&quot;avatar-uploader&quot;  :auto-upload=&quot;false&quot;  :show-file-list=&quot;false&quot;  :on-change=&quot;onUploadFile&quot;&gt;  &lt;img v-if=&quot;imgUrl&quot; :src=&quot;imgUrl&quot; class=&quot;avatar&quot; /&gt;  &lt;el-icon v-else class=&quot;avatar-uploader-icon&quot;&gt;&lt;Plus /&gt;&lt;/el-icon&gt;&lt;/el-upload&gt;</code></pre><ol start="2"><li>准备数据 和 选择图片的处理逻辑</li></ol><pre><code class="jsx">const imgUrl = ref(&#39;&#39;)const onUploadFile = (uploadFile) =&gt; &#123;  imgUrl.value = URL.createObjectURL(uploadFile.raw)  formModel.value.cover_img = uploadFile.raw&#125;</code></pre><ol start="3"><li>样式美化</li></ol><pre><code class="css">.avatar-uploader &#123;  :deep() &#123;    .avatar &#123;      width: 178px;      height: 178px;      display: block;    &#125;    .el-upload &#123;      border: 1px dashed var(--el-border-color);      border-radius: 6px;      cursor: pointer;      position: relative;      overflow: hidden;      transition: var(--el-transition-duration-fast);    &#125;    .el-upload:hover &#123;      border-color: var(--el-color-primary);    &#125;    .el-icon.avatar-uploader-icon &#123;      font-size: 28px;      color: #8c939d;      width: 178px;      height: 178px;      text-align: center;    &#125;  &#125;&#125;</code></pre><h3 id="富文本编辑器-vue-quill"><a href="#富文本编辑器-vue-quill" class="headerlink" title="富文本编辑器 [ vue-quill ]"></a>富文本编辑器 [ vue-quill ]</h3><p>官网地址：<a href="https://vueup.github.io/vue-quill/">https://vueup.github.io/vue-quill/</a></p><ol><li>安装包</li></ol><pre><code class="js">pnpm add @vueup/vue-quill@latest</code></pre><ol start="2"><li>注册成局部组件</li></ol><pre><code class="jsx">import &#123; QuillEditor &#125; from &#39;@vueup/vue-quill&#39;import &#39;@vueup/vue-quill/dist/vue-quill.snow.css&#39;</code></pre><ol start="3"><li>页面中使用绑定</li></ol><pre><code class="jsx">&lt;div class=&quot;editor&quot;&gt;  &lt;quill-editor    theme=&quot;snow&quot;    v-model:content=&quot;formModel.content&quot;    contentType=&quot;html&quot;  &gt;  &lt;/quill-editor&gt;&lt;/div&gt;</code></pre><ol start="4"><li>样式美化</li></ol><pre><code class="jsx">.editor &#123;  width: 100%;  :deep(.ql-editor) &#123;    min-height: 200px;  &#125;&#125;</code></pre><h3 id="添加文章功能"><a href="#添加文章功能" class="headerlink" title="添加文章功能"></a>添加文章功能</h3><ol><li>封装添加接口</li></ol><pre><code class="jsx">export const artPublishService = (data) =&gt;  request.post(&#39;/my/article/add&#39;, data)</code></pre><ol start="2"><li>注册点击事件调用</li></ol><pre><code class="jsx">&lt;el-form-item&gt;  &lt;el-button @click=&quot;onPublish(&#39;已发布&#39;)&quot; type=&quot;primary&quot;&gt;发布&lt;/el-button&gt;  &lt;el-button @click=&quot;onPublish(&#39;草稿&#39;)&quot; type=&quot;info&quot;&gt;草稿&lt;/el-button&gt;&lt;/el-form-item&gt;// 发布文章const emit = defineEmits([&#39;success&#39;])const onPublish = async (state) =&gt; &#123;  // 将已发布还是草稿状态，存入 state  formModel.value.state = state  // 转换 formData 数据  const fd = new FormData()  for (let key in formModel.value) &#123;    fd.append(key, formModel.value[key])  &#125;  if (formModel.value.id) &#123;    console.log(&#39;编辑操作&#39;)  &#125; else &#123;    // 添加请求    await artPublishService(fd)    ElMessage.success(&#39;添加成功&#39;)    visibleDrawer.value = false    emit(&#39;success&#39;, &#39;add&#39;)  &#125;&#125;</code></pre><ol start="3"><li>父组件监听事件，重新渲染</li></ol><pre><code class="jsx">&lt;article-edit ref=&quot;articleEditRef&quot; @success=&quot;onSuccess&quot;&gt;&lt;/article-edit&gt;// 添加修改成功const onSuccess = (type) =&gt; &#123;  if (type === &#39;add&#39;) &#123;    // 如果是添加，需要跳转渲染最后一页，编辑直接渲染当前页    const lastPage = Math.ceil((total.value + 1) / params.value.pagesize)    params.value.pagenum = lastPage  &#125;  getArticleList()&#125;</code></pre><h3 id="添加完成后的内容重置"><a href="#添加完成后的内容重置" class="headerlink" title="添加完成后的内容重置"></a>添加完成后的内容重置</h3><pre><code class="jsx">const formRef = ref()const editorRef = ref()const open = async (row) =&gt; &#123;  visibleDrawer.value = true  if (row.id) &#123;    console.log(&#39;编辑回显&#39;)  &#125; else &#123;    formModel.value = &#123; ...defaultForm &#125;    imgUrl.value = &#39;&#39;    editorRef.value.setHTML(&#39;&#39;)  &#125;&#125;</code></pre><h3 id="编辑文章回显"><a href="#编辑文章回显" class="headerlink" title="编辑文章回显"></a>编辑文章回显</h3><p>如果是编辑操作，一打开抽屉，就需要发送请求，获取数据进行回显</p><ol><li>封装接口，根据 id 获取详情数据</li></ol><pre><code class="jsx">export const artGetDetailService = (id) =&gt;  request.get(&#39;my/article/info&#39;, &#123; params: &#123; id &#125; &#125;)</code></pre><ol start="2"><li>页面中调用渲染</li></ol><pre><code class="jsx">const open = async (row) =&gt; &#123;  visibleDrawer.value = true  if (row.id) &#123;    console.log(&#39;编辑回显&#39;)    const res = await artGetDetailService(row.id)    formModel.value = res.data.data    imgUrl.value = baseURL + formModel.value.cover_img    // 提交给后台，需要的是 file 格式的，将网络图片，转成 file 格式    // 网络图片转成 file 对象, 需要转换一下    formModel.value.cover_img = await imageUrlToFile(imgUrl.value, formModel.value.cover_img)  &#125; else &#123;    console.log(&#39;添加功能&#39;)    ...  &#125;&#125;</code></pre><p>chatGPT prompt：封装一个函数，基于 axios， 网络图片地址，转 file 对象， 请注意：写中文注释</p><pre><code class="jsx">// 将网络图片地址转换为File对象async function imageUrlToFile(url, fileName) &#123;  try &#123;    // 第一步：使用axios获取网络图片数据    const response = await axios.get(url, &#123; responseType: &#39;arraybuffer&#39; &#125;);    const imageData = response.data;    // 第二步：将图片数据转换为Blob对象    const blob = new Blob([imageData], &#123; type: response.headers[&#39;content-type&#39;] &#125;);    // 第三步：创建一个新的File对象    const file = new File([blob], fileName, &#123; type: blob.type &#125;);    return file;  &#125; catch (error) &#123;    console.error(&#39;将图片转换为File对象时发生错误:&#39;, error);    throw error;  &#125;&#125;</code></pre><h3 id="编辑文章功能"><a href="#编辑文章功能" class="headerlink" title="编辑文章功能"></a>编辑文章功能</h3><ol><li>封装编辑接口</li></ol><pre><code class="jsx">export const artEditService = (data) =&gt; request.put(&#39;my/article/info&#39;, data)</code></pre><ol start="2"><li>提交时调用</li></ol><pre><code class="jsx">const onPublish = async (state) =&gt; &#123;  ...  if (formModel.value.id) &#123;    await artEditService(fd)    ElMessage.success(&#39;编辑成功&#39;)    visibleDrawer.value = false    emit(&#39;success&#39;, &#39;edit&#39;)  &#125; else &#123;    // 添加请求    ...  &#125;&#125;</code></pre><h2 id="文章删除"><a href="#文章删除" class="headerlink" title="文章删除"></a>文章删除</h2><ol><li>封装删除接口</li></ol><pre><code class="jsx">export const artDelService = (id) =&gt; request.delete(&#39;my/article/info&#39;, &#123; params: &#123; id &#125; &#125;)</code></pre><ol start="2"><li>页面中添加确认框调用</li></ol><pre><code class="jsx">const onDeleteArticle = async (row) =&gt; &#123;  await ElMessageBox.confirm(&#39;你确认删除该文章信息吗？&#39;, &#39;温馨提示&#39;, &#123;    type: &#39;warning&#39;,    confirmButtonText: &#39;确认&#39;,    cancelButtonText: &#39;取消&#39;  &#125;)  await artDelService(row.id)  ElMessage(&#123; type: &#39;success&#39;, message: &#39;删除成功&#39; &#125;)  getArticleList()&#125;</code></pre><h1 id="ChatGPT-amp-Copilot"><a href="#ChatGPT-amp-Copilot" class="headerlink" title="ChatGPT &amp; Copilot"></a>ChatGPT &amp; Copilot</h1><h2 id="AI-的认知-amp-讲解内容说明"><a href="#AI-的认知-amp-讲解内容说明" class="headerlink" title="AI 的认知 &amp; 讲解内容说明"></a>AI 的认知 &amp; 讲解内容说明</h2><p>认知同步：</p><ol><li>AI 早已不是新事物 (接受)  &#x3D;&gt;  语音识别，人脸识别，无人驾驶，智能机器人…    (包括 ChatGPT 也是研发了多年的产物)</li><li>AI 本质是智能工具 (认识)  &#x3D;&gt;  人工智能辅助，可以提升效率，但不具备思想意识，无法从零到一取代人类工作</li><li>AI 一定会淘汰掉一部分人  &#x3D;&gt;  逆水行舟，不进则退；学会拥抱变化，尽早上车</li></ol><p>两个工具：</p><ol><li><p>ChatGPT 3.5 的使用   (4.0 使用方式一致，回答准确度更高，但付费，且每3小时，有次数限制)</p><ol><li><p>正常注册流程  (IP限制，手机号限制)</p></li><li><p>三方整合产品</p><ul><li><p>谷歌搜索：chatgpt 免费网站列表</p></li><li><p><a href="https://github.com/LiLittleCat/awesome-free-chatgpt">https://github.com/LiLittleCat/awesome-free-chatgpt</a></p></li></ul></li></ol></li><li><p>工具 Github Copilot 智能生成代码</p></li></ol><h2 id="ChatGPT-的基本使用-Prompt-优化"><a href="#ChatGPT-的基本使用-Prompt-优化" class="headerlink" title="ChatGPT 的基本使用 - Prompt 优化"></a>ChatGPT 的基本使用 - Prompt 优化</h2><p>AI 互动的过程中，容易出现的问题：</p><ul><li>AI未能理解问题的核心要点</li><li>AI的回答过于宽泛 或 过于具体</li><li>AI提供了错误的信息或观点</li><li>AI未能提供有价值的建议或解决方案</li></ul><p>在识别了问题所在之后，我们可以尝试以下策略来优化我们的Prompt：</p><ul><li><p><strong>明确提问</strong>：</p><p>确保问题表述清晰明确，关键字的准确度，决定了AI 对于需求的理解。</p></li><li><p><strong>细化需求：</strong></p><p>将问题拆分成多个小问题，可以帮助AI更具针对性地回答，也利于即时纠错。</p></li><li><p><strong>添加背景信息：</strong></p><p>提供有关问题背景的详细信息，也可以给 AI 预设一个角色，将有助于AI生成更具深度和价值的回答。</p></li><li><p><strong>适当引导：</strong></p><p>比如：“例如”、“请注意”、“请使用”等，来告诉模型你期望它做什么 或者 不做什么</p></li><li><p><strong>限制范围：</strong></p><p>通过限定回答的范围和长度，可以引导AI生成更精炼的回答</p></li></ul><p>​…</p><h3 id="案例-前端简历"><a href="#案例-前端简历" class="headerlink" title="案例 - 前端简历"></a>案例 - 前端简历</h3><h4 id="Prompt-优化前："><a href="#Prompt-优化前：" class="headerlink" title="Prompt 优化前："></a>Prompt 优化前：</h4><p>Prompt1:  </p><pre><code>前端简历</code></pre><h4 id="Prompt-优化后："><a href="#Prompt-优化后：" class="headerlink" title="Prompt 优化后："></a>Prompt 优化后：</h4><p>Prompt1:  </p><pre><code>背景：你是一名【具有三年开发经验】的前端开发工程师，这三年期间，前两年，你做的【金融】相关四个项目，最后一年做的是【医疗】相关领域的两个项目，且有一定的管理 10人+ 团队的经验。主要的技术栈：【Vue】 和 【小程序】。由于你是计算机软件工程专业，所以你具备一些Java后台、Mysql数据库的知识，也掌握一些基础的算法。问题：你会如何编写你的简历个人技能介绍要求：8条技能介绍，请注意：你不会 angular。</code></pre><p>Prompt2：</p><pre><code class="jsx">基于上文情境，你会如何编写你的项目经验介绍</code></pre><p>Prompt3：</p><pre><code class="jsx">你刚才说的方向完全没有问题，但是我想看到更多的项目技术亮点，项目业务解决方案。请注意：每个项目3个技术亮点，3个业务解决方案。</code></pre><h2 id="工具-Github-Copilot-智能生成代码的使用"><a href="#工具-Github-Copilot-智能生成代码的使用" class="headerlink" title="工具 Github Copilot 智能生成代码的使用"></a>工具 Github Copilot 智能生成代码的使用</h2><h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><ul><li>登录 github，试用 Copilot</li><li>打开 vscode， 搜索并安装插件 Copilot</li></ul><h3 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h3><ul><li>删除键：不接受</li><li>Tab键：接收</li><li>Ctrl + enter： 查看更多方案</li></ul><h2 id="个人中心项目实战-基本资料"><a href="#个人中心项目实战-基本资料" class="headerlink" title="个人中心项目实战 - 基本资料"></a>个人中心项目实战 - 基本资料</h2><h3 id="静态结构-校验处理"><a href="#静态结构-校验处理" class="headerlink" title="静态结构 + 校验处理"></a>静态结构 + 校验处理</h3><p>chatgpt prompt 提示词参考：</p><pre><code>请基于 elementPlus 和 Vue3 的语法，生成组件代码要求：一、表单结构要求1.  组件中包含一个el-form表单，有四行内容，前三行是输入框，第四行是按钮2. 第一行 label 登录名称，输入框禁用不可输入状态3. 第二行 label 用户昵称，输入框可输入4. 第三行 label 用户邮箱，输入框可输入5. 第四行按钮，提交修改二、校验需求给昵称 和 邮箱添加校验1. 昵称 nickname 必须是2-10位的非空字符串2. 邮箱 email 符合邮箱格式即可，且不能为空</code></pre><p>参考目标代码：</p><pre><code class="jsx">&lt;script setup&gt;import &#123; useUserStore &#125; from &#39;@/stores&#39;import &#123; ref &#125; from &#39;vue&#39;const &#123;  user: &#123; username, nickname, email, id &#125;&#125; = useUserStore()const userInfo = ref(&#123; username, nickname, email, id &#125;)const rules = &#123;  nickname: [    &#123; required: true, message: &#39;请输入用户昵称&#39;, trigger: &#39;blur&#39; &#125;,    &#123;      pattern: /^\S&#123;2,10&#125;$/,      message: &#39;昵称必须是2-10位的非空字符串&#39;,      trigger: &#39;blur&#39;    &#125;  ],  email: [    &#123; required: true, message: &#39;请输入用户邮箱&#39;, trigger: &#39;blur&#39; &#125;,    &#123; type: &#39;email&#39;, message: &#39;邮箱格式不正确&#39;, trigger: &#39;blur&#39; &#125;  ]&#125;&lt;/script&gt;&lt;template&gt;  &lt;page-container title=&quot;基本资料&quot;&gt;    &lt;el-row&gt;      &lt;el-col :span=&quot;12&quot;&gt;        &lt;el-form          :model=&quot;userInfo&quot;          :rules=&quot;rules&quot;          ref=&quot;formRef&quot;          label-width=&quot;100px&quot;          size=&quot;large&quot;        &gt;          &lt;el-form-item label=&quot;登录名称&quot;&gt;            &lt;el-input v-model=&quot;userInfo.username&quot; disabled&gt;&lt;/el-input&gt;          &lt;/el-form-item&gt;          &lt;el-form-item label=&quot;用户昵称&quot; prop=&quot;nickname&quot;&gt;            &lt;el-input v-model=&quot;userInfo.nickname&quot;&gt;&lt;/el-input&gt;          &lt;/el-form-item&gt;          &lt;el-form-item label=&quot;用户邮箱&quot; prop=&quot;email&quot;&gt;            &lt;el-input v-model=&quot;userInfo.email&quot;&gt;&lt;/el-input&gt;          &lt;/el-form-item&gt;          &lt;el-form-item&gt;            &lt;el-button type=&quot;primary&quot;&gt;提交修改&lt;/el-button&gt;          &lt;/el-form-item&gt;        &lt;/el-form&gt;      &lt;/el-col&gt;    &lt;/el-row&gt;  &lt;/page-container&gt;&lt;/template&gt;</code></pre><h3 id="封装接口，更新个人信息"><a href="#封装接口，更新个人信息" class="headerlink" title="封装接口，更新个人信息"></a>封装接口，更新个人信息</h3><ol><li>封装接口</li></ol><pre><code class="jsx">export const userUpdateInfoService = (&#123; id, nickname, email &#125;) =&gt;  request.put(&#39;/my/userinfo&#39;, &#123; id, nickname, email &#125;)</code></pre><ol start="2"><li>页面中校验后，封装调用</li></ol><pre><code class="jsx">const formRef = ref()const onSubmit = async () =&gt; &#123;  const valid = await formRef.value.validate()  if (valid) &#123;    await userUpdateInfoService(userInfo.value)    await getUser()    ElMessage.success(&#39;修改成功&#39;)  &#125;&#125;</code></pre><h2 id="个人中心项目实战-更换头像"><a href="#个人中心项目实战-更换头像" class="headerlink" title="个人中心项目实战 - 更换头像"></a>个人中心项目实战 - 更换头像</h2><h3 id="静态结构"><a href="#静态结构" class="headerlink" title="静态结构"></a>静态结构</h3><pre><code class="jsx">&lt;script setup&gt;import &#123; ref &#125; from &#39;vue&#39;import &#123; Plus, Upload &#125; from &#39;@element-plus/icons-vue&#39;import &#123; useUserStore &#125; from &#39;@/stores&#39;const userStore = useUserStore()const imgUrl = ref(userStore.user.user_pic)const onUploadFile = (file) =&gt; &#123;  console.log(file)&#125;&lt;/script&gt;&lt;template&gt;  &lt;page-container title=&quot;更换头像&quot;&gt;    &lt;el-row&gt;      &lt;el-col :span=&quot;12&quot;&gt;        &lt;el-upload          ref=&quot;uploadRef&quot;          class=&quot;avatar-uploader&quot;          :auto-upload=&quot;false&quot;          :show-file-list=&quot;false&quot;          :on-change=&quot;onUploadFile&quot;        &gt;          &lt;img v-if=&quot;imgUrl&quot; :src=&quot;imgUrl&quot; class=&quot;avatar&quot; /&gt;          &lt;img v-else src=&quot;@/assets/avatar.jpg&quot; width=&quot;278&quot; /&gt;        &lt;/el-upload&gt;        &lt;br /&gt;        &lt;el-button type=&quot;primary&quot; :icon=&quot;Plus&quot; size=&quot;large&quot;&gt;          选择图片        &lt;/el-button&gt;        &lt;el-button type=&quot;success&quot; :icon=&quot;Upload&quot; size=&quot;large&quot;&gt;          上传头像        &lt;/el-button&gt;      &lt;/el-col&gt;    &lt;/el-row&gt;  &lt;/page-container&gt;&lt;/template&gt;&lt;style lang=&quot;scss&quot; scoped&gt;.avatar-uploader &#123;  :deep() &#123;    .avatar &#123;      width: 278px;      height: 278px;      display: block;    &#125;    .el-upload &#123;      border: 1px dashed var(--el-border-color);      border-radius: 6px;      cursor: pointer;      position: relative;      overflow: hidden;      transition: var(--el-transition-duration-fast);    &#125;    .el-upload:hover &#123;      border-color: var(--el-color-primary);    &#125;    .el-icon.avatar-uploader-icon &#123;      font-size: 28px;      color: #8c939d;      width: 278px;      height: 278px;      text-align: center;    &#125;  &#125;&#125;&lt;/style&gt;</code></pre><h3 id="选择预览图片"><a href="#选择预览图片" class="headerlink" title="选择预览图片"></a>选择预览图片</h3><pre><code class="jsx">const uploadRef = ref()const imgUrl = ref(userStore.user.user_pic)const onUploadFile = (file) =&gt; &#123;  const reader = new FileReader()  reader.readAsDataURL(file.raw)  reader.onload = () =&gt; &#123;    imgUrl.value = reader.result  &#125;&#125;&lt;el-upload ref=&quot;uploadRef&quot;&gt;&lt;/el-upload&gt; &lt;el-button  @click=&quot;uploadRef.$el.querySelector(&#39;input&#39;).click()&quot;  type=&quot;primary&quot;  :icon=&quot;Plus&quot;  size=&quot;large&quot;  &gt;选择图片&lt;/el-button&gt;</code></pre><h3 id="上传头像"><a href="#上传头像" class="headerlink" title="上传头像"></a>上传头像</h3><ol><li>封装接口</li></ol><pre><code class="jsx">export const userUploadAvatarService = (avatar) =&gt; request.patch(&#39;/my/update/avatar&#39;, &#123; avatar &#125;)</code></pre><ol start="2"><li>调用接口</li></ol><pre><code class="jsx">const onUpdateAvatar = async () =&gt; &#123;  await userUploadAvatarService(imgUrl.value)  await userStore.getUser()  ElMessage(&#123; type: &#39;success&#39;, message: &#39;更换头像成功&#39; &#125;)&#125;</code></pre><h2 id="个人中心项目实战-重置密码"><a href="#个人中心项目实战-重置密码" class="headerlink" title="个人中心项目实战 - 重置密码"></a>个人中心项目实战 - 重置密码</h2><p>chatgpt  prompt</p><pre><code class="jsx">请基于 elementPlus 和 Vue3 的语法，生成组件代码要求：一、表单结构要求1. 组件中包含一个el-form表单，有四行内容，前三行是表单输入框，第四行是两个按钮2. 第一行 label 原密码3. 第二行 label 新密码4. 第三行 label 确认密码5. 第四行两个按钮，修改密码 和 重置二、form绑定字段如下：const pwdForm = ref(&#123;  old_pwd: &#39;&#39;,  new_pwd: &#39;&#39;,  re_pwd: &#39;&#39;&#125;)三、校验需求所有字段，都是 6-15位 非空自定义校验1：原密码 和 新密码不能一样自定义校验2：新密码 和 确认密码必须一样</code></pre><h3 id="静态结构-校验处理-1"><a href="#静态结构-校验处理-1" class="headerlink" title="静态结构 + 校验处理"></a>静态结构 + 校验处理</h3><pre><code class="jsx">&lt;script setup&gt;import &#123; ref &#125; from &#39;vue&#39;const pwdForm = ref(&#123;  old_pwd: &#39;&#39;,  new_pwd: &#39;&#39;,  re_pwd: &#39;&#39;&#125;)const checkOldSame = (rule, value, cb) =&gt; &#123;  if (value === pwdForm.value.old_pwd) &#123;    cb(new Error(&#39;原密码和新密码不能一样!&#39;))  &#125; else &#123;    cb()  &#125;&#125;const checkNewSame = (rule, value, cb) =&gt; &#123;  if (value !== pwdForm.value.new_pwd) &#123;    cb(new Error(&#39;新密码和确认再次输入的新密码不一样!&#39;))  &#125; else &#123;    cb()  &#125;&#125;const rules = &#123;  // 原密码  old_pwd: [    &#123; required: true, message: &#39;请输入密码&#39;, trigger: &#39;blur&#39; &#125;,    &#123;      pattern: /^\S&#123;6,15&#125;$/,      message: &#39;密码长度必须是6-15位的非空字符串&#39;,      trigger: &#39;blur&#39;    &#125;  ],  // 新密码  new_pwd: [    &#123; required: true, message: &#39;请输入新密码&#39;, trigger: &#39;blur&#39; &#125;,    &#123;      pattern: /^\S&#123;6,15&#125;$/,      message: &#39;密码长度必须是6-15位的非空字符串&#39;,      trigger: &#39;blur&#39;    &#125;,    &#123; validator: checkOldSame, trigger: &#39;blur&#39; &#125;  ],  // 确认新密码  re_pwd: [    &#123; required: true, message: &#39;请再次确认新密码&#39;, trigger: &#39;blur&#39; &#125;,    &#123;      pattern: /^\S&#123;6,15&#125;$/,      message: &#39;密码长度必须是6-15位的非空字符串&#39;,      trigger: &#39;blur&#39;    &#125;,    &#123; validator: checkNewSame, trigger: &#39;blur&#39; &#125;  ]&#125;&lt;/script&gt;&lt;template&gt;  &lt;page-container title=&quot;重置密码&quot;&gt;    &lt;el-row&gt;      &lt;el-col :span=&quot;12&quot;&gt;        &lt;el-form          :model=&quot;pwdForm&quot;          :rules=&quot;rules&quot;          ref=&quot;formRef&quot;          label-width=&quot;100px&quot;          size=&quot;large&quot;        &gt;          &lt;el-form-item label=&quot;原密码&quot; prop=&quot;old_pwd&quot;&gt;            &lt;el-input v-model=&quot;pwdForm.old_pwd&quot; type=&quot;password&quot;&gt;&lt;/el-input&gt;          &lt;/el-form-item&gt;          &lt;el-form-item label=&quot;新密码&quot; prop=&quot;new_pwd&quot;&gt;            &lt;el-input v-model=&quot;pwdForm.new_pwd&quot; type=&quot;password&quot;&gt;&lt;/el-input&gt;          &lt;/el-form-item&gt;          &lt;el-form-item label=&quot;确认新密码&quot; prop=&quot;re_pwd&quot;&gt;            &lt;el-input v-model=&quot;pwdForm.re_pwd&quot; type=&quot;password&quot;&gt;&lt;/el-input&gt;          &lt;/el-form-item&gt;          &lt;el-form-item&gt;            &lt;el-button @click=&quot;onSubmit&quot; type=&quot;primary&quot;&gt;修改密码&lt;/el-button&gt;            &lt;el-button @click=&quot;onReset&quot;&gt;重置&lt;/el-button&gt;          &lt;/el-form-item&gt;        &lt;/el-form&gt;      &lt;/el-col&gt;    &lt;/el-row&gt;  &lt;/page-container&gt;&lt;/template&gt;</code></pre><h3 id="封装接口，更新密码信息"><a href="#封装接口，更新密码信息" class="headerlink" title="封装接口，更新密码信息"></a>封装接口，更新密码信息</h3><ol><li>封装接口</li></ol><pre><code class="jsx">export const userUpdatePassService = (&#123; old_pwd, new_pwd, re_pwd &#125;) =&gt;  request.patch(&#39;/my/updatepwd&#39;, &#123; old_pwd, new_pwd, re_pwd &#125;)</code></pre><ol start="2"><li>页面中调用</li></ol><pre><code class="jsx">const formRef = ref()const router = useRouter()const userStore = useUserStore()const onSubmit = async () =&gt; &#123;  const valid = await formRef.value.validate()  if (valid) &#123;    await userUpdatePassService(pwdForm.value)    ElMessage(&#123; type: &#39;success&#39;, message: &#39;更换密码成功&#39; &#125;)    userStore.setToken(&#39;&#39;)    userStore.setUser(&#123;&#125;)    router.push(&#39;/login&#39;)  &#125;&#125;const onReset = () =&gt; &#123;  formRef.value.resetFields()&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>项目面试准备</title>
      <link href="/2023/08/03/%E9%A1%B9%E7%9B%AE%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/"/>
      <url>/2023/08/03/%E9%A1%B9%E7%9B%AE%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/</url>
      
        <content type="html"><![CDATA[<h1 id="瑞吉外卖"><a href="#瑞吉外卖" class="headerlink" title="瑞吉外卖"></a>瑞吉外卖</h1><h2 id="common"><a href="#common" class="headerlink" title="common"></a>common</h2><h3 id="BaseCOntext"><a href="#BaseCOntext" class="headerlink" title="BaseCOntext"></a>BaseCOntext</h3><ul><li><p><em>threadLocal</em></p><p><code>ThreadLocal</code> 是 Java 中的一个类，它提供了一种创建线程本地变量的方式。线程本地变量是指只属于特定线程的变量，不与其他线程共享。</p><p>相当于每个线程都有自己的副本  自己的东西自己访问</p><p>private static ThreadLocal<Long> <em>threadLocal</em>&#x3D;new ThreadLocal<Long>();<br>public static void setCurrentId(Long id) {<br><em>threadLocal</em>.set(id);<br>}<br>public static Long getCurrentId() {<br>return <em>threadLocal</em>.get();<br>}</Long></Long></p><p>这段代码定义了一个全局异常处理器 <code>GlobalExceptionHandler</code>，它使用了 Spring 的 <code>@ControllerAdvice</code> 注解来声明，能够处理所有带有 <code>@RestController</code> 或 <code>@Controller</code> 注解的类的异常。</p><p>在 <code>GlobalExceptionHandler</code> 中，定义了两个异常处理方法：</p><ol><li><code>getErrorMessage()</code>：用于处理 <code>SQLIntegrityConstraintViolationException</code> 异常。如果该异常的错误信息中包含 “Duplicate entry”，则说明是由于违反唯一性约束而导致的异常，此时会提取出重复键值，并返回一个包含错误信息的 <code>R</code> 对象。否则，会返回一个包含默认错误信息的 <code>R</code> 对象。</li><li><code>getCustomException()</code>：用于处理自定义异常 <code>CustomException</code>。该方法会直接将异常信息封装成一个包含错误信息的 <code>R</code> 对象，并返回给调用方。</li></ol><p>这些异常处理方法都使用了 <code>@ExceptionHandler</code> 注解来声明，用于指定处理哪种类型的异常。当程序抛出相应的异常时，Spring MVC 会自动将异常对象传递给对应的异常处理方法，并执行该方法中的逻辑。</p><p>需要注意的是，这些异常处理方法都使用了 <code>@ResponseBody</code> 注解来指定返回值类型为 JSON 格式。这意味着当这些方法返回一个 <code>R</code> 对象时，Spring MVC 会自动将该对象序列化成 JSON 格式并返回给调用方。由于这些方法都是返回一个包含错误信息的 <code>R</code> 对象，因此它们都能够提供统一的异常处理机制，从而提高程序的稳定性和可维护性。</p><pre><code>package com.atheima.reggie.common;import java.sql.SQLIntegrityConstraintViolationException;import lombok.extern.slf4j.Slf4j;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.bind.annotation.RestController;@ControllerAdvice(annotations = &#123;RestController.class,Controller.class&#125;)@ResponseBody@Slf4jpublic class GlobalExceptionHandler &#123;    /**     * 异常处理方法     * @return     */    @ExceptionHandler(SQLIntegrityConstraintViolationException.class)    public R&lt;String&gt; getErrorMessage(SQLIntegrityConstraintViolationException exception)&#123;        log.error(exception.getMessage());        if (exception.getMessage().contains(&quot;Duplicate entry&quot;))&#123;            String[] split = exception.getMessage().split(&quot; &quot;);            String error= split[2]+&quot;已经存在&quot;;            return R.error(error);        &#125;        return R.error(&quot;未知的错误发生&quot;);    &#125;    /**     * 异常处理方法     * @return     */    @ExceptionHandler(CustomException.class)    public R&lt;String&gt; getCustomException(CustomException exception)&#123;        log.error(exception.getMessage());        return R.error(exception.getMessage());    &#125;&#125;</code></pre><p>这段代码是一个 MyBatis Plus 的配置类，用于配置 MyBatis Plus 的插件。</p><p>在这个配置类中，通过 <code>@Configuration</code> 注解将该类标识为一个配置类，告诉 Spring 容器需要对该类进行处理。</p><p>然后，使用 <code>@Bean</code> 注解定义了一个名为 <code>mybatisPlusInterceptor</code> 的方法，该方法返回一个 <code>MybatisPlusInterceptor</code> 实例。</p><p>在方法内部，创建了一个 <code>MybatisPlusInterceptor</code> 对象，并通过 <code>addInnerInterceptor</code> 方法添加了一个 <code>PaginationInnerInterceptor</code> 内部拦截器。<code>PaginationInnerInterceptor</code> 是 MyBatis Plus 提供的分页插件，用于处理分页查询的逻辑。</p><p>最后，将创建的 <code>MybatisPlusInterceptor</code> 对象返回。</p><p>这样，当 Spring 容器初始化时，会自动调用该配置类中的 <code>mybatisPlusInterceptor</code> 方法，将返回的 <code>MybatisPlusInterceptor</code> 实例注册到容器中，使得 MyBatis Plus 插件生效，其中包括了分页查询的功能。</p><pre><code>@Configurationpublic class MybatisPlusConfig &#123;    @Bean    public MybatisPlusInterceptor mybatisPlusInterceptor()&#123;        MybatisPlusInterceptor mybatisPlusInterceptor=new MybatisPlusInterceptor();        mybatisPlusInterceptor.addInnerInterceptor(new PaginationInnerInterceptor());        return mybatisPlusInterceptor;    &#125;&#125;</code></pre><p>这段代码是一个 Redis 的配置类，用于配置 RedisTemplate。</p><p>在这个配置类中，使用 <code>@Configuration</code> 注解将该类标识为一个配置类，告诉 Spring 容器需要对该类进行处理。</p><p>继承了 <code>CachingConfigurerSupport</code> 类，表示扩展了 Spring 的缓存配置支持。</p><p>然后，使用 <code>@Bean</code> 注解定义了一个名为 <code>redisTemplate</code> 的方法，该方法返回一个 <code>RedisTemplate&lt;Object, Object&gt;</code> 实例。</p><p>在方法内部，创建了一个 <code>RedisTemplate&lt;Object, Object&gt;</code> 对象，并进行了一些配置操作。具体配置如下：</p><ul><li>通过 <code>setKeySerializer</code> 方法设置了 key 的序列化器为 <code>StringRedisSerializer</code>，将 key 序列化为字符串。</li><li>可以根据需要，通过 <code>setValueSerializer</code> 方法设置 value 的序列化器。在代码中，该行代码是被注释掉的，表示使用默认的序列化器 <code>JdkSerializationRedisSerializer</code>。</li></ul><p>最后，将创建的 <code>RedisTemplate&lt;Object, Object&gt;</code> 对象返回。</p><p>这样，当 Spring 容器初始化时，会自动调用该配置类中的 <code>redisTemplate</code> 方法，将返回的 <code>RedisTemplate</code> 实例注册到容器中，使得在应用程序中可以使用该实例来操作 Redis 数据库。</p><pre><code>@Configurationpublic class RedisConfig extends CachingConfigurerSupport &#123;    @Bean    public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory) &#123;        RedisTemplate&lt;Object, Object&gt; redisTemplate = new RedisTemplate&lt;&gt;();        //默认的Key序列化器为：JdkSerializationRedisSerializer        redisTemplate.setKeySerializer(new StringRedisSerializer()); // key序列化        //redisTemplate.setValueSerializer(new GenericJackson2JsonRedisSerializer()); // value序列化        redisTemplate.setConnectionFactory(connectionFactory);        return redisTemplate;    &#125;&#125;</code></pre></li></ul><p>controller注解</p><p><code>@RequestBody</code> 注解用于指示 Spring MVC 控制器方法参数绑定时，从请求的主体中获取数据并进行反序列化。</p><p>一般情况下，当请求的数据以 JSON、XML 或其他格式作为请求主体发送到服务器时，您需要使用 <code>@RequestBody</code> 注解来告诉 Spring 框架将请求主体中的数据绑定到方法参数上。</p><p>在您提供的代码示例中，<code>@RequestBody</code> 注解用于将请求主体中的 JSON 数据反序列化为 <code>Employee</code> 对象，并将其作为参数传递给 <code>login</code> 方法。</p><p>使用 <code>@RequestBody</code> 注解的好处是，它使得控制器方法的参数绑定变得简单和自动化。您无需手动从请求中提取数据、解析 JSON 或处理其他反序列化逻辑，Spring 框架会自动完成这些操作。</p><p>需要注意的是，使用 <code>@RequestBody</code> 注解时，需要确保请求的 Content-Type 与请求主体中的数据格式相匹配，以便 Spring 框架能够正确解析请求主体中的数据并进行反序列化。常见的 Content-Type 类型包括 application&#x2F;json、application&#x2F;xml 等。</p><p>分页知识</p><p>这段代码是一个处理分页查询的方法，使用了 <code>@GetMapping</code> 注解标记为处理 GET 请求的方法。</p><p>请求路径为 “&#x2F;page”，接收的请求参数包括 <code>page</code>（当前页码）、<code>pageSize</code>（每页显示的记录数）和 <code>name</code>（查询条件）。</p><p>方法内部进行了以下处理逻辑：</p><ol><li>使用日志记录了请求中的 <code>page</code>、<code>pageSize</code> 和 <code>name</code> 参数的值。</li><li>构建了一个 <code>Page</code> 对象，表示分页查询的信息，其中传入了当前页码和每页显示的记录数。</li><li>构建了一个 <code>LambdaQueryWrapper</code> 对象，用于构造查询条件。</li><li>使用 <code>like</code> 方法设置了一个查询条件，即根据 <code>name</code> 参数进行模糊查询。当 <code>name</code> 参数不为空时，才会添加该查询条件。</li><li>使用 <code>orderByDesc</code> 方法设置了一个排序条件，即按照 <code>updateTime</code> 字段进行降序排序。</li><li>调用 <code>employeeService</code> 的 <code>page</code> 方法执行分页查询，将查询结果存入 <code>pageinfo</code> 对象中。</li><li>返回一个包装了结果的 R 对象，其中包含了处理结果的状态码和消息，以及分页查询的结果 <code>pageinfo</code>。</li></ol><p>最终，返回的结果中包含了分页查询的数据，可以在客户端进行展示或其他操作。</p><pre><code>  @GetMapping(&quot;/page&quot;)    public R&lt;Page&gt; page(int page,int pageSize,String name) &#123;        log.info(&quot;page=&#123;&#125;,pageSize=&#123;&#125;,name=&#123;&#125;&quot;,page,pageSize,name);        //构建分页构造器        Page pageinfo=new Page&lt;&gt;(page,pageSize);        //构造条件构造器        LambdaQueryWrapper&lt;Employee&gt; lambdaQueryWrapper=new LambdaQueryWrapper();        lambdaQueryWrapper.like(StringUtils.isNotEmpty(name),Employee::getName,name);        lambdaQueryWrapper.orderByDesc(Employee::getUpdateTime);        //执行查询        employeeService.page(pageinfo,lambdaQueryWrapper);        return R.success(pageinfo);    &#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>图灵商城开发</title>
      <link href="/2023/08/02/%E5%9B%BE%E7%81%B5%E5%95%86%E5%9F%8E%E5%BC%80%E5%8F%91/"/>
      <url>/2023/08/02/%E5%9B%BE%E7%81%B5%E5%95%86%E5%9F%8E%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="图片一"><a href="#图片一" class="headerlink" title="图片一"></a>图片一</h1><p><img src="/2023/08/02/%E5%9B%BE%E7%81%B5%E5%95%86%E5%9F%8E%E5%BC%80%E5%8F%91/personboke\blog\source_posts\图灵商城开发\Snipaste_2023-08-02_23-19-04.png" alt="Snipaste_2023-08-02_23-19-04"></p><h1 id="图片2直接截图"><a href="#图片2直接截图" class="headerlink" title="图片2直接截图"></a>图片2直接截图</h1><p><img src="/2023/08/02/%E5%9B%BE%E7%81%B5%E5%95%86%E5%9F%8E%E5%BC%80%E5%8F%91/personboke/blog/source/_posts/图灵商城开发/01.png" alt="01"><img src="/2023/08/02/%E5%9B%BE%E7%81%B5%E5%95%86%E5%9F%8E%E5%BC%80%E5%8F%91/personboke\blog\source_posts\图灵商城开发\image-20230802233505512.png" alt="image-20230802233505512"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java集成短信服务</title>
      <link href="/2023/08/01/java%E9%9B%86%E6%88%90%E7%9F%AD%E4%BF%A1%E6%9C%8D%E5%8A%A1/"/>
      <url>/2023/08/01/java%E9%9B%86%E6%88%90%E7%9F%AD%E4%BF%A1%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="java集成短信服务"><a href="#java集成短信服务" class="headerlink" title="java集成短信服务"></a>java集成短信服务</h1><h2 id="注册一个帐号"><a href="#注册一个帐号" class="headerlink" title="注册一个帐号"></a>注册一个帐号</h2><p>使用的是<strong>容联云</strong>，百度搜一下官网</p><p>用手机注册一个帐号就行，免费体验不需要认证<br>注册后会有八块钱送，可以使用免费的给自己设置三个固定手机号发送短信，不需要认证。</p><p><img src="/2023/08/01/java%E9%9B%86%E6%88%90%E7%9F%AD%E4%BF%A1%E6%9C%8D%E5%8A%A1/personboke\blog\source_posts\java集成短信服务\image-20230801212907523.png" alt="image-20230801212907523"></p><p><strong>此页面的 三个信息需要在代码中去进行填写认证</strong></p><p>主账户</p><p>账户授权令牌</p><p>访问的Rest URl</p><p>APP id</p><h1 id="绑定用于接收短信的手机号"><a href="#绑定用于接收短信的手机号" class="headerlink" title="绑定用于接收短信的手机号"></a>绑定用于接收短信的手机号</h1><p>控制台—管理—号码管理—测试号码”绑定 测试号码</p><p><img src="/2023/08/01/java%E9%9B%86%E6%88%90%E7%9F%AD%E4%BF%A1%E6%9C%8D%E5%8A%A1/personboke\blog\source_posts\java集成短信服务\image-20230801213129678.png" alt="image-20230801213129678"></p><h3 id="添加maven依赖"><a href="#添加maven依赖" class="headerlink" title="添加maven依赖"></a>添加maven依赖</h3><p>jdk要使用8以上</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;com.cloopen&lt;/groupId&gt;    &lt;artifactId&gt;java-sms-sdk&lt;/artifactId&gt;    &lt;version&gt;1.0.3&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><p>我们需要把以上<strong>四个信息</strong>填入，还有接收短信的<strong>手机号码</strong>，<strong>验证码</strong>需要自己手动生成，（这里使用四位随机整数），然后将这些信息传到短信服务平台帮我们发送。</p><pre><code class="java">@Componentpublic class SendMessage &#123;        public static String message(String phone)&#123;            //返回产生的验证码            String code= null;            //生产环境请求地址：app.cloopen.com            String serverIp = &quot;app.cloopen.com&quot;;            //请求端口            String serverPort = &quot;8883&quot;;            //主账号,登陆云通讯网站后,可在控制台首页看到开发者主账号ACCOUNT SID和主账号令牌AUTH TOKEN            String accountSId =&quot;自己的&quot;;            String accountToken = &quot;自己的&quot;;            //请使用管理控制台中已创建应用的APPID            String appId = &quot;自己的&quot;;            CCPRestSmsSDK sdk = new CCPRestSmsSDK();            sdk.init(serverIp, serverPort);            sdk.setAccount(accountSId, accountToken);            sdk.setAppId(appId);            sdk.setBodyType(BodyType.Type_JSON);            //手机号码            String to = phone;            String templateId= &quot;1&quot;;//使用的模板id            //生成四位随机数            int random=(int)(Math.random()*10000);            code = String.valueOf(random);            String[] datas = &#123;code,&quot;2&quot;&#125;;//格式:你的验证码是&#123;code&#125;，请于&#123;2&#125;分钟内正确输入            //HashMap&lt;String, Object&gt; result = sdk.sendTemplateSMS(to,templateId,datas);            HashMap&lt;String, Object&gt; result = sdk.sendTemplateSMS(to,templateId,datas);            if(&quot;000000&quot;.equals(result.get(&quot;statusCode&quot;)))&#123;                //正常返回输出data包体信息（map）                HashMap&lt;String,Object&gt; data = (HashMap&lt;String, Object&gt;) result.get(&quot;data&quot;);                Set&lt;String&gt; keySet = data.keySet();                for(String key:keySet)&#123;                    Object object = data.get(key);                    System.out.println(key +&quot; = &quot;+object);                &#125;            &#125;else&#123;                //异常返回输出错误码和错误信息                System.out.println(&quot;错误码=&quot; + result.get(&quot;statusCode&quot;) +&quot; 错误信息= &quot;+result.get(&quot;statusMsg&quot;));            &#125;            return code;        &#125;&#125;</code></pre><h2 id="调用方法一并附上防止有看不懂的"><a href="#调用方法一并附上防止有看不懂的" class="headerlink" title="调用方法一并附上防止有看不懂的"></a>调用方法一并附上防止有看不懂的</h2><pre><code>package com.atheima.reggie.controller;import com.atheima.reggie.Utils.SendMessageUtils;import com.atheima.reggie.Utils.ValidateCodeUtils;import com.atheima.reggie.common.R;import com.atheima.reggie.common.SendMessage;import com.atheima.reggie.entity.User;import com.atheima.reggie.service.UserService;import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;import java.util.Map;import java.util.concurrent.TimeUnit;import javax.servlet.http.HttpSession;import lombok.extern.slf4j.Slf4j;import org.apache.commons.lang.StringUtils;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.core.TimeoutUtils;import org.springframework.web.bind.annotation.*;@RestController@RequestMapping(&quot;/user&quot;)@Slf4jpublic class UserController &#123;    @Autowired    private UserService userService;    @Autowired    private RedisTemplate redisTemplate;    @Autowired    private SendMessage sendMessage;    @PostMapping(&quot;/sendMsg&quot;)    public R&lt;String&gt; sendMessage(@RequestBody User user, HttpSession session)&#123;        String phone=user.getPhone();        //获取手机号//        if (StringUtils.isNotEmpty(phone))&#123;//            //生成随机的四位验证码//            Integer integer = ValidateCodeUtils.generateValidateCode(4);//            String code = integer.toString();////            SendMessageUtils.message(phone);//            //调用api短信//            //需要生成的验证码保存到session////            session.setAttribute(phone,code);//            //将生成的验证码缓存到redis中并且设置有效期5分钟//            redisTemplate.opsForValue().set(phone,code,5,TimeUnit.MINUTES);//            log.info(&quot;Sent message&quot;+code);//        SendMessage()        String code=sendMessage.message(phone);        if (StringUtils.isNotEmpty(code))&#123;            session.setAttribute(phone,code);          //将生成的验证码缓存到redis中并且设置有效期5分钟            redisTemplate.opsForValue().set(phone,code,5,TimeUnit.MINUTES);            log.info(&quot;Sent message&quot;+code);            return R.success(&quot;验证码登录成功&quot;);        &#125;        return R.success(&quot;验证码登录失败&quot;);        &#125;    @PostMapping(&quot;/login&quot;)    public R&lt;User&gt; login(@RequestBody Map map,HttpSession session)&#123;        log.info(map.toString());        String phone = map.get(&quot;phone&quot;).toString();        String code = map.get(&quot;code&quot;).toString();        //从cookie中//        String phonecodeinsessoin =(String) session.getAttribute(phone);        //从Redis中获取缓存验证码        String phonecodeinsessoin=(String) redisTemplate.opsForValue().get(phone);        if (phonecodeinsessoin!=null&amp;&amp;phonecodeinsessoin.equals(code))&#123;            LambdaQueryWrapper&lt;User&gt; lambdaQueryWrapper=new LambdaQueryWrapper&lt;&gt;();            lambdaQueryWrapper.eq(User::getPhone,phone);            User user = userService.getOne(lambdaQueryWrapper);            if (user==null)&#123;                user=new User();                user.setPhone(phone);                user.setStatus(1);                userService.save(user);            &#125;            session.setAttribute(&quot;user&quot;,user.getId());            //如果用户登陆成功则删除缓存验证码            redisTemplate.delete(phone);            return R.success(user);        &#125;        return R.error(&quot;登陆失败&quot;);    &#125;    @PostMapping(&quot;/loginout&quot;)    public R&lt;String&gt; loginout(@RequestBody Map map,HttpSession session)&#123;        session.removeAttribute(&quot;user&quot;);        return R.success(&quot;退出成功&quot;);    &#125;&#125;</code></pre><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img src="/2023/08/01/java%E9%9B%86%E6%88%90%E7%9F%AD%E4%BF%A1%E6%9C%8D%E5%8A%A1/personboke\blog\source_posts\java集成短信服务\image-20230801213715539.png" alt="image-20230801213715539"></p><p>Springboot集成qq邮箱<br>自己以前做过就不多赘述<br>以下文章来自博客<br><a href="https://blog.csdn.net/sdrfghb/article/details/126845550">https://blog.csdn.net/sdrfghb/article/details/126845550</a>?<br>提示：以下是本篇文章正文内容，下面案例可供参考</p><p>邮箱设置<br>这边主要展示qq邮箱设置，网易或别的邮箱请自行百度设置</p><p>qq邮箱地址<br>打开账号POP3&#x2F;SMTP服务</p><p>注意保存授权码</p><p>添加依赖，为了让验证码页面好看点，咱们可以使用thymeleaf</p><p>org.springframework.boot spring-boot-starter-mail org.springframework.boot spring-boot-starter-thymeleaf<br>yaml 配置<br>spring:<br>mail:</p><h1 id="邮箱服务器地址"><a href="#邮箱服务器地址" class="headerlink" title="邮箱服务器地址"></a>邮箱服务器地址</h1><p>host: smtp.qq.com</p><h1 id="账号"><a href="#账号" class="headerlink" title="账号"></a>账号</h1><p>username: qq号</p><h1 id="密码"><a href="#密码" class="headerlink" title="密码"></a>密码</h1><p>password: 上面qq邮箱的授权码</p><h1 id="编码格式"><a href="#编码格式" class="headerlink" title="编码格式"></a>编码格式</h1><p>default-encoding: UTF-8</p><h1 id="超时时间"><a href="#超时时间" class="headerlink" title="超时时间"></a>超时时间</h1><p>properties:<br>mail:<br>smtp:<br>auth: true<br>enable: true<br>connectiontimeout: 10000<br>timeout: 10000<br>writetimeout: 10000</p><h1 id="配置SSL-加密工厂"><a href="#配置SSL-加密工厂" class="headerlink" title="配置SSL 加密工厂"></a>配置SSL 加密工厂</h1><p>socketFactoryClass: javax.net.ssl.SSLSocketFactory</p><h1 id="表示开启-DEBUG-模式，这样，邮件发送过程的日志会在控制台打印出来，方便排查错误"><a href="#表示开启-DEBUG-模式，这样，邮件发送过程的日志会在控制台打印出来，方便排查错误" class="headerlink" title="表示开启 DEBUG 模式，这样，邮件发送过程的日志会在控制台打印出来，方便排查错误"></a>表示开启 DEBUG 模式，这样，邮件发送过程的日志会在控制台打印出来，方便排查错误</h1><p>debug: true</p><p>封装工具类<br>&#x2F;**</p><ul><li><p>description: 使用thymeleaf模板发送邮件</p></li><li></li><li><p>@param subject 主题</p></li><li><p>@param map Thymeleaf html模板参数</p></li><li><p>@param htmlName 模板名称</p></li><li><p>@param addressee 收件人</p></li><li><p>@return boolean</p></li><li><p>@author Tigger<br>*&#x2F;<br>public boolean sendThymeleafMail(String subject, Map&lt;String, Object&gt; map, String htmlName, String… addressee) {<br>boolean flag &#x3D; false;<br>try {<br>MimeMessage mimeMessage &#x3D; javaMailSender.createMimeMessage();<br>MimeMessageHelper mimeMessageHelper &#x3D; null;<br>mimeMessageHelper &#x3D; new MimeMessageHelper(mimeMessage, true);<br>&#x2F;&#x2F; 邮件发送者<br>mimeMessageHelper.setFrom(from);<br>&#x2F;&#x2F; 邮件接受者<br>mimeMessageHelper.setTo(addressee);<br>&#x2F;&#x2F; 主题<br>mimeMessageHelper.setSubject(subject);</p><pre><code>  // 这里引入的是Template的Context  Context context = new Context();  // 设置模板中的变量  context.setVariables(map);  // 第一个参数为模板的名称  String process = templateEngine.process(htmlName, context);  // 第二个参数true表示这是一个html文本  mimeMessageHelper.setText(process,true);  javaMailSender.send(mimeMessage);  flag = true;</code></pre><p>  }<br>  catch (MessagingException e) {<br>  e.printStackTrace();<br>  }<br>  return flag;</p></li></ul><p>}</p><p>16<br>使用，这边使用了lombok和redis，需要的自己引下依赖，不需要的自行删除。<br>&#x2F;**</p><p>description: 生成指定位数短信验证码<br>@param count 指定位数<br>@return java.lang.String<br>@author Tigger<br><em>&#x2F;<br>private String getRandCode(int count) {<br>return String.valueOf((int)((Math.random()9+1) Math.pow(10,count-1)));<br>}<br>&#x2F;</em>*</p><p>description: 发送邮箱验证码<br>@param mailNumber 发送邮箱账号<br>@return java.lang.String<br>@author Tigger<br>*&#x2F;<br>public String sendCodeMailInfo(String mailNumber) {<br>String sendMessage &#x3D; null;<br>String randCode &#x3D; getRandCode(6);<br>log.info(“邮箱验证码-{}”, randCode);<br>Map&lt;String, Object&gt; stringObjectMap &#x3D; new HashMap&lt;&gt;(1);<br>stringObjectMap.put(“codeMessage”, randCode);<br>boolean mail &#x3D; mailUtil.sendThymeleafMail(“验证码”, stringObjectMap, “mailAssign.html”, mailNumber);<br>if (mail) {<br>log.info(“邮箱验证码发送成功”);<br>&#x2F;&#x2F; 将验证码放入redis<br>boolean set &#x3D; redisUtil.set(mailNumber + FinalCode.REDIS_Mail_SMS, randCode, FinalCode.SECOND_NUMBER);<br>if (set) {<br>log.info(“短信验证码缓存成功”);<br>}<br>sendMessage &#x3D; “邮箱验证码发送成功”;<br>}<br>return sendMessage;<br>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>javascript关键点</title>
      <link href="/2023/07/17/javascript%E5%85%B3%E9%94%AE%E7%82%B9/"/>
      <url>/2023/07/17/javascript%E5%85%B3%E9%94%AE%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="javascript关键点"><a href="#javascript关键点" class="headerlink" title="javascript关键点"></a>javascript关键点</h1><h3 id="object的属性"><a href="#object的属性" class="headerlink" title="object的属性"></a>object的属性</h3><p>给object对象拓展一个属性 dosome方法</p><p>这里所有的对象都可以用这个拓展方法</p><pre><code>Object.prototype.dosome=function（）&#123;        .........&#125;</code></pre><h3 id="js中怎样定义类"><a href="#js中怎样定义类" class="headerlink" title="js中怎样定义类"></a>js中怎样定义类</h3><p><strong>方式一</strong></p><pre><code>function 类名(形参1，形参....)&#123;this.属性=参数；this.属性=参数；.....&#125;</code></pre><p><strong>方式二</strong></p><pre><code>类名=function(形参1，形参....)&#123;this.属性=参数；this.属性=参数；.....&#125;</code></pre><p>这里为什么这么熟悉？</p><p>没错很熟悉，这里就是函数的定义</p><p>关键看如何调用</p><p>如果直接使用</p><pre><code>function example(形参1，形参....)&#123;this.属性=参数；this.属性=参数；.....&#125;example();</code></pre><p>这种写法即是简单函数的调用不会再浏览器堆里开辟空间</p><pre><code>function example(形参1，形参....)&#123;this.属性=参数；this.属性=参数；.....&#125;var obj=new example();</code></pre><p>这种写法即表示创建了一个对象</p><p>example</p><pre><code>function student(形参1，形参....)&#123;this.属性=参数；this.属性=参数；this.work=function()&#123;    .......&#125;.....&#125;var student1=new student(x1,x2,x3);</code></pre><h4 id="访问一个对象属性方式"><a href="#访问一个对象属性方式" class="headerlink" title="访问一个对象属性方式"></a>访问一个对象属性方式</h4><p>object.属性</p><p>object[属性]</p><h4 id="null-NaN-undefine的区别"><a href="#null-NaN-undefine的区别" class="headerlink" title="null NaN undefine的区别"></a>null NaN undefine的区别</h4><p><strong>&#x3D;&#x3D;&#x3D; 和&#x3D;&#x3D; 和&#x3D;的区别</strong></p><p>&#x3D;赋值操作 赋值操作</p><p>&#x3D;&#x3D;比较值是否相等 等同运算符</p><p>&#x3D;&#x3D;&#x3D;比较内容以及数据类型是否相同 全等运算符</p><p>typeof（null） &#x3D; object</p><p>typeof（NaN） &#x3D;number</p><p>typeof（undefine） &#x3D;undefine</p><p>&#x3D;&#x3D;的时候 null&#x3D;&#x3D;undefine 为true其余皆为false</p><h1 id="js的常用事件操作"><a href="#js的常用事件操作" class="headerlink" title="js的常用事件操作"></a>js的常用事件操作</h1><p><strong>JS的常用事件</strong>：</p><pre><code>                （1）blur失去焦点                （5）focus获得焦点                                （3）click鼠标单击                （4）dblclick鼠标双击                                （6）keydown键盘按下                （7）keyup键盘弹起                                （9）mousedown鼠标按下                （10）mouseover鼠标经过                （11）mousemove鼠标移动                （12）mouseout鼠标离开                （13）mouseup鼠标弹起                                （16）submit表单提交                （14）reset表单重置                                （15）select文本被选定                （2）change下拉列表选中项改变，或文本框内容改变                （8）load页面加载完毕                            提醒：任何一个事件都有对应的事件句柄。事件句柄是在事件名称前添加on就行。</code></pre><p><strong>注意：当页面加载的过程中我们定义的事件都会加载 但是并不会执行</strong></p><p><strong>当我们触发到某一事件之后会调用函数 此时调用函数的是浏览器的监听器调用的</strong></p><p><strong>此时这些函数被称为回调函数</strong></p><p>BOM操作简单来说是修改浏览器的操作比如迁建后退 或者…</p><p>顶级对象即为 window.属性</p><p><strong>获取html的id对应的标签</strong> 也就是DOM操作</p><p>顶级对象为Document.对象</p><pre><code>alert(&quot;阻止程序的执行！&quot;)            // 根据id获取元素/节点对象            // 在JS当中有一个内置的隐含的对象叫做:document            // document代表整个HTML文档.            // 在JS当中有一个内置的隐含的对象叫做:window            // window代表整个浏览器窗口.            // window对象是BOM的顶级对象,BOM中的老大.            // document对象是DOM的顶级对象,DOM中的老大.            // 严格意义上来说,window是包含document的.            var mybtnElt = document.getElementById(&quot;mybtn&quot;);                        //console.log(mybtnElt)            //alert(mybtnElt) //[object HTMLInputElement]                        // 重点:在JS当中,当你获取了一个节点之后,这个节点中有什么属性你就可以&quot;点&quot;什么.            //mybtnElt.type = &quot;checkbox&quot;;            //mybtnElt.type = &quot;text&quot;;            mybtnElt.value = &quot;我是一个按钮对象哦！&quot;;</code></pre><p><strong>注册事件的第二种方式</strong></p><pre><code>    /* 定义一个函数 */            function sum()&#123;                console.log(&quot;sum function invoke!&quot;)            &#125;                        /* 根据id获取button对象 */            var hellobtnElt = document.getElementById(&quot;hellobtn&quot;);                        // 元素中有什么属性,就能&quot;点&quot;什么.            /* 这行代码在页面打开的时候会执行，这行代码执行的意义是：将sum这个回调函数绑定到hellobtn的click事件上 */            /* 这个回调函数sum在什么时候执行？click事件发生之后才会被监听器调用！ */            //hellobtnElt.onclick = sum  //不要这样写: hellobtnElt.onclick = sum()                        // 回调函数可以是一个匿名函数            // 这行代码的执行只是完成事件click的注册,给click事件注册一个回调函数.            // 这行代码执行的时候，回调函数并不会被执行。            // 只有当这个按钮发生click事件之后,这个回调函数会自动被监听器来调用.            hellobtnElt.onclick = function()&#123;                console.log(&quot;我是一个回调函数，同时我没有名字，叫做匿名函数！&quot;)            &#125;            </code></pre><h3 id="onload事件的绑定"><a href="#onload事件的绑定" class="headerlink" title="onload事件的绑定"></a>onload事件的绑定</h3><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;onload事件句柄&lt;/title&gt;    &lt;/head&gt;    &lt;!-- 页面加载完毕之后监听器调用myfun()回调函数 --&gt;    &lt;!-- &lt;body onload=&quot;myfun()&quot;&gt; --&gt;    &lt;!-- &lt;body id=&quot;mybody&quot;&gt; --&gt;    &lt;body&gt;                &lt;script type=&quot;text/javascript&quot;&gt;                        /* function myfun()&#123;                console.log(&quot;myfun execute!~~~~~~~~~~~~~~&quot;)            &#125; */                        // 这种方式可以,就是代码有点多,在JS当中,window对象也可以onload.            //var mybodyElt = document.getElementById(&quot;mybody&quot;);            //mybodyElt.onload = myfun                        /* 在页面打开的时候，以下这行代码会执行，这行代码执行的作用是：将回调函数myfun注册到load事件上 */            /* 当页面全部加载完毕之后，会发生load事件，load事件发生之后，监听器负责调用回调函数myfun */            //window.onload = myfun                        // load事件发生之后,后面的“匿名回调函数”会被监听器调用.            window.onload = function()&#123;                console.log(&quot;hello world!&quot;)            &#125;                        // 页面打开的过程中实际上是各种事件的绑定.            // 等这些事件一个一个发生之后,回调函数统一都是由监听器来负责调用的.            /* xxxElt.onclick = function()&#123;&#125;            xxxElt.onblur = function()&#123;&#125; */                    &lt;/script&gt;                    &lt;/body&gt;    &lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt;    alert(&quot;页面加载过程中！&quot;)&lt;/script&gt;</code></pre><h1 id="捕捉键盘回车进行确认登陆"><a href="#捕捉键盘回车进行确认登陆" class="headerlink" title="捕捉键盘回车进行确认登陆"></a>捕捉键盘回车进行确认登陆</h1><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;捕捉回车键（怎么在JS中捕捉键值。）&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;                &lt;script type=&quot;text/javascript&quot;&gt;                        /* function sum(x , y)&#123;                            &#125;                        sum();            sum(1);            sum(1,2);            sum(1,2,3);            */                       /* function myfun()&#123;                console.log(&quot;执行了myfun....没有参数的！&quot;)            &#125; */                        /* function myfun(fdsafdsafds)&#123;                console.log(&quot;执行了myfun....有参数的！&quot;)            &#125;                        myfun(&quot;abc&quot;) */                                    // x, y都是变量名,随意的,随便写.只要符合标识符命名规范就行.            window.onload = function(x)&#123; // x代表的就是load事件对象.                // 给id=&quot;username&quot;的节点绑定keydown事件                // 后面的这个回调函数是我们负责编写的,但是调用者是监听器.                // 监听器调用这个回调函数的时候会传过来一个事件对象.                // 你如果需要使用这个事件对象的时候,你可以写上,你不需要这个事件对象的时候,可以省略.                document.getElementById(&quot;username&quot;).onkeydown = function(y)&#123; // y代表的就是一个keydown事件对象.                    //console.log(&quot;keydown.....&quot;)                    // 在这里捕捉键值,当用户敲回车键了,则登录                    // 新知识点:所有的“键盘事件对象”,有keyCode属性,这个keyCode属性可以获取键值.                    // keyCode是键盘事件对象的属性.                    // 记住:键盘上回车键的键值永远都是13.ECS键的键值永远都是27.                    if(y.keyCode == 13) &#123;                        console.log(&quot;登录，正在进行身份认证，请稍后...&quot;);                    &#125;else if(y.keyCode == 27)&#123;                        console.log(&quot;系统安全退出了！&quot;)                    &#125;                &#125;            &#125;                    &lt;/script&gt;                用户名：&lt;input type=&quot;text&quot; id=&quot;username&quot; /&gt;            &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="事件的完美案例"><a href="#事件的完美案例" class="headerlink" title="事件的完美案例"></a>事件的完美案例</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;事件的最后一个完美的案例&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;script type=&quot;text/javascript&quot;&gt;                        /* 这段代码有3个回调函数。 */            /* 最外层的回调函数是在load事件发生之后才会执行！ */            window.onload = function()&#123;                            /* //给id=&quot;btn1&quot;的元素绑定鼠标单击                var btn1Elt = document.getElementById(&quot;btn1&quot;);                btn1Elt.onclick = function()&#123; // btn1被单击click之后,这个事件发生了,才会执行这个回调函数                    console.log(&quot;按钮1被点击了！&quot;)                &#125;                                //给id=&quot;btn2&quot;的元素绑定鼠标单击                var btn2Elt = document.getElementById(&quot;btn2&quot;);                btn2Elt.onclick = function()&#123;// btn2被单击click之后,这个事件发生了,才会执行这个回调函数                    console.log(&quot;按钮2被点击了！&quot;)                &#125; */                                document.getElementById(&quot;btn1&quot;).onclick = function()&#123;                    console.log(&quot;按钮1单击&quot;)                &#125;                                document.getElementById(&quot;btn2&quot;).onclick = function()&#123;                    console.log(&quot;按钮2单击&quot;)                &#125;                                document.getElementById(&quot;username&quot;).onblur = function()&#123;                    console.log(&quot;失去焦点了&quot;)                &#125;                            &#125;                    &lt;/script&gt;                &lt;input type=&quot;button&quot; id=&quot;btn1&quot; value=&quot;按钮1&quot;/&gt;        &lt;br&gt;        &lt;input type=&quot;button&quot; id=&quot;btn2&quot; value=&quot;按钮2&quot;/&gt;        &lt;br&gt;        &lt;input type=&quot;text&quot; id=&quot;username&quot; /&gt;            &lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="js的void函数"><a href="#js的void函数" class="headerlink" title="js的void函数"></a>js的void函数</h3><p>一般只用在href后面用于点击不跳转</p><h3 id="js的循环语句"><a href="#js的循环语句" class="headerlink" title="js的循环语句"></a>js的循环语句</h3><p>for in 这里面的循环遍历数组得到的是数组的下标</p><pre><code>for(var index in arr)&#123;&#125;</code></pre><p>循环遍历一个对象的话就会得到对象的属性</p><pre><code>for(var 属性 in person)&#123;        &#125;</code></pre><h3 id="js的数组中的基本方法"><a href="#js的数组中的基本方法" class="headerlink" title="js的数组中的基本方法"></a>js的数组中的基本方法</h3><pre><code>arr.push（）添加的元素都是加到最后arr.pop（）弹出末尾元素弹出并且数组长度减一可以模拟栈的数据结构先进后出arr.reverse()反转数组连接数组arr.join（$）数组中的元素将按照下标拼接arr[0]$arr[1]$......</code></pre><h3 id="js中的日期类型"><a href="#js中的日期类型" class="headerlink" title="js中的日期类型"></a>js中的日期类型</h3><p>…….</p><p><a href="file:///C:/Users/李开恩/AppData/Roaming/Typora/typora-user-images/image-20230716125505572.png"><img src="file:///C:/Users/%E6%9D%8E%E5%BC%80%E6%81%A9/AppData/Roaming/Typora/typora-user-images/image-20230716125505572.png" alt="image-20230716125505572"></a></p><h3 id="BOM和DOM区别"><a href="#BOM和DOM区别" class="headerlink" title="BOM和DOM区别"></a>BOM和DOM区别</h3><h4 id="1-BOM和DOM的区别与联系"><a href="#1-BOM和DOM的区别与联系" class="headerlink" title="1. BOM和DOM的区别与联系"></a>1. <strong>BOM和DOM的区别与联系</strong></h4><p>BOM: Browser Object Model（浏览器对象模型），通过BOM的对象和方法可以完成浏览器窗口的操作，例如：关闭浏览器，前进，后退，修改地址栏上的地址等，这些操作都属于BOM。BOM的顶级内置对象是window。</p><p>DOM: Document Object Model（文档对象模型），通过DOM的对象和方法可以完成网页中元素的增删改，让网页产生动态效果，DOM的顶级内置对象是document。</p><p><a href="file:///C:/Users/李开恩/AppData/Local/Temp/ksohtml17920/wps2.png"><img src="file:///C:/Users/%E6%9D%8E%E5%BC%80%E6%81%A9/AppData/Local/Temp/ksohtml17920/wps2.png" alt="img"></a></p><h3 id="BOM操作"><a href="#BOM操作" class="headerlink" title="BOM操作"></a>BOM操作</h3><p>onclick&#x3D; Window.open（’网址’）</p><p>开启一个新窗口</p><p><a href="file:///C:/Users/李开恩/AppData/Roaming/Typora/typora-user-images/image-20230716150220309.png"><img src="file:///C:/Users/%E6%9D%8E%E5%BC%80%E6%81%A9/AppData/Roaming/Typora/typora-user-images/image-20230716150220309.png" alt="image-20230716150220309"></a></p><p>window.confirm弹窗 点击确认返回true 取消则返回false</p><p>window.alert(内容) 弹出内容</p><p>跳转页面可以通过多种方式：（这些都是发送请求！！！！）</p><h3 id="JS中发送请求的几种方式"><a href="#JS中发送请求的几种方式" class="headerlink" title="JS中发送请求的几种方式"></a>JS中发送请求的几种方式</h3><pre><code>            第一种方式：直接在浏览器地址栏上写URL。（重点）                        第二种方式：可以点击超链接（重点）                        第三种方式：提交表单（重点）                        第四种方式：window.open(url,target)  （了解）                        第五种方式：js代码（重点）                        window.location.href                        window.location                        document.location.href                        document.location                                    通过浏览器向服务器发送请求，通常是以上的五种方式。</code></pre><p>eval（字符串）</p><p>这个函数可以解析并执行以字符串来写的js代码</p><h3 id="js中的json-对象解析以及字符串拼接实现table中的tbody内容"><a href="#js中的json-对象解析以及字符串拼接实现table中的tbody内容" class="headerlink" title="js中的json 对象解析以及字符串拼接实现table中的tbody内容"></a>js中的json 对象解析以及字符串拼接实现table中的tbody内容</h3><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;My Cesium.js App&lt;/title&gt;   &lt;/head&gt;&lt;body&gt;            &lt;script type=&quot;text/javascript&quot;&gt;        /* 从java过来一个json格式的字符串 */        var fromJava = &quot;&#123;\&quot;total\&quot; : 2, \&quot;students\&quot; : [&#123;\&quot;name\&quot;:\&quot;李四\&quot;,\&quot;age\&quot;:19&#125;,&#123;\&quot;name\&quot;:\&quot;王五\&quot;,\&quot;age\&quot;:18&#125;]&#125;&quot;;                window.onload = function()&#123;            document.getElementById(&quot;displaybtn&quot;).onclick = function()&#123;                // 解析上面的json格式的字符串,将解析出来的数据放到tbody当中.                // 转化json对象                window.eval(&quot;var json = &quot; + fromJava) //json对象有了.                // 设置总记录条数                document.getElementById(&quot;totalSpan&quot;).innerHTML = json.total;                // 拼接HTML                var studentArray = json.students;                var html = &quot;&quot;;                for(var i = 0; i &lt; studentArray.length; i++)&#123;                    var s = studentArray[i]                    html += &quot;&lt;tr&gt;&quot;;                    html += &quot;&lt;td&gt;&quot;+(i+1)+&quot;&lt;/td&gt;&quot;;                    html += &quot;&lt;td&gt;&quot;+s.name+&quot;&lt;/td&gt;&quot;;                    html += &quot;&lt;td&gt;&quot;+s.age+&quot;&lt;/td&gt;&quot;;                    html += &quot;&lt;/tr&gt;&quot;;                &#125;                // 将以上拼接的HTML设置到tbody当中                document.getElementById(&quot;stutbody&quot;).innerHTML = html;            &#125;        &#125;            &lt;/script&gt;        &lt;input type=&quot;button&quot; value=&quot;查看学生信息列表&quot; id=&quot;displaybtn&quot; /&gt;    &lt;hr &gt;        &lt;table border=&quot;1px&quot; width=&quot;40%&quot;&gt;        &lt;tr&gt;            &lt;th&gt;序号&lt;/th&gt;            &lt;th&gt;学生姓名&lt;/th&gt;            &lt;th&gt;学生年龄&lt;/th&gt;        &lt;/tr&gt;        &lt;tbody id=&quot;stutbody&quot;&gt;            &lt;!-- &lt;tr&gt;                &lt;td&gt;1&lt;/td&gt;                &lt;td&gt;张三&lt;/td&gt;                &lt;td&gt;20&lt;/td&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td&gt;2&lt;/td&gt;                &lt;td&gt;李四&lt;/td&gt;                &lt;td&gt;22&lt;/td&gt;            &lt;/tr&gt; --&gt;        &lt;/tbody&gt;    &lt;/table&gt;    总记录条数：&lt;span id=&quot;totalSpan&quot;&gt;0&lt;/span&gt;条    &lt;!-- 总记录条数：2条 --&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="正则表达式东西"><a href="#正则表达式东西" class="headerlink" title="正则表达式东西"></a>正则表达式东西</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;正则表达式&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;script type=&quot;text/javascript&quot;&gt;            /*                 1、什么是正则表达式，有什么用？                    正则表达式是一门独立的学科，基本每个语言都支持。                    正则表达式不是JS专属的。不过在JS中使用居多。                    通常使用正则表达式进行字符串格式匹配。                                        正则表达式是有一堆特殊的符号组成的一个表达式。                    每一个特殊的符号都有特殊的代表含义。                                        例如：                        qq号的正则表达式。                        邮箱地址的正则表达式。                                            邮箱地址格式验证：                        程序中有一个邮箱地址的正则表达式。                        用户输入了一个邮箱地址。                        那么邮箱地址的正则表达式和邮箱地址进行匹配，能匹配成功，表示合法，反之表示不合法。                                        2、对于javascript程序员来说，我们对于正则表达式掌握到什么程度呢？                    第一：能够看懂正则表达式                    第二：简单的正则要会写                    第三：要能够独立的从网络当中搜索到你想要的正则表达式（搜索能力要有）                    第四：要会创建JS的正则表达式对象。                    第五：要会调用JS正则表达式对象的方法。                                3、常见的正则表达式符号有哪些？                    . 匹配除换行符以外的任意字符                     \w 匹配字母或数字或下划线或汉字                     \s 匹配任意的空白符                     \d 匹配数字                     \b 匹配单词的开始或结束                     ^ 匹配字符串的开始                     $ 匹配字符串的结束                                         * 重复零次或更多次 0-N次                    + 重复一次或更多次  1-N次                    ? 重复零次或一次  0或1次                    &#123;n&#125; 重复n次  n次                    &#123;n,&#125; 重复n次或更多次  n+次                    &#123;n,m&#125; 重复n到m次  n到m次                    注意：数量永远匹配的都是前面的那个字符出现的次数。                                        \W 匹配任意不是字母，数字，下划线，汉字的字符                     \S 匹配任意不是空白符的字符                     \D 匹配任意非数字的字符                     \B 匹配不是单词开头或结束的位置                     [^x] 匹配除了x以外的任意字符                     [^aeiou] 匹配除了aeiou这几个字母以外的任意字符                                         | 表示或者                                        [a-z]&#123;1&#125; a到z所有的字符中的任意1个。                                        [a-zA-Z0-9]&#123;3,&#125; 前面这堆中的任意字符至少出现3个。                                        [1-9][0-9]&#123;4,&#125;    qq号的正则表达式，最小的qq号是10000                                        [1-9] 没有指定数量的时候，默认是1个。                                    4、邮箱的正则表达式：                    ^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$                    这个邮箱地址从网上找了之后不一定能用，你需要测试。反复测试。                                5、在JS中怎么创建正则表达式对象呢？                                    包括两种方式，重点使用第一种                                        第一种方式：直接量语法                        var regExp = /正则表达式/标记                                            第二种方式：使用内置类RegExp类。                        var regExp = new RegExp(&quot;正则表达式&quot;, &quot;标记&quot;)                                        标记是可选项！！！！！都有哪些值可选呢？                        g：全局 global                        i: 忽略大小写 ignorecase                        gi: 全局扫描，并且忽略大小写。                                6、正则表达式对象有一个很重要的方法：                    var emailRegExp = /^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$/                    var ok = emailRegExp.test(&quot;用户输入的字符串&quot;);                    返回值ok是true表示，匹配成功了。                                        其实在JS中，字符串String也是支持正则表达式的。             */            // 字符串对象使用正则表达式            console.log(&quot;1980-11-10&quot;.replace(&quot;-&quot;, &quot;/&quot;))            // g表示global全局的,所有的 - 替换成/            console.log(&quot;1980-11-10&quot;.replace(/-/g, &quot;/&quot;))                        function checkEmail()&#123;                //获取邮箱地址                var email = document.getElementById(&quot;email&quot;).value;                // 创建正则表达式对象                var regExp = /^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$/;                // 验证                var ok = regExp.test(email);                if(ok)&#123;                    alert(&quot;邮箱地址合法&quot;)                &#125;else&#123;                    alert(&quot;邮箱地址不合法&quot;);                &#125;            &#125;                    &lt;/script&gt;                邮箱地址：&lt;input type=&quot;text&quot; id=&quot;email&quot; /&gt;        &lt;input type=&quot;button&quot; value=&quot;验证邮箱地址&quot; onclick=&quot;checkEmail()&quot;/&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="表单的验证实现"><a href="#表单的验证实现" class="headerlink" title="表单的验证实现"></a>表单的验证实现</h3><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;                &lt;style type=&quot;text/css&quot;&gt;            span &#123;                font-size: 12px;                color: red;            &#125;        &lt;/style&gt;            &lt;/head&gt;    &lt;body&gt;        &lt;script type=&quot;text/javascript&quot;&gt;            /*             （1）用户名不能为空            （2）用户名必须在6-14位之间            （3）用户名只能有数字和字母组成，不能含有其它符号（正则表达式）            （4）密码和确认密码一致            （5）统一失去焦点验证            （6）错误提示信息统一在span标签中提示，并且要求字体12号，红色。            （7）文本框再次获得焦点后，清空错误提示信息            （8）最终表单中所有项均合法方可提交             */            window.onload = function()&#123;                                var nameErrorSpan = document.getElementById(&quot;nameError&quot;);                                // 给id=&quot;username&quot;的节点绑定blur事件                var usernameElt = document.getElementById(&quot;username&quot;);                usernameElt.onblur = function()&#123;                    // 获取用户名                    var username = usernameElt.value;                    // 去除掉前后空白                    username = username.trim();                    // 用户名不能为空,不能为空串                    //if(username.length == 0)&#123;&#125;                    if(username == &quot;&quot;)&#123;                        nameErrorSpan.innerHTML = &quot;用户名不能为空&quot;;                    &#125;else&#123;                        // 用户名不是空,继续判断长度是否合法                        if(username.length &lt; 6 || username.length &gt; 14)&#123;                            nameErrorSpan.innerHTML = &quot;用户名长度必须在[6-14]之间&quot;;                        &#125;else&#123;                            // 用户名不为空,并且长度也合法,接下来继续判断用户名中是否有特殊符号                            var regExp = /^[a-zA-Z0-9]+$/                            var ok = regExp.test(username)                            if(ok)&#123;                                // 合法                                nameErrorSpan.innerHTML = &quot;&quot;;                            &#125;else&#123;                                // 不合法                                nameErrorSpan.innerHTML = &quot;用户名只能由数字和字母组成&quot;;                            &#125;                        &#125;                    &#125;                &#125;                                // 获得焦点:清空span的错误信息.                usernameElt.onfocus = function()&#123;                    nameErrorSpan.innerHTML = &quot;&quot;;                &#125;                                var pwdErrorSpan = document.getElementById(&quot;pwdError&quot;);                // 确认密码失去焦点就验证.                document.getElementById(&quot;confirmpwd&quot;).onblur = function()&#123;                    //获取密码                    var userpwd = document.getElementById(&quot;userpwd&quot;).value;                    //获取确认密码                    var confirmpwd = document.getElementById(&quot;confirmpwd&quot;).value;                    //进行比对                    if(userpwd != confirmpwd)&#123;                        pwdErrorSpan.innerHTML = &quot;密码和确认密码不一致&quot;;                    &#125;else&#123;                        pwdErrorSpan.innerHTML = &quot;&quot;;                    &#125;                &#125;                                                document.getElementById(&quot;confirmpwd&quot;).onfocus = function()&#123;                    pwdErrorSpan.innerHTML = &quot;&quot;;                &#125;                                document.getElementById(&quot;regbtn&quot;).onclick = function()&#123;                                        // 验证用户名,怎么验证用户名？让用户名文本框失去焦点                    // 重点:使用JS代码怎么触发事件？？？？？？                    usernameElt.focus(); //触发文本框的获取焦点事件                    usernameElt.blur();//触发文本框的失去焦点事件                                        // 验证密码,怎么验证密码？让确认密码失去焦点                    document.getElementById(&quot;confirmpwd&quot;).focus();                    document.getElementById(&quot;confirmpwd&quot;).blur();                                        // 当所有的span都是空的表示表单合法                    if(nameErrorSpan.innerHTML == &quot;&quot; &amp;&amp; pwdErrorSpan.innerHTML == &quot;&quot;)&#123;                        //提交                        var formObj = document.getElementById(&quot;userForm&quot;);                        // 通过调用submit()方法来完成表单的提交                        formObj.submit();                    &#125;                &#125;            &#125;                    &lt;/script&gt;                &lt;form id=&quot;userForm&quot; action=&quot;http://localhost:8080/oa/save&quot;&gt;            用户名&lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;username&quot;/&gt;&lt;span id=&quot;nameError&quot;&gt;&lt;/span&gt;            &lt;br&gt;            密码&lt;input type=&quot;password&quot; name=&quot;userpwd&quot; id=&quot;userpwd&quot;/&gt;            &lt;br&gt;            &lt;!-- 确认密码是不需要提交给服务器的，这个name不要写！ --&gt;            确认密码&lt;input type=&quot;password&quot; id=&quot;confirmpwd&quot;/&gt; &lt;span id=&quot;pwdError&quot;&gt;&lt;/span&gt;            &lt;br&gt;            &lt;!-- 表单所有项目都合法才能提交 --&gt;            &lt;!-- &lt;input type=&quot;submit&quot; value=&quot;注册&quot; /&gt; --&gt;            &lt;!-- button不能提交表单，但是JS代码可以提交表单 --&gt;            &lt;input type=&quot;button&quot; value=&quot;注册&quot; id=&quot;regbtn&quot;/&gt;        &lt;/form&gt;             &lt;/body&gt;&lt;/html&gt;</code></pre><h1 id="AJAX发送异步请求过程"><a href="#AJAX发送异步请求过程" class="headerlink" title="AJAX发送异步请求过程"></a>AJAX发送异步请求过程</h1><p>这个过程是利用了</p><p>var xhr &#x3D;new XMLHttpRequest();</p><p>这个异步请求对象</p><p>并且将表单的体检按钮换成button 并且设置单击事件</p><p>根据js的函数可以发送请求实现此过程</p><pre><code>function 函数（）&#123;//1.0创建异步对象var xhr =new XMLHttpRequest();//2.绑定事件xhr.onreadystatechange=function()&#123;    if(xhr.readyState==4&amp;&amp;xhr.status==20)&#123;    //获取数据    var data =xhr.responseText；    //更新dom    .......获取数据绑定到标签上面    &#125;&#125;    //3.初始化请求参数    //queryNameproid=1    xhr.open（”get“，URL，true）；        //4.发起请求    xhr.send；&#125;function 函数（）&#123;//1.0创建异步对象var xhr =new XMLHttpRequest();//2.绑定事件xhr.onreadystatechange=function()&#123;    if(xhr.readyState==4&amp;&amp;xhr.status==20)&#123;    //获取数据    var data =xhr.responseText；    //返回对象如果是json格式那么需要去转换个格式    var obj=json.parse(data);    //更新dom    .......获取数据绑定到标签上面    &#125;&#125;    //3.初始化请求参数    //queryNameproid=1    xhr.open（”get“，URL，true）；        //4.发起请求    xhr.send；&#125;</code></pre><h1 id="第一章-Ajax-前端技术"><a href="#第一章-Ajax-前端技术" class="headerlink" title="第一章 Ajax 前端技术"></a>第一章 Ajax 前端技术</h1><p>前端技术： 在浏览器中执行的程序都是前端， html ， css，js等等</p><p>后端技术：在服务器中执行的程序， 使用java语言开发的后端程序。 servlet,jsp, jdbc,mysql,tomcat等等</p><h1 id="1-全局刷新和局部刷新"><a href="#1-全局刷新和局部刷新" class="headerlink" title="1 全局刷新和局部刷新"></a>1 全局刷新和局部刷新</h1><p>1）全局刷新： 使用form， href等发起的请求是全局刷新。</p><p> 用户发起请求， 视图改变了， 跳转视图，使用新的数据添加到页面。</p><p>缺点：</p><pre><code> 1. 传递数据量比较大。 占用网络的带宽    2. 浏览器需要重新的渲染整个页面。     3. 用户的体验不是那么好</code></pre><p>2）局部刷新： 在当前页面中，发起请求，获取数据，更新当前页面的dom对象。 对视图部分刷新。</p><p> 特点：</p><pre><code> 1. 数量比较小， 在网络中传输速度快。    2. 更新页面内容， 是部分更新页面， 浏览器不用全部渲染视图。    3. 在一个页面中，可以做多个 局部刷新    4. 从服务器获取的是数据， 拿到更新视图</code></pre><h1 id="2-异步请求对象"><a href="#2-异步请求对象" class="headerlink" title="2 异步请求对象"></a>2 异步请求对象</h1><p>在局部刷新中，使用异步请求对象，在浏览器内部发起请求，获取数据。</p><p><a href="file:///E:/BaiduNetdiskDownload/HTML+css+JavaScript资料/06-笔记/Ajax/images/image-20201012092218113.png"><img src="file:///E:/BaiduNetdiskDownload/HTML+css+JavaScript%E8%B5%84%E6%96%99/06-%E7%AC%94%E8%AE%B0/Ajax/images/image-20201012092218113.png" alt="image-20201012092218113"></a></p><p>异步对象是在浏览器内部的一种 javascript对象。 各大浏览器都能支持异步对象的使用。chrome ,firework, ie, opper ,</p><p>异步对象 XMLHttpRequest</p><h1 id="3-异步对象XMLHttpRequest介绍"><a href="#3-异步对象XMLHttpRequest介绍" class="headerlink" title="3. 异步对象XMLHttpRequest介绍"></a>3. 异步对象XMLHttpRequest介绍</h1><p>js中的一种对象， 使用js语法创建和使用这个对象。</p><p>var xhr &#x3D; new XMLHttpRequest();</p><p>之后就可以 使用xhr对象的属性或者函数，进行异步对象的操作。</p><p>使用异步对象实现局部刷新， 异步对象主要负责发起请求，传递请求的参数，并从服务器接收数据。</p><p>局部刷新需要使用那些技术：</p><p>1）javascript ： 创建XMLHttpRequest对象， 调用它的属性或者方法</p><p>2）dom：处理dom，更新select的数据</p><p>3）css: 处理视图， 更新，美化。</p><p>4）servlet：服务器端技术</p><p>5）数据格式：json。 它之前是xml</p><p>把上面这些技术的综合使用叫做ajax（阿贾克斯）。</p><h1 id="4-Ajax"><a href="#4-Ajax" class="headerlink" title="4 Ajax"></a>4 Ajax</h1><p>AJAX &#x3D; Asynchronous JavaScript and XML（异步的 JavaScript 和XML）。<br>AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分页面内容的新方法</p><p>AJAX不是新的编程语言，它是多种技术的综合使用。 包含了javascript, dom</p><p>,css, 服务器端技术， servlet ，jsp ，jdbc等等， 还有 json数据格式。</p><p>使用AJAX实现局部刷新。</p><p>Ajax核心是 javascript 和 xml （json）：使用javascript操作异步对象XMLHttpRequest. 和服务器交换使用json数据格式。</p><h1 id="5-异步对象XMLHttpRequest属性和方法"><a href="#5-异步对象XMLHttpRequest属性和方法" class="headerlink" title="5. 异步对象XMLHttpRequest属性和方法"></a>5. 异步对象XMLHttpRequest属性和方法</h1><ol><li><p>创建异步对象，使用js的语法</p><p>var xhr &#x3D; new XMLHttpRequest();</p></li><li><p>XMLHttpRequest方法</p><p>①）open(请求方式, 服务器端的访问地址，异步还是同步)</p><p>例如：xhr.open(“get”,”loginServlet”,true);</p><p>②）send(): 使用异步对象发送请求</p></li><li><p>XMLHttpRequest属性</p><p>readyState属性：请求的状态</p><p> 0：表示创建异步对象时，new XMLHttpRequest();</p><p> 1：表示初始异步对象的请求参数。 执行open()方法</p><p> 2：使用send()方法发送请求。</p><p> 3：使用异步对象从服务器接收了数据</p><p> 4：异步对象接收了数据，并在异步对象内部处理完成后。</p><p>status属性：网络的状态，和Http的状态码对应</p><p> 200：请求成功</p><p> 404： 服务器资源没有找到</p><p> 500： 服务器内部代码有错误</p><p>responseText属性：表示服务器端返回的数据</p><p> 例如： var data &#x3D; xhr.responseText;</p></li></ol><h1 id="6-异步对象XMLHttpRequest使用步骤"><a href="#6-异步对象XMLHttpRequest使用步骤" class="headerlink" title="6. 异步对象XMLHttpRequest使用步骤"></a>6. 异步对象XMLHttpRequest使用步骤</h1><p>1）使用js创建异步对象</p><p> var xhr &#x3D; new XMLHttpRequest();</p><p>2)给异步对象绑定事件。事件名称 onreadystatechange</p><p>例如button增加单击事件 onclick</p><p>xhr绑定事件</p><p>xhr.onreadysatechange&#x3D;function() { 当事件发生时执行的代码 }</p><pre><code>&lt;input type=&quot;button&quot; onclick=&quot;btnClick()&quot; /&gt;&lt;script type=&quot;text/javascript&quot;&gt;    function btnClick()&#123;       按钮单击的处理代码         &#125;&lt;/script&gt;</code></pre><p>在绑定事件中做什么，根据readyState值做请求的处理</p><pre><code>xhr.readystatechagne=function()&#123;   if( xhr.readyState==4 &amp;&amp; xhr.status==200 )&#123;        从服务器获取了数据， 更新当前页面的dom对象，完成请求的处理        var data = xhr.responseText;        更新dom对象        document.getElementById(&quot;#mydiv&quot;).innertHTML = data;   &#125;&#125;</code></pre><ol><li><p>初始请求的参数，执行open()函数</p><p>xhr.open(“get”,”loginServlet”,true)</p></li></ol><p>4)发送请求，执行send()</p><p>xhr.send()</p><h1 id="7-第一个例子"><a href="#7-第一个例子" class="headerlink" title="7. 第一个例子"></a>7. 第一个例子</h1><p>使用全局刷新， 实现计算bmi</p><p>可以使用jsp显示request作用域中的数据，使用el表达式</p><p>也可以使用HttpServletResponse对象输出数据， 数据给了浏览器。 浏览器可以接收HttpServletResponse对象print的数据</p><h1 id="8-同步请求和异步请求"><a href="#8-同步请求和异步请求" class="headerlink" title="8 同步请求和异步请求"></a>8 同步请求和异步请求</h1><p>看open(请求方式， 访问uri地址，boolean是不是异步的)</p><p>true：异步请求</p><p>false：同步请求</p><h1 id="第二章-jQuery"><a href="#第二章-jQuery" class="headerlink" title="第二章 jQuery"></a>第二章 jQuery</h1><ol><li><p>jquery的介绍</p><p>jquery就是js函数库， 里面有大量的js函数， 使用这些函数操作dom对象， 做事件，动画， ajax处理</p><p>地址： <a href="https://jquery.com/">https://jquery.com/</a></p></li><li><p>下载</p><p>下载地址：<a href="https://jquery.com/download/">https://jquery.com/download/</a></p><p>压缩版本： 文件体积比较小，适合项目上线后使用。 jquery-3.4.1.min.js</p><p>未压缩：体积比较大，可读性比较好，适合开发阶段使用 jquery-3.4.1.js</p></li></ol><h2 id="2-1-使用jquery"><a href="#2-1-使用jquery" class="headerlink" title="2.1 使用jquery"></a>2.1 使用jquery</h2><p>步骤：</p><ol><li><p>需要在你的项目中加入jquery的文件， idea中是把jquery放在webapp目录。一般是创建一个js目录。存放js文件的。 对于hbuilder工具， 放在项目的js目录中就可以了</p></li><li><p>创建一个html文件或者jsp都可以， 在文件中使用</p><pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;jquery的文件的相对路径&quot; /&gt; 这样是不行的&lt;script type=&quot;text/javascript&quot; src=&quot;jquery的文件的相对路径&quot; /&gt;&lt;/script&gt;这样是可以的</code></pre></li><li><p>在js代码中，调用jquery中函数</p></li></ol><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;第一个jquery例子&lt;/title&gt;        &lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-3.4.1.js&quot;&gt;&lt;/script&gt;        &lt;script type=&quot;text/javascript&quot;&gt;                        /*              $:jquery中的函数名              document:是参数              $(document): 把js中的document对象变成jquery可以使用的对象。                           然后调用ready()的函数。 这个ready()是jquery中的函数                                                      ready()的执行时间在页面dom对象加载后执行的。相当于js中onload事件                                  ready(函数):表示在页面对象加载后执行 这个函数            */            /* $(document).ready(function()&#123;                alert(&quot;使用jquery了&quot;)            &#125;) */                        /* $(document).ready( myinit() )            function myinit()&#123;                alert(&quot;====相当于onload==&quot;)            &#125; */                        //jquery提供了简单方式,使用ready()            //$(  参数是一个函数 )            $( function()&#123;                alert(&quot;简单的方式使用ready&quot;)            &#125; )                    &lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="2-2-对象的分类"><a href="#2-2-对象的分类" class="headerlink" title="2.2 对象的分类"></a>2.2 对象的分类</h2><p>dom对象和jquery对象。 在一个文件中同时存在两种对象</p><p>dom对象： 使用js的代码获取，创建的对象。 html中的对象都是dom对象。</p><p>jquery对象： 使用jquery获取获取的对象。</p><p>为什么要使用dom对象，还有jquery对象？</p><p>目的是要dom对象的函数或者属性， 以及使用使用jquery中提供的函数或者属性。</p><p>要 dom中的内容就需要使用dom对象， 要使用jquery函数库中的函数需要使用jquery对象。</p><p>dom对象和jquery对象可以相互转换的</p><h3 id="2-2-1-dom对象转为jquery对象。"><a href="#2-2-1-dom对象转为jquery对象。" class="headerlink" title="2.2.1. dom对象转为jquery对象。"></a>2.2.1. dom对象转为jquery对象。</h3><p>语法： $( dom对象 ) 得到的是一个jquery对象， 可以调用jquery中提供的函数</p><pre><code>&lt;input type=&quot;text&quot; id=&quot;t1&quot; /&gt;//通过js的函数，获取dom对象var dom= document.getElementById(&quot;t1&quot;);//把dom转为jqueryvar jqueryObj = $(dom);//调用jquery中的函数jqueryObject.val();//获取dom对象的value属性的值提示：为了区分dom对象和jquery对象，可以在jquery对象变量名上，加一个$ , 例如 $obj </code></pre><h3 id="2-2-2-jquery对象转为dom对象。"><a href="#2-2-2-jquery对象转为dom对象。" class="headerlink" title="2.2.2 jquery对象转为dom对象。"></a>2.2.2 jquery对象转为dom对象。</h3><p>语法： jquery对象是一个数组， 数组成员是dom对象。 使用 [下标] 或 get(下标)</p><pre><code>&lt;input type=&quot;text&quot; id=&quot;txt1&quot;/&gt;使用jquery的方式表示这个dom对象$(&quot;#txt1&quot;):获取id是txt1的dom对象。 var  obj = $(&quot;#txt1&quot;); //obj是一个jquery对象，是一个包含了一个成员的dom数组。  obj[0]就是dom对象var dom = obj[0]; 或者 obj.get(0)//使用dom对象的函数或者属性alert(dom.value)</code></pre><h2 id="2-3-选择器"><a href="#2-3-选择器" class="headerlink" title="2.3 选择器"></a>2.3 选择器</h2><p>什么是选择器： 选择器就是一个字符串， 是一个定位dom对象的字符串。 使用这个字符串作为条件定位dom对象。 可以使用 id ，class样式名称， 标签名称等作为选择器使用，定位dom对象</p><h3 id="2-3-1-基本选择器"><a href="#2-3-1-基本选择器" class="headerlink" title="2.3.1 基本选择器"></a>2.3.1 基本选择器</h3><p>使用dom对象的id， class名称， 标签名称等作为条件定位dom对象。</p><ol><li><p>使用dom对象的id作为条件</p><p>语法： $(“#id”) document.getElementById(“id”)</p></li><li><p>class选择器，使用对象的class名称定位dom对象</p><p>语法：$(“.class名称”) document.getElementsByClassName()</p></li><li><p>标签选择器，使用标签名称作为条件定位dom对象</p><p>语法：$(“标签名称”) document.getElementsByTagName()</p></li><li><p>所有选择器</p><p>语法： $(“*”)</p></li><li><p>组合选择器</p><p>语法：$(“#id,.class,标签名称”)</p><p>组合选择器使用 id 或者class名称或者标签名称定位dom对象， id，class，标签名称可以任意组合。</p></li></ol><h3 id="2-3-2-表单选择器"><a href="#2-3-2-表单选择器" class="headerlink" title="2.3.2 表单选择器"></a>2.3.2 表单选择器</h3><p>表单选择器使用 dom对象的type属性值定位dom对象的， 和form标签无关。</p><p>语法： $(“:type属性值”)</p><p>例如：</p><pre><code>&lt;input type=&quot;text&quot; /&gt;&lt;input type=&quot;text&quot; /&gt;    使用表单选择器： $(&quot;:text&quot;)</code></pre><h2 id="2-4-过滤器"><a href="#2-4-过滤器" class="headerlink" title="2.4 过滤器"></a>2.4 过滤器</h2><p>过滤器是一个字符串，用了筛选dom对象的， 过滤器是和选择器一起使用的。 在选择了dom对象后，在进行过滤筛选。</p><h3 id="2-4-1-基本过滤器"><a href="#2-4-1-基本过滤器" class="headerlink" title="2.4.1 基本过滤器"></a>2.4.1 基本过滤器</h3><p>使用dom对象在数组中的位置，作为过滤条件的。</p><p>1）选择数组中第一个dom成员</p><p>语法：$(“选择器:first”)</p><ol><li>选择数组中最后一个成员</li></ol><p>语法：$(“选择器:last”)</p><ol><li>选择等于指定下标的dom成员</li></ol><p>语法：$(“选择器:eq(下标)”)</p><p>4）选择大于某个下标的所有成员</p><p>语法：$(“选择器:gt(下标)”)</p><p>5）选择小于某个下标的所有成员</p><p>语法：$(“选择器:lt(下标)”)</p><h3 id="2-4-2-表单过滤器"><a href="#2-4-2-表单过滤器" class="headerlink" title="2.4.2 表单过滤器"></a>2.4.2 表单过滤器</h3><p>根据对象的状态作为条件，筛选dom对象</p><p>1）获取可用的文本框</p><p>语法：$(“:text:enabled”)</p><ol><li>获取不可用的文本框</li></ol><p>语法： $(“:text:disabled”)</p><p>3）获取选中的复选框</p><p>语法：$(“:checkbox:checked”)</p><ol><li>获取选中下拉列表框</li></ol><p>语法： $(“选择器 &gt; option:selected”)</p><pre><code>&lt;select id=&quot;lang&quot;&gt;    &lt;option value=&quot;java&quot;&gt;java&lt;/option&gt;    &lt;option value=&quot;sql&quot;&gt;sql&lt;/option&gt;&lt;/select&gt;</code></pre><h2 id="2-5-函数"><a href="#2-5-函数" class="headerlink" title="2.5 函数"></a>2.5 函数</h2><h3 id="2-5-1-第一组函数"><a href="#2-5-1-第一组函数" class="headerlink" title="2.5.1 第一组函数"></a>2.5.1 第一组函数</h3><p>1）val()：操作dom对象的value值</p><p>val(): 没有参数， 获取dom数组中第一个dom对象的value值</p><p>val(参数)： 有参数， 给dom数组中所有dom对象的value属性赋值</p><p>2）text() : 操作标签的文本内容，标签开始和结束之间的内容</p><p>text(): 没有参数， 把dom数组中所有dom对象的文本内容链接起来，形成一个字符串，并返回这个这个字符串。</p><p>text(参数)：给dom数组中的所有成员统一赋予新的文本</p><p>3）attr(): 操作value ，文本以外的属性时。</p><p>attr(“属性名”)：获取dom数组中第一个dom成员的此属性值</p><p>attr(“属性名”,”属性值”)：给dom数组中所有dom成员此属性赋值</p><h3 id="2-5-2-第二组函数"><a href="#2-5-2-第二组函数" class="headerlink" title="2.5.2 第二组函数"></a>2.5.2 第二组函数</h3><p>1） remove()</p><p>删除选择的dom对象和他的子对象</p><p>语法： $(”选择器“).remove()</p><p>2） empty()</p><p>删除dom对象的子对象</p><p>语法： $(“选择器”).empty()</p><ol><li>append()</li></ol><p>给dom对象在他的后面增加新的dom对象</p><p>语法： $(“选择器”).append( 子dom 对象 )</p><ol><li>html()</li></ol><p>html(): 获取dom数组中第一个dom对象的文本值（ html()返回结果相当于innertHTML ）</p><p>html(参数)：给dom数组中所有成员设置新的文本内容。 （html()返回结果相当于innertHTML ）</p><p>5)each()</p><p>each是循环函数， 可以循环数组， json ， dom对象数组</p><p>① $.each( 要循环的内容， function(index,element ){ 处理函数} )</p><p>要循环的内容: 可以是数组， json对象， dom对象数组。</p><p>function： 循环的处理函数， 每个成员都会执行函数一次。</p><p> index：是循环变量的值， 名称自定义</p><p> element： 和index对应的成员， element名称是自定义的</p><p>例如</p><p>doArrayContent： function(index,element ){ 处理函数} )</p><p>② $(“选择器”).each(function(index,element){ 处理函数} )</p><p>可以对jquery对象进行循环处理。 jquery对象就是dom数组</p><h2 id="2-6-事件"><a href="#2-6-事件" class="headerlink" title="2.6 事件"></a>2.6 事件</h2><p>jquery可以给dom对象绑定事件，在程序执行期间动态的处理事件</p><h3 id="2-6-1-第一种事件绑定语法"><a href="#2-6-1-第一种事件绑定语法" class="headerlink" title="2.6.1 第一种事件绑定语法"></a>2.6.1 第一种事件绑定语法</h3><p>语法： $(“选择器”).事件名称(事件的处理函数)</p><p>$(“选择器”)：选择0或多个dom对象。给他们绑定事件</p><p>事件名称： 就是js中的 去掉on的部分。 例如单击事件onclick, 这里的事件名称就是 click</p><p>事件的处理函数: 函数定义， 当事件发生时，执行这个函数。</p><pre><code>例如：&lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;绑定事件&quot;/&gt; 绑定事件$(&quot;#btn&quot;).click( function()&#123; 单击的处理代码 &#125; )$(&quot;:button&quot;).click(function()&#123; 单击处理代码&#125;)&lt;script type=&quot;text/javascript&quot;&gt;                        $(function()&#123;                //页面dom对象加载后执行, 相当于onload事件                //绑定事件                $(&quot;#btn&quot;).click(function()&#123;                    alert(&quot;==button单击了，执行处理函数==&quot;)                &#125;)            &#125;)                            &lt;/script&gt;&lt;body&gt;    &lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;绑定事件&quot; /&gt;&lt;br/&gt;&lt;/body&gt;</code></pre><h3 id="2-6-2-第二种事件绑定方式，-on"><a href="#2-6-2-第二种事件绑定方式，-on" class="headerlink" title="2.6.2 第二种事件绑定方式， on"></a>2.6.2 第二种事件绑定方式， on</h3><p>语法： $(“选择器”).on( 事件名称, function(){事件处理函数})</p><p>事件： 就是js中去掉on的部分。</p><p>function： 事件处理函数</p><pre><code>&lt;body&gt;    &lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;绑定事件&quot; /&gt;&lt;br/&gt;&lt;/body&gt;&lt;script&gt;    $(&quot;#btn&quot;).on(&quot;click&quot;,function()&#123; alert(&quot;按钮单击了&quot;)&#125;)&lt;/script&gt;        </code></pre><h2 id="2-7-Ajax"><a href="#2-7-Ajax" class="headerlink" title="2.7 Ajax"></a>2.7 Ajax</h2><p>使用jquery提供的函数实现ajax请求的处理。 代替直接使用XMLHttpRequest. 但是jquery实际还是使用的异步对象。</p><h3 id="2-7-1-ajax-核心的函数"><a href="#2-7-1-ajax-核心的函数" class="headerlink" title="2.7.1 $.ajax() 核心的函数"></a>2.7.1 $.ajax() 核心的函数</h3><p>语法： $.ajax( { json格式的参数} )</p><p>json格式的参数：key是定义好的， 需要开发人员给key赋值。 这些key是用来表示ajax请求必须的参数</p><p>例如，请求的uri地址， 是不是异步请求， 请求的方式等等。</p><pre><code>$.ajax(  &#123;      url:&quot;queryProvinceServlet&quot;,      type:&quot;get&quot;,      data:&#123;&quot;name&quot;:&quot;李四&quot;,&quot;age&quot;:20&#125;,      dataType:&quot;json&quot;,      success:function(resp) &#123; 开发人员获取数据，更新dom对象 &#125;,      error:function()&#123; alert(&quot;请求错误&quot;)&#125;  &#125;)</code></pre><p>url：服务器的地址，例如某个servlet的访问地址。 queryProvinceServlet</p><p>type:表示请求的方式，get，post。 默认是get。 这个值不用区分大小写</p><p>data：表示提交的请求参数。 可以是string， 数组， json类型的。 推荐使用json格式。</p><p> 例如： data: {“name”:”李四”,”age”:20}</p><p> jquery在发送请求时，会把json中的key作为请求的参数使用， key对应的值作为参数数据。</p><p> 转为的结果： <a href="http://localhost:8080/myweb/queryProvinceServlet?name=%E6%9D%8E%E5%9B%9B&age=20">http://localhost:8080/myweb/queryProvinceServlet?name=李四&amp;age=20</a></p><p>dataType: 数据格式， 可以是 html， text ， xml ，json等等。 表示发起请求后，希望服务器端返回的数据格式。 jquery可以尝试使用对应格式处理返回的数据。 比如你指定了 dataType:json,表示希望服务器返回的是json格式数据。 然后jquery把json数据转为json对象。服务器代码可以获取到 dataType的内容。</p><p> 例如： 请求中 dataType:”json”, jquery发起请求后，</p><p> 在请求头中 Accept: application&#x2F;json, text&#x2F;javascript, <em>&#x2F;</em>; q&#x3D;0.01</p><p> 如果dataType:”text”, 请求中</p><p> Accept: text&#x2F;plain, <em>&#x2F;</em>; q&#x3D;0.01</p><p>success: 函数function。 当服务器端返回了数据，jquery处理完数据后，执行这个函数。 等同于异步对象的 readyState&#x3D;&#x3D;4 $$ status&#x3D;200的情况</p><p> 例如： success:function( data){ 开发人员处理服务器返回的数据 }</p><p> data是自定义形参， 相当于 data&#x3D; xhr.responseText</p><p>error:function(), 当请求错误时，执行这个函数。</p><p>contentType:表示请求的参数数据格式。例如 application&#x2F;json , 这个内容可以不写。</p><p>async: 是一个boolean表示请求是同步的还是异步的。 true是异步的，默认是true； false同步的.</p><h3 id="2-7-2-get"><a href="#2-7-2-get" class="headerlink" title="2.7.2 $.get()"></a>2.7.2 $.get()</h3><p>$.get()这个函数就是执行get请求方式的ajax</p><p>语法： $.get(url, 请求参数， success函数， dataType)</p><p>例如：</p><pre><code>$.get(&quot;queryName&quot;,&#123;&quot;proid&quot;:1&#125;, function(resp)&#123; 获取省份名称 &#125;, &quot;text&quot;)</code></pre><h3 id="2-7-3-post"><a href="#2-7-3-post" class="headerlink" title="2.7.3 $.post()"></a>2.7.3 $.post()</h3><p>$.post() 执行post请求的ajax。</p><p>语法： $.post(url, 请求参数， success函数， dataType)</p><p>例如：</p><pre><code>$.post(&quot;queryName&quot;,&#123;&quot;proid&quot;:1&#125;, function(resp)&#123; 获取省份名称 &#125;, &quot;text&quot;)</code></pre><h2 id="2-8-级联查询"><a href="#2-8-级联查询" class="headerlink" title="2.8 级联查询"></a>2.8 级联查询</h2><p>思路：有两个数据库的查询 1： 查询所有的省份名称和id ； 2 根据提交的省份id ，查询city表，得到城市列表</p><p> 有两个servlet接收请求， 一个查询所有的省份 ；一个是接收省份id的参数，查询省份对应的城市列表。</p><p> 数据格式使用 json</p><p> 发起请求使用 $.ajax, $.get, $.post</p><p> 事件： onChange()</p><p>实现步骤：</p><p>1.数据表province( 获取全部的id和name列的值)，</p><p>city表根据provinceid的值，得到id，name列</p><p>2.创建web应用。 加入mysql驱动的jar 和jackson的jar</p><p>3.创建实体类， Province , City</p><p>4.创建Dao类， QueryDao类，有两个方法</p><p>5.创建Servlet， 两个servlet ，一个是查询所有的省份名称， 一个是查询城市列表</p><p>6.创建jsp， 发起两个ajax请求。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>VUE学习</title>
      <link href="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="vue学习"><a href="#vue学习" class="headerlink" title="vue学习"></a>vue学习</h1><p>要求： 使用数据需要存在</p><p>​不能再插值表达式中使用关键字等语句</p><p>​不能再标签中使用插值表达式</p><pre><code class="vue">&lt;div id=&quot;app&quot;&gt;        &lt;!-- 编写一些用于渲染的代码逻辑 --&gt;        &#123;&#123;name+name&#125;&#125;        &#123;&#123;name.toUpperCase()&#125;&#125;    &lt;/div&gt;    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.7.14/dist/vue.js&quot;&gt;&lt;/script&gt;    &lt;script&gt;        const app=new Vue(            &#123;                el: &#39;#app&#39;,                data: &#123;                    //这个数据是响应式数据                    name: &#39;tony&#39;                &#125;            &#125;        )    &lt;/script&gt;</code></pre><p>VUE中数据改变页面中的渲染也会改变</p><p>VUE中的特点响应式显示</p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230717203822221.png" alt="image-20230717203822221"></p><h4 id="VUE的指令操作"><a href="#VUE的指令操作" class="headerlink" title="VUE的指令操作"></a>VUE的指令操作</h4><p>V-HTML ：可以替换 document.innerHtml 可以解析html语句并且展示到标签内容</p><p>v-show </p><p>1.控制元素隐藏</p><p>2.语法：v-show&#x3D;”表达式” 表达式的值 true显示 ，false 隐藏</p><p>实际上是控制标签的display：none来控制内容是否显示 是显示与不显示的问题</p><p>频繁操作的页面用</p><p>v-if </p><p>1.控制元素隐藏(条件渲染)</p><p>2.语法 v-if&#x3D;”表达式“ 表达式值 true显示，false 隐藏</p><p>实际上是控制判断条件决定是否创建标签 是存在与不存在的问题</p><p> 不经常操作的用v-if</p><p>v-else v-else-if</p><p>1.作用：辅助v-if 进行判断渲染</p><p>2.语法：v-else v-else-if&#x3D;”表达式“</p><p>3.注意：需要紧挨着v-if一起使用</p><p>ag</p><pre><code class="vue">               &lt;div&gt;                &lt;div v-if=&quot;score &gt;= 90&quot;&gt;优秀&lt;/div&gt;                &lt;div v-else-if=&quot;score &gt;= 70&quot;&gt;普通&lt;/div&gt;                &lt;div v-else-if=&quot;score &gt;= 60&quot;&gt;及格&lt;/div&gt;                &lt;div v-else&gt;成绩过低建议重开&lt;/div&gt;              &lt;/div&gt;</code></pre><p>v-on</p><p>1.作用：注册时间&#x3D;添加监听+提供处理逻辑</p><p>2.语法：</p><p>1.v-on：事件名&#x3D;”内敛语句”</p><p>v-on:&#x3D;&#x3D;@</p><pre><code class="vue">           &lt;button v-on:click=&quot;count--&quot;&gt;-&lt;/button&gt;           &lt;span&gt;&#123;&#123;count&#125;&#125;&lt;/span&gt;             &lt;button v-on:click=&quot;count++&quot;&gt;+&lt;/button&gt;            &lt;button @click=&quot;count--&quot;&gt;-&lt;/button&gt;           &lt;span&gt;&#123;&#123;count&#125;&#125;&lt;/span&gt;             &lt;button @click=&quot;count++&quot;&gt;+&lt;/button&gt;  </code></pre><p>2.v-on：时间名&#x3D;”methods中的函数名字“</p><pre><code class="vue">  &lt;/div&gt;      &lt;button @click=&quot;fn&quot;&gt;显示or隐藏&lt;/button&gt;    &lt;h1 v-show=&quot;flag&quot;&gt;黑马程序员&lt;/h1&gt;    &lt;/div&gt;          methods:                  &#123;                    fn()&#123;                        this.flag=!this.flag;                    &#125;                &#125;</code></pre><p>v-on调用传参数</p><p>v-bind：属性名&#x3D;“表达式”</p><p>1.作用：动态的设置html的标签属性-》 src url title ….</p><p>2.语法： v-bind:属性名&#x3D;“表达式”</p><p>可以将v-bind改写成：</p><pre><code class="vue">    &lt;img v-bind:src=&quot;imgurl&quot; alt=&quot;&quot;&gt; tup&lt;/img&gt;</code></pre><p>v-for</p><p>v-for&#x3D;”(item,index) in 数组”</p><p>item 每一项，index 下标</p><pre><code class="vue"> &lt;ul&gt;      &lt;li v-for=&quot;(item, index) in booksList&quot;                                     :key=&quot;item.id&quot;&gt;        &lt;span&gt;&#123;&#123; item.name &#125;&#125;&lt;/span&gt;        &lt;span&gt;&#123;&#123; item.author &#125;&#125;&lt;/span&gt;        &lt;!-- 注册点击事件 →  通过 id 进行删除数组中的 对应项 --&gt;        &lt;button @click=&quot;del(item.id)&quot;&gt;删除&lt;/button&gt;      &lt;/li&gt;    &lt;/ul&gt; &lt;script&gt;    const app = new Vue(&#123;      el: &#39;#app&#39;,      data: &#123;        booksList: [          &#123; id: 1, name: &#39;《红楼梦》&#39;, author: &#39;曹雪芹&#39; &#125;,          &#123; id: 2, name: &#39;《西游记》&#39;, author: &#39;吴承恩&#39; &#125;,          &#123; id: 3, name: &#39;《水浒传》&#39;, author: &#39;施耐庵&#39; &#125;,          &#123; id: 4, name: &#39;《三国演义》&#39;, author: &#39;罗贯中&#39; &#125;        ]      &#125;,      methods: &#123;        del (id) &#123;          // console.log(&#39;删除&#39;, id)          // 通过 id 进行删除数组中的 对应项 → filter(不会改变原数组)          // filter: 根据条件，保留满足条件的对应项，得到一个新数组。          // console.log(this.booksList.filter(item =&gt; item.id !== id))          this.booksList = this.booksList.filter(item =&gt; item.id !== id)        &#125;      &#125;    &#125;)  &lt;/script&gt;</code></pre><p>v-model</p><p>1.作用：给表单元素使用，双向的绑定 –&gt;可以快速获取或者设置表单内容</p><p>v-model&#x3D;”变量”</p><p>数据变化 视图自动更新 </p><p>视图变化数据自动更新</p><p>双向绑定</p><pre><code> &lt;div id=&quot;app&quot;&gt;    &lt;!--       v-model 可以让数据和视图，形成双向数据绑定      (1) 数据变化，视图自动更新      (2) 视图变化，数据自动更新      可以快速[获取]或[设置]表单元素的内容     --&gt;    账户：&lt;input type=&quot;text&quot; v-model=&quot;username&quot;&gt; &lt;br&gt;&lt;br&gt;    密码：&lt;input type=&quot;password&quot; v-model=&quot;password&quot;&gt; &lt;br&gt;&lt;br&gt;    &lt;button @click=&quot;login&quot;&gt;登录&lt;/button&gt;    &lt;button @click=&quot;reset&quot;&gt;重置&lt;/button&gt;  &lt;/div&gt;  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt;  &lt;script&gt;    const app = new Vue(&#123;      el: &#39;#app&#39;,      data: &#123;        username: &#39;&#39;,        password: &#39;&#39;      &#125;,      methods: &#123;        login () &#123;          console.log(this.username, this.password)        &#125;,        reset () &#123;          this.username = &#39;&#39;          this.password = &#39;&#39;        &#125;      &#125;    &#125;)  &lt;/script&gt;</code></pre><h4 id="第一个小案例"><a href="#第一个小案例" class="headerlink" title="第一个小案例"></a>第一个小案例</h4><pre><code class="vue">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot; /&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;./index.css&quot; /&gt;&lt;title&gt;记事本&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 主体区域 --&gt;&lt;section id=&quot;app&quot;&gt;  &lt;!-- 输入框 --&gt;  &lt;header class=&quot;header&quot;&gt;    &lt;h1&gt;小黑记事本&lt;/h1&gt;    &lt;input v-model=&quot;todoName&quot; placeholder=&quot;请输入任务&quot; class=&quot;new-todo&quot; /&gt;    &lt;button class=&quot;add&quot; @click=&quot;add()&quot;&gt;添加任务&lt;/button&gt;  &lt;/header&gt;  &lt;!-- 列表区域 --&gt;  &lt;section class=&quot;main&quot;&gt;    &lt;ul class=&quot;todo-list&quot;&gt;      &lt;li class=&quot;todo&quot; v-for=&quot;(item,index) in list&quot; v-bind:key=&quot;list&quot;&gt;        &lt;div class=&quot;view&quot;&gt;          &lt;span class=&quot;index&quot;&gt;&#123;&#123;index+1&#125;&#125;.&lt;/span&gt; &lt;label&gt;&#123;&#123;item.name&#125;&#125;&lt;/label&gt;          &lt;button @click=&quot;del(item.id)&quot; class=&quot;destroy&quot;&gt;删除&lt;/button&gt;        &lt;/div&gt;      &lt;/li&gt;    &lt;/ul&gt;  &lt;/section&gt;  &lt;!-- 统计和清空 --&gt;  &lt;footer class=&quot;footer&quot;&gt;    &lt;!-- 统计 --&gt;    &lt;span class=&quot;todo-count&quot;&gt;合 计:&lt;strong&gt; &#123;&#123;list.length&#125;&#125; &lt;/strong&gt;&lt;/span&gt;    &lt;!-- 清空 --&gt;    &lt;button v-show=&quot;list.length&gt;0&quot; class=&quot;clear-completed&quot; @click=&quot;qk&quot;&gt;      清空任务    &lt;/button&gt;  &lt;/footer&gt;&lt;/section&gt;&lt;!-- 底部 --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt;  const app = new Vue(&#123;    el: &#39;#app&#39;,    data: &#123;      list:[        &#123;id:1,name: &quot;跑步一公里&quot;&#125;,        &#123;id:2,name: &quot;洗澡一小时&quot;&#125;,      ]    &#125;,  methods:&#123;    del(id)&#123;      this.list=this.list.filter(item=&gt;item.id !==id)    &#125;,    add()&#123;      if(this.todoName.trim()===&quot;&quot;)&#123;        alert(&quot;名称不能为空&quot;)        return      &#125;      this.list.unshift(&#123;        id: +new Date(),        name: this.todoName      &#125;)      this.todoName=&quot;&quot;    &#125;,    qk()&#123;      this.list=[]    &#125;  &#125;  &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><pre><code class="css">html,body &#123;  margin: 0;  padding: 0;&#125;body &#123;  background: #fff;&#125;button &#123;  margin: 0;  padding: 0;  border: 0;  background: none;  font-size: 100%;  vertical-align: baseline;  font-family: inherit;  font-weight: inherit;  color: inherit;  -webkit-appearance: none;  appearance: none;  -webkit-font-smoothing: antialiased;  -moz-osx-font-smoothing: grayscale;&#125;body &#123;  font: 14px &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif;  line-height: 1.4em;  background: #f5f5f5;  color: #4d4d4d;  min-width: 230px;  max-width: 550px;  margin: 0 auto;  -webkit-font-smoothing: antialiased;  -moz-osx-font-smoothing: grayscale;  font-weight: 300;&#125;:focus &#123;  outline: 0;&#125;.hidden &#123;  display: none;&#125;#app &#123;  background: #fff;  margin: 180px 0 40px 0;  padding: 15px;  position: relative;  box-shadow: 0 2px 4px 0 rgba(0, 0, 0, 0.2), 0 25px 50px 0 rgba(0, 0, 0, 0.1);&#125;#app .header input &#123;  border: 2px solid rgba(175, 47, 47, 0.8);  border-radius: 10px;&#125;#app .add &#123;  position: absolute;  right: 15px;  top: 15px;  height: 68px;  width: 140px;  text-align: center;  background-color: rgba(175, 47, 47, 0.8);  color: #fff;  cursor: pointer;  font-size: 18px;  border-radius: 0 10px 10px 0;&#125;#app input::-webkit-input-placeholder &#123;  font-style: italic;  font-weight: 300;  color: #e6e6e6;&#125;#app input::-moz-placeholder &#123;  font-style: italic;  font-weight: 300;  color: #e6e6e6;&#125;#app input::input-placeholder &#123;  font-style: italic;  font-weight: 300;  color: gray;&#125;#app h1 &#123;  position: absolute;  top: -120px;  width: 100%;  left: 50%;  transform: translateX(-50%);  font-size: 60px;  font-weight: 100;  text-align: center;  color: rgba(175, 47, 47, 0.8);  -webkit-text-rendering: optimizeLegibility;  -moz-text-rendering: optimizeLegibility;  text-rendering: optimizeLegibility;&#125;.new-todo,.edit &#123;  position: relative;  margin: 0;  width: 100%;  font-size: 24px;  font-family: inherit;  font-weight: inherit;  line-height: 1.4em;  border: 0;  color: inherit;  padding: 6px;  box-shadow: inset 0 -1px 5px 0 rgba(0, 0, 0, 0.2);  box-sizing: border-box;  -webkit-font-smoothing: antialiased;  -moz-osx-font-smoothing: grayscale;&#125;.new-todo &#123;  padding: 16px;  border: none;  background: rgba(0, 0, 0, 0.003);  box-shadow: inset 0 -2px 1px rgba(0, 0, 0, 0.03);&#125;.main &#123;  position: relative;  z-index: 2;&#125;.todo-list &#123;  margin: 0;  padding: 0;  list-style: none;  overflow: hidden;&#125;.todo-list li &#123;  position: relative;  font-size: 24px;  height: 60px;  box-sizing: border-box;  border-bottom: 1px solid #e6e6e6;&#125;.todo-list li:last-child &#123;  border-bottom: none;&#125;.todo-list .view .index &#123;  position: absolute;  color: gray;  left: 10px;  top: 20px;  font-size: 22px;&#125;.todo-list li .toggle &#123;  text-align: center;  width: 40px;  /* auto, since non-WebKit browsers doesn&#39;t support input styling */  height: auto;  position: absolute;  top: 0;  bottom: 0;  margin: auto 0;  border: none; /* Mobile Safari */  -webkit-appearance: none;  appearance: none;&#125;.todo-list li .toggle &#123;  opacity: 0;&#125;.todo-list li .toggle + label &#123;  /*        Firefox requires `#` to be escaped - https://bugzilla.mozilla.org/show_bug.cgi?id=922433        IE and Edge requires *everything* to be escaped to render, so we do that instead of just the `#` - https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/7157459/    */  background-image: url(&#39;data:image/svg+xml;utf8,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2240%22%20height%3D%2240%22%20viewBox%3D%22-10%20-18%20100%20135%22%3E%3Ccircle%20cx%3D%2250%22%20cy%3D%2250%22%20r%3D%2250%22%20fill%3D%22none%22%20stroke%3D%22%23ededed%22%20stroke-width%3D%223%22/%3E%3C/svg%3E&#39;);  background-repeat: no-repeat;  background-position: center left;&#125;.todo-list li .toggle:checked + label &#123;  background-image: url(&#39;data:image/svg+xml;utf8,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2240%22%20height%3D%2240%22%20viewBox%3D%22-10%20-18%20100%20135%22%3E%3Ccircle%20cx%3D%2250%22%20cy%3D%2250%22%20r%3D%2250%22%20fill%3D%22none%22%20stroke%3D%22%23bddad5%22%20stroke-width%3D%223%22/%3E%3Cpath%20fill%3D%22%235dc2af%22%20d%3D%22M72%2025L42%2071%2027%2056l-4%204%2020%2020%2034-52z%22/%3E%3C/svg%3E&#39;);&#125;.todo-list li label &#123;  word-break: break-all;  padding: 15px 15px 15px 60px;  display: block;  line-height: 1.2;  transition: color 0.4s;&#125;.todo-list li.completed label &#123;  color: #d9d9d9;  text-decoration: line-through;&#125;.todo-list li .destroy &#123;  display: none;  position: absolute;  top: 0;  right: 10px;  bottom: 0;  width: 40px;  height: 40px;  margin: auto 0;  font-size: 30px;  color: #cc9a9a;  margin-bottom: 11px;  transition: color 0.2s ease-out;&#125;.todo-list li .destroy:hover &#123;  color: #af5b5e;&#125;.todo-list li .destroy:after &#123;  content: &#39;×&#39;;&#125;.todo-list li:hover .destroy &#123;  display: block;&#125;.todo-list li .edit &#123;  display: none;&#125;.todo-list li.editing:last-child &#123;  margin-bottom: -1px;&#125;.footer &#123;  color: #777;  padding: 10px 15px;  height: 20px;  text-align: center;  border-top: 1px solid #e6e6e6;&#125;.footer:before &#123;  content: &#39;&#39;;  position: absolute;  right: 0;  bottom: 0;  left: 0;  height: 50px;  overflow: hidden;  box-shadow: 0 1px 1px rgba(0, 0, 0, 0.2), 0 8px 0 -3px #f6f6f6,    0 9px 1px -3px rgba(0, 0, 0, 0.2), 0 16px 0 -6px #f6f6f6,    0 17px 2px -6px rgba(0, 0, 0, 0.2);&#125;.todo-count &#123;  float: left;  text-align: left;&#125;.todo-count strong &#123;  font-weight: 300;&#125;.filters &#123;  margin: 0;  padding: 0;  list-style: none;  position: absolute;  right: 0;  left: 0;&#125;.filters li &#123;  display: inline;&#125;.filters li a &#123;  color: inherit;  margin: 3px;  padding: 3px 7px;  text-decoration: none;  border: 1px solid transparent;  border-radius: 3px;&#125;.filters li a:hover &#123;  border-color: rgba(175, 47, 47, 0.1);&#125;.filters li a.selected &#123;  border-color: rgba(175, 47, 47, 0.2);&#125;.clear-completed,html .clear-completed:active &#123;  float: right;  position: relative;  line-height: 20px;  text-decoration: none;  cursor: pointer;&#125;.clear-completed:hover &#123;  text-decoration: underline;&#125;.info &#123;  margin: 50px auto 0;  color: #bfbfbf;  font-size: 15px;  text-shadow: 0 1px 0 rgba(255, 255, 255, 0.5);  text-align: center;&#125;.info p &#123;  line-height: 1;&#125;.info a &#123;  color: inherit;  text-decoration: none;  font-weight: 400;&#125;.info a:hover &#123;  text-decoration: underline;&#125;/*    Hack to remove background from Mobile Safari.    Can&#39;t use it globally since it destroys checkboxes in Firefox*/@media screen and (-webkit-min-device-pixel-ratio: 0) &#123;  .toggle-all,  .todo-list li .toggle &#123;    background: none;  &#125;  .todo-list li .toggle &#123;    height: 40px;  &#125;&#125;@media (max-width: 430px) &#123;  .footer &#123;    height: 50px;  &#125;  .filters &#123;    bottom: 10px;  &#125;&#125;</code></pre><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230718001533335.png" alt="image-20230718001533335"></p><p>@keyup.enter 键盘回车监听</p><p>v-model修饰符</p><p>v-model.trim  -》 取出首尾空格</p><p>v-model.number-》 转数字</p><p>@时间名.stop  -》 阻止冒泡</p><p>@时间名.prevent -》阻止默认行为</p><p>v-bind的样式增强</p><p>对.class操作</p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230718205311938.png" alt="image-20230718205311938"></p><pre><code class="vue"> &lt;div id=&quot;app&quot;&gt;    &lt;ul&gt;      &lt;li v-for=&quot;(item,index) in list&quot;&gt;&lt;a :class=&quot;&#123;active: index===activeIndex&#125;&quot; href=&quot;#&quot; @click=&quot;activeIndex= index&quot;&gt;&#123;&#123;item.name&#125;&#125;&lt;/a&gt;&lt;/li&gt;    &lt;/ul&gt;  &lt;/div&gt;  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt;  &lt;script&gt;    const app = new Vue(&#123;      el: &#39;#app&#39;,      data: &#123;        activeIndex: 0,        list: [          &#123; id: 1, name: &#39;京东秒杀&#39; &#125;,          &#123; id: 2, name: &#39;每日特价&#39; &#125;,          &#123; id: 3, name: &#39;品类秒杀&#39; &#125;        ]      &#125;    &#125;)</code></pre><p>对stytle操作</p><pre><code class="vue">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;Document&lt;/title&gt;  &lt;style&gt;    .progress &#123;      height: 25px;      width: 400px;      border-radius: 15px;      background-color: #272425;      border: 3px solid #272425;      box-sizing: border-box;      margin-bottom: 30px;    &#125;    .inner &#123;      width: 50%;      height: 20px;      border-radius: 10px;      text-align: right;      position: relative;      background-color: #409eff;      background-size: 20px 20px;      box-sizing: border-box;      transition: all 1s;    &#125;    .inner span &#123;      position: absolute;      right: -20px;      bottom: -25px;    &#125;  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;div class=&quot;progress&quot;&gt;      &lt;div :style=&quot;&#123;width: percent+&#39;%&#39;&#125;&quot; class=&quot;inner&quot;&gt;        &lt;span&gt;&#123;&#123;percent+'%'&#125;&#125;&lt;/span&gt;      &lt;/div&gt;    &lt;/div&gt;    &lt;button @click=&quot;setpercent(25)&quot;&gt;设置25%&lt;/button&gt;    &lt;button @click=&quot;setpercent(50)&quot;&gt;设置50%&lt;/button&gt;    &lt;button @click=&quot;setpercent(75)&quot;&gt;设置75%&lt;/button&gt;    &lt;button @click=&quot;setpercent(100)&quot;&gt;设置100%&lt;/button&gt;  &lt;/div&gt;  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt;  &lt;script&gt;    const app = new Vue(&#123;      el: &#39;#app&#39;,      data: &#123;        percent: 30      &#125;,      methods: &#123;        setpercent(x)&#123;            this.percent=x;        &#125;      &#125;    &#125;)  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230718210424696.png" alt="image-20230718210424696"></p><p>v-model在表单其他属性的使用</p><pre><code class="vue"> &lt;div id=&quot;app&quot;&gt;    &lt;h3&gt;小黑学习网&lt;/h3&gt;    姓名：      &lt;input v-model=&quot;username&quot; type=&quot;text&quot;&gt;       &lt;br&gt;&lt;br&gt;    是否单身：      &lt;input type=&quot;checkbox&quot; v-model=&quot;isSingle&quot;&gt;       &lt;br&gt;&lt;br&gt;    &lt;!--       前置理解：        1. name:  给单选框加上 name 属性 可以分组 → 同一组互相会互斥        2. value: 给单选框加上 value 属性，用于提交给后台的数据      结合 Vue 使用 → v-model    --&gt;    性别:       &lt;input v-model=&quot;gender&quot; type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;1&quot;&gt;男      &lt;input v-model=&quot;gender&quot; type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;0&quot;&gt;女      &lt;br&gt;&lt;br&gt;    &lt;!--       前置理解：        1. option 需要设置 value 值，提交给后台        2. select 的 value 值，关联了选中的 option 的 value 值      结合 Vue 使用 → v-model    --&gt;    所在城市:      &lt;select v-model=&quot;cityname&quot;&gt;        &lt;option value=&quot;bj&quot;&gt;北京&lt;/option&gt;        &lt;option value=&quot;sh&quot;&gt;上海&lt;/option&gt;        &lt;option value=&quot;cd&quot;&gt;成都&lt;/option&gt;        &lt;option value=&quot;nj&quot;&gt;南京&lt;/option&gt;      &lt;/select&gt;      &lt;br&gt;&lt;br&gt;    自我描述：      &lt;textarea v-model=&quot;desc&quot;&gt;&lt;/textarea&gt;     &lt;button&gt;立即注册&lt;/button&gt;  &lt;/div&gt;  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt;  &lt;script&gt;    const app = new Vue(&#123;      el: &#39;#app&#39;,      data: &#123;        username: &#39;2314&#39;,        isSingle: false,        gender: 1,        cityname: &#39;sh&#39;,        desc: 264452      &#125;    &#125;)  &lt;/script&gt;</code></pre><p>计算属性</p><h5 id="computed计算属性"><a href="#computed计算属性" class="headerlink" title="computed计算属性"></a>computed计算属性</h5><pre><code>&lt;body&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;h3&gt;小黑的礼物清单&lt;/h3&gt;    &lt;table&gt;      &lt;tr&gt;        &lt;th&gt;名字&lt;/th&gt;        &lt;th&gt;数量&lt;/th&gt;      &lt;/tr&gt;      &lt;tr v-for=&quot;(item, index) in list&quot; :key=&quot;item.id&quot;&gt;        &lt;td&gt;&#123;&#123; item.name &#125;&#125;&lt;/td&gt;        &lt;td&gt;&#123;&#123; item.num &#125;&#125;个&lt;/td&gt;      &lt;/tr&gt;    &lt;/table&gt;    &lt;!-- 目标：统计求和，求得礼物总数 --&gt;    &lt;p&gt;礼物总数：&#123;&#123;totalCount&#125;&#125;个&lt;/p&gt;  &lt;/div&gt;  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt;  &lt;script&gt;    const app = new Vue(&#123;      el: &#39;#app&#39;,      data: &#123;        // 现有的数据        list: [          &#123; id: 1, name: &#39;篮球&#39;, num: 1 &#125;,          &#123; id: 2, name: &#39;玩具&#39;, num: 2 &#125;,          &#123; id: 3, name: &#39;铅笔&#39;, num: 5 &#125;,        ]      &#125;,      computed: &#123;        totalCount()&#123;                      //需求： 对this.list数组里面的num进行求和          let total= this.list.reduce((sum,item)=&gt; sum+item.num,0)          return total;        &#125;      &#125;    &#125;)  &lt;/script&gt;&lt;/body&gt;</code></pre><p>这里面的totalCount只是一个属性 他不是一个函数 只是一个属性 可以直接用 </p><p>另外 reduce（sum，item）&#x3D;》sum +item.num，0</p><pre><code>computed: &#123;        totalCount()&#123;                      //需求： 对this.list数组里面的num进行求和          let total= this.list.reduce((sum,item)=&gt; sum+item.num,0)          return total;        &#125;      &#125;</code></pre><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230718213627406.png" alt="image-20230718213627406"></p><p>计算属性的完整写法</p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230718214407703.png" alt="image-20230718214407703"></p><pre><code class="vue">  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt;  &lt;script&gt;    const app = new Vue(&#123;      el: &#39;#app&#39;,      data: &#123;        fname: &#39;李&#39;,        lname: &#39;99&#39;,      &#125;,      methods: &#123;        changename()&#123;          this.updatename=&#39;吕布&#39;        &#125;      &#125;,      computed: &#123;        updatename:&#123;          get()&#123;            this.fullname=this.fname+this.lname           return this.fullname;          &#125;,          // 当updatename计算属性被修改时 执行set函数 并且          // 这个操作是双向的 但是具体的逻辑是自己实现          set(value)&#123;            this.fname=value.slice(0,1),            this.lname=value.slice(1)          &#125;        &#125;      &#125;,          &#125;)  &lt;/script&gt;</code></pre><p>综合大案例</p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230718224255059.png" alt="image-20230718224255059"></p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230718224323286.png" alt="image-20230718224323286"></p><pre><code class="vue"> &lt;body&gt;    &lt;div id=&quot;app&quot; class=&quot;score-case&quot;&gt;      &lt;div class=&quot;table&quot;&gt;        &lt;table&gt;          &lt;thead&gt;            &lt;tr&gt;              &lt;th&gt;编号&lt;/th&gt;              &lt;th&gt;科目&lt;/th&gt;              &lt;th&gt;成绩&lt;/th&gt;              &lt;th&gt;操作&lt;/th&gt;            &lt;/tr&gt;          &lt;/thead&gt;          &lt;tbody v-if=&quot;list.length&gt;0&quot;&gt;            &lt;tr v-for=&quot;(item,index) in list&quot; :key=&quot;item.id&quot;&gt;              &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt;              &lt;td&gt;&#123;&#123;item.subject&#125;&#125;&lt;/td&gt;              &lt;td :class=&quot;&#123;red: item.score&lt;60&#125;&quot;&gt;&#123;&#123;item.score&#125;&#125;&lt;/td&gt;              &lt;td&gt;&lt;a @click.prevent=&quot;del(item.id)&quot; href=&quot;www.baidu.comwww.baidu.com&quot;&gt;删除&lt;/a&gt;&lt;/td&gt;            &lt;/tr&gt;          &lt;/tbody&gt;          &lt;tbody v-else&gt;            &lt;tr&gt;              &lt;td colspan=&quot;5&quot;&gt;                &lt;span class=&quot;none&quot;&gt;暂无数据&lt;/span&gt;              &lt;/td&gt;            &lt;/tr&gt;          &lt;/tbody&gt;          &lt;tfoot&gt;            &lt;tr&gt;              &lt;td colspan=&quot;5&quot;&gt;                &lt;span&gt;总分：&#123;&#123;totalScore&#125;&#125;&lt;/span&gt;                &lt;span style=&quot;margin-left: 50px&quot;&gt;平均分：&#123;&#123;averageScorce&#125;&#125;&lt;/span&gt;              &lt;/td&gt;            &lt;/tr&gt;          &lt;/tfoot&gt;        &lt;/table&gt;      &lt;/div&gt;      &lt;div class=&quot;form&quot;&gt;        &lt;div class=&quot;form-item&quot;&gt;          &lt;div class=&quot;label&quot;&gt;科目：&lt;/div&gt;          &lt;div class=&quot;input&quot;&gt;            &lt;input               type=&quot;text&quot;              placeholder=&quot;请输入科目&quot;            v-model.trim=&quot;subject&quot; /&gt;          &lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;form-item&quot;&gt;          &lt;div class=&quot;label&quot;&gt;分数：&lt;/div&gt;          &lt;div class=&quot;input&quot;&gt;            &lt;input              type=&quot;text&quot;              placeholder=&quot;请输入分数&quot;             v-model=&quot;score&quot;/&gt;          &lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;form-item&quot;&gt;          &lt;div class=&quot;label&quot;&gt;&lt;/div&gt;          &lt;div class=&quot;input&quot;&gt;            &lt;button class=&quot;submit&quot; @click=&quot;add()&quot; &gt;添加&lt;/button&gt;          &lt;/div&gt;        &lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt;    &lt;script&gt;      const app = new Vue(&#123;        el: &#39;#app&#39;,        data: &#123;          list: [            &#123; id: 1, subject: &#39;语文&#39;, score: 20 &#125;,            &#123; id: 7, subject: &#39;数学&#39;, score: 99 &#125;,            &#123; id: 12, subject: &#39;英语&#39;, score: 70 &#125;,          ],          subject: &#39;&#39;,          score: 0,        &#125;,        methods:&#123;          del(id)&#123;            this.list=this.list.filter(item=&gt; item.id!=id);          &#125;,          add()&#123;            if(!this.subject)&#123;              alert(&quot;请输入科目&quot;);              return            &#125;            if(typeof this.score !==&#39;number&#39;)&#123;              alert(&quot;输入正确的分数&quot;)              return            &#125;            this.list.unshift(&#123;              id: +new Date(),              subject: this.subject,              score: this.score            &#125;)            this.subject=&#39;&#39;,            this.score=&#39;&#39;          &#125;        &#125;,        computed:&#123;          totalScore()&#123;            return this.list.reduce((sum,item)=&gt;sum+item.score,0)          &#125;,          averageScorce()&#123;            if(this.list.length===0)&#123;              return 0;            &#125;              return (this.totalScore/this.list.length).toFixed(2)          &#125;                  &#125;      &#125;)    &lt;/script&gt;</code></pre><p>watch监听器</p><p>监听frutilist数据一旦改变获得最新值</p><pre><code>        watch:&#123;          fruitList:&#123;            deep:true,            handler(newValue)&#123;              localStorage.setItem(&quot;fruit&quot;,JSON.stringify(newValue))            &#125;          &#125;        &#125;</code></pre><h3 id="重要方法"><a href="#重要方法" class="headerlink" title="重要方法"></a>重要方法</h3><p>数组.reduce</p><p>可以实现累加效果</p><pre><code>return this.fruitList.reduce((sum, item) =&gt; sum + item, 0);</code></pre><p>在这里，累加器函数 <code>(sum, item) =&gt; sum + item</code> 将每个元素依次加到累加器 <code>sum</code> 上，最终返回总和。初始值为 0，确保了当 <code>fruitList</code> 为空数组时，也能得到正确的结果。</p><p>array.find 实现找到指定id的数组元素</p><p>你的代码 <code>fruit.num--;</code> 是想要将找到的水果对象的 <code>num</code> 属性减 1。不过，在使用 <code>find</code> 方法找到对象后，需要确保对象存在才能执行减法操作，否则可能会导致错误。</p><pre><code>const fruit = this.fruitList.find(item =&gt; item.id === id);if (fruit) &#123;  fruit.num--;&#125;</code></pre><p>通过添加条件判断，<code>if (fruit)</code> 确保了对象存在时才执行减法操作。这样可以避免在找不到对象时出现错误，确保代码的稳定性。</p><p>数组.filter 可以实现数组元素的删除</p><p>你的代码 <code>this.fruitList = this.fruitList.filter(item =&gt; item.id !== id);</code> 是想要从 <code>fruitList</code> 数组中移除指定 <code>id</code> 的水果对象。</p><p><code>filter</code> 方法用于创建一个新数组，其中包含满足指定条件的所有元素。在这里，你可以使用 <code>filter</code> 方法来过滤掉指定 <code>id</code> 的水果对象。</p><p>以下是修正后的代码示例：</p><pre><code>javascriptCopy Codethis.fruitList = this.fruitList.filter(item =&gt; item.id !== id);</code></pre><p>通过使用 <code>filter</code> 方法并指定条件 <code>item.id !== id</code>，我们将筛选出 <code>id</code> 不等于给定值的水果对象，然后将结果赋值给 <code>fruitList</code> 数组。这样就实现了从数组中移除指定 <code>id</code> 的水果对象的操作。</p><h1 id="综合案例购物车"><a href="#综合案例购物车" class="headerlink" title="综合案例购物车"></a>综合案例购物车</h1><p><strong>实现功能</strong></p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230719223605712.png" alt="image-20230719223605712"></p><p>需求</p><p>1.渲染功能</p><p>2.删除功能</p><p>3.修改功能</p><p>4.全选反选</p><p>5.统计选中的总价和总数量</p><p>6.持久化到本地</p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230719223714850.png" alt="image-20230719223714850"></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;./css/inputnumber.css&quot; /&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;./css/index.css&quot; /&gt;    &lt;title&gt;购物车&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div class=&quot;app-container&quot; id=&quot;app&quot;&gt;      &lt;!-- 顶部banner --&gt;      &lt;div class=&quot;banner-box&quot;&gt;&lt;img src=&quot;http://autumnfish.cn/static/fruit.jpg&quot; alt=&quot;&quot; /&gt;&lt;/div&gt;      &lt;!-- 面包屑 --&gt;      &lt;div class=&quot;breadcrumb&quot;&gt;        &lt;span&gt;🏠&lt;/span&gt;        /        &lt;span&gt;购物车&lt;/span&gt;      &lt;/div&gt;      &lt;!-- 购物车主体 --&gt;      &lt;div class=&quot;main&quot; v-if=&quot;fruitList.length&gt;0&quot;&gt;        &lt;div class=&quot;table&quot;&gt;          &lt;!-- 头部 --&gt;          &lt;div class=&quot;thead&quot;&gt;            &lt;div class=&quot;tr&quot;&gt;              &lt;div class=&quot;th&quot;&gt;选中&lt;/div&gt;              &lt;div class=&quot;th th-pic&quot;&gt;图片&lt;/div&gt;              &lt;div class=&quot;th&quot;&gt;单价&lt;/div&gt;              &lt;div class=&quot;th num-th&quot;&gt;个数&lt;/div&gt;              &lt;div class=&quot;th&quot;&gt;小计&lt;/div&gt;              &lt;div class=&quot;th&quot;&gt;操作&lt;/div&gt;            &lt;/div&gt;          &lt;/div&gt;          &lt;!-- 身体 --&gt;          &lt;div class=&quot;tbody&quot;&gt;            &lt;div  v-for=&quot;(item,index) in fruitList&quot; :key=&quot;item.id&quot; class=&quot;tr&quot; :class=&quot;&#123;active: item.isChecked&#125;&quot;&gt;              &lt;div class=&quot;td&quot;&gt;&lt;input type=&quot;checkbox&quot; v-model=&quot;item.isChecked&quot; /&gt;&lt;/div&gt;              &lt;div class=&quot;td&quot;&gt;&lt;img :src=&quot;item.icon&quot; alt=&quot;&quot; /&gt;&lt;/div&gt;              &lt;div class=&quot;td&quot;&gt;&#123;&#123;item.price&#125;&#125;&lt;/div&gt;              &lt;div class=&quot;td&quot;&gt;                &lt;div class=&quot;my-input-number&quot;&gt;                  &lt;button :disabled=&quot;item.num&lt;=1&quot; class=&quot;decrease&quot; @click=&quot;inc(item.id)&quot;&gt; - &lt;/button&gt;                  &lt;span class=&quot;my-input__inner&quot;&gt;&#123;&#123;item.num&#125;&#125;&lt;/span&gt;                  &lt;button class=&quot;increase&quot; @click=&quot;su(item.id)&quot;&gt; + &lt;/button&gt;                &lt;/div&gt;              &lt;/div&gt;              &lt;div class=&quot;td&quot;&gt;&#123;&#123;item.price * item.num&#125;&#125;&lt;/div&gt;              &lt;div class=&quot;td&quot;&gt;&lt;button @click=&quot;del(item.id)&quot;&gt;删除&lt;/button&gt;&lt;/div&gt;            &lt;/div&gt;          &lt;/div&gt;        &lt;/div&gt;        &lt;!-- 底部 --&gt;        &lt;div class=&quot;bottom&quot;&gt;          &lt;!-- 全选 --&gt;          &lt;label class=&quot;check-all&quot; &gt;            &lt;input type=&quot;checkbox&quot; v-model=&quot;isall&quot; /&gt;            全选          &lt;/label&gt;          &lt;div class=&quot;right-box&quot;&gt;            &lt;!-- 所有商品总价 --&gt;            &lt;span class=&quot;price-box&quot;&gt;总价&amp;nbsp;&amp;nbsp;:&amp;nbsp;&amp;nbsp;¥&amp;nbsp;&lt;span class=&quot;price&quot;&gt;&#123;&#123;totalprice&#125;&#125;&lt;/span&gt;&lt;/span&gt;            &lt;!-- 结算按钮 --&gt;            &lt;button class=&quot;pay&quot;&gt;结算( &#123;&#123;totalcount&#125;&#125; )&lt;/button&gt;          &lt;/div&gt;        &lt;/div&gt;      &lt;/div&gt;      &lt;!-- 空车 --&gt;      &lt;div class=&quot;empty&quot; v-else&gt;🛒空空如也&lt;/div&gt;    &lt;/div&gt;    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt;    &lt;script&gt;      const defaltArr= [            &#123;              id: 1,              icon: &#39;http://autumnfish.cn/static/火龙果.png&#39;,              isChecked: true,              num: 2,              price: 6,            &#125;,            &#123;              id: 2,              icon: &#39;http://autumnfish.cn/static/荔枝.png&#39;,              isChecked: false,              num: 7,              price: 20,            &#125;,            &#123;              id: 3,              icon: &#39;http://autumnfish.cn/static/榴莲.png&#39;,              isChecked: false,              num: 3,              price: 40,            &#125;,            &#123;              id: 4,              icon: &#39;http://autumnfish.cn/static/鸭梨.png&#39;,              isChecked: true,              num: 10,              price: 3,            &#125;,            &#123;              id: 5,              icon: &#39;http://autumnfish.cn/static/樱桃.png&#39;,              isChecked: false,              num: 20,              price: 34,            &#125;,          ]      const app = new Vue(&#123;        el: &#39;#app&#39;,        data: &#123;          fruitList: JSON.parse(localStorage.getItem(&#39;fruit&#39;))||defaltArr,        &#125;,        methods:&#123;          del(id)&#123;              this.fruitList=this.fruitList.filter(item=&gt; item.id!==id)          &#125;,          su(id)&#123;            const fruit=this.fruitList.find(item=&gt;item.id===id)            fruit.num++;          &#125;,          inc(id)&#123;            const fruit=this.fruitList.find(iteitem=&gt;item.id===id)            fruit.num--;          &#125;        &#125;,        computed: &#123;          isall:&#123;            get()&#123;            return this.fruitList.every(item=&gt; item.isChecked);          &#125;,          set(value)&#123;            this.fruitList.forEach(item =&gt; item.isChecked= value);          &#125;          &#125;,          totalcount()&#123;            return this.fruitList.reduce((sum,item)=&gt;item.isChecked?item.num+sum:sum=sum,0);          &#125;,          totalprice()&#123;            return this.fruitList.reduce((sum,item)=&gt;item.isChecked?item.num*item.price+sum:sum=sum,0);          &#125;          // isall()&#123;          //   //必须苏哦有的小选择框都选中我们才选中这个-every          //   return this.fruitList.every(item=&gt;item.isChecked)          // &#125;        &#125;,        watch:&#123;          fruitList:&#123;            deep:true,            handler(newValue)&#123;              localStorage.setItem(&quot;fruit&quot;,JSON.stringify(newValue))            &#125;          &#125;        &#125;      &#125;)    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><h1 id="VUE的生命周期"><a href="#VUE的生命周期" class="headerlink" title="VUE的生命周期"></a>VUE的生命周期</h1><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230719224810721.png" alt="image-20230719224810721"></p><p><strong>vue的生命周期函数（钩子函数）</strong></p><pre><code class="vue"> &lt;script&gt;    const app = new Vue(&#123;      el: &#39;#app&#39;,      data: &#123;        count: 100,        title: &#39;计数器&#39;      &#125;,      // 1. 创建阶段（准备数据）      beforeCreate () &#123;        console.log(&#39;beforeCreate 响应式数据准备好之前&#39;, this.count)      &#125;,      created () &#123;        console.log(&#39;created 响应式数据准备好之后&#39;, this.count)        // this.数据名 = 请求回来的数据        // 可以开始发送初始化渲染的请求了      &#125;,      // 2. 挂载阶段（渲染模板）      beforeMount () &#123;        console.log(&#39;beforeMount 模板渲染之前&#39;, document.querySelector(&#39;h3&#39;).innerHTML)      &#125;,      mounted () &#123;        console.log(&#39;mounted 模板渲染之后&#39;, document.querySelector(&#39;h3&#39;).innerHTML)        // 可以开始操作dom了      &#125;,      // 3. 更新阶段(修改数据 → 更新视图)      beforeUpdate () &#123;        console.log(&#39;beforeUpdate 数据修改了，视图还没更新&#39;, document.querySelector(&#39;span&#39;).innerHTML)      &#125;,      updated () &#123;        console.log(&#39;updated 数据修改了，视图已经更新&#39;, document.querySelector(&#39;span&#39;).innerHTML)      &#125;,      // 4. 卸载阶段      beforeDestroy () &#123;        console.log(&#39;beforeDestroy, 卸载前&#39;)        console.log(&#39;清除掉一些Vue以外的资源占用，定时器，延时器...&#39;)      &#125;,      destroyed () &#123;        console.log(&#39;destroyed，卸载后&#39;)      &#125;    &#125;)  &lt;/script&gt;</code></pre><p>此函数是在数据创建完毕</p><p>钩子函数 一般操作数据需要在created（）函数中进行</p><p>此钩子函数是视图渲染完毕</p><p>一般操作mounted中进行dom操作</p><h1 id="VUECLI-工程化构建"><a href="#VUECLI-工程化构建" class="headerlink" title="VUECLI 工程化构建"></a>VUECLI 工程化构建</h1><p>在想要创建的目录下面按着shift 点击右键打开vuecli 创建命令为vue create project </p><p>前提是你已经安装了 npm 和vue 然后 启动项目是npm run server 启动命令可以在在</p><p>package.json下修改</p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230721231242849.png" alt="image-20230721231242849"></p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230720223909148.png" alt="image-20230720223909148"></p><p><strong>工程化页面不在index.html下写代码</strong></p><p>index只是容器功能  App.vue是页面编写页面代码</p><p>main.js 是打包的入口文件</p><p>index.html第一个index</p><pre><code class="vue">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;utf-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt;    &lt;link rel=&quot;icon&quot; href=&quot;&lt;%= BASE_URL %&gt;favicon.ico&quot;&gt;    &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;!-- 兼容：给不支持js的浏览器一个提示 --&gt;    &lt;noscript&gt;      &lt;strong&gt;We&#39;re sorry but &lt;%= htmlWebpackPlugin.options.title %&gt; doesn&#39;t work properly without JavaScript enabled. Please enable it to continue.&lt;/strong&gt;    &lt;/noscript&gt;    &lt;!-- Vue所管理的容器：将来创建结构动态渲染这个容器 --&gt;    &lt;div id=&quot;app&quot;&gt;      &lt;!-- 工程化开发模式中：这里不再直接编写模板语法，通过 App.vue 提供结构渲染 --&gt;    &lt;/div&gt;    &lt;!-- built files will be auto injected --&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><p>main.js</p><pre><code></code></pre><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230720233732764.png" alt="image-20230720233732764"></p><h3 id="局部注册和全局注册"><a href="#局部注册和全局注册" class="headerlink" title="局部注册和全局注册"></a>局部注册和全局注册</h3><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230721001822698.png" alt="image-20230721001822698"></p><p>实例在APp.vue局部注册</p><p>import HmHeader from ‘.&#x2F;components&#x2F;HmHeader.vue’</p><p>import HmMain from ‘.&#x2F;components&#x2F;HmMain.vue’</p><p>import HmFooter from ‘.&#x2F;components&#x2F;HmFooter.vue’</p><p>export default {</p><p> components: {</p><p>  &#x2F;&#x2F; ‘组件名’: 组件对象</p><p>  HmHeader: HmHeader,</p><p>  HmMain,</p><p>  HmFooter</p><p> }</p><p>}</p><pre><code>&lt;template&gt;  &lt;div class=&quot;App&quot;&gt;    &lt;!-- 头部组件 --&gt;    &lt;HmHeader&gt;&lt;/HmHeader&gt;    &lt;!-- 主体组件 --&gt;    &lt;HmMain&gt;&lt;/HmMain&gt;    &lt;!-- 底部组件 --&gt;    &lt;HmFooter&gt;&lt;/HmFooter&gt;    &lt;!-- 如果 HmFooter + tab 出不来 → 需要配置 vscode         设置中搜索 trigger on tab → 勾上    --&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import HmHeader from &#39;./components/HmHeader.vue&#39;import HmMain from &#39;./components/HmMain.vue&#39;import HmFooter from &#39;./components/HmFooter.vue&#39;export default &#123;  components: &#123;    // &#39;组件名&#39;: 组件对象    HmHeader: HmHeader,    HmMain,    HmFooter  &#125;&#125;&lt;/script&gt;&lt;style&gt;.App &#123;  width: 600px;  height: 700px;  background-color: #87ceeb;  margin: 0 auto;  padding: 20px;&#125;&lt;/style&gt;</code></pre><p>全局注册注册到mian.js</p><p>用Vue.component(‘HmButton’, HmButton)</p><pre><code>// 文件核心作用：导入App.vue，基于App.vue创建结构渲染index.htmlimport Vue from &#39;vue&#39;import App from &#39;./App.vue&#39;// 编写导入的代码，往代码的顶部编写(规范)import HmButton from &#39;./components/HmButton&#39;Vue.config.productionTip = false// 进行全局注册 → 在所有的组件范围内都能直接使用// Vue.component(组件名，组件对象)Vue.component(&#39;HmButton&#39;, HmButton)// Vue实例化，提供render方法 → 基于App.vue创建结构渲染index.htmlnew Vue(&#123;  // render: h =&gt; h(App),  render: (createElement) =&gt; &#123;    // 基于App创建元素结构    return createElement(App)  &#125;&#125;).$mount(&#39;#app&#39;)</code></pre><h1 id="便捷开发按键"><a href="#便捷开发按键" class="headerlink" title="便捷开发按键"></a>便捷开发按键</h1><p>ctrl+k ctrl+0 组合按 全部合并</p><p>ctrl+k ctrl+j 组合按 全部展开</p><p>shift+alt可以魔法粘贴</p><h3 id="关于vue中的style的局部影响和全局影响"><a href="#关于vue中的style的局部影响和全局影响" class="headerlink" title="关于vue中的style的局部影响和全局影响"></a>关于vue中的style的局部影响和全局影响</h3><style scoped></style><p>加上scoped表示只影响当前组件</p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230722120016634.png" alt="image-20230722120016634"></p><h2 id="补充在Vue中，export和export-default是用于导出模块的两种不同方式。"><a href="#补充在Vue中，export和export-default是用于导出模块的两种不同方式。" class="headerlink" title="补充在Vue中，export和export default是用于导出模块的两种不同方式。****"></a>补充在Vue中，<code>export</code>和<code>export default</code>是用于导出模块的两种不同方式。****</h2><p>在Vue中，<code>export</code>和<code>export default</code>是用于导出模块的两种不同方式。</p><p><code>export</code>用于导出模块中的一个或多个具名变量、函数或类。例如：</p><p>javascript</p><p>Copy</p><pre><code>// module.jsexport const name = &#39;John&#39;;export function sayHello() &#123;  console.log(&#39;Hello!&#39;);&#125;export class Person &#123;  constructor(name) &#123;    this.name = name;  &#125;&#125;</code></pre><p>在另一个文件中，可以使用<code>import</code>关键字导入模块中的具名变量、函数或类。例如：</p><p>javascript</p><p>Copy</p><pre><code>// main.jsimport &#123; name, sayHello, Person &#125; from &#39;./module.js&#39;;console.log(name); // &#39;John&#39;sayHello(); // &#39;Hello!&#39;const person = new Person(&#39;Tom&#39;);console.log(person.name); // &#39;Tom&#39;</code></pre><p><code>export default</code>用于导出模块中的默认值。每个模块只能有一个默认导出。例如：</p><p>javascript</p><p>Copy</p><pre><code>// module.jsexport default &#123;  name: &#39;John&#39;,  sayHello() &#123;    console.log(&#39;Hello!&#39;);  &#125;&#125;</code></pre><p>在另一个文件中，可以使用<code>import</code>关键字导入模块的默认导出。例如：</p><p>javascript</p><p>Copy</p><pre><code>// main.jsimport person from &#39;./module.js&#39;;console.log(person.name); // &#39;John&#39;person.sayHello(); // &#39;Hello!&#39;</code></pre><p>注意：当使用<code>export default</code>时，可以在导入模块时使用任何名称，而不需要使用花括号。但是，当使用<code>export</code>时，必须使用相应的名称（如上例中的<code>&#123; name, sayHello, Person &#125;</code>）。</p><h1 id="父子组件传值"><a href="#父子组件传值" class="headerlink" title="父子组件传值"></a>父子组件传值</h1><p>1.两种组件关系分类和对应的组件通信方案</p><p>父子关系 -》 props $ emit</p><p>非父子关系 -》 provide ￥ inject 或者eventbus</p><p>通用方案 vuex</p><p>2.父子痛惜方案核心流程</p><p>2.1父传子 props：</p><p>1.父中给子添加属性 2.子中props接受 3.使用</p><p>2.子传父</p><p>$emit:父类事件 $em it（”父类事件”，传入参数）</p><h1 id="props参数传递详解"><a href="#props参数传递详解" class="headerlink" title="props参数传递详解"></a>props参数传递详解</h1><p>这是一个接收数据的案例包括了校验规则的使用</p><p>但是这些校验只是警告数据并不会真实不接收 </p><pre><code>&lt;script&gt;export default &#123;  // props:[&#39;username&#39;,&#39;age&#39;,&#39;isSingle&#39;,&#39;car&#39;,&#39;hobby&#39;]  props:&#123;    username: &#123;      type: Number,      required: true,      default: 0,//类型校验非空校验以及默认值      validator(value)&#123;          console.log(value)          if(value&gt;=0&amp;&amp;value&lt;=100)&#123;            return true          &#125;else&#123;            console.log(&quot;传入参数不符合&quot;);            return false;          &#125;      &#125;    &#125;,    age:String,    isSingle: Boolean,    car:Array,    hobby:Array  &#125;&#125;&lt;/script&gt;</code></pre><h1 id="非父子组件的事件触发-通信"><a href="#非父子组件的事件触发-通信" class="headerlink" title="非父子组件的事件触发 通信"></a>非父子组件的事件触发 通信</h1><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230722164544091.png" alt="image-20230722164544091"></p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230722165441242.png" alt="image-20230722165441242"></p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230722165622724.png" alt="image-20230722165622724"></p><h1 id="v-model深入了解"><a href="#v-model深入了解" class="headerlink" title="v-model深入了解"></a>v-model深入了解</h1><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230722170403075.png" alt="image-20230722170403075"></p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230722170712475.png" alt="image-20230722170712475"></p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230722180341321.png" alt="image-20230722180341321"></p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230722180545693.png" alt="image-20230722180545693"></p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230722181212604.png" alt="image-20230722181212604"></p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230722190802738.png" alt="image-20230722190802738"></p><h3 id="在vue中获取dom元素"><a href="#在vue中获取dom元素" class="headerlink" title="在vue中获取dom元素"></a>在vue中获取dom元素</h3><p>在标签里面设置 ref&#x3D;‘名字’</p><p>在使用的地址进行使用    this.$refs.名字</p><p>ag.</p><pre><code class="vue">&lt;template&gt;  &lt;div class=&quot;base-chart-box&quot; ref=&quot;baseChartBox&quot;&gt;子组件&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import * as echarts from &#39;echarts&#39;export default &#123;  mounted() &#123;    // 基于准备好的dom，初始化echarts实例    // document.querySelector 会查找项目中所有的元素    // $refs只会在当前组件查找盒子    // var myChart = echarts.init(document.querySelector(&#39;.base-chart-box&#39;))    var myChart = echarts.init(this.$refs.baseChartBox)    // 绘制图表    myChart.setOption(&#123;      title: &#123;        text: &#39;ECharts 入门示例&#39;,      &#125;,      tooltip: &#123;&#125;,      xAxis: &#123;        data: [&#39;衬衫&#39;, &#39;羊毛衫&#39;, &#39;雪纺衫&#39;, &#39;裤子&#39;, &#39;高跟鞋&#39;, &#39;袜子&#39;],      &#125;,      yAxis: &#123;&#125;,      series: [        &#123;          name: &#39;销量&#39;,          type: &#39;bar&#39;,          data: [5, 20, 36, 10, 10, 20],        &#125;,      ],    &#125;)  &#125;,&#125;&lt;/script&gt;&lt;style scoped&gt;.base-chart-box &#123;  width: 400px;  height: 300px;  border: 3px solid #000;  border-radius: 6px;&#125;&lt;/style&gt;</code></pre><pre><code>&lt;template&gt;  &lt;div class=&quot;app&quot;&gt;    &lt;div class=&quot;base-chart-box&quot;&gt;      这是一个捣乱的盒子    &lt;/div&gt;    &lt;BaseChart&gt;&lt;/BaseChart&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import BaseChart from &#39;./components/BaseChart.vue&#39;export default &#123;  components:&#123;    BaseChart  &#125;&#125;&lt;/script&gt;&lt;style&gt;.base-chart-box &#123;  width: 300px;  height: 200px;&#125;&lt;/style&gt;</code></pre><p>注意 vue中的dom操作时异步执行的 时进行一定dom操作后异步执行 ，所以在使用 获取dom操作的时候 </p><p>更新dom资源后直接使用 可能会爆未定义的错误，</p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230723095303774.png" alt="image-20230723095303774"></p><p>需要放到操作</p><p>this.$nextTick（（）{</p><p>​this.$refs.名字.属性</p><p>}）</p><p>设置setTimeout（</p><p>（）{</p><p>​this.$refs.名字.属性</p><p>}</p><p>）函数也可以操作但是由于这个延迟时间不够精准所以不建议使用</p><h1 id="自定义之指令"><a href="#自定义之指令" class="headerlink" title="自定义之指令"></a>自定义之指令</h1><p>自定义指令：自己定义指定 封装dom操作 拓展额外功能</p><p>全局注册语法</p><p>Vue.directive（‘指令名’，{</p><p>”inserted“（）{</p><p>el.focus</p><p>}}）</p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230723101241674.png" alt="image-20230723101241674"></p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230723134533947.png" alt="image-20230723134533947"></p><p>自定义指令案例</p><pre><code class="vue">&lt;template&gt;  &lt;div&gt;    &lt;h1 v-color=&quot;color1&quot;&gt;指令的值1测试&lt;/h1&gt;    &lt;h1 v-color=&quot;color2&quot;&gt;指令的值2测试&lt;/h1&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  data () &#123;    return &#123;      color1: &#39;red&#39;,      color2: &#39;orange&#39;    &#125;  &#125;,  directives: &#123;    color: &#123;      // 1. inserted 提供的是元素被添加到页面中时的逻辑      inserted (el, binding) &#123;        // console.log(el, binding.value);        // binding.value 就是指令的值        el.style.color = binding.value        debugger      &#125;,      // 2. update 指令的值修改的时候触发，提供值变化后，dom更新的逻辑      update (el, binding) &#123;        console.log(&#39;指令的值修改了&#39;);        el.style.color = binding.value        debugger      &#125;    &#125;  &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt;</code></pre><p>vue3实现</p><pre><code>&lt;template&gt;  &lt;div&gt;    &lt;h1 v-color=&quot;color1&quot;&gt;指令的值1测试&lt;/h1&gt;    &lt;h1 v-color=&quot;color2&quot;&gt;指令的值2测试&lt;/h1&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  data () &#123;    return &#123;      color1: &#39;bule&#39;,      color2: &#39;orange&#39;    &#125;  &#125;,  directives: &#123;    color: &#123;      beforeMount(el, binding) &#123;        el.style.color = binding.value      &#125;,      updated(el, binding) &#123;        console.log(&#39;指令的值修改了&#39;);        el.style.color = binding.value      &#125;    &#125;  &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt;</code></pre><p>veu2实现</p><pre><code>&lt;template&gt;  &lt;div&gt;    &lt;h1 v-color=&quot;color1&quot;&gt;指令的值1测试&lt;/h1&gt;    &lt;h1 v-color=&quot;color2&quot;&gt;指令的值2测试&lt;/h1&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  data () &#123;    return &#123;      color1: &#39;&#39;,      color2: &#39;orange&#39;    &#125;  &#125;,  directives: &#123;    color: &#123;      // 1. inserted 提供的是元素被添加到页面中时的逻辑      inserted (el, binding) &#123;        // console.log(el, binding.value);        // binding.value 就是指令的值        el.style.color = binding.value        debugger      &#125;,      // 2. update 指令的值修改的时候触发，提供值变化后，dom更新的逻辑      update (el, binding) &#123;        console.log(&#39;指令的值修改了&#39;);        el.style.color = binding.value        debugger      &#125;    &#125;  &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt;</code></pre><pre><code></code></pre><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230723151115128.png" alt="image-20230723151115128"></p><pre><code>&lt;template&gt;  &lt;div class=&quot;main&quot;&gt;    &lt;div class=&quot;box&quot; v-loading=&quot;isLoading&quot;&gt;      &lt;ul&gt;        &lt;li v-for=&quot;item in list&quot; :key=&quot;item.id&quot; class=&quot;news&quot;&gt;          &lt;div class=&quot;left&quot;&gt;            &lt;div class=&quot;title&quot;&gt;&#123;&#123; item.title &#125;&#125;&lt;/div&gt;            &lt;div class=&quot;info&quot;&gt;              &lt;span&gt;&#123;&#123; item.source &#125;&#125;&lt;/span&gt;              &lt;span&gt;&#123;&#123; item.time &#125;&#125;&lt;/span&gt;            &lt;/div&gt;          &lt;/div&gt;          &lt;div class=&quot;right&quot;&gt;            &lt;img :src=&quot;item.img&quot; alt=&quot;&quot;&gt;          &lt;/div&gt;        &lt;/li&gt;      &lt;/ul&gt;    &lt;/div&gt;    &lt;div class=&quot;box2&quot; v-loading=&quot;isLoading2&quot;&gt;&lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// 安装axios =&gt;  yarn add axiosimport axios from &#39;axios&#39;// 接口地址：http://hmajax.itheima.net/api/news// 请求方式：getexport default &#123;  data () &#123;    return &#123;      list: [],      isLoading: true,      isLoading2: true    &#125;  &#125;,  async created () &#123;    // 1. 发送请求获取数据    const res = await axios.get(&#39;http://hmajax.itheima.net/api/news&#39;)        setTimeout(() =&gt; &#123;      // 2. 更新到 list 中，用于页面渲染 v-for      this.list = res.data.data      this.isLoading = false      debugger    &#125;, 2)  &#125;,  directives: &#123;    loading: &#123;      beforeMount (el, binding) &#123;        binding.value ? el.classList.add(&#39;loading&#39;) : el.classList.remove(&#39;loading&#39;)      &#125;,      updated (el, binding) &#123;        binding.value ? el.classList.add(&#39;loading&#39;) : el.classList.remove(&#39;loading&#39;)      &#125;    &#125;  &#125;&#125;&lt;/script&gt;&lt;style&gt;.loading:before &#123;  content: &#39;&#39;;  position: absolute;  left: 0;  top: 0;  width: 100%;  height: 100%;  background: #fff url(&#39;./loading.gif&#39;) no-repeat center;&#125;.box2 &#123;  width: 400px;  height: 400px;  border: 2px solid #000;  position: relative;&#125;.box &#123;  width: 800px;  min-height: 500px;  border: 3px solid orange;  border-radius: 5px;  position: relative;&#125;.news &#123;  display: flex;  height: 120px;  width: 600px;  margin: 0 auto;  padding: 20px 0;  cursor: pointer;&#125;.news .left &#123;  flex: 1;  display: flex;  flex-direction: column;  justify-content: space-between;  padding-right: 10px;&#125;.news .left .title &#123;  font-size: 20px;&#125;.news .left .info &#123;  color: #999999;&#125;.news .left .info span &#123;  margin-right: 20px;&#125;.news .right &#123;  width: 160px;  height: 120px;&#125;.news .right img &#123;  width: 100%;  height: 100%;  object-fit: cover;&#125;&lt;/style&gt;</code></pre><h5 id="slot插槽"><a href="#slot插槽" class="headerlink" title="slot插槽"></a>slot插槽</h5><p>插槽如果不起名字就是默认插槽</p><p>起名字就是 具名插槽 可以被选择</p><slot name><p>使用的时候在组件中直接</p><p>&lt;组件名字&gt;</p><p>&lt;template v-slot:插槽名&gt;内容 可以使用html语法 </p><p>&lt;&#x2F;组件名字&gt;</p><p>v-solt：可以简写为#</p><p>v-solt：插槽名字     作为选择某个插槽</p><p>当组件某些内容不确定，可以用slot进行插槽占用</p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230723152145263.png" alt="image-20230723152145263"></p><pre><code>&lt;template&gt;  &lt;div class=&quot;dialog&quot;&gt;    &lt;div class=&quot;dialog-header&quot;&gt;      &lt;h3&gt;友情提示&lt;/h3&gt;      &lt;span class=&quot;close&quot;&gt;✖️&lt;/span&gt;    &lt;/div&gt;    &lt;div class=&quot;dialog-content&quot;&gt;      &lt;!-- 1. 在需要定制的位置，使用slot占位 --&gt;      &lt;slot&gt;&lt;/slot&gt;    &lt;/div&gt;    &lt;div class=&quot;dialog-footer&quot;&gt;      &lt;button&gt;取消&lt;/button&gt;      &lt;button&gt;确认&lt;/button&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  data () &#123;    return &#123;    &#125;  &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;* &#123;  margin: 0;  padding: 0;&#125;.dialog &#123;  width: 470px;  height: 230px;  padding: 0 25px;  background-color: #ffffff;  margin: 40px auto;  border-radius: 5px;&#125;.dialog-header &#123;  height: 70px;  line-height: 70px;  font-size: 20px;  border-bottom: 1px solid #ccc;  position: relative;&#125;.dialog-header .close &#123;  position: absolute;  right: 0px;  top: 0px;  cursor: pointer;&#125;.dialog-content &#123;  height: 80px;  font-size: 18px;  padding: 15px 0;&#125;.dialog-footer &#123;  display: flex;  justify-content: flex-end;&#125;.dialog-footer button &#123;  width: 65px;  height: 35px;  background-color: #ffffff;  border: 1px solid #e1e3e9;  cursor: pointer;  outline: none;  margin-left: 10px;  border-radius: 3px;&#125;.dialog-footer button:last-child &#123;  background-color: #007acc;  color: #fff;&#125;&lt;/style&gt;</code></pre><pre><code>&lt;template&gt;  &lt;div&gt;    &lt;!-- 2. 在使用组件时，组件标签内填入内容 --&gt;    &lt;MyDialog&gt;      &lt;div&gt;你确认要删除么&lt;/div&gt;    &lt;/MyDialog&gt;    &lt;MyDialog&gt;      &lt;p&gt;你确认要退出么&lt;/p&gt;    &lt;/MyDialog&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import MyDialog from &#39;./components/MyDialog.vue&#39;export default &#123;  data () &#123;    return &#123;    &#125;  &#125;,  components: &#123;    MyDialog  &#125;&#125;&lt;/script&gt;&lt;style&gt;body &#123;  background-color: #b3b3b3;&#125;&lt;/style&gt;</code></pre><p><strong>作用域插槽</strong></p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230723173516211.png" alt="image-20230723173516211"></p><pre><code>&lt;template&gt;  &lt;table class=&quot;my-table&quot;&gt;    &lt;thead&gt;      &lt;tr&gt;        &lt;th&gt;序号&lt;/th&gt;        &lt;th&gt;姓名&lt;/th&gt;        &lt;th&gt;年纪&lt;/th&gt;        &lt;th&gt;操作&lt;/th&gt;      &lt;/tr&gt;    &lt;/thead&gt;    &lt;tbody&gt;      &lt;tr v-for=&quot;(item, index) in data&quot; :key=&quot;item.id&quot;&gt;        &lt;td&gt;&#123;&#123; index + 1 &#125;&#125;&lt;/td&gt;        &lt;td&gt;&#123;&#123; item.name &#125;&#125;&lt;/td&gt;        &lt;td&gt;&#123;&#123; item.age &#125;&#125;&lt;/td&gt;        &lt;td&gt;          &lt;!-- 1. 给slot标签，添加属性的方式传值 --&gt;          &lt;slot :row=&quot;item&quot; msg=&quot;测试文本&quot;&gt;&lt;/slot&gt;          &lt;!-- 2. 将所有的属性，添加到一个对象中 --&gt;          &lt;!--              &#123;               row: &#123; id: 2, name: &#39;孙大明&#39;, age: 19 &#125;,               msg: &#39;测试文本&#39;             &#125;           --&gt;        &lt;/td&gt;      &lt;/tr&gt;    &lt;/tbody&gt;  &lt;/table&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  props: &#123;    data: Array  &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;.my-table &#123;  width: 450px;  text-align: center;  border: 1px solid #ccc;  font-size: 24px;  margin: 30px auto;&#125;.my-table thead &#123;  background-color: #1f74ff;  color: #fff;&#125;.my-table thead th &#123;  font-weight: normal;&#125;.my-table thead tr &#123;  line-height: 40px;&#125;.my-table th,.my-table td &#123;  border-bottom: 1px solid #ccc;  border-right: 1px solid #ccc;&#125;.my-table td:last-child &#123;  border-right: none;&#125;.my-table tr:last-child td &#123;  border-bottom: none;&#125;.my-table button &#123;  width: 65px;  height: 35px;  font-size: 18px;  border: 1px solid #ccc;  outline: none;  border-radius: 3px;  cursor: pointer;  background-color: #ffffff;  margin-left: 5px;&#125;&lt;/style&gt;</code></pre><pre><code>&lt;template&gt;  &lt;div&gt;    &lt;MyTable :data=&quot;list&quot;&gt;      &lt;!-- 3. 通过template #插槽名=&quot;变量名&quot; 接收 --&gt;      &lt;template #default=&quot;obj&quot;&gt;        &lt;button @click=&quot;del(obj.row.id)&quot;&gt;          删除        &lt;/button&gt;      &lt;/template&gt;    &lt;/MyTable&gt;        &lt;MyTable :data=&quot;list2&quot;&gt;      &lt;template #default=&quot;&#123; row &#125;&quot;&gt;        &lt;button @click=&quot;show(row)&quot;&gt;查看&lt;/button&gt;      &lt;/template&gt;    &lt;/MyTable&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import MyTable from &#39;./components/MyTable.vue&#39;export default &#123;  data () &#123;    return &#123;      list: [        &#123; id: 1, name: &#39;张小花&#39;, age: 18 &#125;,        &#123; id: 2, name: &#39;孙大明&#39;, age: 19 &#125;,        &#123; id: 3, name: &#39;刘德忠&#39;, age: 17 &#125;,      ],      list2: [        &#123; id: 1, name: &#39;赵小云&#39;, age: 18 &#125;,        &#123; id: 2, name: &#39;刘蓓蓓&#39;, age: 19 &#125;,        &#123; id: 3, name: &#39;姜肖泰&#39;, age: 17 &#125;,      ]    &#125;  &#125;,  methods: &#123;    del (id) &#123;      this.list = this.list.filter(item =&gt; item.id !== id)    &#125;,    show (row) &#123;      // console.log(row);      alert(`姓名：$&#123;row.name&#125;; 年纪：$&#123;row.age&#125;`)    &#125;  &#125;,  components: &#123;    MyTable  &#125;&#125;&lt;/script&gt;</code></pre><p>子控件传值给父</p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230723175418428.png" alt="image-20230723175418428"></p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230723175715061.png" alt="image-20230723175715061"></p><p>父控件进行接受数据</p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230723175457310.png" alt="image-20230723175457310"></p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230723175801432.png" alt="image-20230723175801432"></p><h1 id="综合案例抽取table和tag"><a href="#综合案例抽取table和tag" class="headerlink" title="综合案例抽取table和tag"></a>综合案例抽取table和tag</h1><p>···</p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230723210008642.png" alt="image-20230723210008642"></p><pre><code>&lt;template&gt;  &lt;table class=&quot;my-table&quot;&gt;    &lt;thead&gt;      &lt;tr&gt;        &lt;slot name=&quot;head&quot;&gt;&lt;/slot&gt;      &lt;/tr&gt;    &lt;/thead&gt;    &lt;tbody&gt;      &lt;tr v-for=&quot;(item, index) in data&quot; :key=&quot;item.id&quot;&gt;        &lt;slot name=&quot;body&quot; :item=&quot;item&quot; :index=&quot;index&quot; &gt;&lt;/slot&gt;      &lt;/tr&gt;    &lt;/tbody&gt;  &lt;/table&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  props: &#123;    data: &#123;      type: Array,      required: true    &#125;  &#125;&#125;;&lt;/script&gt;&lt;style lang=&quot;less&quot; scoped&gt;.my-table &#123;  width: 100%;  border-spacing: 0;  img &#123;    width: 100px;    height: 100px;    object-fit: contain;    vertical-align: middle;  &#125;  th &#123;    background: #f5f5f5;    border-bottom: 2px solid #069;  &#125;  td &#123;    border-bottom: 1px dashed #ccc;  &#125;  td,  th &#123;    text-align: center;    padding: 10px;    transition: all .5s;    &amp;.red &#123;      color: red;    &#125;  &#125;  .none &#123;    height: 100px;    line-height: 100px;    color: #999;  &#125;&#125;&lt;/style&gt;</code></pre><pre><code>&lt;template&gt;  &lt;div class=&quot;my-tag&quot;&gt;    &lt;input      v-if=&quot;isEdit&quot;      v-focus      ref=&quot;inp&quot;      class=&quot;input&quot;      type=&quot;text&quot;      placeholder=&quot;输入标签&quot;      :value=&quot;value&quot;      @blur=&quot;isEdit = false&quot;      @keyup.enter=&quot;handleEnter&quot;    /&gt;    &lt;div       v-else      @dblclick=&quot;handleClick&quot;      class=&quot;text&quot;&gt;      &#123;&#123; value &#125;&#125;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  props: &#123;    value: String  &#125;,  data () &#123;    return &#123;      isEdit: false    &#125;  &#125;,  methods: &#123;    handleClick () &#123;      // 双击后，切换到显示状态 (Vue是异步dom更新)      this.isEdit = true            // // 等dom更新完了，再获取焦点      // this.$nextTick(() =&gt; &#123;      //   // 立刻获取焦点      //   this.$refs.inp.focus()      // &#125;)    &#125;,    handleEnter (e) &#123;      // 非空处理      if (e.target.value.trim() === &#39;&#39;) return alert(&#39;标签内容不能为空&#39;)      // 子传父，将回车时，[输入框的内容] 提交给父组件更新      // 由于父组件是v-model，触发事件，需要触发 input 事件      this.$emit(&#39;input&#39;, e.target.value)      // 提交完成，关闭输入状态      this.isEdit = false    &#125;  &#125;&#125;&lt;/script&gt;&lt;style lang=&quot;less&quot; scoped&gt;.my-tag &#123;  cursor: pointer;  .input &#123;    appearance: none;    outline: none;    border: 1px solid #ccc;    width: 100px;    height: 40px;    box-sizing: border-box;    padding: 10px;    color: #666;    &amp;::placeholder &#123;      color: #666;    &#125;  &#125;&#125;&lt;/style&gt;</code></pre><pre><code>&lt;template&gt;  &lt;div class=&quot;table-case&quot;&gt;    &lt;MyTable :data=&quot;goods&quot;&gt;      &lt;template #head&gt;        &lt;th&gt;编号&lt;/th&gt;        &lt;th&gt;名称&lt;/th&gt;        &lt;th&gt;图片&lt;/th&gt;        &lt;th width=&quot;100px&quot;&gt;标签&lt;/th&gt;      &lt;/template&gt;      &lt;template #body=&quot;&#123; item, index &#125;&quot;&gt;        &lt;td&gt;&#123;&#123; index + 1 &#125;&#125;&lt;/td&gt;        &lt;td&gt;&#123;&#123; item.name &#125;&#125;&lt;/td&gt;        &lt;td&gt;          &lt;img            :src=&quot;item.picture&quot;          /&gt;        &lt;/td&gt;        &lt;td&gt;          &lt;MyTag v-model=&quot;item.tag&quot;&gt;&lt;/MyTag&gt;        &lt;/td&gt;      &lt;/template&gt;    &lt;/MyTable&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// my-tag 标签组件的封装// 1. 创建组件 - 初始化// 2. 实现功能//    (1) 双击显示，并且自动聚焦//        v-if v-else @dbclick 操作 isEdit//        自动聚焦：//        1. $nextTick =&gt; $refs 获取到dom，进行focus获取焦点//        2. 封装v-focus指令//    (2) 失去焦点，隐藏输入框//        @blur 操作 isEdit 即可//    (3) 回显标签信息//        回显的标签信息是父组件传递过来的//        v-model实现功能 (简化代码)  v-model =&gt; :value 和 @input//        组件内部通过props接收, :value设置给输入框//    (4) 内容修改了，回车 =&gt; 修改标签信息//        @keyup.enter, 触发事件 $emit(&#39;input&#39;, e.target.value)// ---------------------------------------------------------------------// my-table 表格组件的封装// 1. 数据不能写死，动态传递表格渲染的数据  props// 2. 结构不能写死 - 多处结构自定义 【具名插槽】//    (1) 表头支持自定义//    (2) 主体支持自定义import MyTag from &#39;./components/MyTag.vue&#39;import MyTable from &#39;./components/MyTable.vue&#39;export default &#123;  name: &#39;TableCase&#39;,  components: &#123;    MyTag,    MyTable  &#125;,  data () &#123;    return &#123;      // 测试组件功能的临时数据      tempText: &#39;水杯&#39;,      tempText2: &#39;钢笔&#39;,      goods: [        &#123; id: 101, picture: &#39;https://yanxuan-item.nosdn.127.net/f8c37ffa41ab1eb84bff499e1f6acfc7.jpg&#39;, name: &#39;梨皮朱泥三绝清代小品壶经典款紫砂壶&#39;, tag: &#39;茶具&#39; &#125;,        &#123; id: 102, picture: &#39;https://yanxuan-item.nosdn.127.net/221317c85274a188174352474b859d7b.jpg&#39;, name: &#39;全防水HABU旋钮牛皮户外徒步鞋山宁泰抗菌&#39;, tag: &#39;男鞋&#39; &#125;,        &#123; id: 103, picture: &#39;https://yanxuan-item.nosdn.127.net/cd4b840751ef4f7505c85004f0bebcb5.png&#39;, name: &#39;毛茸茸小熊出没，儿童羊羔绒背心73-90cm&#39;, tag: &#39;儿童服饰&#39; &#125;,        &#123; id: 104, picture: &#39;https://yanxuan-item.nosdn.127.net/56eb25a38d7a630e76a608a9360eec6b.jpg&#39;, name: &#39;基础百搭，儿童套头针织毛衣1-9岁&#39;, tag: &#39;儿童服饰&#39; &#125;,      ]    &#125;  &#125;&#125;&lt;/script&gt;&lt;style lang=&quot;less&quot; scoped&gt;.table-case &#123;  width: 1000px;  margin: 50px auto;  img &#123;    width: 100px;    height: 100px;    object-fit: contain;    vertical-align: middle;  &#125;&#125;&lt;/style&gt;</code></pre><h1 id="路由的介绍"><a href="#路由的介绍" class="headerlink" title="路由的介绍"></a>路由的介绍</h1><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230723210927117.png" alt="image-20230723210927117"></p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230723211053650.png" alt="image-20230723211053650"></p><p>路由的使用步骤</p><ol><li><p>下载</p><p>npm add vue</p></li><li><p>引入</p></li><li><p>安装注册</p></li><li><p>创建路由对象</p></li><li><p>注入 将路由对象注入到nie VUE实例中，建立联系</p></li></ol><p>在 Vue 3 中，使用 Vue Router 来实现路由功能，以下是使用 Vue Router 的基本步骤：</p><ol><li><p>安装 Vue Router：在项目中使用 npm 或 yarn 安装 Vue Router。</p><pre><code>npm install vue-router# 或者yarn add vue-router```</code></pre></li><li><p>创建路由实例：在项目中创建一个路由实例，并定义路由表和路由规则。您可以在创建路由实例时，使用 <code>createRouter</code> 工厂函数来创建一个路由实例，例如：</p><pre><code>import &#123; createRouter, createWebHistory &#125; from &#39;vue-router&#39;import Home from &#39;./views/Home.vue&#39;import About from &#39;./views/About.vue&#39;const routes = [  &#123;    path: &#39;/&#39;,    name: &#39;Home&#39;,    component: Home  &#125;,  &#123;    path: &#39;/about&#39;,    name: &#39;About&#39;,    component: About  &#125;]const router = createRouter(&#123;  history: createWebHistory(),  routes&#125;)export default router```在上面的代码中，我们使用 `createRouter` 工厂函数创建了一个路由实例，并定义了两个路由规则，分别对应 `&#39;/&#39;` 和 `&#39;/about&#39;` 路径。`createWebHistory` 函数用于创建一个基于 HTML5 history 模式的路由模式。</code></pre></li><li><p>在根组件中使用路由：在根组件中使用路由，并将路由实例传递给应用程序。您可以通过在 <code>main.js</code> 文件中引入路由实例，并将其传递给根组件来使用路由。例如：</p><pre><code>import &#123; createApp &#125; from &#39;vue&#39;import App from &#39;./App.vue&#39;import router from &#39;./router&#39;createApp(App).use(router).mount(&#39;#app&#39;)```</code></pre></li><li><p>定义路由出口：在根组件中定义一个路由出口，用于显示路由组件。您可以在根组件的模板中使用 <code>&lt;router-view&gt;</code> 标签来定义路由出口，例如：</p><pre><code>&lt;template&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;router-view /&gt;  &lt;/div&gt;&lt;/template&gt;```在上面的代码中，我们使用 `&lt;router-view&gt;` 标签来定义路由出口，并在其中显示路由组件。</code></pre></li><li><p>创建路由组件：在项目中创建多个路由组件，用于根据不同的路由规则来显示不同的内容。您可以在项目中创建多个路由组件，并在路由表中定义相应的路由规则，例如：</p><pre><code>// Home.vue&lt;template&gt;  &lt;div&gt;    &lt;h1&gt;Home&lt;/h1&gt;    &lt;p&gt;This is the home page.&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;// About.vue&lt;template&gt;  &lt;div&gt;    &lt;h1&gt;About&lt;/h1&gt;    &lt;p&gt;This is the about page.&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;```在上面的代码中，我们分别创建了 `Home` 和 `About` 两个路由组件，并定义了它们的模板。</code></pre></li><li><p>使用路由链接：在项目中使用路由链接，用于在不同的路由之间进行导航。您可以在项目中使用 <code>&lt;router-link&gt;</code> 标签来创建路由链接，例如：</p><pre><code>&lt;router-link to=&quot;/&quot;&gt;Home&lt;/router-link&gt;&lt;router-link to=&quot;/about&quot;&gt;About&lt;/router-link&gt;```在上面的代码中，我们使用 `&lt;router-link&gt;` 标签分别创建了两个路由链接，用于在 `Home` 和 `About` 之间进行导航。</code></pre></li></ol><p>这些是使用 Vue Router 的基本步骤，您可以根据您的实际需求进行相应的修改和扩展。</p><pre><code>import Vue from &#39;vue&#39;import App from &#39;./App.vue&#39;// 路由的使用步骤 5 + 2// 5个基础步骤// 1. 下载 v3.6.5// 2. 引入// 3. 安装注册 Vue.use(Vue插件)// 4. 创建路由对象// 5. 注入到new Vue中，建立关联// 2个核心步骤// 1. 建组件(views目录)，配规则// 2. 准备导航链接，配置路由出口(匹配的组件展示的位置) import Find from &#39;./views/Find&#39;import My from &#39;./views/My&#39;import Friend from &#39;./views/Friend&#39;import VueRouter from &#39;vue-router&#39;Vue.use(VueRouter) // VueRouter插件初始化const router = new VueRouter(&#123;  // routes 路由规则们  // route  一条路由规则 &#123; path: 路径, component: 组件 &#125;  routes: [    &#123; path: &#39;/find&#39;, component: Find &#125;,    &#123; path: &#39;/my&#39;, component: My &#125;,    &#123; path: &#39;/friend&#39;, component: Friend &#125;,  ]&#125;)Vue.config.productionTip = falsenew Vue(&#123;  render: h =&gt; h(App),  router&#125;).$mount(&#39;#app&#39;)</code></pre><p>router拆分模块</p><p>router&#x2F;index.js</p><pre><code>// 路由的使用步骤 5 + 2// 5个基础步骤// 1. 下载 v3.6.5// 2. 引入// 3. 安装注册 Vue.use(Vue插件)// 4. 创建路由对象// 5. 注入到new Vue中，建立关联// 2个核心步骤// 1. 建组件(views目录)，配规则// 2. 准备导航链接，配置路由出口(匹配的组件展示的位置) import Find from &#39;@/views/Find&#39;import My from &#39;@/views/My&#39;import Friend from &#39;@/views/Friend&#39;import VueRouter from &#39;vue-router&#39;import Vue from &#39;vue&#39;Vue.use(VueRouter) // VueRouter插件初始化const router = new VueRouter(&#123;  // routes 路由规则们  // route  一条路由规则 &#123; path: 路径, component: 组件 &#125;  routes: [    &#123; path: &#39;/find&#39;, component: Find &#125;,    &#123; path: &#39;/my&#39;, component: My &#125;,    &#123; path: &#39;/friend&#39;, component: Friend &#125;,  ]&#125;)export default router</code></pre><p>main.js引入router</p><pre><code>import Vue from &#39;vue&#39;import App from &#39;./App.vue&#39;import router from &#39;./router&#39;Vue.config.productionTip = falsenew Vue(&#123;  render: h =&gt; h(App),  router&#125;).$mount(&#39;#app&#39;)</code></pre><h2 id="追加"><a href="#追加" class="headerlink" title="追加"></a>追加</h2><p>vue的路由一般定义再view文件夹 </p><p>步骤流程</p><p>再view 下面创建路由设置路由规则</p><p> 然后暴露此路由对象</p><pre><code>const router=new VueRouter(&#123;  routes:[    &#123; path: &#39;/find&#39;,component: Find&#125;    ,&#123;path: &#39;/my&#39;,component: My&#125;,    &#123;path: &#39;/friend&#39;,component: Friend&#125;  ]&#125;)export default router</code></pre><p>路由规则是path ‘&#x2F;路径’，comonement：组件引入名字 此时是用的router-link 而不是a标签</p><p>路由规则是path ‘#&#x2F;路径’，comonement：组件引入名字 此时是a标签</p><p>配置好路由之后需要再main.js引入路由对象</p><pre><code>new Vue(&#123;  render: h =&gt; h(App),  router&#125;).$mount(&#39;#app&#39;)</code></pre><p>这一切做好之后再展示的页面即App.vue下配置自己的模块以及对应的路由信息</p><pre><code>&lt;template&gt;  &lt;div&gt;    &lt;div class=&quot;footer_wrap&quot;&gt;      &lt;router-link to=&quot;/find&quot;&gt;发现音乐&lt;/router-link &gt;      &lt;router-link to=&quot;/my&quot;&gt;我的音乐&lt;/router-link &gt;      &lt;router-link to=&quot;/friend&quot;&gt;朋友&lt;/router-link &gt;    &lt;/div&gt;    &lt;div class=&quot;top&quot;&gt;      &lt;!-- 路由出口 → 匹配的组件所展示的位置 --&gt;      &lt;router-view&gt;&lt;/router-view&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><p>此代码router-link可以换成a标签但是这样a标签格式需要再路由的path前面加一个#</p><h2 id="router-link声明式路由"><a href="#router-link声明式路由" class="headerlink" title="router-link声明式路由"></a>router-link声明式路由</h2><pre><code> &lt;a href=&quot;#/find&quot;&gt;发现音乐&lt;/a &gt;</code></pre><p>这样才是a标签的模式因为路由有个#非常难看不建议使用</p><p>然后就是为什么要用router-link？</p><p>router-link 在渲染组件的时候其实还是a标签</p><p>但是 它会在a标签上面追加一个router-link-active属性和router-link-exact-active</p><p>这两个数据可以设置高亮方便我们操作</p><p>如下展示</p><p>.footer_wrap a.router-link-active{</p><p> background-color: aqua;</p><p>}</p><p>router-link-exact-active精准操作</p><p>另一个标签是模糊操作 例如 to&#x3D;‘&#x2F;my’ 可以匹配到&#x2F;my&#x2F;a &#x2F;my&#x2F;b这样的路径仍旧有个router-link-active属性</p><p>而精准只存在于to&#x3D;‘&#x2F;my’</p><h2 id="router-link声明式跳转传参"><a href="#router-link声明式跳转传参" class="headerlink" title="router-link声明式跳转传参"></a>router-link声明式跳转传参</h2><p>案例2</p><p>在router文件夹下创建路由.js</p><p>重复过程配置路由规则</p><pre><code>import Home from &#39;@/views/Home&#39;import Search from &#39;@/views/Search&#39;// import NotFound from &#39;@/views/NotFound&#39;import Vue from &#39;vue&#39;import VueRouter from &#39;vue-router&#39;Vue.use(VueRouter) // VueRouter插件初始化// 创建了一个路由对象const router = new VueRouter(&#123;  // 注意：一旦采用了 history 模式，地址栏就没有 #，需要后台配置访问规则  mode: &#39;history&#39;,  routes: [    &#123; path: &#39;/home&#39;, component: Home &#125;,    &#123; path: &#39;/search&#39;, component: Search &#125;,    // &#123; path: &#39;*&#39;, component: NotFound &#125;  ]&#125;)export default router</code></pre><p>在main.js引入路由对象</p><p>new Vue({</p><p> render: h &#x3D;&gt; h(App),</p><p> router</p><p>}).$mount(‘#app’)</p><p>在app.vue下设置路由组件的对应路由出口</p><p>这里使用的router-link</p><pre><code>&lt;template&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;div class=&quot;link&quot;&gt;      &lt;router-link to=&quot;/home&quot;&gt;首页&lt;/router-link&gt;      &lt;router-link to=&quot;/search&quot;&gt;搜索页&lt;/router-link&gt;    &lt;/div&gt;    &lt;router-view&gt;&lt;/router-view&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;&#125;;&lt;/script&gt;</code></pre><p>此时我们需要传参怎么办》？</p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke\blog\source_posts\VUE学习\image-20230724213914128.png" alt="image-20230724213914128"></p><p>在点击首页之后通过路由规则最终转到home页面</p><p>home页面点击黑马程序员  前端培训  如何成为前端大牛</p><p>三个连接跳转到搜索页面并且携带 自己的标签内容</p><p>  <router-link to="/search?key=黑马程序员">黑马程序员</router-link></p><p>最简单的写法直接在地址后面拼接一个param&#x3D;值的形式</p><p>接受页面用</p><p>在js中可以直接这样写</p><p><strong>$router.query.key</strong> 接受即可</p><p>在vue的created中需要加一个this.$router.query.key</p><p>因为是标识是vue对象的作用域</p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke\blog\source_posts\VUE学习\image-20230724214531226.png" alt="image-20230724214531226"></p><h3 id="声明式导航-跳转传参之动态传参"><a href="#声明式导航-跳转传参之动态传参" class="headerlink" title="声明式导航-跳转传参之动态传参"></a>声明式导航-跳转传参之动态传参</h3><p>  { path: ‘&#x2F;search&#x2F;:keys’, component: Search },</p><p>配置路由的时候需要在路径中传毒参数的地方设置 :动态参数名字</p><p>在传递参数的过程只需</p><pre><code>  &lt;router-link to=&quot;/search/前端培训&quot;&gt;前端培训&lt;/router-link&gt;</code></pre><p>直接把参数写道路径中即可</p><p>接收的时候只需要通过这总方式</p><pre><code>    &lt;p&gt;搜索关键字: &#123;&#123; $route.params.keys &#125;&#125; &lt;/p&gt;</code></pre><pre><code>&#123; path: &#39;/search/:keys/:wd&#39;, component: Search &#125;,多个参数很方便 &lt;router-link to=&quot;/search/前端培训/后端无敌&quot;&gt;前端培训&lt;/router-link&gt;    &lt;p&gt;搜索关键字: &#123;&#123; $route.params.keys &#125;&#125;       &#123;&#123; $route.params.wd &#125;&#125;&lt;/p&gt;## </code></pre><p>另外提一下我们这边设置了动态传参就必须传不穿的话有问题可以设置不必须传参</p><p>  { path: ‘&#x2F;search&#x2F;:keys?’, component: Search },</p><p>只需要在动态路由添加个？即可代表为不必须获得参数</p><p>但是我觉得这样如果有多个参数可能会有冲突</p><p>解答 ： &#x3D;&#x3D;》</p><p>由<code>/user/:userId/:optionalParam1?/:optionalParam2?</code>，其中<code>:optionalParam1</code>和<code>:optionalParam2</code>是可选参数。如果我们只传递了<code>userId</code>参数，则<code>$route.params.optionalParam1</code>和<code>$route.params.optionalParam2</code>都会是undefined，我们可以在路由组件中根据这些参数是否存在来进行相应的处理。</p><p>会变成未定义而不是冲突传值</p><p><strong>追加</strong></p><p>routes: [</p><p>  { path: ‘&#x2F;‘, redirect: ‘&#x2F;home’ },</p><p>  { path: ‘*’, component: NotFound }</p><p> ]</p><p>})</p><p>设置重定向页和404页</p><p>只需要  { path: ‘&#x2F;‘, redirect: ‘&#x2F;home’ },在路由中配置一下啊rediect即可</p><p>路由找不到即可配置个* 转到404页面</p><p>设置路径中不包含#</p><pre><code>http://localhost:8080/search?key=%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98#/home</code></pre><p>路由默认模式是hash模式路径中会包含#</p><p>const router &#x3D; new VueRouter({</p><p> &#x2F;&#x2F; 注意：一旦采用了 history 模式，地址栏就没有 #，需要后台配置访问规则</p><p> mode: ‘history’,</p><p> routes: [</p><p>  { path: ‘&#x2F;‘, redirect: ‘&#x2F;home’ },</p><p>  { path: ‘&#x2F;home’, component: Home },</p><p>  { name: ‘search’, path: ‘&#x2F;search&#x2F;:words?’, component: Search },</p><p>  { path: ‘*’, component: NotFound }</p><p> ]</p><p>})</p><p>只需把 mode: ‘history’,配置为history即可</p><h2 id="router-link"><a href="#router-link" class="headerlink" title="router-link"></a>router-link</h2><p>高亮展示</p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230723224616654.png" alt="image-20230723224616654"></p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230723225120110.png" alt="image-20230723225120110"></p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230723225224395.png" alt="image-20230723225224395"></p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230723225621524.png" alt="image-20230723225621524"></p><p>更换router高亮的的类名字 </p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230723225723812.png" alt="image-20230723225723812"></p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230723230135381.png" alt="image-20230723230135381"></p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230723231449780.png" alt="image-20230723231449780"></p><p>路径传参</p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230723231839856.png" alt="image-20230723231839856"></p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230723232203645.png" alt="image-20230723232203645"></p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230723232305841.png" alt="image-20230723232305841"></p><p><strong>路径传参变为可选参数</strong></p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230723232418201.png" alt="image-20230723232418201"></p><h2 id="重定向操作"><a href="#重定向操作" class="headerlink" title="重定向操作"></a>重定向操作</h2><p>Vue路由重定向</p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230723232636853.png" alt="image-20230723232636853"></p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230723232840692.png" alt="image-20230723232840692"></p><p>由hash模式转变为history模式去掉#</p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230723233124721.png" alt="image-20230723233124721"></p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230723233509019.png" alt="image-20230723233509019"></p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke\blog\source_posts\VUE学习\image-20230724202640978.png" alt="image-20230724202640978"></p><p>路由的案例</p><pre><code>&lt;template&gt;  &lt;div class=&quot;home&quot;&gt;    &lt;div class=&quot;logo-box&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;search-box&quot;&gt;      &lt;input type=&quot;text&quot;&gt;      &lt;button @click=&quot;goSearch&quot;&gt;搜索一下&lt;/button&gt;    &lt;/div&gt;    &lt;div class=&quot;hot-link&quot;&gt;      热门搜索：      &lt;router-link to=&quot;/search/黑马程序员&quot;&gt;黑马程序员&lt;/router-link&gt;      &lt;router-link to=&quot;/search/前端培训&quot;&gt;前端培训&lt;/router-link&gt;      &lt;router-link to=&quot;/search/如何成为前端大牛&quot;&gt;如何成为前端大牛&lt;/router-link&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;FindMusic&#39;,  methods: &#123;    goSearch () &#123;      // 1. 通过路径的方式跳转      // (1) this.$router.push(&#39;路由路径&#39;) [简写]      // this.$router.push(&#39;/search&#39;)      // (2) this.$router.push(&#123;     [完整写法]      //         path: &#39;路由路径&#39;       //     &#125;)      // this.$router.push(&#123;      //   path: &#39;/search&#39;      // &#125;)      // 2. 通过命名路由的方式跳转 (需要给路由起名字) 适合长路径      //    this.$router.push(&#123;      //        name: &#39;路由名&#39;      //    &#125;)      this.$router.push(&#123;        name: &#39;search&#39;      &#125;)    &#125;  &#125;&#125;&lt;/script&gt;&lt;style&gt;.logo-box &#123;  height: 150px;  background: url(&#39;@/assets/logo.jpeg&#39;) no-repeat center;&#125;.search-box &#123;  display: flex;  justify-content: center;&#125;.search-box input &#123;  width: 400px;  height: 30px;  line-height: 30px;  border: 2px solid #c4c7ce;  border-radius: 4px 0 0 4px;  outline: none;&#125;.search-box input:focus &#123;  border: 2px solid #ad2a26;&#125;.search-box button &#123;  width: 100px;  height: 36px;  border: none;  background-color: #ad2a26;  color: #fff;  position: relative;  left: -2px;  border-radius: 0 4px 4px 0;&#125;.hot-link &#123;  width: 508px;  height: 60px;  line-height: 60px;  margin: 0 auto;&#125;.hot-link a &#123;  margin: 0 5px;&#125;&lt;/style&gt;</code></pre><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke\blog\source_posts\VUE学习\image-20230724205858339.png" alt="image-20230724205858339"></p><h1 id="编程式导航-基本跳转"><a href="#编程式导航-基本跳转" class="headerlink" title="编程式导航-基本跳转"></a>编程式导航-基本跳转</h1><p>点击搜索一下跳转页面</p><pre><code>  &lt;button @click=&quot;goSearch&quot;&gt;搜索一下&lt;/button&gt;</code></pre><p>配置一个单击事件</p><pre><code>goSearch () &#123;   // 1. 通过路径的方式跳转   // (1) this.$router.push(&#39;路由路径&#39;) [简写]   // this.$router.push(&#39;/search&#39;)   // (2) this.$router.push(&#123;   [完整写法]   //     path: &#39;路由路径&#39;    //   &#125;)   // this.$router.push(&#123;   //  path: &#39;/search&#39;   // &#125;)</code></pre><p>简化设置用名字跳转</p><p>这样的话需要在路由规则中设置</p><pre><code>    mode: &#39;history&#39;,  routes: [    &#123; name: &#39;search&#39;, path: &#39;/search/:words?&#39;, component: Search &#125;,    &#123; path: &#39;*&#39;, component: NotFound &#125;  ]&#125;)</code></pre><pre><code>  // 2. 通过命名路由的方式跳转 (需要给路由起名字) 适合长路径      //    this.$router.push(&#123;      //        name: &#39;路由名&#39;      //    &#125;)       this.$router.push(&#123;        name: &#39;search&#39;      &#125;)</code></pre><p>编程时路由传参</p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke\blog\source_posts\VUE学习\image-20230724221911887.png" alt="image-20230724221911887"></p><pre><code>   this.$router.push(`/search?key=$&#123;this.inpValue&#125;`)   获取参数   &lt;p&gt;搜索关键字: &#123;&#123; $route.query.key &#125;&#125;    </code></pre><pre><code> this.$router.push(&#123;        path: &#39;/search&#39;,        query:&#123;          key: this.inpValue,        &#125;      &#125;)这样写更方便</code></pre><p>动态路由传参</p><p>这样记得看一下 &#96;&#96; 是支持js语法的</p><p>遵循路由中的规则</p><p> { path: ‘&#x2F;search&#x2F;:words?’, component: Search },</p><p>   this.$router.push(<code>/serch/$&#123;this.inpValue&#125;</code>)</p><h1 id="路由精美案例"><a href="#路由精美案例" class="headerlink" title="路由精美案例"></a>路由精美案例</h1><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke\blog\source_posts\VUE学习\image-20230724225532216.png" alt="image-20230724225532216"></p><p>二级路由配置</p><pre><code>const router = new VueRouter(&#123;  //通过children配置可一嵌套路由  //1.在children配置规则  //2.准备二级路由入口也就是在一级路由的页面配置 router-view  routes: [    &#123;path:&quot;/&quot;, component: Layout,children:[&#123;path:&quot;/article&quot;, component: Article&#125;,    &#123;path:&quot;/collect&quot;, component: Collect&#125;,  ]&#125;,    &#123;path:&quot;/detail&quot;, component: ArticleDetail&#125;,    &#123;path:&quot;/like&quot;, component: Like&#125;,    &#123;path:&quot;/user&quot;, component: User&#125;,      ]&#125;)</code></pre><pre><code>&lt;template&gt;  &lt;div class=&quot;h5-wrapper&quot;&gt;    &lt;div class=&quot;content&quot;&gt;      &lt;router-view&gt;&lt;/router-view&gt;    &lt;/div&gt;    &lt;nav class=&quot;tabbar&quot;&gt;      &lt;!-- 导航高亮操作      1.a标签换成router-link        2.结合高亮类操作 --&gt;      &lt;router-link to=&quot;#/article&quot;&gt;面经&lt;/router-link&gt;       &lt;router-link  to=&quot;#/collect&quot;&gt;收藏&lt;/router-link &gt;      &lt;router-link  to=&quot;#/like&quot;&gt;喜欢&lt;/router-link &gt;      &lt;router-link  to=&quot;#/user&quot;&gt;我的&lt;/router-link &gt;    &lt;/nav&gt;  &lt;/div&gt;&lt;/template&gt;style  a.router-link-active&#123;    color: aqua;  &#125;</code></pre><h2 id="十六、面经基础版-二级导航高亮"><a href="#十六、面经基础版-二级导航高亮" class="headerlink" title="十六、面经基础版-二级导航高亮"></a>十六、面经基础版-二级导航高亮</h2><h3 id="1-实现思路"><a href="#1-实现思路" class="headerlink" title="1.实现思路"></a>1.实现思路</h3><ul><li>将a标签替换成 <router-link></router-link>组件，配置to属性，不用加 #</li><li>结合高亮类名实现高亮效果 (推荐模糊匹配：router-link-active)</li></ul><h3 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2.代码实现"></a>2.代码实现</h3><p>Layout.vue</p><pre><code class="vue">....    &lt;nav class=&quot;tabbar&quot;&gt;      &lt;router-link to=&quot;/article&quot;&gt;面经&lt;/router-link&gt;      &lt;router-link to=&quot;/collect&quot;&gt;收藏&lt;/router-link&gt;      &lt;router-link to=&quot;/like&quot;&gt;喜欢&lt;/router-link&gt;      &lt;router-link to=&quot;/user&quot;&gt;我的&lt;/router-link&gt;    &lt;/nav&gt;&lt;style&gt;   a.router-link-active &#123;      color: orange;    &#125;&lt;/style&gt;</code></pre><h2 id="十七、面经基础版-首页请求渲染"><a href="#十七、面经基础版-首页请求渲染" class="headerlink" title="十七、面经基础版-首页请求渲染"></a>十七、面经基础版-首页请求渲染</h2><h3 id="1-步骤分析"><a href="#1-步骤分析" class="headerlink" title="1.步骤分析"></a>1.步骤分析</h3><p>1.安装axios </p><p>2.看接口文档，确认请求方式，请求地址，请求参数</p><p>3.created中发送请求，获取数据，存储到data中</p><p>4.页面动态渲染</p><h3 id="2-代码实现-1"><a href="#2-代码实现-1" class="headerlink" title="2.代码实现"></a>2.代码实现</h3><p>1.安装axios</p><p><code>yarn add axios </code>  <code>npm i axios</code></p><p>2.接口文档</p><pre><code class="vue">请求地址: https://mock.boxuegu.com/mock/3083/articles请求方式: get</code></pre><p>3.created中发送请求，获取数据，存储到data中</p><pre><code class="vue"> data() &#123;    return &#123;      articelList: [],    &#125;  &#125;,  async created() &#123;    const &#123;  data: &#123; result: &#123; rows &#125; &#125;&#125; = await axios.get(&#39;https://mock.boxuegu.com/mock/3083/articles&#39;)    this.articelList = rows  &#125;,</code></pre><p>4.页面动态渲染</p><pre><code class="vue">&lt;template&gt;  &lt;div class=&quot;article-page&quot;&gt;    &lt;div class=&quot;article-item&quot; v-for=&quot;item in articelList&quot; :key=&quot;item.id&quot;&gt;      &lt;div class=&quot;head&quot;&gt;        &lt;img :src=&quot;item.creatorAvatar&quot; alt=&quot;&quot; /&gt;        &lt;div class=&quot;con&quot;&gt;          &lt;p class=&quot;title&quot;&gt;&#123;&#123; item.stem &#125;&#125;&lt;/p&gt;          &lt;p class=&quot;other&quot;&gt;&#123;&#123; item.creatorName &#125;&#125; | &#123;&#123; item.createdAt &#125;&#125;&lt;/p&gt;        &lt;/div&gt;      &lt;/div&gt;      &lt;div class=&quot;body&quot;&gt;        &#123;&#123;item.content&#125;&#125;      &lt;/div&gt;      &lt;div class=&quot;foot&quot;&gt;点赞 &#123;&#123;item.likeCount&#125;&#125; | 浏览 &#123;&#123;item.views&#125;&#125;&lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><h2 id="十八、面经基础版-查询参数传参"><a href="#十八、面经基础版-查询参数传参" class="headerlink" title="十八、面经基础版-查询参数传参"></a>十八、面经基础版-查询参数传参</h2><h3 id="1-说明"><a href="#1-说明" class="headerlink" title="1.说明"></a>1.说明</h3><p>跳转详情页需要把当前点击的文章id传给详情页，获取数据</p><ul><li>查询参数传参  this.$router.push(‘&#x2F;detail?参数1&#x3D;参数值&amp;参数2&#x3D;参数值’) </li><li>动态路由传参  先改造路由 在传参  this.$router.push(‘&#x2F;detail&#x2F;参数值’)</li></ul><h3 id="2-查询参数传参实现"><a href="#2-查询参数传参实现" class="headerlink" title="2.查询参数传参实现"></a>2.查询参数传参实现</h3><p>Article.vue</p><pre><code class="vue">&lt;template&gt;  &lt;div class=&quot;article-page&quot;&gt;    &lt;div class=&quot;article-item&quot;       v-for=&quot;item in articelList&quot; :key=&quot;item.id&quot;       @click=&quot;$router.push(`/detail?id=$&#123;item.id&#125;`)&quot;&gt;     ...    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><p>ArticleDetail.vue</p><pre><code class="vue">  created()&#123;    console.log(this.$route.query.id)  &#125;</code></pre><h2 id="十九、面经基础版-动态路由传参"><a href="#十九、面经基础版-动态路由传参" class="headerlink" title="十九、面经基础版-动态路由传参"></a>十九、面经基础版-动态路由传参</h2><h3 id="1-实现步骤"><a href="#1-实现步骤" class="headerlink" title="1.实现步骤"></a>1.实现步骤</h3><ul><li>改造路由</li><li>动态传参</li><li>在详情页获取参数</li></ul><h3 id="2-代码实现-2"><a href="#2-代码实现-2" class="headerlink" title="2.代码实现"></a>2.代码实现</h3><p>改造路由</p><p>router&#x2F;index.js</p><pre><code class="js">...  &#123;      path: &#39;/detail/:id&#39;,      component: ArticleDetail  &#125;</code></pre><p>Article.vue</p><pre><code class="vue">&lt;div class=&quot;article-item&quot;      v-for=&quot;item in articelList&quot; :key=&quot;item.id&quot;      @click=&quot;$router.push(`/detail/$&#123;item.id&#125;`)&quot;&gt;       .... &lt;/div&gt;</code></pre><p>ArticleDetail.vue</p><pre><code class="vue">  created()&#123;    console.log(this.$route.params.id)  &#125;</code></pre><h3 id="3-额外优化功能点-点击回退跳转到上一页"><a href="#3-额外优化功能点-点击回退跳转到上一页" class="headerlink" title="3.额外优化功能点-点击回退跳转到上一页"></a>3.额外优化功能点-点击回退跳转到上一页</h3><p>ArticleDetail.vue</p><pre><code class="vue">&lt;template&gt;  &lt;div class=&quot;article-detail-page&quot;&gt;    &lt;nav class=&quot;nav&quot;&gt;&lt;span class=&quot;back&quot; @click=&quot;$router.back()&quot;&gt;&amp;lt;&lt;/span&gt; 面经详情&lt;/nav&gt;     ....  &lt;/div&gt;&lt;/template&gt;</code></pre><h2 id="二十、面经基础版-详情页渲染"><a href="#二十、面经基础版-详情页渲染" class="headerlink" title="二十、面经基础版-详情页渲染"></a>二十、面经基础版-详情页渲染</h2><h3 id="1-实现步骤分析"><a href="#1-实现步骤分析" class="headerlink" title="1.实现步骤分析"></a>1.实现步骤分析</h3><ul><li>导入axios</li><li>查看接口文档</li><li>在created中发送请求</li><li>页面动态渲染</li></ul><h3 id="2-代码实现-3"><a href="#2-代码实现-3" class="headerlink" title="2.代码实现"></a>2.代码实现</h3><p>接口文档</p><pre><code class="vue"> 请求地址: https://mock.boxuegu.com/mock/3083/articles/:id 请求方式: get</code></pre><p>在created中发送请求</p><pre><code class="vue"> data() &#123;    return &#123;      articleDetail:&#123;&#125;    &#125;  &#125;,  async created() &#123;    const id = this.$route.params.id    const &#123;data:&#123;result&#125;&#125; = await axios.get(      `https://mock.boxuegu.com/mock/3083/articles/$&#123;id&#125;`    )    this.articleDetail = result  &#125;,</code></pre><p>页面动态渲染</p><pre><code class="vue">&lt;template&gt;  &lt;div class=&quot;article-detail-page&quot;&gt;    &lt;nav class=&quot;nav&quot;&gt;      &lt;span class=&quot;back&quot; @click=&quot;$router.back()&quot;&gt;&amp;lt;&lt;/span&gt; 面经详情    &lt;/nav&gt;    &lt;header class=&quot;header&quot;&gt;      &lt;h1&gt;&#123;&#123;articleDetail.stem&#125;&#125;&lt;/h1&gt;      &lt;p&gt;&#123;&#123;articleDetail.createAt&#125;&#125; | &#123;&#123;articleDetail.views&#125;&#125; 浏览量 | &#123;&#123;articleDetail.likeCount&#125;&#125; 点赞数&lt;/p&gt;      &lt;p&gt;        &lt;img          :src=&quot;articleDetail.creatorAvatar&quot;          alt=&quot;&quot;        /&gt;        &lt;span&gt;&#123;&#123;articleDetail.creatorName&#125;&#125;&lt;/span&gt;      &lt;/p&gt;    &lt;/header&gt;    &lt;main class=&quot;body&quot;&gt;      &#123;&#123;articleDetail.content&#125;&#125;    &lt;/main&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><h2 id="二十一、面经基础版-缓存组件"><a href="#二十一、面经基础版-缓存组件" class="headerlink" title="二十一、面经基础版-缓存组件"></a>二十一、面经基础版-缓存组件</h2><h3 id="1-问题"><a href="#1-问题" class="headerlink" title="1.问题"></a>1.问题</h3><p>从面经列表 点到 详情页，又点返回，数据重新加载了 →  <strong>希望回到原来的位置</strong></p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke\blog\source_posts\assets\1682578630060.png" alt="68257863006"></p><h3 id="2-原因"><a href="#2-原因" class="headerlink" title="2.原因"></a>2.原因</h3><p>当路由被<strong>跳转</strong>后，原来所看到的组件就<strong>被销毁</strong>了（会执行组件内的beforeDestroy和destroyed生命周期钩子），<strong>重新返回</strong>后组件又被<strong>重新创建</strong>了（会执行组件内的beforeCreate,created,beforeMount,Mounted生命周期钩子），<strong>所以数据被加载了</strong></p><h3 id="3-解决方案"><a href="#3-解决方案" class="headerlink" title="3.解决方案"></a>3.解决方案</h3><p>利用keep-alive把原来的组件给缓存下来</p><h3 id="4-什么是keep-alive"><a href="#4-什么是keep-alive" class="headerlink" title="4.什么是keep-alive"></a>4.什么是keep-alive</h3><p>keep-alive 是 Vue 的内置组件，当它包裹动态组件时，<strong>会缓存不活动的组件实例，而不是销毁</strong>它们。</p><p>keep-alive 是一个抽象组件：它自身不会渲染成一个 DOM 元素，也不会出现在父组件中。</p><p><strong>优点：</strong></p><p>在组件切换过程中把切换出去的组件保留在内存中，防止重复渲染DOM，</p><p>减少加载时间及性能消耗，提高用户体验性。</p><p>App.vue</p><pre><code class="vue">&lt;template&gt;  &lt;div class=&quot;h5-wrapper&quot;&gt;    &lt;keep-alive&gt;      &lt;router-view&gt;&lt;/router-view&gt;    &lt;/keep-alive&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><p><strong>问题：</strong></p><p>缓存了所有被切换的组件</p><h3 id="5-keep-alive的三个属性"><a href="#5-keep-alive的三个属性" class="headerlink" title="5.keep-alive的三个属性"></a>5.keep-alive的三个属性</h3><p>① include  ： 组件名数组，只有匹配的组件<strong>会被缓存</strong></p><p>② exclude ： 组件名数组，任何匹配的组件都<strong>不会被缓存</strong></p><p>③ max       ： 最多可以<strong>缓存多少</strong>组件实例</p><p>App.vue</p><pre><code class="vue">&lt;template&gt;  &lt;div class=&quot;h5-wrapper&quot;&gt;    &lt;keep-alive :include=&quot;[&#39;LayoutPage&#39;]&quot;&gt;      &lt;router-view&gt;&lt;/router-view&gt;    &lt;/keep-alive&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><h3 id="6-额外的两个生命周期钩子"><a href="#6-额外的两个生命周期钩子" class="headerlink" title="6.额外的两个生命周期钩子"></a>6.额外的两个生命周期钩子</h3><p><strong>keep-alive的使用会触发两个生命周期函数</strong></p><p><strong>activated</strong> 当组件被激活（使用）的时候触发 →  进入这个页面的时候触发</p><p><strong>deactivated</strong> 当组件不被使用的时候触发      →  离开这个页面的时候触发</p><p>组件<strong>缓存后</strong>就<strong>不会执行</strong>组件的<strong>created, mounted, destroyed</strong> 等钩子了</p><p>所以其提供了<strong>actived 和deactived</strong>钩子，帮我们实现业务需求。</p><h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7.总结"></a>7.总结</h3><p>1.keep-alive是什么</p><p>2.keep-alive的优点</p><p>3.keep-alive的三个属性 (了解)</p><p>4.keep-alive的使用会触发两个生命周期函数(了解)</p><h2 id="二十二、VueCli-自定义创建项目"><a href="#二十二、VueCli-自定义创建项目" class="headerlink" title="二十二、VueCli 自定义创建项目"></a>二十二、VueCli 自定义创建项目</h2><p>1.安装脚手架 (已安装)</p><pre><code>npm i @vue/cli -g</code></pre><p>2.创建项目</p><pre><code>vue create hm-exp-mobile</code></pre><ul><li>选项</li></ul><pre><code class="js">Vue CLI v5.0.8? Please pick a preset:  Default ([Vue 3] babel, eslint)  Default ([Vue 2] babel, eslint)&gt; Manually select features     选自定义</code></pre><ul><li>手动选择功能</li></ul><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke\blog\source_posts\assets\1682941856172.png" alt="68294185617"></p><ul><li>选择vue的版本</li></ul><pre><code class="jsx">  3.x&gt; 2.x</code></pre><ul><li>是否使用history模式</li></ul><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke\blog\source_posts\assets\1682941888453.png" alt="image-20201025150602129"></p><ul><li>选择css预处理</li></ul><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke\blog\source_posts\assets\1682941900018.png" alt="image-20220629175133593"></p><ul><li>选择eslint的风格 （eslint 代码规范的检验工具，检验代码是否符合规范）</li><li>比如：const age &#x3D; 18;   &#x3D;&gt;  报错！多加了分号！后面有工具，一保存，全部格式化成最规范的样子</li></ul><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke\blog\source_posts\assets\1682941918562.png" alt="68294191856"></p><ul><li>选择校验的时机 （直接回车）</li></ul><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke\blog\source_posts\assets\1682941935794.png" alt="68294193579"></p><ul><li>选择配置文件的生成方式 （直接回车）</li></ul><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke\blog\source_posts\assets\1682941947985.png" alt="68294194798"></p><ul><li>是否保存预设，下次直接使用？  &#x3D;&gt;   不保存，输入 N</li></ul><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke\blog\source_posts\assets\1682941961551.png" alt="68294196155"></p><ul><li>等待安装，项目初始化完成</li></ul><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke\blog\source_posts\assets\1682941974763.png" alt="68294197476"></p><ul><li>启动项目</li></ul><pre><code>npm run serve</code></pre><h2 id="二十三、ESlint代码规范及手动修复"><a href="#二十三、ESlint代码规范及手动修复" class="headerlink" title="二十三、ESlint代码规范及手动修复"></a>二十三、ESlint代码规范及手动修复</h2><p>代码规范：一套写代码的约定规则。例如：赋值符号的左右是否需要空格？一句结束是否是要加;？… </p><blockquote><p> 没有规矩不成方圆  </p></blockquote><p>ESLint:是一个代码检查工具，用来检查你的代码是否符合指定的规则(你和你的团队可以自行约定一套规则)。在创建项目时，我们使用的是 <a href="https://standardjs.com/readme-zhcn.html">JavaScript Standard Style</a> 代码风格的规则。</p><h4 id="1-JavaScript-Standard-Style-规范说明"><a href="#1-JavaScript-Standard-Style-规范说明" class="headerlink" title="1.JavaScript Standard Style 规范说明"></a>1.JavaScript Standard Style 规范说明</h4><p>建议把：<a href="https://standardjs.com/rules-zhcn.html">https://standardjs.com/rules-zhcn.html</a> 看一遍，然后在写的时候,  遇到错误就查询解决。</p><p>下面是这份规则中的一小部分：</p><ul><li><em>字符串使用单引号</em> – 需要转义的地方除外</li><li><em>无分号</em> – <a href="http://blog.izs.me/post/2353458699/an-open-letter-to-javascript-leaders-regarding">这</a><a href="http://inimino.org/~inimino/blog/javascript_semicolons">没什么不好。</a><a href="https://www.youtube.com/watch?v=gsfbh17Ax9I">不骗你！</a></li><li><em>关键字后加空格</em> <code>if (condition) &#123; ... &#125;</code></li><li><em>函数名后加空格</em> <code>function name (arg) &#123; ... &#125;</code></li><li>坚持使用全等 <code>===</code> 摒弃 <code>==</code> 一但在需要检查 <code>null || undefined</code> 时可以使用 <code>obj == null</code></li><li>……</li></ul><h4 id="2-代码规范错误"><a href="#2-代码规范错误" class="headerlink" title="2.代码规范错误"></a>2.代码规范错误</h4><p>如果你的代码不符合standard的要求，eslint会跳出来刀子嘴，豆腐心地提示你。</p><p>下面我们在main.js中随意做一些改动：添加一些空行，空格。</p><pre><code class="js">import Vue from &#39;vue&#39;import App from &#39;./App.vue&#39;import &#39;./styles/index.less&#39;import router from &#39;./router&#39;Vue.config.productionTip = falsenew Vue ( &#123;  render: h =&gt; h(App),  router&#125;).$mount(&#39;#app&#39;)</code></pre><p>按下保存代码之后：</p><p>你将会看在控制台中输出如下错误：</p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke\blog\source_posts\VUE学习\image-20230725223826641.png" alt="image-20230725223826641"></p><blockquote><p>eslint 是来帮助你的。心态要好，有错，就改。</p></blockquote><h4 id="3-手动修正"><a href="#3-手动修正" class="headerlink" title="3.手动修正"></a>3.手动修正</h4><p>根据错误提示来一项一项手动修正。</p><p>如果你不认识命令行中的语法报错是什么意思，你可以根据错误代码（func-call-spacing, space-in-parens,…..）去 ESLint 规则列表中查找其具体含义。</p><p>打开 <a href="https://zh-hans.eslint.org/docs/latest/rules/">ESLint 规则表</a>，使用页面搜索（Ctrl + F）这个代码，查找对该规则的一个释义。</p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke\blog\source_posts\assets\1682942792219.png" alt="68294279221"></p><h2 id="二十四、通过eslint插件来实现自动修正"><a href="#二十四、通过eslint插件来实现自动修正" class="headerlink" title="二十四、通过eslint插件来实现自动修正"></a>二十四、通过eslint插件来实现自动修正</h2><blockquote><ol><li>eslint会自动高亮错误显示</li><li>通过配置，eslint会自动帮助我们修复错误</li></ol></blockquote><ul><li>如何安装</li></ul><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke\blog\source_posts\assets\1682942920986.png" alt="68294292098"></p><ul><li>如何配置</li></ul><pre><code class="js">// 当保存的时候，eslint自动帮我们修复错误&quot;editor.codeActionsOnSave&quot;: &#123;    &quot;source.fixAll&quot;: true&#125;,// 保存代码，不自动格式化&quot;editor.formatOnSave&quot;: false</code></pre><ul><li>注意：eslint的配置文件必须在根目录下，这个插件才能才能生效。打开项目必须以根目录打开，一次打开一个项目</li><li>注意：使用了eslint校验之后，把vscode带的那些格式化工具全禁用了 Beatify</li></ul><p>settings.json 参考</p><pre><code class="jsx">&#123;    &quot;window.zoomLevel&quot;: 2,    &quot;workbench.iconTheme&quot;: &quot;vscode-icons&quot;,    &quot;editor.tabSize&quot;: 2,    &quot;emmet.triggerExpansionOnTab&quot;: true,    // 当保存的时候，eslint自动帮我们修复错误    &quot;editor.codeActionsOnSave&quot;: &#123;        &quot;source.fixAll&quot;: true    &#125;,    // 保存代码，不自动格式化    &quot;editor.formatOnSave&quot;: false&#125;</code></pre><h2 id="一、Vuex-概述"><a href="#一、Vuex-概述" class="headerlink" title="一、Vuex 概述"></a>一、<a href="https://vuex.vuejs.org/zh/">Vuex</a> 概述</h2><p>目标：明确<a href="https://vuex.vuejs.org/zh/">Vuex</a>是什么，应用场景以及优势</p><h3 id="1-是什么"><a href="#1-是什么" class="headerlink" title="1.是什么"></a>1.是什么</h3><p>Vuex 是一个 Vue 的 状态管理工具，状态就是数据。</p><p>大白话：Vuex 是一个插件，可以帮我们管理 Vue 通用的数据 (多组件共享的数据)。例如：购物车数据   个人信息数</p><h3 id="2-使用场景"><a href="#2-使用场景" class="headerlink" title="2.使用场景"></a>2.使用场景</h3><ul><li><p>某个状态 在 很多个组件 来使用 (个人信息)</p></li><li><p>多个组件 共同维护 一份数据 (购物车)</p></li></ul><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke/blog/source/_posts/assets/1683178186642.png" alt="68317818664"></p><h3 id="3-优势"><a href="#3-优势" class="headerlink" title="3.优势"></a>3.优势</h3><ul><li>共同维护一份数据，<strong>数据集中化管理</strong></li><li><strong>响应式变化</strong></li><li>操作简洁 (vuex提供了一些辅助函数)</li></ul><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke/blog/source/_posts/assets/1683178293366.png" alt="68317829336"></p><h3 id="4-注意："><a href="#4-注意：" class="headerlink" title="4.注意："></a>4.注意：</h3><p>官方原文：</p><ul><li>不是所有的场景都适用于vuex，只有在必要的时候才使用vuex</li><li>使用了vuex之后，会附加更多的框架中的概念进来，增加了项目的复杂度  （数据的操作更便捷，数据的流动更清晰）</li></ul><p>Vuex就像《近视眼镜》, 你自然会知道什么时候需要用它~</p><h2 id="二、需求-多组件共享数据"><a href="#二、需求-多组件共享数据" class="headerlink" title="二、需求: 多组件共享数据"></a>二、需求: 多组件共享数据</h2><p>目标：基于脚手架创建项目，构建 vuex 多组件数据共享环境</p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke/blog/source/_posts/assets/1683178912695.png" alt="68317891269"></p><p>效果是三个组件共享一份数据:</p><ul><li>任意一个组件都可以修改数据</li><li>三个组件的数据是同步的</li></ul><h3 id="1-创建项目"><a href="#1-创建项目" class="headerlink" title="1.创建项目"></a>1.创建项目</h3><pre><code>vue create vuex-demo</code></pre><h3 id="2-创建三个组件-目录如下"><a href="#2-创建三个组件-目录如下" class="headerlink" title="2.创建三个组件, 目录如下"></a>2.创建三个组件, 目录如下</h3><pre><code>|-components|--Son1.vue|--Son2.vue|-App.vue</code></pre><h3 id="3-源代码如下"><a href="#3-源代码如下" class="headerlink" title="3.源代码如下"></a>3.源代码如下</h3><p><code>App.vue</code>在入口组件中引入 Son1 和 Son2 这两个子组件</p><pre><code class="html">&lt;template&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;h1&gt;根组件&lt;/h1&gt;    &lt;input type=&quot;text&quot;&gt;    &lt;Son1&gt;&lt;/Son1&gt;    &lt;hr&gt;    &lt;Son2&gt;&lt;/Son2&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Son1 from &#39;./components/Son1.vue&#39;import Son2 from &#39;./components/Son2.vue&#39;export default &#123;  name: &#39;app&#39;,  data: function () &#123;    return &#123;    &#125;  &#125;,  components: &#123;    Son1,    Son2  &#125;&#125;&lt;/script&gt;&lt;style&gt;#app &#123;  width: 600px;  margin: 20px auto;  border: 3px solid #ccc;  border-radius: 3px;  padding: 10px;&#125;&lt;/style&gt;</code></pre><p><code>main.js</code></p><pre><code class="js">import Vue from &#39;vue&#39;import App from &#39;./App.vue&#39;Vue.config.productionTip = falsenew Vue(&#123;  render: h =&gt; h(App)&#125;).$mount(&#39;#app&#39;)</code></pre><p><code>Son1.vue</code></p><pre><code class="html">&lt;template&gt;  &lt;div class=&quot;box&quot;&gt;    &lt;h2&gt;Son1 子组件&lt;/h2&gt;    从vuex中获取的值: &lt;label&gt;&lt;/label&gt;    &lt;br&gt;    &lt;button&gt;值 + 1&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;Son1Com&#39;&#125;&lt;/script&gt;&lt;style lang=&quot;css&quot; scoped&gt;.box&#123;  border: 3px solid #ccc;  width: 400px;  padding: 10px;  margin: 20px;&#125;h2 &#123;  margin-top: 10px;&#125;&lt;/style&gt;</code></pre><p><code>Son2.vue</code></p><pre><code class="html">&lt;template&gt;  &lt;div class=&quot;box&quot;&gt;    &lt;h2&gt;Son2 子组件&lt;/h2&gt;    从vuex中获取的值:&lt;label&gt;&lt;/label&gt;    &lt;br /&gt;    &lt;button&gt;值 - 1&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;Son2Com&#39;&#125;&lt;/script&gt;&lt;style lang=&quot;css&quot; scoped&gt;.box &#123;  border: 3px solid #ccc;  width: 400px;  padding: 10px;  margin: 20px;&#125;h2 &#123;  margin-top: 10px;&#125;&lt;/style&gt;</code></pre><h2 id="三、vuex-的使用-创建仓库"><a href="#三、vuex-的使用-创建仓库" class="headerlink" title="三、vuex 的使用 - 创建仓库"></a>三、vuex 的使用 - 创建仓库</h2><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke/blog/source/_posts/assets/1683212784179.png" alt="68321278417"></p><h3 id="1-安装-vuex"><a href="#1-安装-vuex" class="headerlink" title="1.安装 vuex"></a>1.安装 vuex</h3><p>安装vuex与vue-router类似，vuex是一个独立存在的插件，如果脚手架初始化没有选 vuex，就需要额外安装。</p><pre><code class="bash">yarn add vuex@3 或者 npm i vuex@3</code></pre><h3 id="2-新建-store-index-js-专门存放-vuex"><a href="#2-新建-store-index-js-专门存放-vuex" class="headerlink" title="2.新建 store/index.js 专门存放 vuex"></a>2.新建 <code>store/index.js</code> 专门存放 vuex</h3><p>​为了维护项目目录的整洁，在src目录下新建一个store目录其下放置一个index.js文件。 (和 <code>router/index.js</code> 类似)</p><p>​<img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke/blog/source/_posts/assets/1683212805824.png" alt="68321280582"></p><h3 id="3-创建仓库-store-index-js"><a href="#3-创建仓库-store-index-js" class="headerlink" title="3.创建仓库 store/index.js"></a>3.创建仓库 <code>store/index.js</code></h3><pre><code class="jsx">// 导入 vueimport Vue from &#39;vue&#39;// 导入 vueximport Vuex from &#39;vuex&#39;// vuex也是vue的插件, 需要use一下, 进行插件的安装初始化Vue.use(Vuex)// 创建仓库 storeconst store = new Vuex.Store()// 导出仓库export default store</code></pre><h3 id="4-在-main-js-中导入挂载到-Vue-实例上"><a href="#4-在-main-js-中导入挂载到-Vue-实例上" class="headerlink" title="4 在 main.js 中导入挂载到 Vue 实例上"></a>4 在 main.js 中导入挂载到 Vue 实例上</h3><pre><code class="js">import Vue from &#39;vue&#39;import App from &#39;./App.vue&#39;import store from &#39;./store&#39;Vue.config.productionTip = falsenew Vue(&#123;  render: h =&gt; h(App),  store&#125;).$mount(&#39;#app&#39;)</code></pre><p>此刻起, 就成功创建了一个 <strong>空仓库!!</strong></p><h3 id="5-测试打印Vuex"><a href="#5-测试打印Vuex" class="headerlink" title="5.测试打印Vuex"></a>5.测试打印Vuex</h3><p>App.vue</p><pre><code class="js">created()&#123;  console.log(this.$store)&#125;</code></pre><h2 id="四、核心概念-state-状态"><a href="#四、核心概念-state-状态" class="headerlink" title="四、核心概念 - state 状态"></a>四、核心概念 - state 状态</h2><h3 id="1-目标"><a href="#1-目标" class="headerlink" title="1.目标"></a>1.目标</h3><p>明确如何给仓库 提供 数据，如何 使用 仓库的数据</p><h3 id="2-提供数据"><a href="#2-提供数据" class="headerlink" title="2.提供数据"></a>2.提供数据</h3><p>State提供唯一的公共数据源，所有共享的数据都要统一放到Store中的State中存储。</p><p>打开项目中的store.js文件，在state对象中可以添加我们要共享的数据。</p><pre><code class="jsx">// 创建仓库 storeconst store = new Vuex.Store(&#123;  // state 状态, 即数据, 类似于vue组件中的data,  // 区别：  // 1.data 是组件自己的数据,   // 2.state 中的数据整个vue项目的组件都能访问到  state: &#123;    count: 101  &#125;&#125;)</code></pre><h3 id="3-访问Vuex中的数据"><a href="#3-访问Vuex中的数据" class="headerlink" title="3.访问Vuex中的数据"></a>3.访问Vuex中的数据</h3><p>问题: 如何在组件中获取count?</p><ol><li>通过$store直接访问  —&gt;  </li><li>通过辅助函数mapState 映射计算属性  —&gt;  </li></ol><h3 id="4-通过-store访问的语法"><a href="#4-通过-store访问的语法" class="headerlink" title="4.通过$store访问的语法"></a>4.通过$store访问的语法</h3><pre><code class="js">获取 store： 1.Vue模板中获取 this.$store 2.js文件中获取 import 导入 store模板中：     &#123;&#123; $store.state.xxx &#125;&#125;组件逻辑中：  this.$store.state.xxxJS模块中：   store.state.xxx</code></pre><h3 id="5-代码实现"><a href="#5-代码实现" class="headerlink" title="5.代码实现"></a>5.代码实现</h3><h4 id="5-1模板中使用"><a href="#5-1模板中使用" class="headerlink" title="5.1模板中使用"></a>5.1模板中使用</h4><p>组件中可以使用  <strong>$store</strong> 获取到vuex中的store对象实例，可通过<strong>state</strong>属性属性获取<strong>count</strong>， 如下</p><pre><code class="vue">&lt;h1&gt;state的数据 - &#123;&#123; $store.state.count &#125;&#125;&lt;/h1&gt;</code></pre><h4 id="5-2组件逻辑中使用"><a href="#5-2组件逻辑中使用" class="headerlink" title="5.2组件逻辑中使用"></a>5.2组件逻辑中使用</h4><p>将state属性定义在计算属性中 <a href="https://vuex.vuejs.org/zh/guide/state.html">https://vuex.vuejs.org/zh/guide/state.html</a></p><pre><code class="js">&lt;h1&gt;state的数据 - &#123;&#123; count &#125;&#125;&lt;/h1&gt;// 把state中数据，定义在组件内的计算属性中  computed: &#123;    count () &#123;      return this.$store.state.count    &#125;  &#125;</code></pre><h4 id="5-3-js文件中使用"><a href="#5-3-js文件中使用" class="headerlink" title="5.3 js文件中使用"></a>5.3 js文件中使用</h4><pre><code class="vue">//main.jsimport store from &quot;@/store&quot;console.log(store.state.count)</code></pre><p>每次都像这样一个个的提供计算属性, 太麻烦了,我们有没有简单的语法帮我们获取state中的值呢？</p><h2 id="五、通过辅助函数-mapState获取-state中的数据"><a href="#五、通过辅助函数-mapState获取-state中的数据" class="headerlink" title="五、通过辅助函数  - mapState获取 state中的数据"></a>五、通过辅助函数  - mapState获取 state中的数据</h2><blockquote><p>mapState是辅助函数，帮助我们把store中的数据映射到 组件的计算属性中, 它属于一种方便的用法</p></blockquote><p>用法 ：</p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke/blog/source/_posts/assets/1683214719574.png" alt="68321471957"> </p><h3 id="1-第一步：导入mapState-mapState是vuex中的一个函数"><a href="#1-第一步：导入mapState-mapState是vuex中的一个函数" class="headerlink" title="1.第一步：导入mapState (mapState是vuex中的一个函数)"></a>1.第一步：导入mapState (mapState是vuex中的一个函数)</h3><pre><code class="js">import &#123; mapState &#125; from &#39;vuex&#39;</code></pre><h3 id="2-第二步：采用数组形式引入state属性"><a href="#2-第二步：采用数组形式引入state属性" class="headerlink" title="2.第二步：采用数组形式引入state属性"></a>2.第二步：采用数组形式引入state属性</h3><pre><code class="js">mapState([&#39;count&#39;]) </code></pre><blockquote><p>上面代码的最终得到的是 <strong>类似于</strong></p></blockquote><pre><code class="js">count () &#123;    return this.$store.state.count&#125;</code></pre><h3 id="3-第三步：利用展开运算符将导出的状态映射给计算属性"><a href="#3-第三步：利用展开运算符将导出的状态映射给计算属性" class="headerlink" title="3.第三步：利用展开运算符将导出的状态映射给计算属性"></a>3.第三步：利用<strong>展开运算符</strong>将导出的状态映射给计算属性</h3><pre><code class="js">  computed: &#123;    ...mapState([&#39;count&#39;])  &#125;</code></pre><pre><code class="vue"> &lt;div&gt; state的数据：&#123;&#123; count &#125;&#125;&lt;/div&gt;</code></pre><h2 id="六、开启严格模式及Vuex的单项数据流"><a href="#六、开启严格模式及Vuex的单项数据流" class="headerlink" title="六、开启严格模式及Vuex的单项数据流"></a>六、开启严格模式及Vuex的单项数据流</h2><h3 id="1-目标-1"><a href="#1-目标-1" class="headerlink" title="1.目标"></a>1.目标</h3><p>明确 vuex 同样遵循单向数据流，组件中不能直接修改仓库的数据</p><h3 id="2-直接在组件中修改Vuex中state的值"><a href="#2-直接在组件中修改Vuex中state的值" class="headerlink" title="2.直接在组件中修改Vuex中state的值"></a>2.直接在组件中修改Vuex中state的值</h3><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke/blog/source/_posts/assets/1683215892288.png" alt="68321589228"></p><p>Son1.vue</p><pre><code class="vue">button @click=&quot;handleAdd&quot;&gt;值 + 1&lt;/button&gt;methods:&#123;     handleAdd (n) &#123;      // 错误代码(vue默认不会监测，监测需要成本)       this.$store.state.count++      // console.log(this.$store.state.count)     &#125;,&#125;</code></pre><h3 id="3-开启严格模式"><a href="#3-开启严格模式" class="headerlink" title="3.开启严格模式"></a>3.开启严格模式</h3><p>通过 <code>strict: true</code> 可以开启严格模式,开启严格模式后，直接修改state中的值会报错</p><blockquote><p><strong>state数据的修改只能通过mutations，并且mutations必须是同步的</strong></p></blockquote><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke/blog/source/_posts/assets/1683215821033.png" alt="68321471957"></p><h2 id="七、核心概念-mutations"><a href="#七、核心概念-mutations" class="headerlink" title="七、核心概念-mutations"></a>七、核心概念-mutations</h2><h3 id="1-定义mutations"><a href="#1-定义mutations" class="headerlink" title="1.定义mutations"></a>1.定义mutations</h3><pre><code class="js">const store  = new Vuex.Store(&#123;  state: &#123;    count: 0  &#125;,  // 定义mutations  mutations: &#123;       &#125;&#125;)</code></pre><h3 id="2-格式说明"><a href="#2-格式说明" class="headerlink" title="2.格式说明"></a>2.格式说明</h3><p>mutations是一个对象，对象中存放修改state的方法</p><pre><code class="js">mutations: &#123;    // 方法里参数 第一个参数是当前store的state属性    // payload 载荷 运输参数 调用mutaiions的时候 可以传递参数 传递载荷    addCount (state) &#123;      state.count += 1    &#125;  &#125;,</code></pre><h3 id="3-组件中提交-mutations"><a href="#3-组件中提交-mutations" class="headerlink" title="3.组件中提交 mutations"></a>3.组件中提交 mutations</h3><pre><code class="jsx">this.$store.commit(&#39;addCount&#39;)</code></pre><h3 id="4-练习"><a href="#4-练习" class="headerlink" title="4.练习"></a>4.练习</h3><p>1.在mutations中定义个点击按钮进行 +5 的方法</p><p>2.在mutations中定义个点击按钮进行 改变title 的方法</p><p>3.在组件中调用mutations修改state中的值</p><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h3><p>通过mutations修改state的步骤</p><p>1.定义 mutations 对象，对象中存放修改 state 的方法</p><p>2.组件中提交调用 mutations(通过$store.commit(‘mutations的方法名’))</p><h2 id="八、带参数的-mutations"><a href="#八、带参数的-mutations" class="headerlink" title="八、带参数的 mutations"></a>八、带参数的 mutations</h2><h3 id="1-目标："><a href="#1-目标：" class="headerlink" title="1.目标："></a>1.目标：</h3><p>掌握 mutations 传参语法</p><h3 id="2-语法"><a href="#2-语法" class="headerlink" title="2.语法"></a>2.语法</h3><p>看下面这个案例，每次点击不同的按钮，加的值都不同，每次都要定义不同的mutations处理吗？</p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke/blog/source/_posts/assets/1683217004239.png" alt="68321700423"></p><p>提交 mutation 是可以传递参数的  <code>this.$store.commit(&#39;xxx&#39;,  参数)</code></p><h4 id="2-1-提供mutation函数（带参数）"><a href="#2-1-提供mutation函数（带参数）" class="headerlink" title="2.1 提供mutation函数（带参数）"></a>2.1 提供mutation函数（带参数）</h4><pre><code class="js">mutations: &#123;  ...  addCount (state, count) &#123;    state.count = count  &#125;&#125;,</code></pre><h4 id="2-2-提交mutation"><a href="#2-2-提交mutation" class="headerlink" title="2.2 提交mutation"></a>2.2 提交mutation</h4><pre><code class="jsx">handle ( ) &#123;  this.$store.commit(&#39;addCount&#39;, 10)&#125;</code></pre><p><strong>小tips: 提交的参数只能是一个, 如果有多个参数要传, 可以传递一个对象</strong></p><pre><code class="jsx">this.$store.commit(&#39;addCount&#39;, &#123;  count: 10&#125;)</code></pre><h2 id="九、练习-mutations的减法功能"><a href="#九、练习-mutations的减法功能" class="headerlink" title="九、练习-mutations的减法功能"></a>九、练习-mutations的减法功能</h2><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke/blog/source/_posts/assets/1683217248752.png" alt="68321724875"></p><h3 id="1-步骤"><a href="#1-步骤" class="headerlink" title="1.步骤"></a>1.步骤</h3><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke/blog/source/_posts/assets/1683217268256.png" alt="68321726825"></p><h3 id="2-代码实现-4"><a href="#2-代码实现-4" class="headerlink" title="2.代码实现"></a>2.代码实现</h3><p>Son2.vue</p><pre><code class="vue">    &lt;button @click=&quot;subCount(1)&quot;&gt;值 - 1&lt;/button&gt;    &lt;button @click=&quot;subCount(5)&quot;&gt;值 - 5&lt;/button&gt;    &lt;button @click=&quot;subCount(10)&quot;&gt;值 - 10&lt;/button&gt;    export default &#123;        methods:&#123;             subCount (n) &#123;                 this.$store.commit(&#39;addCount&#39;, n)        &#125;,        &#125;    &#125;</code></pre><p>store&#x2F;index.js</p><pre><code class="js">mutations:&#123;    subCount (state, n) &#123;      state.count -= n    &#125;,&#125;</code></pre><h2 id="十、练习-Vuex中的值和组件中的input双向绑定"><a href="#十、练习-Vuex中的值和组件中的input双向绑定" class="headerlink" title="十、练习-Vuex中的值和组件中的input双向绑定"></a>十、练习-Vuex中的值和组件中的input双向绑定</h2><h3 id="1-目标-2"><a href="#1-目标-2" class="headerlink" title="1.目标"></a>1.目标</h3><p>实时输入，实时更新，巩固 mutations 传参语法</p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke/blog/source/_posts/assets/1683217697064.png" alt="68321769706"></p><h3 id="2-实现步骤"><a href="#2-实现步骤" class="headerlink" title="2.实现步骤"></a>2.实现步骤</h3><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke/blog/source/_posts/assets/1683217717788.png" alt="68321771778"></p><h3 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3.代码实现"></a>3.代码实现</h3><p>App.vue</p><pre><code class="vue">&lt;input :value=&quot;count&quot; @input=&quot;handleInput&quot; type=&quot;text&quot;&gt;export default &#123;  methods: &#123;    handleInput (e) &#123;      // 1. 实时获取输入框的值      const num = +e.target.value      // 2. 提交mutation，调用mutation函数      this.$store.commit(&#39;changeCount&#39;, num)    &#125;  &#125;&#125;</code></pre><p>store&#x2F;index.js</p><pre><code class="js">mutations: &#123;    changeCount (state, newCount) &#123;      state.count = newCount   &#125;&#125;,</code></pre><h2 id="十一、辅助函数-mapMutations"><a href="#十一、辅助函数-mapMutations" class="headerlink" title="十一、辅助函数- mapMutations"></a>十一、辅助函数- mapMutations</h2><blockquote><p>mapMutations和mapState很像，它把位于mutations中的方法提取了出来，我们可以将它导入</p></blockquote><pre><code class="js">import  &#123; mapMutations &#125; from &#39;vuex&#39;methods: &#123;    ...mapMutations([&#39;addCount&#39;])&#125;</code></pre><blockquote><p>上面代码的含义是将mutations的方法导入了methods中，等价于</p></blockquote><pre><code class="js">methods: &#123;      // commit(方法名, 载荷参数)      addCount () &#123;          this.$store.commit(&#39;addCount&#39;)      &#125; &#125;</code></pre><p>此时，就可以直接通过this.addCount调用了</p><pre><code class="jsx">&lt;button @click=&quot;addCount&quot;&gt;值+1&lt;/button&gt;</code></pre><p>但是请注意： Vuex中mutations中要求不能写异步代码，如果有异步的ajax请求，应该放置在actions中</p><h2 id="十二、核心概念-actions"><a href="#十二、核心概念-actions" class="headerlink" title="十二、核心概念 - actions"></a>十二、核心概念 - actions</h2><blockquote><p>state是存放数据的，mutations是同步更新数据 (便于监测数据的变化, 更新视图等, 方便于调试工具查看变化)，</p><p>actions则负责进行异步操作</p></blockquote><p><strong>说明：mutations必须是同步的</strong></p><p><strong>需求: 一秒钟之后, 要给一个数 去修改state</strong></p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke/blog/source/_posts/assets/1683218603674.png" alt="68321860367"></p><h3 id="1-定义actions"><a href="#1-定义actions" class="headerlink" title="1.定义actions"></a><strong>1.定义actions</strong></h3><pre><code class="js">mutations: &#123;  changeCount (state, newCount) &#123;    state.count = newCount  &#125;&#125;actions: &#123;  setAsyncCount (context, num) &#123;    // 一秒后, 给一个数, 去修改 num    setTimeout(() =&gt; &#123;      context.commit(&#39;changeCount&#39;, num)    &#125;, 1000)  &#125;&#125;,</code></pre><h3 id="2-组件中通过dispatch调用"><a href="#2-组件中通过dispatch调用" class="headerlink" title="2.组件中通过dispatch调用"></a><strong>2.组件中通过dispatch调用</strong></h3><pre><code class="js">setAsyncCount () &#123;  this.$store.dispatch(&#39;setAsyncCount&#39;, 666)&#125;</code></pre><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke/blog/source/_posts/assets/1683441987572.png" alt="68344198757"></p><h2 id="十三、辅助函数-mapActions"><a href="#十三、辅助函数-mapActions" class="headerlink" title="十三、辅助函数 -mapActions"></a>十三、辅助函数 -mapActions</h2><p>1.目标：掌握辅助函数 mapActions，映射方法</p><blockquote><p>mapActions 是把位于 actions中的方法提取了出来，映射到组件methods中</p></blockquote><p>Son2.vue</p><pre><code class="js">import &#123; mapActions &#125; from &#39;vuex&#39;methods: &#123;   ...mapActions([&#39;changeCountAction&#39;])&#125;//mapActions映射的代码 本质上是以下代码的写法//methods: &#123;//  changeCountAction (n) &#123;//    this.$store.dispatch(&#39;changeCountAction&#39;, n)//  &#125;,//&#125;</code></pre><p>直接通过 this.方法 就可以调用</p><pre><code class="vue">&lt;button @click=&quot;changeCountAction(200)&quot;&gt;+异步&lt;/button&gt;</code></pre><h2 id="十四、核心概念-getters"><a href="#十四、核心概念-getters" class="headerlink" title="十四、核心概念 - getters"></a>十四、核心概念 - getters</h2><blockquote><p>除了state之外，有时我们还需要从state中<strong>筛选出符合条件的一些数据</strong>，这些数据是依赖state的，此时会用到getters</p></blockquote><p>例如，state中定义了list，为1-10的数组，</p><pre><code class="js">state: &#123;    list: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]&#125;</code></pre><p>组件中，需要显示所有大于5的数据，正常的方式，是需要list在组件中进行再一步的处理，但是getters可以帮助我们实现它</p><h3 id="1-定义getters"><a href="#1-定义getters" class="headerlink" title="1.定义getters"></a>1.定义getters</h3><pre><code class="js">  getters: &#123;    // getters函数的第一个参数是 state    // 必须要有返回值     filterList:  state =&gt;  state.list.filter(item =&gt; item &gt; 5)  &#125;</code></pre><h3 id="2-使用getters"><a href="#2-使用getters" class="headerlink" title="2.使用getters"></a>2.使用getters</h3><h4 id="2-1原始方式-store"><a href="#2-1原始方式-store" class="headerlink" title="2.1原始方式-$store"></a>2.1原始方式-$store</h4><pre><code class="vue">&lt;div&gt;&#123;&#123; $store.getters.filterList &#125;&#125;&lt;/div&gt;</code></pre><h4 id="2-2辅助函数-mapGetters"><a href="#2-2辅助函数-mapGetters" class="headerlink" title="2.2辅助函数 - mapGetters"></a>2.2辅助函数 - mapGetters</h4><pre><code class="js">computed: &#123;    ...mapGetters([&#39;filterList&#39;])&#125;</code></pre><pre><code class="vue"> &lt;div&gt;&#123;&#123; filterList &#125;&#125;&lt;/div&gt;</code></pre><h2 id="十五、使用小结"><a href="#十五、使用小结" class="headerlink" title="十五、使用小结"></a>十五、使用小结</h2><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke/blog/source/_posts/assets/1683442133911.png" alt="68344213391"></p><h2 id="十六、核心概念-module"><a href="#十六、核心概念-module" class="headerlink" title="十六、核心概念 - module"></a>十六、核心概念 - module</h2><h3 id="1-目标-3"><a href="#1-目标-3" class="headerlink" title="1.目标"></a>1.目标</h3><p>掌握核心概念 module 模块的创建</p><h3 id="2-问题"><a href="#2-问题" class="headerlink" title="2.问题"></a>2.问题</h3><p>由于使用<strong>单一状态树</strong>，应用的所有状态<strong>会集中到一个比较大的对象</strong>。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。</p><p>这句话的意思是，如果把所有的状态都放在state中，当项目变得越来越大的时候，Vuex会变得越来越难以维护</p><p>由此，又有了Vuex的模块化</p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke/blog/source/_posts/assets/1683425758358.png" alt="68342575835"></p><h3 id="3-模块定义-准备-state"><a href="#3-模块定义-准备-state" class="headerlink" title="3.模块定义 - 准备 state"></a><strong>3.模块定义</strong> - 准备 state</h3><p>定义两个模块   <strong>user</strong> 和  <strong>setting</strong></p><p>user中管理用户的信息状态  userInfo  <code>modules/user.js</code></p><pre><code class="jsx">const state = &#123;  userInfo: &#123;    name: &#39;zs&#39;,    age: 18  &#125;&#125;const mutations = &#123;&#125;const actions = &#123;&#125;const getters = &#123;&#125;export default &#123;  state,  mutations,  actions,  getters&#125;</code></pre><p>setting中管理项目应用的  主题色 theme，描述 desc， <code>modules/setting.js</code></p><pre><code class="jsx">const state = &#123;  theme: &#39;dark&#39;  desc: &#39;描述真呀真不错&#39;&#125;const mutations = &#123;&#125;const actions = &#123;&#125;const getters = &#123;&#125;export default &#123;  state,  mutations,  actions,  getters&#125;</code></pre><p>在<code>store/index.js</code>文件中的modules配置项中，注册这两个模块</p><pre><code class="js">import user from &#39;./modules/user&#39;import setting from &#39;./modules/setting&#39;const store = new Vuex.Store(&#123;    modules:&#123;        user,        setting    &#125;&#125;)</code></pre><p>使用模块中的数据,  可以直接通过模块名访问 <code>$store.state.模块名.xxx</code>  &#x3D;&gt;  <code>$store.state.setting.desc</code></p><p>也可以通过 mapState 映射</p><h2 id="十七、获取模块内的state数据"><a href="#十七、获取模块内的state数据" class="headerlink" title="十七、获取模块内的state数据"></a>十七、获取模块内的state数据</h2><h3 id="1-目标：-1"><a href="#1-目标：-1" class="headerlink" title="1.目标："></a>1.目标：</h3><p>掌握模块中 state 的访问语法</p><p>尽管已经分模块了，但其实子模块的状态，还是会挂到根级别的 state 中，属性名就是模块名</p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke/blog/source/_posts/assets/1683427841660.png" alt="68342784166"></p><h3 id="2-使用模块中的数据"><a href="#2-使用模块中的数据" class="headerlink" title="2.使用模块中的数据"></a>2.使用模块中的数据</h3><ol><li>直接通过模块名访问 $store.state.模块名.xxx</li><li>通过 mapState 映射：<ol><li>默认根级别的映射  mapState([ ‘xxx’ ])     </li><li>子模块的映射 ：mapState(‘模块名’, [‘xxx’])  -  需要开启命名空间 <strong>namespaced:true</strong></li></ol></li></ol><p><code>modules/user.js</code></p><pre><code class="jsx">const state = &#123;  userInfo: &#123;    name: &#39;zs&#39;,    age: 18  &#125;,  myMsg: &#39;我的数据&#39;&#125;const mutations = &#123;  updateMsg (state, msg) &#123;    state.myMsg = msg  &#125;&#125;const actions = &#123;&#125;const getters = &#123;&#125;export default &#123;  namespaced: true,  state,  mutations,  actions,  getters&#125;</code></pre><h3 id="3-代码示例"><a href="#3-代码示例" class="headerlink" title="3.代码示例"></a>3.代码示例</h3><p>$store直接访问</p><pre><code class="js">$store.state.user.userInfo.name</code></pre><p>mapState辅助函数访问</p><pre><code class="js">...mapState(&#39;user&#39;, [&#39;userInfo&#39;]),...mapState(&#39;setting&#39;, [&#39;theme&#39;, &#39;desc&#39;]),</code></pre><h2 id="十八、获取模块内的getters数据"><a href="#十八、获取模块内的getters数据" class="headerlink" title="十八、获取模块内的getters数据"></a>十八、获取模块内的getters数据</h2><h3 id="1-目标：-2"><a href="#1-目标：-2" class="headerlink" title="1.目标："></a>1.目标：</h3><p>掌握模块中 getters 的访问语</p><h3 id="2-语法："><a href="#2-语法：" class="headerlink" title="2.语法："></a>2.语法：</h3><p>使用模块中 getters 中的数据： </p><ol><li>直接通过模块名访问<code> $store.getters[&#39;模块名/xxx &#39;]</code></li><li>通过 mapGetters 映射      <ol><li>默认根级别的映射  <code>mapGetters([ &#39;xxx&#39; ]) </code></li><li>子模块的映射  <code>mapGetters(&#39;模块名&#39;, [&#39;xxx&#39;])</code> -  需要开启命名空间</li></ol></li></ol><h3 id="3-代码演示"><a href="#3-代码演示" class="headerlink" title="3.代码演示"></a>3.代码演示</h3><p><code>modules/user.js</code></p><pre><code class="js">const getters = &#123;  // 分模块后，state指代子模块的state  UpperCaseName (state) &#123;    return state.userInfo.name.toUpperCase()  &#125;&#125;</code></pre><p>Son1.vue 直接访问getters</p><pre><code class="html">&lt;!-- 测试访问模块中的getters - 原生 --&gt;&lt;div&gt;&#123;&#123; $store.getters['user/UpperCaseName'] &#125;&#125;&lt;/div&gt;</code></pre><p>Son2.vue 通过命名空间访问</p><pre><code class="js">computed:&#123;  ...mapGetters(&#39;user&#39;, [&#39;UpperCaseName&#39;])&#125;</code></pre><h2 id="十九、获取模块内的mutations方法"><a href="#十九、获取模块内的mutations方法" class="headerlink" title="十九、获取模块内的mutations方法"></a>十九、获取模块内的mutations方法</h2><h3 id="1-目标：-3"><a href="#1-目标：-3" class="headerlink" title="1.目标："></a>1.目标：</h3><p>掌握模块中 mutation 的调用语法</p><h3 id="2-注意："><a href="#2-注意：" class="headerlink" title="2.注意："></a>2.注意：</h3><p>默认模块中的 mutation 和 actions 会被挂载到全局，<strong>需要开启命名空间</strong>，才会挂载到子模块。</p><h3 id="3-调用方式："><a href="#3-调用方式：" class="headerlink" title="3.调用方式："></a>3.调用方式：</h3><ol><li>直接通过 store 调用   $store.commit(‘模块名&#x2F;xxx ‘,  额外参数)</li><li>通过 mapMutations 映射    <ol><li>默认根级别的映射  mapMutations([ ‘xxx’ ])     </li><li>子模块的映射 mapMutations(‘模块名’, [‘xxx’])  -  需要开启命名空间</li></ol></li></ol><h3 id="4-代码实现"><a href="#4-代码实现" class="headerlink" title="4.代码实现"></a>4.代码实现</h3><p><code>modules/user.js</code></p><pre><code class="js">const mutations = &#123;  setUser (state, newUserInfo) &#123;    state.userInfo = newUserInfo  &#125;&#125;</code></pre><p><code>modules/setting.js</code></p><pre><code class="js">const mutations = &#123;  setTheme (state, newTheme) &#123;    state.theme = newTheme  &#125;&#125;</code></pre><p>Son1.vue</p><pre><code class="vue">&lt;button @click=&quot;updateUser&quot;&gt;更新个人信息&lt;/button&gt; &lt;button @click=&quot;updateTheme&quot;&gt;更新主题色&lt;/button&gt;export default &#123;  methods: &#123;    updateUser () &#123;      // $store.commit(&#39;模块名/mutation名&#39;, 额外传参)      this.$store.commit(&#39;user/setUser&#39;, &#123;        name: &#39;xiaowang&#39;,        age: 25      &#125;)    &#125;,     updateTheme () &#123;      this.$store.commit(&#39;setting/setTheme&#39;, &#39;pink&#39;)    &#125;  &#125;&#125;</code></pre><p>Son2.vue</p><pre><code class="vue">&lt;button @click=&quot;setUser(&#123; name: &#39;xiaoli&#39;, age: 80 &#125;)&quot;&gt;更新个人信息&lt;/button&gt;&lt;button @click=&quot;setTheme(&#39;skyblue&#39;)&quot;&gt;更新主题&lt;/button&gt;methods:&#123;// 分模块的映射...mapMutations(&#39;setting&#39;, [&#39;setTheme&#39;]),...mapMutations(&#39;user&#39;, [&#39;setUser&#39;]),&#125;</code></pre><h2 id="二十、获取模块内的actions方法"><a href="#二十、获取模块内的actions方法" class="headerlink" title="二十、获取模块内的actions方法"></a>二十、获取模块内的actions方法</h2><h3 id="1-目标：-4"><a href="#1-目标：-4" class="headerlink" title="1.目标："></a>1.目标：</h3><p>掌握模块中 action 的调用语法 (同理 - 直接类比 mutation 即可)</p><h3 id="2-注意：-1"><a href="#2-注意：-1" class="headerlink" title="2.注意："></a>2.注意：</h3><p>默认模块中的 mutation 和 actions 会被挂载到全局，<strong>需要开启命名空间</strong>，才会挂载到子模块。</p><h3 id="3-调用语法："><a href="#3-调用语法：" class="headerlink" title="3.调用语法："></a>3.调用语法：</h3><ol><li>直接通过 store 调用   $store.dispatch(‘模块名&#x2F;xxx ‘,  额外参数)</li><li>通过 mapActions 映射     <ol><li>默认根级别的映射  mapActions([ ‘xxx’ ])     </li><li>子模块的映射 mapActions(‘模块名’, [‘xxx’])  -  需要开启命名空间</li></ol></li></ol><h3 id="4-代码实现-1"><a href="#4-代码实现-1" class="headerlink" title="4.代码实现"></a>4.代码实现</h3><p>需求：</p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke/blog/source/_posts/assets/1683431615694.png" alt="68343161569"></p><p><code>modules/user.js</code></p><pre><code class="js">const actions = &#123;  setUserSecond (context, newUserInfo) &#123;    // 将异步在action中进行封装    setTimeout(() =&gt; &#123;      // 调用mutation   context上下文，默认提交的就是自己模块的action和mutation      context.commit(&#39;setUser&#39;, newUserInfo)    &#125;, 1000)  &#125;&#125;</code></pre><p>Son1.vue  直接通过store调用</p><pre><code class="vue">&lt;button @click=&quot;updateUser2&quot;&gt;一秒后更新信息&lt;/button&gt;methods:&#123;    updateUser2 () &#123;      // 调用action dispatch      this.$store.dispatch(&#39;user/setUserSecond&#39;, &#123;        name: &#39;xiaohong&#39;,        age: 28      &#125;)    &#125;,&#125;</code></pre><p>Son2.vue mapActions映射</p><pre><code class="js">&lt;button @click=&quot;setUserSecond(&#123; name: &#39;xiaoli&#39;, age: 80 &#125;)&quot;&gt;一秒后更新信息&lt;/button&gt;methods:&#123;  ...mapActions(&#39;user&#39;, [&#39;setUserSecond&#39;])&#125;</code></pre><h2 id="二十一、Vuex模块化的使用小结"><a href="#二十一、Vuex模块化的使用小结" class="headerlink" title="二十一、Vuex模块化的使用小结"></a>二十一、Vuex模块化的使用小结</h2><h3 id="1-直接使用"><a href="#1-直接使用" class="headerlink" title="1.直接使用"></a>1.直接使用</h3><ol><li>state –&gt; $store.state.<strong>模块名</strong>.数据项名</li><li>getters –&gt; $store.getters[‘<strong>模块名</strong>&#x2F;属性名’]</li><li>mutations –&gt; $store.commit(‘<strong>模块名</strong>&#x2F;方法名’, 其他参数)</li><li>actions –&gt; $store.dispatch(‘<strong>模块名</strong>&#x2F;方法名’, 其他参数)</li></ol><h3 id="2-借助辅助方法使用"><a href="#2-借助辅助方法使用" class="headerlink" title="2.借助辅助方法使用"></a>2.借助辅助方法使用</h3><p>1.import { mapXxxx, mapXxx } from ‘vuex’</p><p>computed、methods: {</p><p>​     &#x2F;&#x2F; <strong>…mapState、…mapGetters放computed中；</strong></p><p>​    &#x2F;&#x2F;  <strong>…mapMutations、…mapActions放methods中；</strong></p><p>​    …mapXxxx(<strong>‘模块名’</strong>, [‘数据项|方法’]),</p><p>​    …mapXxxx(<strong>‘模块名’</strong>, { 新的名字: 原来的名字 }),</p><p>}</p><p>2.组件中直接使用 属性 <code>&#123;&#123; age &#125;&#125;</code> 或 方法 <code>@click=&quot;updateAge(2)&quot;</code></p><h2 id="二十二、综合案例-创建项目"><a href="#二十二、综合案例-创建项目" class="headerlink" title="二十二、综合案例 - 创建项目"></a>二十二、综合案例 - 创建项目</h2><ol><li><p>脚手架新建项目 (注意：<strong>勾选vuex</strong>)      </p><p>版本说明：</p><p>vue2   vue-router3   vuex3               </p><p>vue3  vue-router4  vuex4&#x2F;pinia</p></li></ol><pre><code>vue create vue-cart-demo</code></pre><ol start="2"><li>将原本src内容清空，替换成教学资料的《vuex-cart-准备代码》</li></ol><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke/blog/source/_posts/assets/1683432959356.png" alt="68343295935"></p><p>需求：</p><ol><li>发请求动态渲染购物车，数据存vuex （存cart模块， 将来还会有user模块，article模块…）</li><li>数字框可以修改数据</li><li>动态计算总价和总数量</li></ol><h2 id="二十三、综合案例-构建vuex-cart模块"><a href="#二十三、综合案例-构建vuex-cart模块" class="headerlink" title="二十三、综合案例-构建vuex-cart模块"></a>二十三、综合案例-构建vuex-cart模块</h2><ol><li>新建 <code>store/modules/cart.js</code></li></ol><pre><code class="jsx">export default &#123;  namespaced: true,  state () &#123;    return &#123;      list: []    &#125;  &#125;,&#125;</code></pre><ol start="2"><li>挂载到 vuex 仓库上 <code>store/cart.js</code></li></ol><pre><code class="jsx">import Vuex from &#39;vuex&#39;import Vue from &#39;vue&#39;import cart from &#39;./modules/cart&#39;Vue.use(Vuex)const store = new Vuex.Store(&#123;  modules: &#123;    cart  &#125;&#125;)export default store</code></pre><h2 id="二十四、综合案例-准备后端接口服务环境-了解"><a href="#二十四、综合案例-准备后端接口服务环境-了解" class="headerlink" title="二十四、综合案例-准备后端接口服务环境(了解)"></a>二十四、综合案例-准备后端接口服务环境(了解)</h2><ol><li>安装全局工具 json-server （全局工具仅需要安装一次）</li></ol><pre><code>yarn global add json-server 或 npm i json-server  -g</code></pre><ol start="2"><li>代码根目录新建一个 db 目录</li><li>将资料 index.json 移入 db 目录</li><li>进入 db 目录，执行命令，启动后端接口服务 (使用–watch 参数 可以实时监听 json 文件的修改)</li></ol><pre><code>json-server  --watch  index.json</code></pre><h2 id="二十五、综合案例-请求动态渲染数据"><a href="#二十五、综合案例-请求动态渲染数据" class="headerlink" title="二十五、综合案例-请求动态渲染数据"></a>二十五、综合案例-请求动态渲染数据</h2><h3 id="1-目标-4"><a href="#1-目标-4" class="headerlink" title="1.目标"></a>1.目标</h3><p>请求获取数据存入 vuex, 映射渲染</p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke/blog/source/_posts/assets/1683436471929.png" alt="6834364719 2"></p><ol><li>安装 axios</li></ol><pre><code class="jsx">yarn add axios</code></pre><ol start="2"><li>准备actions 和 mutations</li></ol><pre><code class="jsx">import axios from &#39;axios&#39;export default &#123;  namespaced: true,  state () &#123;    return &#123;      list: []    &#125;  &#125;,  mutations: &#123;    updateList (state, payload) &#123;      state.list = payload    &#125;  &#125;,  actions: &#123;    async getList (ctx) &#123;      const res = await axios.get(&#39;http://localhost:3000/cart&#39;)      ctx.commit(&#39;updateList&#39;, res.data)    &#125;  &#125;&#125;</code></pre><ol start="3"><li><code>App.vue</code>页面中调用 action,  获取数据</li></ol><pre><code class="jsx">import &#123; mapState &#125; from &#39;vuex&#39;export default &#123;  name: &#39;App&#39;,  components: &#123;    CartHeader,    CartFooter,    CartItem  &#125;,  created () &#123;    this.$store.dispatch(&#39;cart/getList&#39;)  &#125;,  computed: &#123;    ...mapState(&#39;cart&#39;, [&#39;list&#39;])  &#125;&#125;</code></pre><ol start="4"><li>动态渲染</li></ol><pre><code class="jsx">&lt;!-- 商品 Item 项组件 --&gt;&lt;cart-item v-for=&quot;item in list&quot; :key=&quot;item.id&quot; :item=&quot;item&quot;&gt;&lt;/cart-item&gt;</code></pre><p><code>cart-item.vue</code></p><pre><code class="jsx">&lt;template&gt;  &lt;div class=&quot;goods-container&quot;&gt;    &lt;!-- 左侧图片区域 --&gt;    &lt;div class=&quot;left&quot;&gt;      &lt;img :src=&quot;item.thumb&quot; class=&quot;avatar&quot; alt=&quot;&quot;&gt;    &lt;/div&gt;    &lt;!-- 右侧商品区域 --&gt;    &lt;div class=&quot;right&quot;&gt;      &lt;!-- 标题 --&gt;      &lt;div class=&quot;title&quot;&gt;&#123;&#123;item.name&#125;&#125;&lt;/div&gt;      &lt;div class=&quot;info&quot;&gt;        &lt;!-- 单价 --&gt;        &lt;span class=&quot;price&quot;&gt;￥&#123;&#123;item.price&#125;&#125;&lt;/span&gt;        &lt;div class=&quot;btns&quot;&gt;          &lt;!-- 按钮区域 --&gt;          &lt;button class=&quot;btn btn-light&quot;&gt;-&lt;/button&gt;          &lt;span class=&quot;count&quot;&gt;&#123;&#123;item.count&#125;&#125;&lt;/span&gt;          &lt;button class=&quot;btn btn-light&quot;&gt;+&lt;/button&gt;        &lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;CartItem&#39;,  props: &#123;    item: Object  &#125;,  methods: &#123;  &#125;&#125;&lt;/script&gt;</code></pre><h2 id="二十六、综合案例-修改数量"><a href="#二十六、综合案例-修改数量" class="headerlink" title="二十六、综合案例-修改数量"></a>二十六、综合案例-修改数量</h2><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke/blog/source/_posts/assets/1683437346997.png" alt="68343734699"></p><ol><li>注册点击事件</li></ol><pre><code class="jsx">&lt;!-- 按钮区域 --&gt;&lt;button class=&quot;btn btn-light&quot; @click=&quot;onBtnClick(-1)&quot;&gt;-&lt;/button&gt;&lt;span class=&quot;count&quot;&gt;&#123;&#123;item.count&#125;&#125;&lt;/span&gt;&lt;button class=&quot;btn btn-light&quot; @click=&quot;onBtnClick(1)&quot;&gt;+&lt;/button&gt;</code></pre><ol start="2"><li>页面中dispatch action</li></ol><pre><code class="jsx">onBtnClick (step) &#123;  const newCount = this.item.count + step  if (newCount &lt; 1) return  // 发送修改数量请求  this.$store.dispatch(&#39;cart/updateCount&#39;, &#123;    id: this.item.id,    count: newCount  &#125;)&#125;</code></pre><ol start="3"><li>提供action函数</li></ol><pre><code class="jsx">async updateCount (ctx, payload) &#123;  await axios.patch(&#39;http://localhost:3000/cart/&#39; + payload.id, &#123;    count: payload.count  &#125;)  ctx.commit(&#39;updateCount&#39;, payload)&#125;</code></pre><ol start="4"><li>提供mutation处理函数</li></ol><pre><code class="jsx">mutations: &#123;  ...,  updateCount (state, payload) &#123;    const goods = state.list.find((item) =&gt; item.id === payload.id)    goods.count = payload.count  &#125;&#125;,</code></pre><h2 id="二十七、综合案例-底部总价展示"><a href="#二十七、综合案例-底部总价展示" class="headerlink" title="二十七、综合案例-底部总价展示"></a>二十七、综合案例-底部总价展示</h2><ol><li>提供getters</li></ol><pre><code class="jsx">getters: &#123;  total(state) &#123;    return state.list.reduce((p, c) =&gt; p + c.count, 0);  &#125;,  totalPrice (state) &#123;    return state.list.reduce((p, c) =&gt; p + c.count * c.price, 0);  &#125;,&#125;,</code></pre><ol start="2"><li>动态渲染</li></ol><pre><code class="jsx">&lt;template&gt;  &lt;div class=&quot;footer-container&quot;&gt;    &lt;!-- 中间的合计 --&gt;    &lt;div&gt;      &lt;span&gt;共 &#123;&#123;total&#125;&#125; 件商品，合计：&lt;/span&gt;      &lt;span class=&quot;price&quot;&gt;￥&#123;&#123;totalPrice&#125;&#125;&lt;/span&gt;    &lt;/div&gt;    &lt;!-- 右侧结算按钮 --&gt;    &lt;button class=&quot;btn btn-success btn-settle&quot;&gt;结算&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; mapGetters &#125; from &#39;vuex&#39;export default &#123;  name: &#39;CartFooter&#39;,  computed: &#123;    ...mapGetters(&#39;cart&#39;, [&#39;total&#39;, &#39;totalPrice&#39;])  &#125;&#125;&lt;/script&gt;</code></pre><h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><p>商城系统</p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke\blog\source_posts\VUE学习\image-20230726225416358.png" alt="image-20230726225416358"></p></slot>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo基本操作</title>
      <link href="/2023/07/15/hexo%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>/2023/07/15/hexo%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo的常用指令合集"><a href="#Hexo的常用指令合集" class="headerlink" title="Hexo的常用指令合集"></a>Hexo的常用指令合集</h1><p>xo有许多主题，其实最火爆的是NexT、Matery等，复制关键词到GitHub或者baidu都能搜到。权衡利弊最终我还是选择了大多数人使用的next。我这边先用的buttfly后期有时间再进行优化</p><h2 id="关于部署命令"><a href="#关于部署命令" class="headerlink" title="关于部署命令"></a>关于部署命令</h2><h4 id="（1）hexo-g或hexo-generate"><a href="#（1）hexo-g或hexo-generate" class="headerlink" title="（1）hexo g或hexo generate"></a>（1）<code>hexo g</code>或<code>hexo generate</code></h4><p>该命令执行后在hexo站点根目录下生成public文件夹</p><p><img src="/2023/07/15/hexo%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230715194722355.png" alt="image-20230715194722355"></p><h4 id="（2）hexo-clean"><a href="#（2）hexo-clean" class="headerlink" title="（2）hexo clean"></a>（2）<code>hexo clean</code></h4><p>把（1）中的<code>public</code>文件夹删除</p><h4 id="（3）hexo-s或hexo-server"><a href="#（3）hexo-s或hexo-server" class="headerlink" title="（3）hexo s或hexo server"></a>（3）<code>hexo s</code>或<code>hexo server</code></h4><p>启动服务，默认地址为<a href="http://localhost:4000/%EF%BC%8C4000%E7%AB%AF%E5%8F%A3">http://localhost:4000/，4000端口</a></p><p><img src="/2023/07/15/hexo%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230715194810602.png" alt="image-20230715194810602"></p><h4 id="4）hexo-d或hexo-deploy"><a href="#4）hexo-d或hexo-deploy" class="headerlink" title="4）hexo d或hexo deploy"></a>4）<code>hexo d</code>或<code>hexo deploy</code></h4><p>部署站点，在本地生成<code>.deploy_git</code>文件夹，并将编译后的文件上传至 GitHub。</p><h4 id="5）hexo-new"><a href="#5）hexo-new" class="headerlink" title="5）hexo new"></a>5）hexo new</h4><p>例如： hexo new photo “my-first-blog”<br>上述指令执行时，Hexo 会尝试在 scaffolds 中寻找photo.md布局，若找到，则根据该布局新建文章；若未找到或指令中未指定该参数，则使用post.md新建文章。新建文章的名称在_config.yml中配置。</p><h4 id="（6）删除文章"><a href="#（6）删除文章" class="headerlink" title="（6）删除文章"></a>（6）删除文章</h4><p>只需在本地把<code>source/_posts</code>文件夹下的文章源文件删除后，执行以下命令重新部署即可。</p><pre><code class="hexo">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s // 一定要先 clean，防止灵异事件发生</code></pre><h4 id="7）重新打包发布到本地"><a href="#7）重新打包发布到本地" class="headerlink" title="7）重新打包发布到本地"></a>7）重新打包发布到本地</h4><pre><code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</code></pre><h4 id="8）重新打包发布到GItHub"><a href="#8）重新打包发布到GItHub" class="headerlink" title="8）重新打包发布到GItHub"></a>8）重新打包发布到GItHub</h4><pre><code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code></pre><h1 id="Hexo写文章基本操作"><a href="#Hexo写文章基本操作" class="headerlink" title="Hexo写文章基本操作"></a>Hexo写文章基本操作</h1><h2 id="步骤1"><a href="#步骤1" class="headerlink" title="步骤1"></a>步骤1</h2><p>打开hexo的根目录，也就是里面有_config.yml, source, themes等等的那个，对于我个人我把他叫做myblog</p><h2 id="步骤2"><a href="#步骤2" class="headerlink" title="步骤2"></a>步骤2</h2><p>在该目录下打开git bash，执行该代码，可在浏览器打开<code>http://localhost:4000/</code>进行实时查看自己的网站。（注意：此时外网还不能访问本地的修改，只有提交之后才能访问。）</p><pre><code>hexo server</code></pre><h2 id="步骤3（此时还是在根目录下执行以下操作）"><a href="#步骤3（此时还是在根目录下执行以下操作）" class="headerlink" title="步骤3（此时还是在根目录下执行以下操作）"></a>步骤3（此时还是在根目录下执行以下操作）</h2><h3 id="新建发布文章（post-page）"><a href="#新建发布文章（post-page）" class="headerlink" title="新建发布文章（post page）"></a>新建发布文章（post page）</h3><p>执行以下命令后会自动在<code>\myblog\source\_posts</code>下新建一个<code>a.md</code>并且标题是“a”，此时刷新<code>http://localhost:4000/</code>可以看到本地已经更新出标题为a的这篇文章。</p><pre><code>hexo new a</code></pre><h3 id="新建草稿（draft-page）"><a href="#新建草稿（draft-page）" class="headerlink" title="新建草稿（draft page）"></a>新建草稿（draft page）</h3><p>执行以下命令后会自动在<code>\myblog\source\_drafts</code>下新建一个<code>b.md</code>并且标题是“b”，此时刷新<code>http://localhost:4000/</code>本地并没有更新出这篇文章。</p><pre><code>hexo new draft b</code></pre><h3 id="发布草稿"><a href="#发布草稿" class="headerlink" title="发布草稿"></a>发布草稿</h3><p>草稿可以通过命令变成发布文章，仍然是需要在根目录执行以下命令</p><pre><code>hexo publish b</code></pre><p>这个时候你会发现_drafts里的b.md不见了，跑到了_posts里面,也就说明你的草稿发布成功了。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第02章 MySQL的数据目录</title>
      <link href="/2023/07/15/%E7%AC%AC02%E7%AB%A0%20MySQL%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95/"/>
      <url>/2023/07/15/%E7%AC%AC02%E7%AB%A0%20MySQL%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h3 id="第02章-MySQL的数据目录"><a href="#第02章-MySQL的数据目录" class="headerlink" title="第02章 MySQL的数据目录"></a>第02章 MySQL的数据目录</h3><h4 id="1-MySQL8的主要目录结构"><a href="#1-MySQL8的主要目录结构" class="headerlink" title="1. MySQL8的主要目录结构"></a><strong>1. MySQL8的主要目录结构</strong></h4><pre><code class="shell">find / -name mysql</code></pre><h5 id="1-1-数据库文件的存放路径"><a href="#1-1-数据库文件的存放路径" class="headerlink" title="1.1 数据库文件的存放路径"></a><strong>1.1</strong> <strong>数据库文件的存放路径</strong></h5><pre><code class="mysql">show variables like &#39;datadir&#39;; # /var/lib/mysql/</code></pre><h5 id="1-2-相关命令目录"><a href="#1-2-相关命令目录" class="headerlink" title="1.2 相关命令目录"></a><strong>1.2</strong> <strong>相关命令目录</strong></h5><p><strong>相关命令目录：&#x2F;usr&#x2F;bin 和&#x2F;usr&#x2F;sbin。</strong></p><h5 id="1-3-配置文件目录"><a href="#1-3-配置文件目录" class="headerlink" title="1.3 配置文件目录"></a><strong>1.3</strong> <strong>配置文件目录</strong></h5><p><strong>配置文件目录：&#x2F;usr&#x2F;share&#x2F;mysql-8.0（命令及配置文件），&#x2F;etc&#x2F;mysql（如my.cnf）</strong></p><h4 id="2-数据库和文件系统的关系"><a href="#2-数据库和文件系统的关系" class="headerlink" title="2. 数据库和文件系统的关系"></a><strong>2.</strong> <strong>数据库和文件系统的关系</strong></h4><h5 id="2-1-表在文件系统中的表示"><a href="#2-1-表在文件系统中的表示" class="headerlink" title="2.1 表在文件系统中的表示"></a><strong>2.1</strong> <strong>表在文件系统中的表示</strong></h5><h6 id="2-3-1-InnoDB存储引擎模式"><a href="#2-3-1-InnoDB存储引擎模式" class="headerlink" title="2.3.1 InnoDB存储引擎模式"></a><strong>2.3.1 InnoDB存储引擎模式</strong></h6><p><strong>1.</strong> <strong>表结构</strong></p><p>为了保存表结构，<code>InnoDB</code>在<code>数据目录</code>下对应的数据库子目录下创建了一个专门用于<code>描述表结构的文件</code></p><pre><code>表名.frm</code></pre><p><strong>2.</strong> <strong>表中数据和索引</strong></p><p><strong>① 系统表空间（system tablespace）</strong></p><p>默认情况下，InnoDB会在数据目录下创建一个名为<code>ibdata1</code>、大小为<code>12M</code>的<code>自拓展</code>文件，这个文件就是对应的<code>系统表空间</code>在文件系统上的表示。</p><p><strong>② 独立表空间(file-per-table tablespace)</strong> </p><p>在MySQL5.6.6以及之后的版本中，InnoDB并不会默认的把各个表的数据存储到系统表空间中，而是为<code>每一个表建立一个独立表空间</code>，也就是说我们创建了多少个表，就有多少个独立表空间。使用<code>独立表空间</code>来存储表数据的话，会在该表所属数据库对应的子目录下创建一个表示该独立表空间的文件，文件名和表名相同。</p><pre><code>表名.ibd</code></pre><blockquote><p>MySQL8.0中不再单独提供<code>表名.frm</code>，而是合并在<code>表名.ibd</code>文件中。</p></blockquote><p><strong>③ 系统表空间与独立表空间的设置</strong></p><p>我们可以自己指定使用<code>系统表空间</code>还是<code>独立表空间</code>来存储数据，这个功能由启动参数<code>innodb_file_per_table</code>控制</p><pre><code class="ini">[server] innodb_file_per_table=0 # 0：代表使用系统表空间； 1：代表使用独立表空间</code></pre><p><strong>④ 其他类型的表空间</strong></p><p>随着MySQL的发展，除了上述两种老牌表空间之外，现在还新提出了一些不同类型的表空间，比如通用表空间（general tablespace）、临时表空间（temporary tablespace）等。</p><h6 id="2-3-2-MyISAM存储引擎模式"><a href="#2-3-2-MyISAM存储引擎模式" class="headerlink" title="2.3.2 MyISAM存储引擎模式"></a><strong>2.3.2 MyISAM存储引擎模式</strong></h6><p><strong>1.</strong> <strong>表结构</strong></p><p>在存储表结构方面， MyISAM 和 InnoDB 一样，也是在<code>数据目录</code>下对应的数据库子目录下创建了一个专门用于描述表结构的文件</p><pre><code>表名.frm</code></pre><p><strong>2.</strong> <strong>表中数据和索引</strong></p><p>在MyISAM中的索引全部都是<code>二级索引</code>，该存储引擎的<code>数据和索引是分开存放</code>的。所以在文件系统中也是使用不同的文件来存储数据文件和索引文件，同时表数据都存放在对应的数据库子目录下。</p><pre><code>test.frm 存储表结构 #MySQL8.0 改为了 b.xxx.sditest.MYD 存储数据 (MYData) test.MYI 存储索引 (MYIndex</code></pre><h3 id><a href="#" class="headerlink" title></a></h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第03章 用户与权限管理</title>
      <link href="/2023/07/15/%E7%AC%AC03%E7%AB%A0%20%E7%94%A8%E6%88%B7%E4%B8%8E%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"/>
      <url>/2023/07/15/%E7%AC%AC03%E7%AB%A0%20%E7%94%A8%E6%88%B7%E4%B8%8E%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="第03章-用户与权限管理"><a href="#第03章-用户与权限管理" class="headerlink" title="第03章 用户与权限管理"></a>第03章 用户与权限管理</h3><h4 id="1-用户管理"><a href="#1-用户管理" class="headerlink" title="1. 用户管理"></a><strong>1.</strong> <strong>用户管理</strong></h4><h5 id="1-1-登录MySQL服务器"><a href="#1-1-登录MySQL服务器" class="headerlink" title="1.1 登录MySQL服务器"></a><strong>1.1</strong> <strong>登录MySQL服务器</strong></h5><p>启动MySQL服务后，可以通过mysql命令来登录MySQL服务器，命令如下：</p><pre><code class="mysql">mysql –h hostname|hostIP –P port –u username –p DatabaseName –e &quot;SQL语句&quot;</code></pre><ul><li><code>-h参数</code>后面接主机名或者主机IP，hostname为主机，hostIP为主机IP。 </li><li><code>-P参数</code>后面接MySQL服务的端口，通过该参数连接到指定的端口。MySQL服务的默认端口是3306，不使用该参数时自动连接到3306端口，port为连接的端口号。</li><li><code>-u参数</code>后面接用户名，username为用户名。</li><li><code>-p参数</code>会提示输入密码。</li><li><code>DatabaseName参数</code>指明登录到哪一个数据库中。如果没有该参数，就会直接登录到MySQL数据库中，然后可以使用USE命令来选择数据库。</li><li><code>-e参数</code>后面可以直接加SQL语句。登录MySQL服务器以后即可执行这个SQL语句，然后退出MySQL服务器。</li></ul><pre><code class="mysql">mysql -uroot -p -hlocalhost -P3306 mysql -e &quot;select host,user from user&quot;</code></pre><h5 id="1-2-创建用户"><a href="#1-2-创建用户" class="headerlink" title="1.2 创建用户"></a><strong>1.2</strong> <strong>创建用户</strong></h5><pre><code class="mysql">CREATE USER 用户名 [IDENTIFIED BY &#39;密码&#39;][,用户名 [IDENTIFIED BY &#39;密码&#39;]];</code></pre><p>举例：</p><pre><code class="mysql">CREATE USER zhang3 IDENTIFIED BY &#39;123123&#39;; # 默认host是 %CREATE USER &#39;kangshifu&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;123456&#39;;</code></pre><h5 id="1-3-修改用户"><a href="#1-3-修改用户" class="headerlink" title="1.3 修改用户"></a><strong>1.3</strong> <strong>修改用户</strong></h5><pre><code class="mysql">UPDATE mysql.user SET USER=&#39;li4&#39; WHERE USER=&#39;wang5&#39;; FLUSH PRIVILEGES;</code></pre><h5 id="1-4-删除用户"><a href="#1-4-删除用户" class="headerlink" title="1.4 删除用户"></a><strong>1.4</strong> <strong>删除用户</strong></h5><p><strong>方式1：使用DROP方式删除（推荐）</strong></p><pre><code class="mysql">DROP USER user[,user]…;</code></pre><p>举例：</p><pre><code class="mysql">DROP USER li4 ; # 默认删除host为%的用户DROP USER &#39;kangshifu&#39;@&#39;localhost&#39;;</code></pre><p><strong>方式2：使用DELETE方式删除（不推荐，有残留信息）</strong></p><pre><code class="mysql">DELETE FROM mysql.user WHERE Host=’hostname’ AND User=’username’;FLUSH PRIVILEGES;</code></pre><h5 id="1-5-设置当前用户密码"><a href="#1-5-设置当前用户密码" class="headerlink" title="1.5 设置当前用户密码"></a><strong>1.5</strong> <strong>设置当前用户密码</strong></h5><p><strong>1.</strong> <strong>使用ALTER USER命令来修改当前用户密码</strong></p><pre><code class="mysql">ALTER USER USER() IDENTIFIED BY &#39;new_password&#39;;</code></pre><p><strong>2.</strong> <strong>使用SET语句来修改当前用户密码</strong></p><pre><code class="mysql">SET PASSWORD=&#39;new_password&#39;;</code></pre><h5 id="1-6-修改其它用户密码"><a href="#1-6-修改其它用户密码" class="headerlink" title="1.6 修改其它用户密码"></a><strong>1.6</strong> <strong>修改其它用户密码</strong></h5><p><strong>1.</strong> <strong>使用ALTER语句来修改普通用户的密码</strong></p><pre><code class="mysql">ALTER USER user [IDENTIFIED BY &#39;新密码&#39;] [,user[IDENTIFIED BY &#39;新密码&#39;]]…;</code></pre><p><strong>2.</strong> <strong>使用SET命令来修改普通用户的密码</strong></p><pre><code class="mysql">SET PASSWORD FOR &#39;username&#39;@&#39;hostname&#39;=&#39;new_password&#39;;</code></pre><h4 id="2-权限管理"><a href="#2-权限管理" class="headerlink" title="2. 权限管理"></a><strong>2.</strong> <strong>权限管理</strong></h4><h5 id="2-1-权限列表"><a href="#2-1-权限列表" class="headerlink" title="2.1 权限列表"></a><strong>2.1</strong> <strong>权限列表</strong></h5><pre><code class="mysql">show privileges;</code></pre><ul><li><code>CREATE和DROP权限</code>，可以创建新的数据库和表，或删除（移掉）已有的数据库和表。如果将MySQL数据库中的DROP权限授予某用户，用户就可以删除MySQL访问权限保存的数据库。</li><li><code>SELECT、INSERT、UPDATE和DELETE权限</code>允许在一个数据库现有的表上实施操作。</li><li><code>SELECT权限</code>只有在它们真正从一个表中检索行时才被用到。</li><li><code>INDEX权限</code>允许创建或删除索引，INDEX适用于已有的表。如果具有某个表的CREATE权限，就可以在CREATE TABLE语句中包括索引定义。</li><li><code>ALTER权限</code>可以使用ALTER TABLE来更改表的结构和重新命名表。</li><li><code>CREATE ROUTINE权限</code>用来创建保存的程序（函数和程序），<code>ALTER ROUTINE权限</code>用来更改和删除保存的程序，<code>EXECUTE权限</code>用来执行保存的程序。</li><li><code>GRANT权限</code>允许授权给其他用户，可用于数据库、表和保存的程序。</li><li><code>FILE权限</code>使用户可以使用LOAD DATA INFILE和SELECT … INTO OUTFILE语句读或写服务器上的文件，任何被授予FILE权限的用户都能读或写MySQL服务器上的任何文件（说明用户可以读任何数据库目录下的文件，因为服务器可以访问这些文件）。</li></ul><h5 id="2-2-授予权限的原则"><a href="#2-2-授予权限的原则" class="headerlink" title="2.2 授予权限的原则"></a><strong>2.2</strong> <strong>授予权限的原则</strong></h5><p>权限控制主要是出于安全因素，因此需要遵循以下几个<code>经验原则</code>：</p><p>1、只授予能<code>满足需要的最小权限</code>，防止用户干坏事。比如用户只是需要查询，那就只给select权限就可以了，不要给用户赋予update、insert或者delete权限。</p><p>2、创建用户的时候<code>限制用户的登录主机</code>，一般是限制成指定IP或者内网IP段。</p><p>3、为每个用户<code>设置满足密码复杂度的密码</code>。 </p><p>4、<code>定期清理不需要的用户</code>，回收权限或者删除用户。</p><h5 id="2-3-授予权限"><a href="#2-3-授予权限" class="headerlink" title="2.3 授予权限"></a><strong>2.3</strong> <strong>授予权限</strong></h5><pre><code class="mysql">GRANT 权限1,权限2,…权限n ON 数据库名称.表名称 TO 用户名@用户地址 [IDENTIFIED BY ‘密码口令’];</code></pre><ul><li>该权限如果发现没有该用户，则会直接新建一个用户。</li><li>给li4用户用本地命令行方式，授予atguigudb这个库下的所有表的插删改查的权限。</li></ul><pre><code class="mysql">GRANT SELECT,INSERT,DELETE,UPDATE ON atguigudb.* TO li4@localhost;</code></pre><ul><li>授予通过网络方式登录的joe用户 ，对所有库所有表的全部权限，密码设为123。注意这里唯独不包括grant的权限</li></ul><pre><code class="mysql">GRANT ALL PRIVILEGES ON *.* TO joe@&#39;%&#39; IDENTIFIED BY &#39;123&#39;;</code></pre><h5 id="2-4-查看权限"><a href="#2-4-查看权限" class="headerlink" title="2.4 查看权限"></a><strong>2.4</strong> <strong>查看权限</strong></h5><ul><li>查看当前用户权限</li></ul><pre><code class="mysql">SHOW GRANTS; # 或 SHOW GRANTS FOR CURRENT_USER; # 或 SHOW GRANTS FOR CURRENT_USER();</code></pre><ul><li>查看某用户的全局权限</li></ul><pre><code class="mysql">SHOW GRANTS FOR &#39;user&#39;@&#39;主机地址&#39;;</code></pre><h5 id="2-5-收回权限"><a href="#2-5-收回权限" class="headerlink" title="2.5 收回权限"></a><strong>2.5</strong> <strong>收回权限</strong></h5><p><strong>注意：在将用户账户从user表删除之前，应该收回相应用户的所有权限。</strong></p><ul><li>收回权限命令</li></ul><pre><code class="mysql">REVOKE 权限1,权限2,…权限n ON 数据库名称.表名称 FROM 用户名@用户地址;</code></pre><ul><li>举例</li></ul><pre><code class="mysql">#收回全库全表的所有权限 REVOKE ALL PRIVILEGES ON *.* FROM joe@&#39;%&#39;; #收回mysql库下的所有表的插删改查权限 REVOKE SELECT,INSERT,UPDATE,DELETE ON mysql.* FROM joe@localhost;</code></pre><ul><li>注意：<code>须用户重新登录后才能生效</code></li></ul><h4 id="3-角色管理"><a href="#3-角色管理" class="headerlink" title="3. 角色管理"></a><strong>3.</strong> <strong>角色管理</strong></h4><h5 id="3-1-创建角色"><a href="#3-1-创建角色" class="headerlink" title="3.1 创建角色"></a><strong>3.1</strong> <strong>创建角色</strong></h5><pre><code class="mysql">CREATE ROLE &#39;role_name&#39;[@&#39;host_name&#39;] [,&#39;role_name&#39;[@&#39;host_name&#39;]]...</code></pre><p>角色名称的命名规则和用户名类似。如果<code>host_name省略，默认为%</code>，<code>role_name不可省略</code>，不可为空。</p><h5 id="3-2-给角色赋予权限"><a href="#3-2-给角色赋予权限" class="headerlink" title="3.2 给角色赋予权限"></a><strong>3.2</strong> <strong>给角色赋予权限</strong></h5><pre><code class="mysql">GRANT privileges ON table_name TO &#39;role_name&#39;[@&#39;host_name&#39;];</code></pre><p>上述语句中privileges代表权限的名称，多个权限以逗号隔开。可使用SHOW语句查询权限名称</p><pre><code class="mysql">SHOW PRIVILEGES\G</code></pre><h5 id="3-3-查看角色的权限"><a href="#3-3-查看角色的权限" class="headerlink" title="3.3 查看角色的权限"></a><strong>3.3</strong> <strong>查看角色的权限</strong></h5><pre><code class="mysql">SHOW GRANTS FOR &#39;role_name&#39;;</code></pre><p>只要你创建了一个角色，系统就会自动给你一个“<code>USAGE</code>”权限，意思是<code>连接登录数据库的权限</code>。</p><h5 id="3-4-回收角色的权限"><a href="#3-4-回收角色的权限" class="headerlink" title="3.4 回收角色的权限"></a><strong>3.4</strong> <strong>回收角色的权限</strong></h5><pre><code class="mysql">REVOKE privileges ON tablename FROM &#39;rolename&#39;;</code></pre><h5 id="3-5-删除角色"><a href="#3-5-删除角色" class="headerlink" title="3.5 删除角色"></a><strong>3.5</strong> <strong>删除角色</strong></h5><pre><code class="mysql">DROP ROLE role [,role2]...</code></pre><p>注意，<code>如果你删除了角色，那么用户也就失去了通过这个角色所获得的所有权限</code>。</p><h5 id="3-6-给用户赋予角色"><a href="#3-6-给用户赋予角色" class="headerlink" title="3.6 给用户赋予角色"></a><strong>3.6</strong> <strong>给用户赋予角色</strong></h5><p>角色创建并授权后，要赋给用户并处于<code>激活状态</code>才能发挥作用。</p><pre><code class="mysql">GRANT role [,role2,...] TO user [,user2,...];</code></pre><p>查询当前已激活的角色</p><pre><code class="mysql">SELECT CURRENT_ROLE();</code></pre><h5 id="3-7-激活角色"><a href="#3-7-激活角色" class="headerlink" title="3.7 激活角色"></a><strong>3.7</strong> <strong>激活角色</strong></h5><p><strong>方式1：使用set default role 命令激活角色</strong></p><pre><code class="mysql">SET DEFAULT ROLE ALL TO &#39;kangshifu&#39;@&#39;localhost&#39;;</code></pre><p><strong>方式2：将activate_all_roles_on_login设置为ON</strong></p><pre><code class="mysql">SET GLOBAL activate_all_roles_on_login=ON;</code></pre><p>这条 SQL 语句的意思是，对<code>所有角色永久激活</code>。</p><h5 id="3-8-撤销用户的角色"><a href="#3-8-撤销用户的角色" class="headerlink" title="3.8 撤销用户的角色"></a><strong>3.8</strong> <strong>撤销用户的角色</strong></h5><pre><code class="mysql">REVOKE role FROM user;</code></pre><h5 id="3-9-设置强制角色-mandatory-role"><a href="#3-9-设置强制角色-mandatory-role" class="headerlink" title="3.9 设置强制角色(mandatory role)"></a><strong>3.9</strong> <strong>设置强制角色(mandatory role)</strong></h5><p>方式1：服务启动前设置</p><pre><code class="ini">[mysqld] mandatory_roles=&#39;role1,role2@localhost,r3@%.atguigu.com&#39;</code></pre><p>方式2：运行时设置</p><pre><code class="mysql">SET PERSIST mandatory_roles = &#39;role1,role2@localhost,r3@%.example.com&#39;; #系统重启后仍然有效SET GLOBAL mandatory_roles = &#39;role1,role2@localhost,r3@%.example.com&#39;; #系统重启后失效</code></pre><h3 id><a href="#" class="headerlink" title></a></h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第04章 逻辑架构</title>
      <link href="/2023/07/15/%E7%AC%AC04%E7%AB%A0%20%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/"/>
      <url>/2023/07/15/%E7%AC%AC04%E7%AB%A0%20%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h3 id="第04章-逻辑架构"><a href="#第04章-逻辑架构" class="headerlink" title="第04章 逻辑架构"></a>第04章 逻辑架构</h3><h4 id="1-逻辑架构剖析"><a href="#1-逻辑架构剖析" class="headerlink" title="1. 逻辑架构剖析"></a><strong>1.</strong> <strong>逻辑架构剖析</strong></h4><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203291130782.png" alt="MySQL服务器端的逻辑架构说明"></p><h5 id="1-1-第1层：连接层"><a href="#1-1-第1层：连接层" class="headerlink" title="1.1 第1层：连接层"></a><strong>1.1</strong> <strong>第1层：连接层</strong></h5><p>系统（客户端）访问<code>MySQL</code>服务器前，做的第一件事就是建立<code>TCP</code>连接。</p><p>经过三次握手建立连接成功后，<code>MySQL</code>服务器对<code>TCP</code>传输过来的账号密码做身份认证、权限获取。</p><ul><li><strong>用户名或密码不对，会收到一个Access denied for user错误，客户端程序结束执行</strong></li><li><strong>用户名密码认证通过，会从权限表查出账号拥有的权限与连接关联，之后的权限判断逻辑，都将依赖于此时读到的权限</strong></li></ul><p><code>TCP</code>连接收到请求后，必须要分配给一个线程专门与这个客户端的交互。所以还会有个线程池，去走后面的流程。每一个连接从线程池中获取线程，省去了创建和销毁线程的开销。</p><h5 id="1-2-第2层：服务层"><a href="#1-2-第2层：服务层" class="headerlink" title="1.2 第2层：服务层"></a><strong>1.2</strong> <strong>第2层：服务层</strong></h5><ul><li><p><strong>SQL Interface: SQL接口</strong></p><ul><li>接收用户的SQL命令，并且返回用户需要查询的结果。比如SELECT … FROM就是调用SQL Interface </li><li>MySQL支持DML（数据操作语言）、DDL（数据定义语言）、存储过程、视图、触发器、自定义函数等多种SQL语言接口</li></ul></li><li><p><strong>Parser:</strong> <strong>解析器</strong></p><ul><li>在解析器中对 SQL 语句进行语法分析、语义分析。将SQL语句分解成数据结构，并将这个结构传递到后续步骤，以后SQL语句的传递和处理就是基于这个结构的。如果在分解构成中遇到错误，那么就说明这个SQL语句是不合理的。</li><li>在SQL命令传递到解析器的时候会被解析器验证和解析，并为其创建<code>语法树</code>，并根据数据字典丰富查询语法树，会<code>验证该客户端是否具有执行该查询的权限</code>。创建好语法树后，MySQL还会对SQL查询进行语法上的优化，进行查询重写。</li></ul></li><li><p><strong>Optimizer:</strong> <strong>查询优化器</strong></p><ul><li>SQL语句在语法解析之后、查询之前会使用查询优化器确定 SQL 语句的执行路径，生成一个<code>执行计划</code>。</li><li>这个执行计划表明应该<code>使用哪些索引</code>进行查询（全表检索还是使用索引检索），表之间的连接顺序如何，最后会按照执行计划中的步骤调用存储引擎提供的方法来真正的执行查询，并将查询结果返回给用户。</li><li>它使用“<code>选取-投影-连接</code>”策略进行查询。例如：</li></ul><pre><code class="mysql">SELECT id,name FROM student WHERE gender = &#39;女&#39;;</code></pre><p>这个SELECT查询先根据WHERE语句进行<code>选取</code>，而不是将表全部查询出来以后再进行gender过滤。 这个SELECT查询先根据id和name进行属性<code>投影</code>，而不是将属性全部取出以后再进行过滤，将这两个查询条件<code>连接</code>起来生成最终查询结果。</p></li><li><p><strong>Caches &amp; Buffers： 查询缓存组件</strong></p><ul><li>MySQL内部维持着一些Cache和Buffer，比如Query Cache用来缓存一条SELECT语句的执行结果，如果能够在其中找到对应的查询结果，那么就不必再进行查询解析、优化和执行的整个过程了，直接将结果反馈给客户端。</li><li>这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等 。</li><li>这个查询缓存可以在<code>不同客户端之间共享</code>。 </li><li>从MySQL 5.7.20开始，不推荐使用查询缓存，并在<code>MySQL 8.0中删除</code>。</li></ul></li></ul><h5 id="1-3-第3层：引擎层"><a href="#1-3-第3层：引擎层" class="headerlink" title="1.3 第3层：引擎层"></a><strong>1.3</strong> <strong>第3层：引擎层</strong></h5><p>插件式存储引擎层（ Storage Engines），<strong>真正的负责了MySQL中数据的存储和提取，对物理服务器级别维护的底层数据执行操作</strong>，服务层通过API与存储引擎进行通信。</p><h5 id="1-4-小结"><a href="#1-4-小结" class="headerlink" title="1.4 小结"></a><strong>1.4</strong> <strong>小结</strong></h5><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203291131321.png" alt="image-20220329113126234"></p><p>简化为三层结构：</p><ol><li><p>连接层：客户端和服务器端建立连接，客户端发送 SQL 至服务器端；</p></li><li><p>SQL 层（服务层）：对 SQL 语句进行查询处理；与数据库文件的存储方式无关；</p></li><li><p>存储引擎层：与数据库文件打交道，负责数据的存储和读取。</p></li></ol><h4 id="2-SQL执行流程"><a href="#2-SQL执行流程" class="headerlink" title="2. SQL执行流程"></a><strong>2. SQL执行流程</strong></h4><h5 id="2-1-MySQL-中的-SQL执行流程"><a href="#2-1-MySQL-中的-SQL执行流程" class="headerlink" title="2.1 MySQL 中的 SQL执行流程"></a><strong>2.1 MySQL</strong> <strong>中的</strong> <strong>SQL执行流程</strong></h5><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203291133116.png" alt="image-20220329113337008"></p><p><strong>MySQL的查询流程：</strong></p><p><strong>1.</strong> <strong>查询缓存</strong>：Server 如果在查询缓存中发现了这条 SQL 语句，就会直接将结果返回给客户端；如果没有，就进入到解析器阶段。需要说明的是，因为查询缓存往往效率不高，所以在 MySQL8.0 之后就抛弃了这个功能。</p><p>查询缓存是提前把查询结果缓存起来，这样下次不需要执行就可以直接拿到结果。需要说明的是，在MySQL 中的查询缓存，不是缓存查询计划，而是查询对应的结果。这就意味着查询匹配的<code>鲁棒性大大降低</code>，只有<code>相同的查询操作才会命中查询缓存</code>。两个查询请求在任何字符上的不同（例如：空格、注释、大小写），都会导致缓存不会命中。因此 MySQL 的 查询缓存命中率不高 。</p><p>同时，如果查询请求中包含某些系统函数、用户自定义变量和函数、一些系统表，如 mysql、 information_schema、 performance_schema 数据库中的表，那这个请求就不会被缓存。</p><p>此外，既然是缓存，那就有它<code>缓存失效的时候</code>。MySQL的缓存系统会监测涉及到的每张表，只要该表的结构或者数据被修改，如对该表使用了<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>、<code>TRUNCATE TABLE</code>、<code>ALTER TABLE</code>、<code>DROP TABLE</code>或<code>DROP DATABASE</code>语句，那使用该表的所有高速缓存查询都将变为无效并从高速缓存中删除！对于<code>更新压力大的数据库</code>来说，查询缓存的命中率会非常低。</p><p><strong>2.</strong> <strong>解析器</strong>：在解析器中对 SQL 语句进行语法分析、语义分析。</p><p>分析器先做“<code>词法分析</code>”。你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是什么，代表什么。 MySQL 从你输入的”select”这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名 T”，把字符串“ID”识别成“列 ID”。</p><p>接着，要做“<code>语法分析</code>”。根据词法分析的结果，语法分析器（比如：Bison）会根据语法规则，判断你输入的这个 SQL 语句是否<code>满足 MySQL 语法</code>。如果SQL语句正确，则会生成一个语法树。</p><p><strong>3.</strong> <strong>优化器</strong>：在优化器中会确定 SQL 语句的执行路径，比如是根据<code>全表检索</code>，还是根据<code>索引检索</code>等。在查询优化器中，可以分为<code>逻辑查询</code>优化阶段和<code>物理查询</code>优化阶段。</p><p><strong>4.</strong> <strong>执行器</strong>：在执行之前需要判断该用户是否<code>具备权限</code>。如果没有，就会返回权限错误。如果具备权限，就执行 SQL查询并返回结果。在 MySQL8.0 以下的版本，如果设置了查询缓存，这时会将查询结果进行缓存。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203291145074.png" alt="image-20220329114541991"></p><p>SQL 语句在 MySQL 中的流程是： SQL语句→查询缓存→解析器→优化器→执行器 。</p><h4 id="3-数据库缓冲池-buffer-pool"><a href="#3-数据库缓冲池-buffer-pool" class="headerlink" title="3. 数据库缓冲池(buffer pool)"></a><strong>3.</strong> <strong>数据库缓冲池(buffer pool)</strong></h4><p><code>InnoDB</code>存储引擎是以页为单位来管理存储空间的，我们进行的增删改查操作其实本质上都是在访问页面（包括读页面、写页面、创建新页面等操作）。而磁盘 I&#x2F;O 需要消耗的时间很多，而在内存中进行操作，效率则会高很多，为了能让数据表或者索引中的数据随时被我们所用，DBMS 会申请<code>占用内存来作为数据缓冲池</code>，在真正访问页面之前，需要把在磁盘上的页缓存到内存中的<code>Buffer Pool</code>之后才可以访问。</p><p>这样做的好处是可以让磁盘活动最小化，从而<code>减少与磁盘直接进行 I/O 的时间</code>。要知道，这种策略对提升 SQL 语句的查询性能来说至关重要。如果索引的数据在缓冲池里，那么访问的成本就会降低很多。</p><h5 id="3-1-缓冲池-vs-查询缓存"><a href="#3-1-缓冲池-vs-查询缓存" class="headerlink" title="3.1 缓冲池 vs 查询缓存"></a><strong>3.1</strong> <strong>缓冲池</strong> <strong>vs</strong> <strong>查询缓存</strong></h5><p><strong>1.</strong> <strong>缓冲池（Buffer Pool）</strong></p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203291155004.png" alt="image-20220329115517901"></p><p>从图中，你能看到 InnoDB 缓冲池包括了数据页、索引页、插入缓冲、锁信息、自适应 Hash 和数据字典信息等。</p><p><strong>缓存原则：</strong></p><p>“<code>位置 * 频次</code>”这个原则，可以帮我们对 I&#x2F;O 访问效率进行优化。</p><p>首先，位置决定效率，提供缓冲池就是为了在内存中可以直接访问数据。</p><p>其次，频次决定优先级顺序。因为缓冲池的大小是有限的，比如磁盘有 200G，但是内存只有 16G，缓冲池大小只有 1G，就无法将所有数据都加载到缓冲池里，这时就涉及到优先级顺序，会<code>优先对使用频次高的热数据进行加载</code>。</p><p><strong>2.</strong> <strong>查询缓存</strong></p><p>查询缓存是提前把<code>查询结果缓存</code>起来，这样下次不需要执行就可以直接拿到结果。需要说明的是，在MySQL 中的查询缓存，不是缓存查询计划，而是查询对应的结果。因为命中条件苛刻，而且只要数据表发生变化，查询缓存就会失效，因此命中率低。</p><h5 id="3-2-缓冲池如何读取数据"><a href="#3-2-缓冲池如何读取数据" class="headerlink" title="3.2 缓冲池如何读取数据"></a><strong>3.2</strong> <strong>缓冲池如何读取数据</strong></h5><p>缓冲池管理器会尽量将经常使用的数据保存起来，在数据库进行页面读操作的时候，首先会判断该页面是否在缓冲池中，如果存在就直接读取，如果不存在，就会通过内存或磁盘将页面存放到缓冲池中再进行读取。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203291159111.png" alt="image-20220329115958009"></p><h5 id="3-3-查看-x2F-设置缓冲池的大小"><a href="#3-3-查看-x2F-设置缓冲池的大小" class="headerlink" title="3.3 查看&#x2F;设置缓冲池的大小"></a><strong>3.3</strong> <strong>查看&#x2F;设置缓冲池的大小</strong></h5><p>查看缓冲池的大小</p><pre><code class="mysql">show variables like &#39;innodb_buffer_pool_size&#39;;</code></pre><p>设置缓冲池的大小</p><pre><code class="mysql">set global innodb_buffer_pool_size = 268435456;</code></pre><p>或者</p><pre><code class="ini">[server] innodb_buffer_pool_size = 268435456</code></pre><h5 id="3-4-多个Buffer-Pool实例"><a href="#3-4-多个Buffer-Pool实例" class="headerlink" title="3.4 多个Buffer Pool实例"></a><strong>3.4</strong> <strong>多个Buffer Pool实例</strong></h5><pre><code class="ini">[server] innodb_buffer_pool_instances = 2</code></pre><p>何查看缓冲池的个数</p><pre><code class="mysql">show variables like &#39;innodb_buffer_pool_instances&#39;;</code></pre><p>每个<code>Buffer Pool</code>实例实际占内存空间</p><pre><code>innodb_buffer_pool_size/innodb_buffer_pool_instances</code></pre><h3 id><a href="#" class="headerlink" title></a></h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第06章 索引的数据结构</title>
      <link href="/2023/07/15/%E7%AC%AC06%E7%AB%A0%20%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2023/07/15/%E7%AC%AC06%E7%AB%A0%20%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h3 id="第06章-索引的数据结构"><a href="#第06章-索引的数据结构" class="headerlink" title="第06章 索引的数据结构"></a>第06章 索引的数据结构</h3><h4 id="1-索引及其优缺点"><a href="#1-索引及其优缺点" class="headerlink" title="1. 索引及其优缺点"></a><strong>1.</strong> <strong>索引及其优缺点</strong></h4><h5 id="1-1-索引概述"><a href="#1-1-索引概述" class="headerlink" title="1.1 索引概述"></a><strong>1.1</strong> <strong>索引概述</strong></h5><p>MySQL官方对索引的定义为：<strong>索引（Index）是帮助MySQL高效获取数据的数据结构</strong>。</p><p><strong>索引的本质：</strong>索引是数据结构。你可以简单理解为“排好序的快速查找数据结构”，满足特定查找算法。这些数据结构以某种方式指向数据， 这样就可以在这些数据结构的基础上实现<code>高级查找算法</code>。</p><h5 id="1-2-优点"><a href="#1-2-优点" class="headerlink" title="1.2 优点"></a><strong>1.2</strong> <strong>优点</strong></h5><p>（1）类似大学图书馆建书目索引，提高数据检索的效率，降低<code>数据库的IO成本</code>，这也是创建索引最主要的原因。</p><p>（2）通过创建唯一索引，可以保证数据库表中每一行<code>数据的唯一性</code>。</p><p>（3）在实现数据的参考完整性方面，可以<code>加速表和表之间的连接</code>。换句话说，对于有依赖关系的子表和父表联合查询时，可以提高查询速度。</p><p>（4）在使用分组和排序子句进行数据查询时，可以显著<code>减少查询中分组和排序的时间</code>，降低了CPU的消耗。</p><h5 id="1-3-缺点"><a href="#1-3-缺点" class="headerlink" title="1.3 缺点"></a><strong>1.3</strong> <strong>缺点</strong></h5><p>（1）创建索引和维护索引要<code>耗费时间</code>，并且随着数据量的增加，所耗费的时间也会增加。</p><p>（2）索引需要占<code>磁盘空间</code>，除了数据表占数据空间之外，每一个索引还要占一定的物理空间<code>存储在磁盘上</code>，如果有大量的索引，索引文件就可能比数据文件更快达到最大文件尺寸。</p><p>（3）虽然索引大大提高了查询速度，同时却会<code>降低更新表的速度</code>。当对表中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。</p><h4 id="2-InnoDB中索引的推演"><a href="#2-InnoDB中索引的推演" class="headerlink" title="2. InnoDB中索引的推演"></a><strong>2. InnoDB中索引的推演</strong></h4><h5 id="2-1-索引之前的查找"><a href="#2-1-索引之前的查找" class="headerlink" title="2.1 索引之前的查找"></a><strong>2.1</strong> <strong>索引之前的查找</strong></h5><pre><code class="mysql">SELECT [列名列表] FROM 表名 WHERE 列名 = xxx;</code></pre><p><strong>1.在一个页中的查找</strong></p><p>假设目前表中的记录比较少，所有的记录都可以被存放在一个页中，在查找记录的时候可以根据搜索条件的不同分为两种情况：</p><ul><li>以主键为搜索条件<ul><li>可以在页目录中使用<code>二分法</code>快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。</li></ul></li><li>以其他列作为搜索条件<ul><li>因为在数据页中并没有对非主键建立所谓的页目录，所以我们无法通过二分法快速定位相应的槽。这种情况下只能从最小记录开始依次遍历单链表中的每条记录，然后对比每条记录是不是符合搜索条件。很显然，这种查找的效率是非常低的。</li></ul></li></ul><p><strong>2.在很多页中查找</strong></p><p>大部分情况下我们表中存放的记录都是非常多的，需要好多的数据页来存储这些记录。在很多页中查找记录的话可以分为两个步骤：</p><ol><li>定位到记录所在的页。</li><li>从所在的页内查找相应的记录。</li></ol><p>在没有索引的情况下，不论是根据主键列或者其他列的值进行查找，由于我们并不能快速的定位到记录所在的页，所以只能<code>从第一个页</code>沿着<code>双向链表</code>一直往下找，在每一个页中根据我们上面的查找方式去查找指定的记录。因为要遍历所有的数据页，所以这种方式显然是<code>超级耗时</code>的。</p><h5 id="2-2-设计索引"><a href="#2-2-设计索引" class="headerlink" title="2.2 设计索引"></a><strong>2.2</strong> <strong>设计索引</strong></h5><pre><code class="mysql">mysql&gt; CREATE TABLE index_demo(    -&gt; c1 INT,    -&gt; c2 INT,    -&gt; c3 CHAR(1),    -&gt; PRIMARY KEY(c1)    -&gt; ) ROW_FORMAT = Compact;</code></pre><p>这个新建的<code>index_demo</code>表中有2个INT类型的列，1个CHAR(1)类型的列，而且我们规定了c1列为主键，这个表使用<code>Compact</code>行格式来实际存储记录的。这里我们简化了index_demo表的行格式示意图：</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203300956080.png" alt="image-20220330095642965"></p><ul><li><code>record_type</code>：记录头信息的一项属性，表示记录的类型，<code>0</code>表示普通记录、<code>1</code>表示目录项记录、<code>2</code>表示最小记录、<code>3</code>表示最大记录。</li><li><code>next_record</code>：记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量，我们用箭头来表明下一条记录是谁。</li><li><code>各个列的值</code>：这里只记录在<code>index_demo</code>表中的三个列，分别是<code>c1</code>、<code>c2</code>和<code>c3</code>。 </li><li><code>其他信息</code>：除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。</li></ul><p>将记录格式示意图的其他信息项暂时去掉并把它竖起来的效果就是这样：</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301000365.png" alt="image-20220330100053271"></p><p>把一些记录放到页里的示意图就是：</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301001377.png" alt="image-20220330100150297"></p><p><strong>1.</strong> <strong>一个简单的索引设计方案</strong></p><p>我们在根据某个搜索条件查找一些记录时为什么要遍历所有的数据页呢？因为各个页中的记录并没有规律，我们并不知道我们的搜索条件匹配哪些页中的记录，所以不得不依次遍历所有的数据页。所以如果我们<code>想快速的定位到需要查找的记录在哪些数据页</code>中该咋办？我们可以为快速定位记录所在的数据页而<code>建立一个目录</code>，建这个目录必须完成下边这些事：</p><ul><li><strong>下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。</strong></li><li><strong>给所有的页建立一个目录项。</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301004386.png" alt="image-20220330100409306"></p><p>以<code>页28</code>为例，它对应<code>目录项2</code>，这个目录项中包含着该页的页号<code>28</code>以及该页中用户记录的最小主键值<code>5</code>。我们只需要把几个目录项在物理存储器上连续存储（比如：数组），就可以实现根据主键值快速查找某条记录的功能了。比如：查找主键值为<code>20</code>的记录，具体查找过程分两步：</p><ol><li><p>先从目录项中根据<code>二分法</code>快速确定出主键值为<code>20</code>的记录在<code>目录项3</code>中（因为 12 &lt; 20 &lt; 209 ），它对应的页是<code>页9</code>。 </p></li><li><p>再根据前边说的在页中查找记录的方式去<code>页9</code>中定位具体的记录。</p></li></ol><p>至此，针对数据页做的简易目录就搞定了。这个目录有一个别名，称为<code>索引</code>。</p><p><strong>2. InnoDB中的索引方案</strong> </p><p><strong>① 迭代1次：目录项纪录的页</strong></p><p>我们把前边使用到的目录项放到数据页中的样子就是这样：</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301028743.png" alt="image-20220330102834658"></p><p>从图中可以看出来，我们新分配了一个编号为30的页来专门存储目录项记录。这里再次强调<code>目录项记录</code>和普通的<code>用户记录</code>的<strong>不同点</strong>：</p><ul><li><code>目录项记录</code>的<code>record_type</code>值是1，而<code>普通用户记录</code>的<code>record_type</code>值是0。</li><li>目录项记录只有<code>主键值和页的编号</code>两个列，而普通的用户记录的列是用户自己定义的，可能包含<code>很多列</code>，另外还有InnoDB自己添加的隐藏列。</li><li>了解：记录头信息里还有一个叫<code>min_rec_mask</code>的属性，只有在存储<code>目录项记录</code>的页中的主键值最小的<code>目录项记录</code>的<code>min_rec_mask</code>值为<code>1</code>，其他别的记录的<code>min_rec_mask</code>值都是<code>0</code>。</li></ul><p><strong>相同点：</strong>两者用的是一样的数据页，都会为主键值生成<code>Page Directory</code>（页目录），从而在按照主键值进行查找时可以使用<code>二分法</code>来加快查询速度。</p><p>现在以查找主键为<code>20</code>的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边两步：</p><ol><li><p>先到存储<code>目录项记录</code>的页，也就是页30中通过<code>二分法</code>快速定位到对应目录项，因为 12 &lt; 20 &lt; 209 ，所以定位到对应的记录所在的页就是页9。 </p></li><li><p>再到存储用户记录的页9中根据<code>二分法</code>快速定位到主键值为<code>20</code>的用户记录。</p></li></ol><p><strong>② 迭代2次：多个目录项纪录的页</strong></p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301034997.png" alt="image-20220330103442914"></p><p>从图中可以看出，我们插入了一条主键值为320的用户记录之后需要两个新的数据页：</p><ul><li>为存储该用户记录而新生成了<code>页31</code>。</li><li>因为原先存储目录项记录的<code>页30的容量已满</code>（我们前边假设只能存储4条目录项记录），所以不得不需要一个新的<code>页32</code>来存放<code>页31</code>对应的目录项。</li></ul><p>现在因为存储目录项记录的页不止一个，所以如果我们想根据主键值查找一条用户记录大致需要3个步骤，以查找主键值为<code>20</code>的记录为例：</p><ol><li><p>确定<code>目录项记录页</code>我们现在的存储目录项记录的页有两个，即<code>页30</code>和<code>页32</code>，又因为页30表示的目录项的主键值的范围是 [1, 320) ，页32表示的目录项的主键值不小于 320 ，所以主键值为<code>20</code>的记录对应的目录项记录在<code>页30</code>中。</p></li><li><p>通过目录项记录页<code>确定用户记录真实所在的页</code>。在一个存储<code>目录项记录</code>的页中通过主键值定位一条目录项记录的方式说过了。</p></li><li><p>在真实存储用户记录的页中定位到具体的记录。</p></li></ol><p><strong>③ 迭代3次：目录项记录页的目录页</strong></p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301038376.png" alt="image-20220330103847284"></p><p>如图，我们生成了一个存储更高级目录项的<code>页33</code>，这个页中的两条记录分别代表页30和页32，如果用户记录的主键值在<code>[1, 320)</code>之间，则到页30中查找更详细的目录项记录，如果主键值<code>不小于320</code>的话，就到页32中查找更详细的目录项记录。</p><p>我们可以用下边这个图来描述它：</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301040190.png" alt="image-20220330104012108"></p><p>这个数据结构，它的名称是<code>B+树</code>。 </p><p><strong>④</strong> <strong>B+Tree</strong></p><p>一个B+树的节点其实可以分成好多层，规定最下边的那层，也就是存放我们用户记录的那层为第<code>0</code>层，之后依次往上加。之前我们做了一个非常极端的假设：存放用户记录的页<code>最多存放3条记录</code>，存放目录项记录的页<code>最多存放4条记录</code>。其实真实环境中一个页存放的记录数量是非常大的，假设所有存放用户记录的叶子节点代表的数据页可以存放<code>100条用户记录</code>，所有存放目录项记录的内节点代表的数据页可以存放<code>1000条目录项记录</code>，那么：</p><ul><li>如果B+树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放<code>100</code>条记录。</li><li>如果B+树有2层，最多能存放<code>1000×100=10,0000</code>条记录。</li><li>如果B+树有3层，最多能存放<code>1000×1000×100=1,0000,0000</code>条记录。</li><li>如果B+树有4层，最多能存放<code>1000×1000×1000×100=1000,0000,0000</code>条记录。相当多的记录！！！</li></ul><p>你的表里能存放<code>100000000000</code>条记录吗？所以一般情况下，我们<code>用到的B+树都不会超过4层</code>，那我们通过主键值去查找某条记录最多只需要做4个页面内的查找（查找3个目录项页和一个用户记录页），又因为在每个页面内有所谓的<code>Page Directory</code>（页目录），所以在页面内也可以通过<code>二分法</code>实现快速定位记录。</p><h5 id="2-3-常见索引概念"><a href="#2-3-常见索引概念" class="headerlink" title="2.3 常见索引概念"></a><strong>2.3</strong> <strong>常见索引概念</strong></h5><p><strong>1.</strong> <strong>聚簇索引</strong></p><p><strong>特点：</strong></p><ol><li><p>使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：</p><ul><li><p><code>页内</code>的记录是按照主键的大小顺序排成一个<code>单向链表</code>。</p></li><li><p>各个存放<code>用户记录的页</code>也是根据页中用户记录的主键大小顺序排成一个<code>双向链表</code>。</p></li><li><p>存放<code>目录项记录的页</code>分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个<code>双向链表</code>。</p></li></ul></li><li><p>B+树的<code>叶子节点</code>存储的是完整的用户记录。</p><p>所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。</p></li></ol><p><strong>优点：</strong></p><ul><li><code>数据访问更快</code>，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快</li><li>聚簇索引对于主键的<code>排序查找</code>和<code>范围查找</code>速度非常快</li><li>按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多个数据块中提取数据，所以<code>节省了大量的io操作</code>。</li></ul><p><strong>缺点：</strong></p><ul><li><code>插入速度严重依赖于插入顺序</code>，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个<strong>自增ID列为主键</strong></li><li><code>更新主键的代价很高</code>，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义<strong>主键为不可更新</strong></li><li><code>二级索引访问需要两次索引查找</code>，第一次找到主键值，第二次根据主键值找到行数据</li></ul><p><strong>2.</strong> <strong>二级索引（辅助索引、非聚簇索引）</strong></p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301050055.png" alt="image-20220330105018965"></p><p><strong>概念：回表</strong> 我们根据这个以c2列大小排序的B+树只能确定我们要查找记录的主键值，所以如果我们想根据c2列的值查找到完整的用户记录的话，仍然需要到<code>聚簇索引</code>中再查一遍，这个过程称为<code>回表</code>。也就是根据c2列的值查询一条完整的用户记录需要使用到<code>2</code>棵B+树！</p><p><strong>3.</strong> <strong>联合索引</strong></p><p>我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让B+树按照<code>c2和c3列</code>的大小进行排序，这个包含两层含义：</p><ul><li><p>先把各个记录和页按照c2列进行排序。</p></li><li><p>在记录的c2列相同的情况下，采用c3列进行排序</p></li></ul><p>注意一点，以c2和c3列的大小为排序规则建立的B+树称为<code>联合索引</code>，本质上也是一个二级索引。它的意思与分别为c2和c3列分别建立索引的表述是不同的，不同点如下：</p><ul><li><p>建立<code>联合索引</code>只会建立如上图一样的1棵B+树。</p></li><li><p>为c2和c3列分别建立索引会分别以c2和c3列的大小为排序规则建立2棵B+树。</p></li></ul><h5 id="2-4-InnoDB的B-树索引的注意事项"><a href="#2-4-InnoDB的B-树索引的注意事项" class="headerlink" title="2.4 InnoDB的B+树索引的注意事项"></a><strong>2.4 InnoDB的B+树索引的注意事项</strong></h5><p><strong>1.</strong> <strong>根页面位置万年不动</strong> </p><p>我们前边介绍B+索引的时候，为了大家理解上的方便，先把存储用户记录的叶子节点都画出来，然后接着画存储目录项记录的内节点，实际上B+树的形成过程是这样的：</p><ul><li>每当为某个表创建一个B+树索引（聚簇索引不是人为创建的，默认就有）的时候，都会为这个索引创建一个<code>根节点</code>页面。最开始表中没有数据的时候，每个B+树索引对应的<code>根节点</code>中既没有用户记录，也没有目录项记录。</li><li>随后向表中插入用户记录时，先把用户记录存储到这个<code>根节点</code>中。</li><li>当根节点中的可用<code>空间用完时</code>继续插入记录，此时会将根节点中的所有记录复制到一个新分配的页，比如<code>页a</code>中，然后对这个新页进行<code>页分裂</code>的操作，得到另一个新页，比如<code>页b</code>。这时新插入的记录根据键值（也就是聚簇索引中的主键值，二级索引中对应的索引列的值）的大小就会被分配到<code>页a</code>或者<code>页b</code>中，而<code>根节点</code>便升级为存储目录项记录的页。</li></ul><p>这个过程特别注意的是：一个B+树索引的根节点自诞生之日起，便不会再移动。这样只要我们对某个表建立一个索引，那么它的根节点的页号便会被记录到某个地方，然后凡是<code>InnoDB</code>存储引擎需要用到这个索引的时候，都会从那个固定的地方取出根节点的页号，从而来访问这个索引。</p><p><strong>2.</strong> <strong>内节点中目录项记录的唯一性</strong> </p><p>我们知道B+树索引的内节点中目录项记录的内容是<code>索引列+页号</code>的搭配，但是这个搭配对于二级索引来说有点不严谨。还拿<code>index_demo</code>表为例，假设这个表中的数据是这样的：</p><table><thead><tr><th>c1</th><th>c2</th><th>c3</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>‘u’</td></tr><tr><td>3</td><td>1</td><td>‘d’</td></tr><tr><td>5</td><td>1</td><td>‘y’</td></tr><tr><td>7</td><td>1</td><td>‘a’</td></tr></tbody></table><p>如果二级索引中目录项的内容只是<code>索引号+页号</code>的搭配的话，那么为<code>c2</code>列建立索引后的B+树应该长这样：</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301110222.png" alt="image-20220330111029120"></p><p>如果我们想要新插入一行记录，其中<code>c1</code>、<code>c2</code>、<code>c3</code>的值分别是：<code>9</code>、<code>1</code>、<code>c</code>，那么在修改这个为c2列建立的二级索引对应的B+树时便碰到了个大问题：由于<code>页3</code>中存储的目录项记录是由<code>c2列+页号</code>的值构成的，<code>页3</code>中的两条目录项记录对应的c2列的值都是<code>1</code>，那么我们这条新插入的记录到底应该放在<code>页4</code>中，还是应该放在<code>页5</code>中啊？答案是：对不起，懵了。</p><p>为了让新插入记录能找到自己在哪个页里，我们需要<strong>保证在B+树的同一层内节点的目录项记录除页号这个字段以外是唯一的。</strong>所以对于二级索引的内节点的目录项记录的内容实际上是由三个部分构成的：</p><ul><li>索引列的值</li><li>主键值</li><li>页号</li></ul><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301120304.png" alt="image-20220330112018199"></p><p>这样我们再插入记录<code>(9, 1, &#39;c&#39;)</code>时，由于<code>页3</code>中存储的目录项记录是由<code>c2列+主键+页号</code>的值构成的，可以先把新记录的<code>c2</code>列的值和<code>页3</code>中各目录项记录的<code>c2</code>列的值作比较，如果<code>c2</code>列的值相同的话，可以接着比较主键值，因为B+树同一层中不同目录项记录的<code>c2列+主键</code>的值肯定是不一样的，所以最后肯定能定位唯一的一条目录项记录，在本例中最后确定新记录应该被插入到<code>页5</code>中。</p><p><strong>3.</strong> <strong>一个页面最少可以存储2条记录</strong></p><p>一个B+树只需要很少的层级就可以轻松存储数亿条记录，查询速度相当不错！这是因为B+树本质上就是一个大的多层级目录，每经过一个目录时都会过滤掉许多无效的子目录，直到最后访问的存储真实数据的目录。那如果一个大的目录中只存放一个子目录是个啥效果呢？那就是目录层级非常非常非常多，而且最后的那个存放真实数据的目录中存放一条记录。费了半天劲只能存放一条真实的用户记录？所以<code>InnoDB的一个数据页至少可以存放两条记录</code></p><h4 id="3-MyISAM中的索引方案"><a href="#3-MyISAM中的索引方案" class="headerlink" title="3. MyISAM中的索引方案"></a><strong>3. MyISAM中的索引方案</strong></h4><p><strong>B树索引适用存储引擎如表所示：</strong></p><table><thead><tr><th>索引&#x2F;存储引擎</th><th>MyISAM</th><th>InnoDB</th><th>Memory</th></tr></thead><tbody><tr><td>B-Tree索引</td><td>支持</td><td>支持</td><td>支持</td></tr></tbody></table><p>即使多个存储引擎支持同一种类型的索引，但是他们的实现原理也是不同的。Innodb和MyISAM默认的索引是Btree索引；而Memory默认的索引是Hash索引。</p><p>MyISAM引擎使用<code>B+Tree</code>作为索引结构，叶子节点的data域存放的是<code>数据记录的地址</code>。</p><h5 id="3-1-MyISAM索引的原理"><a href="#3-1-MyISAM索引的原理" class="headerlink" title="3.1 MyISAM索引的原理"></a><strong>3.1 MyISAM索引的原理</strong></h5><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301133907.png" alt="image-20220330113307813"></p><h5 id="3-2-MyISAM-与-InnoDB对比"><a href="#3-2-MyISAM-与-InnoDB对比" class="headerlink" title="3.2 MyISAM 与 InnoDB对比"></a><strong>3.2 MyISAM</strong> <strong>与</strong> <strong>InnoDB对比</strong></h5><p><strong>MyISAM的索引方式都是“非聚簇”的，与InnoDB包含1个聚簇索引是不同的。</strong></p><p><strong>小结两种引擎中索引的区别：</strong></p><p>① 在InnoDB存储引擎中，我们只需要根据主键值对<code>聚簇索引</code>进行一次查找就能找到对应的记录，而在<code>MyISAM</code>中却需要进行一次<code>回表</code>操作，意味着MyISAM中建立的索引相当于全部都是<code>二级索引</code>。 </p><p>② InnoDB的数据文件本身就是索引文件，而MyISAM索引文件和数据文件是<code>分离的</code>，索引文件仅保存数据记录的地址。</p><p>③ InnoDB的非聚簇索引data域存储相应记录<code>主键的值</code>，而MyISAM索引记录的是<code>地址</code>。换句话说，InnoDB的所有非聚簇索引都引用主键作为data域。</p><p>④ MyISAM的回表操作是十分<code>快速</code>的，因为是拿着地址偏移量直接到文件中取数据的，反观InnoDB是通过获取主键之后再去聚簇索引里找记录，虽然说也不慢，但还是比不上直接用地址去访问。</p><p>⑤ InnoDB要求表<code>必须有主键</code>（<code>MyISAM可以没有</code>）。如果没有显式指定，则MySQL系统会自动选择一个可以非空且唯一标识数据记录的列作为主键。如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整型。</p><h4 id="4-索引的代价"><a href="#4-索引的代价" class="headerlink" title="4. 索引的代价"></a><strong>4.</strong> <strong>索引的代价</strong></h4><p>索引是个好东西，可不能乱建，它在空间和时间上都会有消耗：</p><ul><li><strong>空间上的代价</strong></li></ul><p>每建立一个索引都要为它建立一棵B+树，每一棵B+树的每一个节点都是一个数据页，一个页默认会占用<code>16KB</code>的存储空间，一棵很大的B+树由许多数据页组成，那就是很大的一片存储空间。</p><ul><li><strong>时间上的代价</strong></li></ul><p>每次对表中的数据进行<code>增、删、改</code>操作时，都需要去修改各个B+树索引。而且我们讲过，B+树每层节点都是按照索引列的值<code>从小到大的顺序排序</code>而组成了<code>双向链表</code>。不论是叶子节点中的记录，还是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些<code>记录移位</code>，<code>页面分裂</code>、<code>页面回收</code>等操作来维护好节点和记录的排序。如果我们建了许多索引，每个索引对应的B+树都要进行相关的维护操作，会给性能拖后腿。</p><h4 id="5-MySQL数据结构选择的合理性"><a href="#5-MySQL数据结构选择的合理性" class="headerlink" title="5. MySQL数据结构选择的合理性"></a><strong>5. MySQL数据结构选择的合理性</strong></h4><h5 id="5-1-二叉搜索树"><a href="#5-1-二叉搜索树" class="headerlink" title="5.1 二叉搜索树"></a><strong>5.1</strong> <strong>二叉搜索树</strong></h5><p>如果我们利用二叉树作为索引结构，那么磁盘的IO次数和索引树的高度是相关的。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301636830.png" alt="image-20220330163602743"></p><p>为了提高查询效率，就需要<code>减少磁盘IO数</code>。为了减少磁盘IO的次数，就需要尽量<code>降低树的高度</code>，需要把原来“瘦高”的树结构变的“矮胖”，树的每层的分叉越多越好。</p><h5 id="5-2-AVL树"><a href="#5-2-AVL树" class="headerlink" title="5.2 AVL树"></a><strong>5.2 AVL树</strong></h5><p>如果我们利用二叉树作为索引结构，那么磁盘的IO次数和索引树的高度是相关的。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301635653.png" alt="image-20220330163506536"></p><p>针对同样的数据，如果我们把二叉树改成<code>M 叉树</code>（M&gt;2）呢？当 M&#x3D;3 时，同样的 31 个节点可以由下面的三叉树来进行存储：</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301637104.png" alt="image-20220330163709022"></p><h5 id="5-3-B-Tree"><a href="#5-3-B-Tree" class="headerlink" title="5.3 B-Tree"></a><strong>5.3 B-Tree</strong></h5><p>B 树的结构如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301638995.png" alt="image-20220330163803905"></p><p>一个 M 阶的 B 树（M&gt;2）有以下的特性：</p><ol><li><p>根节点的儿子数的范围是 [2,M]。 </p></li><li><p>每个中间节点包含 k-1 个关键字和 k 个孩子，孩子的数量 &#x3D; 关键字的数量 +1，k 的取值范围为[ceil(M&#x2F;2), M]。 </p></li><li><p>叶子节点包括 k-1 个关键字（叶子节点没有孩子），k 的取值范围为 [ceil(M&#x2F;2), M]。 </p></li><li><p>假设中间节点节点的关键字为：Key[1], Key[2], …, Key[k-1]，且关键字按照升序排序，即 Key[i] &lt;Key[i+1]。此时 k-1 个关键字相当于划分了 k 个范围，也就是对应着 k 个指针，即为：P[1], P[2], …,P[k]，其中 P[1] 指向关键字小于 Key[1] 的子树，P[i] 指向关键字属于 (Key[i-1], Key[i]) 的子树，P[k]指向关键字大于 Key[k-1] 的子树。</p></li><li><p>所有叶子节点位于同一层。</p></li></ol><p>上面那张图所表示的 B 树就是一棵 3 阶的 B 树。我们可以看下磁盘块 2，里面的关键字为（8，12），它有 3 个孩子 (3，5)，(9，10) 和 (13，15)，你能看到 (3，5) 小于 8，(9，10) 在 8 和 12 之间，而 (13，15)大于 12，刚好符合刚才我们给出的特征。</p><p>然后我们来看下如何用 B 树进行查找。假设我们想要<code>查找的关键字是 9</code>，那么步骤可以分为以下几步：</p><ol><li><p>我们与根节点的关键字 (17，35）进行比较，9 小于 17 那么得到指针 P1； </p></li><li><p>按照指针 P1 找到磁盘块 2，关键字为（8，12），因为 9 在 8 和 12 之间，所以我们得到指针 P2； </p></li><li><p>按照指针 P2 找到磁盘块 6，关键字为（9，10），然后我们找到了关键字 9。</p></li></ol><p>你能看出来在 B 树的搜索过程中，我们比较的次数并不少，但如果把数据读取出来然后在内存中进行比较，这个时间就是可以忽略不计的。而读取磁盘块本身需要进行 I&#x2F;O 操作，消耗的时间比在内存中进行比较所需要的时间要多，是数据查找用时的重要因素。<code>B 树相比于平衡二叉树来说磁盘 I/O 操作要少</code>，在数据查询中比平衡二叉树效率要高。所以<code>只要树的高度足够低，IO次数足够少，就可以提高查询性能</code>。</p><p><strong>再举例1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301644761.png" alt="image-20220330164411665"></p><h5 id="5-4-B-Tree"><a href="#5-4-B-Tree" class="headerlink" title="5.4 B+Tree"></a><strong>5.4 B+Tree</strong></h5><p><strong>B+</strong> <strong>树和</strong> <strong>B</strong> <strong>树的差异：</strong></p><ol><li><p>有 k 个孩子的节点就有 k 个关键字。也就是孩子数量 &#x3D; 关键字数，而 B 树中，孩子数量 &#x3D; 关键字数+1。</p></li><li><p>非叶子节点的关键字也会同时存在在子节点中，并且是在子节点中所有关键字的最大（或最小）。</p></li><li><p>非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子节点中。而 B 树中， <code>非叶子节点既保存索引，也保存数据记录</code>。 </p></li><li><p>所有关键字都在叶子节点出现，叶子节点构成一个有序链表，而且叶子节点本身按照关键字的大小从小到大顺序链接。</p></li></ol><blockquote><p>B 树和 B+ 树都可以作为索引的数据结构，在 MySQL 中采用的是 B+ 树。</p><p>但B树和B+树各有自己的应用场景，不能说B+树完全比B树好，反之亦然。</p></blockquote><p><strong>思考题：为了减少IO，索引树会一次性加载吗？</strong></p><blockquote><p>1、数据库索引是存储在磁盘上的，如果数据量很大，必然导致索引的大小也会很大，超过几个G。</p><p>2、当我们利用索引查询时候，是不可能将全部几个G的索引都加载进内存的，我们能做的只能是：逐一加载每一个磁盘页，因为磁盘页对应着索引树的节点。</p></blockquote><p><strong>思考题：B+树的存储能力如何？为何说一般查找行记录，最多只需1~3次磁盘IO</strong></p><blockquote><p>InnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT(占用4个字节)或BIGINT(占用8个字节)，指针类型也一般为4或8个字节，也就是说一个页（B+Tree中的一个节点）中大概存储16KB&#x2F;(8B+8B)&#x3D;1K个键值，因为是估算，为了方便计算，这里的K取值为10^3。也就是说一个深度为3的B+Tree索引可以维护10^3 * 10^3 * 10^3 &#x3D; 10亿条记录。（这里假定一个数据页也存储10^3条行记录数据了）</p><p>实际情况中每个节点可能不能填充满，因此在数据库中，<code>B+Tree的高度一般都在2~4层</code>。MySQL的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1~3次磁盘I&#x2F;O操作</p></blockquote><p><strong>思考题：为什么说B+树比B-树更适合实际应用中操作系统的文件索引和数据库索引？</strong></p><blockquote><p>1.B+树的磁盘读写代价更低</p><p>B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对于B树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。</p><p>2、B+树的查询效率更加稳定</p><p>由于非终结点并不是最终指向文件内容的节点，而只是叶子结点中关键字的索引。所有任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p></blockquote><p><strong>思考题：Hash索引与B+树索引的区别</strong></p><blockquote><p>1、Hash索引<code>不能进行范围查询</code>，而B+树可以。这是因为Hash索引指向的数据是无序的，而B+树的叶子节点是个有序的链表。</p><p>2、Hash索引<code>不支持联合索引的最左侧原则</code>（即联合索引的部分索引无法使用），而B+树可以。对于联合索引来说，Hash索引在计算Hash值的时候是将索引键合并后再一起计算Hash值，所以不会针对每个索引单独计算Hash值。因此如果用到联合索引的一个或者几个索引时，联合索引无法被利用。</p><p>3、Hash索引<code>不支持 ORDER BY 排序</code>，因为Hash索引指向的数据是无序的，因此无法起到排序优化的作用，而B+树索引数据是有序的，可以起到对该字段ORDER BY 排序优化的作用。同理，我们也无法用Hash索引进行<code>模糊查询</code>，而B+树使用LIKE进行模糊查询的时候，LIKE后面后模糊查询（比如%结尾）的话就可以起到优化作用。</p><p>4、<code>InnoDB不支持哈希索引</code></p></blockquote><h3 id><a href="#" class="headerlink" title></a></h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第05章 存储引擎</title>
      <link href="/2023/07/15/%E7%AC%AC05%E7%AB%A0%20%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
      <url>/2023/07/15/%E7%AC%AC05%E7%AB%A0%20%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<h3 id="第05章-存储引擎"><a href="#第05章-存储引擎" class="headerlink" title="第05章 存储引擎"></a>第05章 存储引擎</h3><h4 id="1-查看存储引擎"><a href="#1-查看存储引擎" class="headerlink" title="1. 查看存储引擎"></a><strong>1.</strong> <strong>查看存储引擎</strong></h4><pre><code class="mysql">show engines;# 或show engines\G</code></pre><h4 id="2-设置系统默认的存储引擎"><a href="#2-设置系统默认的存储引擎" class="headerlink" title="2. 设置系统默认的存储引擎"></a><strong>2.</strong> <strong>设置系统默认的存储引擎</strong></h4><ul><li>查看默认的存储引擎：</li></ul><pre><code class="mysql">show variables like &#39;%storage_engine%&#39;; #或SELECT @@default_storage_engine;</code></pre><ul><li>修改默认的存储引擎</li></ul><p>如果在创建表的语句中没有显式指定表的存储引擎的话，那就会默认使用<code>InnoDB</code>作为表的存储引擎。</p><pre><code class="mysql">SET DEFAULT_STORAGE_ENGINE=MyISAM;</code></pre><p>或者修改<code>my.cnf</code>文件：</p><pre><code class="ini">default-storage-engine=MyISAM </code></pre><pre><code class="shell"># 重启服务 systemctl restart mysqld.service</code></pre><h4 id="3-设置表的存储引擎"><a href="#3-设置表的存储引擎" class="headerlink" title="3. 设置表的存储引擎"></a><strong>3.</strong> <strong>设置表的存储引擎</strong></h4><p>存储引擎是负责对表中的数据进行提取和写入工作的，我们可以为<code>不同的表设置不同的存储引擎</code>，也就是说不同的表可以有不同的物理存储结构，不同的提取和写入方式。</p><h5 id="3-1-创建表时指定存储引擎"><a href="#3-1-创建表时指定存储引擎" class="headerlink" title="3.1 创建表时指定存储引擎"></a><strong>3.1</strong> <strong>创建表时指定存储引擎</strong></h5><pre><code class="mysql">CREATE TABLE 表名(    建表语句; ) ENGINE = 存储引擎名称;</code></pre><h5 id="3-2-修改表的存储引擎"><a href="#3-2-修改表的存储引擎" class="headerlink" title="3.2 修改表的存储引擎"></a><strong>3.2</strong> <strong>修改表的存储引擎</strong></h5><pre><code class="mysql">ALTER TABLE 表名 ENGINE = 存储引擎名称;</code></pre><h4 id="4-引擎介绍"><a href="#4-引擎介绍" class="headerlink" title="4. 引擎介绍"></a><strong>4.</strong> <strong>引擎介绍</strong></h4><h5 id="4-1-InnoDB-引擎：具备外键支持功能的事务存储引擎"><a href="#4-1-InnoDB-引擎：具备外键支持功能的事务存储引擎" class="headerlink" title="4.1 InnoDB 引擎：具备外键支持功能的事务存储引擎"></a><strong>4.1 InnoDB</strong> <strong>引擎：具备外键支持功能的事务存储引擎</strong></h5><ul><li>MySQL从3.23.34a开始就包含InnoDB存储引擎。<code>大于等于5.5之后，默认采用InnoDB引擎</code>。 </li><li>InnoDB是MySQL的<code>默认事务型引擎</code>，它被设计用来处理大量的短期(short-lived)事务。可以确保事务的完整提交(Commit)和回滚(Rollback)。</li><li>除了增加和查询外，还需要更新、删除操作，那么，应优先选择InnoDB存储引擎。</li><li><strong>除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑InnoDB引擎。</strong></li><li>数据文件结构：<ul><li>表名.frm 存储表结构（MySQL8.0时，合并在表名.ibd中）</li><li>表名.ibd 存储数据和索引</li></ul></li><li>InnoDB是<code>为处理巨大数据量的最大性能设计</code>。<ul><li>在以前的版本中，字典数据以元数据文件、非事务表等来存储。现在这些元数据文件被删除了。比如：<code>.frm</code>，<code>.par</code>，<code>.trn</code>，<code>.isl</code>，<code>.db.opt</code>等都在MySQL8.0中不存在了。</li></ul></li><li>对比MyISAM的存储引擎，<code>InnoDB写的处理效率差一些</code>，并且会占用更多的磁盘空间以保存数据和索引。</li><li>MyISAM只缓存索引，不缓存真实数据；InnoDB不仅缓存索引还要缓存真实数据，<code>对内存要求较高</code>，而且内存大小对性能有决定性的影响。</li></ul><h5 id="4-2-MyISAM-引擎：主要的非事务处理存储引擎"><a href="#4-2-MyISAM-引擎：主要的非事务处理存储引擎" class="headerlink" title="4.2 MyISAM 引擎：主要的非事务处理存储引擎"></a><strong>4.2 MyISAM</strong> <strong>引擎：主要的非事务处理存储引擎</strong></h5><ul><li>MyISAM提供了大量的特性，包括全文索引、压缩、空间函数(GIS)等，但MyISAM<code>不支持事务、行级锁、外键</code>，有一个毫无疑问的缺陷就是<code>崩溃后无法安全恢复</code>。 </li><li><code>5.5之前默认的存储引擎</code></li><li>优势是访问的<code>速度快</code>，对事务完整性没有要求或者以SELECT、INSERT为主的应用</li><li>针对数据统计有额外的常数存储。故而 count(*) 的查询效率很高</li><li>数据文件结构：<ul><li>表名.frm 存储表结构</li><li>表名.MYD 存储数据 (MYData)</li><li>表名.MYI 存储索引 (MYIndex)</li></ul></li><li>应用场景：只读应用或者以读为主的业务</li></ul><h5 id="4-3-Archive-引擎：用于数据存档"><a href="#4-3-Archive-引擎：用于数据存档" class="headerlink" title="4.3 Archive 引擎：用于数据存档"></a><strong>4.3 Archive</strong> <strong>引擎：用于数据存档</strong></h5><h5 id="4-4-Blackhole-引擎：丢弃写操作，读操作会返回空内容"><a href="#4-4-Blackhole-引擎：丢弃写操作，读操作会返回空内容" class="headerlink" title="4.4 Blackhole 引擎：丢弃写操作，读操作会返回空内容"></a><strong>4.4 Blackhole</strong> <strong>引擎：丢弃写操作，读操作会返回空内容</strong></h5><h5 id="4-5-CSV-引擎：存储数据时，以逗号分隔各个数据项"><a href="#4-5-CSV-引擎：存储数据时，以逗号分隔各个数据项" class="headerlink" title="4.5 CSV 引擎：存储数据时，以逗号分隔各个数据项"></a><strong>4.5 CSV</strong> <strong>引擎：存储数据时，以逗号分隔各个数据项</strong></h5><h5 id="4-6-Memory-引擎：置于内存的表"><a href="#4-6-Memory-引擎：置于内存的表" class="headerlink" title="4.6 Memory 引擎：置于内存的表"></a><strong>4.6 Memory</strong> <strong>引擎：置于内存的表</strong></h5><h5 id="4-7-Federated-引擎：访问远程表"><a href="#4-7-Federated-引擎：访问远程表" class="headerlink" title="4.7 Federated 引擎：访问远程表"></a><strong>4.7 Federated</strong> <strong>引擎：访问远程表</strong></h5><h5 id="4-8-Merge引擎：管理多个MyISAM表构成的表集合"><a href="#4-8-Merge引擎：管理多个MyISAM表构成的表集合" class="headerlink" title="4.8 Merge引擎：管理多个MyISAM表构成的表集合"></a><strong>4.8 Merge引擎：管理多个MyISAM表构成的表集合</strong></h5><h5 id="4-9-NDB引擎：MySQL集群专用存储引擎"><a href="#4-9-NDB引擎：MySQL集群专用存储引擎" class="headerlink" title="4.9 NDB引擎：MySQL集群专用存储引擎"></a><strong>4.9 NDB引擎：MySQL集群专用存储引擎</strong></h5><h4 id="5-MyISAM和InnoDB"><a href="#5-MyISAM和InnoDB" class="headerlink" title="5. MyISAM和InnoDB"></a><strong>5. MyISAM和InnoDB</strong></h4><table><thead><tr><th>对比项</th><th><strong>MyISAM</strong></th><th><strong>InnoDB</strong></th></tr></thead><tbody><tr><td>外键</td><td>不支持</td><td>支持</td></tr><tr><td>事务</td><td>不支持</td><td>支持</td></tr><tr><td>行表锁</td><td>表锁，即使操作一条记录也会锁住整个表，不适合高并发的操作</td><td>行锁，操作时只锁某一行，不对其它行有影响，适合高并发的操作</td></tr><tr><td>缓存</td><td>只缓存索引，不缓存真实数据</td><td>不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响</td></tr><tr><td>自带系统表使用</td><td>Y</td><td>N</td></tr><tr><td>关注点</td><td>性能：节省资源、消耗少、简单业务</td><td>事务：并发写、事务、更大资源</td></tr><tr><td>默认安装</td><td>Y</td><td>Y</td></tr><tr><td>默认使用</td><td>N</td><td>Y</td></tr></tbody></table><h3 id><a href="#" class="headerlink" title></a></h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第07章 InnoDB数据存储结构</title>
      <link href="/2023/07/15/%E7%AC%AC07%E7%AB%A0%20InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/"/>
      <url>/2023/07/15/%E7%AC%AC07%E7%AB%A0%20InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h3 id="第07章-InnoDB数据存储结构"><a href="#第07章-InnoDB数据存储结构" class="headerlink" title="第07章 InnoDB数据存储结构"></a>第07章 InnoDB数据存储结构</h3><h4 id="1-数据库的存储结构：页"><a href="#1-数据库的存储结构：页" class="headerlink" title="1. 数据库的存储结构：页"></a>1. 数据库的存储结构：页</h4><p>索引结构给我们提供了高效的索引方式，不过索引信息以及数据记录都保存在文件上的，确切说是存储在页结构中。另一方面，索引是在存储引擎中实现的，MySQL服务器上的<code>存储引擎</code>负责对表中数据的读取和写入工作。不同存储引擎中<code>存放的格式</code>一般不同的，甚至有的存储引擎比如Memory都不用磁盘来存储数据。</p><p>由于<code>InnoDB</code>是MySQL的<code>默认存储引擎</code>，所以本章剖析InooDB存储引擎的数据存储结构。</p><h5 id="1-1-磁盘与内存交互基本单位：页"><a href="#1-1-磁盘与内存交互基本单位：页" class="headerlink" title="1.1 磁盘与内存交互基本单位：页"></a>1.1 磁盘与内存交互基本单位：页</h5><p>InnoDB将数据划分为若干个页，InnoDB中页的大小默认为<code>16KB</code>。</p><p>以<code>页</code>作为磁盘和内存之间交互的基本单位，也就是一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。也就是说，<strong>在数据库中，不论读一行，还是读多行，都是将这些行所在的页进行加载。也就是说，数据库管理存储空间的基本单位是页（Page），数据库I&#x2F;O操作的最小单位是页。</strong>一个页中可以存储多个行记录。</p><blockquote><p>记录是按照行来存储的，但是数据库的读取并不以行为单位，否则一次读取（也就是一次I&#x2F;O操作）只能处理一行数据，效率会非常低。</p></blockquote><h5 id="1-2-页结构概述"><a href="#1-2-页结构概述" class="headerlink" title="1.2 页结构概述"></a>1.2 页结构概述</h5><p>页a、页b、页c…页n这些页可以<code>不在物理结构上相连</code>，只要通过<code>双向链表</code>相关联即可。每个数据页中的记录会按照主键值从小到大的顺序组成一个<code>单向链表</code>，每个数据页都会为存储在它里边的记录生成一个<code>页目录</code>，在通过主键查找某条记录的时候可以在页目录中<code>使用二分法</code>快速定位到对应的槽，然后再遍历该槽对应的分组中的记录即可快速找到指定的记录。</p><h5 id="1-3-页的上层结构"><a href="#1-3-页的上层结构" class="headerlink" title="1.3 页的上层结构"></a>1.3 页的上层结构</h5><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301838071.png" alt="image-20220330183814954"></p><p>区（Extent）是比页大一级的存储结构，在InnoDB存储引擎中，一个区会分配<code>64个连续的页</code>。因为InnoDB中的页大小默认是16KB，所以一个区的大小是64*16KB&#x3D;<code>1MB</code>。</p><p>段（Segment）由一个或多个区组成，区在文件系统是一个连续分配的空间（在InnoDB中是连续的64个页），不过在段中不要求区与区之间是相邻的。<code>段是数据库中的分配单位，不同类型的数据库对象以不同的段形式存在。</code>当我们创建数据表、索引的时候，就会相应创建对应的段，比如创建一张表时会创建一个表段，创建一个索引时会创建一个索引段。</p><p>表空间（Tablespace）是一个逻辑容器，表空间存储的对象是段，在一个表空间中可以有一个或多个段，但是一个段只能属于一个表空间。数据库由一个或多个表空间组成，表空间从管理上可以划分为<code>系统表空间</code>、<code>用户表空间</code>、<code>撤销表空间</code>、<code>临时表空间</code>等。</p><h4 id="2-页的内部结构"><a href="#2-页的内部结构" class="headerlink" title="2. 页的内部结构"></a>2. 页的内部结构</h4><h5 id="2-1-第1部分：文件头部和文件尾部"><a href="#2-1-第1部分：文件头部和文件尾部" class="headerlink" title="2.1 第1部分：文件头部和文件尾部"></a>2.1 第1部分：文件头部和文件尾部</h5><h6 id="2-1-1-File-Header（文件头部）（38字节）"><a href="#2-1-1-File-Header（文件头部）（38字节）" class="headerlink" title="2.1.1 File Header（文件头部）（38字节）"></a>2.1.1 File Header（文件头部）（38字节）</h6><p><strong>作用</strong>：<br>描述各种页的通用信息。（比如页的编号、其上一页、下一页是谁等）</p><p><strong>大小</strong>：38字节</p><table><thead><tr><th>名称</th><th>占用空间大小</th><th>描述</th></tr></thead><tbody><tr><td><code>FIL_PAGE_SPACE_OR_CHKSUM</code></td><td><code>4</code>字节</td><td>页的校验和（checksum值）</td></tr><tr><td><code>FIL_PAGE_OFFSET</code></td><td><code>4</code>字节</td><td>页号</td></tr><tr><td><code>FIL_PAGE_PREV</code></td><td><code>4</code>字节</td><td>上一个页的页号</td></tr><tr><td><code>FIL_PAGE_NEXT</code></td><td><code>4</code>字节</td><td>下一个页的页号</td></tr><tr><td>FIL_PAGE_LSN</td><td><code>8</code>字节</td><td>页面被最后修改时对应的日志序列位置</td></tr><tr><td><code>FIL_PAGE_TYPE</code></td><td><code>2</code>字节</td><td>该页的类型</td></tr><tr><td>FIL_PAGE_FILE_FLUSH_LSN</td><td><code>8</code>字节</td><td>仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值</td></tr><tr><td><code>FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID</code></td><td><code>4</code>字节</td><td>页属于哪个表空间</td></tr></tbody></table><ul><li><code>FIL_PAGE_OFFSET（4字节）</code>：每一个页都有一个单独的页号，就跟你的身份证号码一样，InnoDB通过页号可以唯一定位一个页。</li><li><code>FIL_PAGE_TYPE（2字节）</code>：这个代表当前页的类型。</li></ul><table><thead><tr><th>类型名称</th><th>十六进制</th><th>描述</th></tr></thead><tbody><tr><td>FIL_PAGE_TYPE_ALLOCATED</td><td>0x0000</td><td>最新分配，还没有使用</td></tr><tr><td><code>FIL_PAGE_UNDO_LOG</code></td><td>0x0002</td><td>Undo日志页</td></tr><tr><td>FIL_PAGE_INODE</td><td>0x0003</td><td>段信息节点</td></tr><tr><td>FIL_PAGE_IBUF_FREE_LIST</td><td>0x0004</td><td>Insert Buffer空闲列表</td></tr><tr><td>FIL_PAGE_IBUF_BITMAP</td><td>0x0005</td><td>Insert Buffer位图</td></tr><tr><td><code>FIL_PAGE_TYPE_SYS</code></td><td>0x0006</td><td>系统页</td></tr><tr><td>FIL_PAGE_TYPE_TRX_SYS</td><td>0x0007</td><td>事务系统数据</td></tr><tr><td>FIL_PAGE_TYPE_FSP_HDR</td><td>0x0008</td><td>表空间头部信息</td></tr><tr><td>FIL_PAGE_TYPE_XDES</td><td>0x0009</td><td>扩展描述页</td></tr><tr><td>FIL_PAGE_TYPE_BLOB</td><td>0x000A</td><td>溢出页</td></tr><tr><td><code>FIL_PAGE_INDEX</code></td><td>0x45BF</td><td>索引页，也就是我们所说的<code>数据页</code></td></tr></tbody></table><ul><li><code>FIL_PAGE_PREV（4字节）和FIL_PAGE_NEXT（4字节）</code>：InnoDB都是以页为单位存放数据的，如果数据分散到多个不连续的页中存储的话需要把这些页关联起来，FIL_PAGE_PREV和FIL_PAGE_NEXT就分别代表本页的上一个和下一个页的页号。这样通过建立一个双向链表把许许多多的页就都串联起来了，保证这些页之间<strong>不需要是物理上的连续，而是逻辑上的连续。</strong></li><li><code>FIL_PAGE_SPACE_OR_CHKSUM（4字节）</code>：代表当前页面的校验和（checksum）。文件头部和文件尾部都有属性：FIL_PAGE_SPACE_OR_CHKSUM</li></ul><p><strong>作用：</strong></p><p>InnoDB存储引擎以页为单位把数据加载到内存中处理，如果该页中的数据在内存中被修改了，那么<code>在修改后的某个时间需要把数据同步到磁盘中。</code>但是在同步了一半的时候断电了，造成了该页传输的不完整。</p><p>为了检测一个页是否完整（也就是在同步的时候有没有发生只同步一半的尴尬情况），这时可以通过文件尾的校验和（checksum 值）与文件头的校验和做比对，如果两个值不相等则证明页的传输有问题，需要重新进行传输，否则认为页的传输已经完成。</p><ul><li><code>FIL_PAGE_LSN（8字节）</code>：页面被最后修改时对应的日志序列位置（英文名是：Log Sequence Number）</li></ul><h6 id="2-1-2-File-Trailer（文件尾部）（8字节）"><a href="#2-1-2-File-Trailer（文件尾部）（8字节）" class="headerlink" title="2.1.2 File Trailer（文件尾部）（8字节）"></a>2.1.2 File Trailer（文件尾部）（8字节）</h6><ul><li>前4个字节代表页的校验和：这个部分是和File Header中的校验和相对应的。</li><li>后4个字节代表页面被最后修改时对应的日志序列位置（LSN）：这个部分也是为了校验页的完整性的，如果首部和尾部的LSN值校验不成功的话，就说明同步过程出现了问题。</li></ul><h5 id="2-2-第2部分：空闲空间、用户记录和最小最大记录"><a href="#2-2-第2部分：空闲空间、用户记录和最小最大记录" class="headerlink" title="2.2 第2部分：空闲空间、用户记录和最小最大记录"></a>2.2 第2部分：空闲空间、用户记录和最小最大记录</h5><h6 id="2-2-1-Free-Space-空闲空间"><a href="#2-2-1-Free-Space-空闲空间" class="headerlink" title="2.2.1 Free Space (空闲空间)"></a>2.2.1 Free Space (空闲空间)</h6><p>我们自己存储的记录会按照指定的<code>行格式</code>存储到<code>User Records</code>部分。但是在一开始生成页的时候，其实并没有User Records这个部分，<code>每当我们插入一条记录，都会从Free Space部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到User Records部分</code>，当Free Space部分的空间全部被User Records部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去<code>申请新的页</code>了。</p><h6 id="2-2-2-User-Records-用户记录"><a href="#2-2-2-User-Records-用户记录" class="headerlink" title="2.2.2 User Records (用户记录)"></a>2.2.2 User Records (用户记录)</h6><p>User Records中的这些记录按照<code>指定的行格式</code>一条一条摆在User Records部分，相互之间形成<code>单链表</code>。</p><h6 id="2-2-3-Infimum-Supremum（最小最大记录）"><a href="#2-2-3-Infimum-Supremum（最小最大记录）" class="headerlink" title="2.2.3 Infimum + Supremum（最小最大记录）"></a>2.2.3 Infimum + Supremum（最小最大记录）</h6><p><strong>记录可以比较大小吗</strong>？<br>是的，记录可以比大小，对于一条完整的记录来说，比较记录的大小就是<code>比较主键</code>的大小。比方说我们插入的4行记录的主键值分别是：1、2、3、4，这也就意味着这4条记录是从小到大依次递增。</p><p>InnoDB规定的最小记录与最大记录这两条记录的构造十分简单，都是由5字节大小的记录头信息和8字节大小的一个固定的部分组成的。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301913664.png" alt="image-20220330191335574"></p><p>这两条记录<code>不是我们自己定义的记录</code>，所以它们并不存放在页的User Records部分，他们被单独放在一个称为Infimum + Supremum的部分</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301914167.png" alt="image-20220330191446070"></p><h5 id="2-3-第3部分：页目录和页面头部"><a href="#2-3-第3部分：页目录和页面头部" class="headerlink" title="2.3 第3部分：页目录和页面头部"></a>2.3 第3部分：页目录和页面头部</h5><h6 id="2-3-1-Page-Directory（页目录）"><a href="#2-3-1-Page-Directory（页目录）" class="headerlink" title="2.3.1 Page Directory（页目录）"></a>2.3.1 Page Directory（页目录）</h6><p><strong>为什么需要页目录</strong>？<br>在页中，记录是以<code>单向链表</code>的形式进行存储的。单向链表的特点就是插入、删除非常方便，但是<code>检索效率不高</code>，最差的情况下需要遍历链表上的所有节点才能完成检索。因此在页结构中专门设计了页目录这个模块，<code>专门给记录做一个目录</code>，通过<code>二分查找法</code>的方式进行检索，提升效率。</p><p><strong>页目录，二分法查找</strong></p><ol><li>将所有的记录<code>分成几个组</code>，这些记录包括最小记录和最大记录，但不包括标记为“已删除”的记录。</li><li>第 1 组，也就是最小记录所在的分组只有 1 个记录；<br>最后一组，就是最大记录所在的分组，会有 1-8 条记录；<br>其余的组记录数量在 4-8 条之间。<br>这样做的好处是，除了第 1 组（最小记录所在组）以外，其余组的记录数会<code>尽量平分</code>。</li><li>在每个组中最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段。</li><li><code>页目录用来存储每组最后一条记录的地址偏移量</code>，这些地址偏移量会按照<code>先后顺序存储</code>起来，每组的地址偏移量也被称之为<code>槽（slot）</code>，每个槽相当于指针指向了不同组的最后一个记录。</li></ol><p><strong>举例：</strong></p><p>现在的page_demo表中正常的记录共有6条，InnoDB会把它们分成两组，第一组中只有一个最小记录，第二组中是剩余的5条记录。如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301921631.png" alt="image-20220330192130497"></p><p>从这个图中我们需要注意这么几点：</p><ul><li>现在页目录部分中有两个槽，也就意味着我们的记录被分成了两个组，槽1中的值是112，代表最大记录的地址偏移量（就是从页面的0字节开始数，数112个字节）；槽0中的值是99，代表最小记录的地址偏移量。</li><li>注意最小和最大记录的头信息中的n_owned属性<ul><li>最小记录的n_owned值为1，这就代表着以最小记录结尾的这个分组中只有1条记录，也就是最小记录本身。</li><li>最大记录的n_owned值为5，这就代表着以最大记录结尾的这个分组中只有5条记录，包括最大记录本身还有我们自己插入的4条记录。</li></ul></li></ul><p>用箭头指向的方式替代数字，这样更易于我们理解，修改后如下</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301924874.png" alt="image-20220330192413776"></p><p><strong>为什么最小记录的n_owned值为1，而最大记录的n_owned值为5呢？</strong></p><p>InnoDB规定：对于最小记录所在的分组只能有1条记录，最大记录所在的分组拥有的记录条数只能在1<del>8条之间，剩下的分组中记录的条数范围只能在是 4</del>8 条之间。</p><p>分组是按照下边的步骤进行的：</p><ul><li>初始情况下一个数据页里只有最小记录和最大记录两条记录，它们分属于两个分组。</li><li>之后每插入一条记录，都会从页目录中找到主键值比本记录的主键值大并且差值最小的槽，然后把该槽对应的记录的n_owned值加1，表示本组内又添加了一条记录，直到该组中的记录数等于8个。</li><li>在一个组中的记录数等于8个后再插入一条记录时，会将组中的记录拆分成两个组，一个组中4条记录，另一个5条记录。这个过程会在页目录中新增一个槽来记录这个新增分组中最大的那条记录的偏移量。</li></ul><h6 id="2-3-2-Page-Header（页面头部）"><a href="#2-3-2-Page-Header（页面头部）" class="headerlink" title="2.3.2 Page Header（页面头部）"></a>2.3.2 Page Header（页面头部）</h6><p>为了能得到一个数据页中存储的记录的状态信息，比如本页中已经存储了多少条记录，第一条记录的地址是什么，页目录中存储了多少个槽等等，特意在页中定义了一个叫Page Header的部分，这个部分占用固定的56个字节，专门存储各种状态信息。</p><table><thead><tr><th>名称</th><th>占用空间大小</th><th>描述</th></tr></thead><tbody><tr><td>PAGE_N_DIR_SLOTS</td><td>2字节</td><td>在页目录中的槽数量</td></tr><tr><td>PAGE_HEAP_TOP</td><td>2字节</td><td>还未使用的空间最小地址，也就是说从该地址之后就是<code>Free Space</code></td></tr><tr><td>PAGE_N_HEAP</td><td>2字节</td><td>本页中的记录的数量（包括最小和最大记录以及标记为删除的记录）</td></tr><tr><td>PAGE_FREE</td><td>2字节</td><td>第一个已经标记为删除的记录的记录地址（各个已删除的记录通过<code>next_record</code>也会组成一个单链表，这个单链表中的记录可以被重新利用）</td></tr><tr><td>PAGE_GARBAGE</td><td>2字节</td><td>已删除记录占用的字节数</td></tr><tr><td>PAGE_LAST_INSERT</td><td>2字节</td><td>最后插入记录的位置</td></tr><tr><td>PAGE_DIRECTION</td><td>2字节</td><td>记录插入的方向</td></tr><tr><td>PAGE_N_DIRECTION</td><td>2字节</td><td>一个方向连续插入的记录数量</td></tr><tr><td>PAGE_N_RECS</td><td>2字节</td><td>该页中记录的数量（不包括最小和最大记录以及被标记为删除的记录）</td></tr><tr><td>PAGE_MAX_TRX_ID</td><td>8字节</td><td>修改当前页的最大事务ID，该值仅在二级索引中定义</td></tr><tr><td>PAGE_LEVEL</td><td>2字节</td><td>当前页在B+树中所处的层级</td></tr><tr><td>PAGE_INDEX_ID</td><td>8字节</td><td>索引ID，表示当前页属于哪个索引</td></tr><tr><td>PAGE_BTR_SEG_LEAF</td><td>10字节</td><td>B+树叶子段的头部信息，仅在B+树的Root页定义</td></tr><tr><td>PAGE_BTR_SEG_TOP</td><td>10字节</td><td>B+树非叶子段的头部信息，仅在B+树的Root页定义</td></tr></tbody></table><h4 id="3-InnoDB行格式（或记录格式）"><a href="#3-InnoDB行格式（或记录格式）" class="headerlink" title="3. InnoDB行格式（或记录格式）"></a>3. InnoDB行格式（或记录格式）</h4><h5 id="3-1-指定行格式的语法"><a href="#3-1-指定行格式的语法" class="headerlink" title="3.1 指定行格式的语法"></a>3.1 指定行格式的语法</h5><pre><code class="mysql">CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称</code></pre><pre><code class="mysql">ALTER TABLE 表名 ROW_FORMAT=行格式名称</code></pre><h5 id="3-2-COMPACT行格式"><a href="#3-2-COMPACT行格式" class="headerlink" title="3.2 COMPACT行格式"></a>3.2 COMPACT行格式</h5><p>在MySQL 5.1版本中，默认设置为Compact行格式。一条完整的记录其实可以被分为记录的额外信息和记录的真实数据两大部分。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301939611.png" alt="image-20220330193949517"></p><h6 id="3-2-1-变长字段长度列表"><a href="#3-2-1-变长字段长度列表" class="headerlink" title="3.2.1 变长字段长度列表"></a>3.2.1 变长字段长度列表</h6><p>MySQL支持一些变长的数据类型，比如VARCHAR(M)、VARBINARY(M)、TEXT类型，BLOB类型，这些数据类型修饰列称为<code>变长字段</code>，变长字段中存储多少字节的数据不是固定的，所以我们在存储真实数据的时候需要顺便把这些数据占用的字节数也存起来。<code>在Compact行格式中，把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长字段长度列表。</code></p><blockquote><p> 注意：这里面存储的变长长度和字段顺序是反过来的。比如两个varchar字段在表结构的顺序是a(10)，b(15)。那么在变长字段长度列表中存储的长度顺序就是15，10，是反过来的。</p></blockquote><h6 id="3-2-2-NULL值列表"><a href="#3-2-2-NULL值列表" class="headerlink" title="3.2.2 NULL值列表"></a>3.2.2 NULL值列表</h6><p>Compact行格式会把可以为NULL的列统一管理起来，存在一个标记为NULL值列表中。如果表中没有允许存储 NULL 的列，则 NULL值列表也不存在了。<br><strong>为什么定义NULL值列表？</strong><br>之所以要存储NULL是因为数据都是需要对齐的，如果<code>没有标注出来NULL值的位置</code>，就有可能在查询数据的时候<code>出现混乱</code>。如果使用<code>一个特定的符号</code>放到相应的数据位表示空置的话，虽然能达到效果，但是这样很浪费空间，所以直接就在行数据得头部开辟出一块空间专门用来记录该行数据哪些是非空数据，哪些是空数据，格式如下：</p><ol><li>二进制位的值为1时，代表该列的值为NULL。</li><li>二进制位的值为0时，代表该列的值不为NULL。</li></ol><blockquote><p>注意：同样顺序也是反过来存放的</p></blockquote><h6 id="3-2-3-记录头信息（5字节）"><a href="#3-2-3-记录头信息（5字节）" class="headerlink" title="3.2.3 记录头信息（5字节）"></a>3.2.3 记录头信息（5字节）</h6><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301945235.png" alt="image-20220330194534127"></p><table><thead><tr><th>名称</th><th>大小（单位：bit）</th><th>描述</th></tr></thead><tbody><tr><td><code>预留位1</code></td><td>1</td><td>没有使用</td></tr><tr><td><code>预留位2</code></td><td>1</td><td>没有使用</td></tr><tr><td><code>delete_mask</code></td><td>1</td><td>标记该记录是否被删除</td></tr><tr><td><code>mini_rec_mask</code></td><td>1</td><td>B+树的每层非叶子节点中的最小记录都会添加该标记</td></tr><tr><td><code>n_owned</code></td><td>4</td><td>表示当前记录拥有的记录数</td></tr><tr><td><code>heap_no</code></td><td>13</td><td>表示当前记录在记录堆的位置信息</td></tr><tr><td><code>record_type</code></td><td>3</td><td>表示当前记录的类型，<code>0</code>表示普通记录，<code>1</code>表示B+树非叶子节点记录，<code>2</code>表示最小记录，<code>3</code>表示最大记录</td></tr><tr><td><code>next_record</code></td><td>16</td><td>表示下一条记录的相对位置</td></tr></tbody></table><ul><li><code>delete_mask</code>：这个属性标记着当前记录是否被删除，占用1个二进制位。<ul><li>值为0：代表记录并没有被删除</li><li>值为1：代表记录被删除掉了</li></ul></li></ul><p><strong>被删除的记录为什么还在页中存储呢？</strong><br>你以为它删除了，可它还在真实的磁盘上。这些被删除的记录之所以不立即从磁盘上移除，是因为移除它们之后其他的记录在磁盘上需要<code>重新排列，导致性能消耗</code>。所以只是打一个删除标记而已，所有被删除掉的记录都会组成一个所谓的<code>垃圾链表</code>，在这个链表中的记录占用的空间称之为<code>可重用空间</code>，之后如果有新记录插入到表中的话，可能把这些被删除的记录占用的存储空间覆盖掉。</p><ul><li><code>min_rec_mask</code>：B+树的每层非叶子节点中的最小记录都会添加该标记，min_rec_mask值为1。我们自己插入的四条记录的min_rec_mask值都是0，意味着它们都不是B+树的非叶子节点中的最小记录。</li><li><code>record_type</code>：这个属性表示当前记录的类型，一共有4种类型的记录：<ul><li>0：表示普通记录</li><li>1：表示B+树非叶节点记录</li><li>2：表示最小记录</li><li>3：表示最大记录</li></ul></li><li><code>heap_no</code>：这个属性表示当前记录在本页中的位置。</li></ul><p><strong>怎么不见heap_no值为0和1的记录呢</strong>？<br>MySQL会自动给每个页里加了两个记录，由于这两个记录并不是我们自己插入的，所以有时候也称为<code>伪记录</code>或者<code>虚拟记录</code>。这两个伪记录一个代表<code>最小记录</code>，一个代表<code>最大记录</code>。最小记录和最大记录的heap_no值分别是0和1，也就是说它们的位置最靠前</p><ul><li><code>n_owned</code>：页目录中每个组中最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段</li><li><code>next_record</code>：记录头信息里该属性非常重要，它表示从当前记录的真实数据到下一条记录的真实数据的<code>地址偏移量</code>。</li></ul><h6 id="3-2-4-记录的真实数据"><a href="#3-2-4-记录的真实数据" class="headerlink" title="3.2.4 记录的真实数据"></a>3.2.4 记录的真实数据</h6><table><thead><tr><th>列名</th><th>是否必须</th><th>占用空间</th><th>描述</th></tr></thead><tbody><tr><td>row_id</td><td>否</td><td>6字节</td><td>行ID，唯一标识一条记录</td></tr><tr><td>transaction_id</td><td>是</td><td>6字节</td><td>事务ID</td></tr><tr><td>roll_pointer</td><td>是</td><td>7字节</td><td>回滚指针</td></tr></tbody></table><p>一个表没有手动定义主键，则会选取一个Unique键作为主键，如果连Unique键都没有定义的话，则会为表默认添加一个名为row_id的隐藏列作为主键。所以row_id是在没有自定义主键以及Unique键的情况下才会存在的。</p><h5 id="3-3-Dynamic和Compressed行格式"><a href="#3-3-Dynamic和Compressed行格式" class="headerlink" title="3.3 Dynamic和Compressed行格式"></a>3.3 Dynamic和Compressed行格式</h5><p>我们可以知道一个页的大小一般是16KB，也就是16384字节，而一个VARCHAR(M)类型的列就最多可以存储65533个字节，这样就可能出现一个页存放不了一条记录，这种现象称为<code>行溢出</code></p><p>在Compact和Reduntant行格式中，对于占用存储空间非常大的列，在记录的真实数据处只会存储该列的一部分数据，把剩余的数据分散存储在几个其他的页中进行<code>分页存储</code>，然后记录的真实数据处用20个字节存储指向这些页的地址（当然这20个字节中还包括这些分散在其他页面中的数据的占用的字节数），从而可以找到剩余数据所在的页。这称为<code>页的扩展</code>。</p><p>在MySQL 8.0中，默认行格式就是Dynamic，Dynamic、Compressed行格式和Compact行格式挺像，只不过在处理行溢出数据时有分歧</p><ul><li>Compressed和Dynamic两种记录格式对于存放在BLOB中的数据采用了完全的行溢出的方式。如图，在数据页中只存放20个字节的指针（溢出页的地址），实际的数据都存放在Off Page（溢出页）中。</li><li>Compact和Redundant两种格式会在记录的真实数据处存储一部分数据（存放768个前缀字节）。</li></ul><h4 id="4-区、段和碎片区"><a href="#4-区、段和碎片区" class="headerlink" title="4. 区、段和碎片区"></a>4. 区、段和碎片区</h4><h5 id="4-1-为什么要有区？"><a href="#4-1-为什么要有区？" class="headerlink" title="4.1 为什么要有区？"></a>4.1 为什么要有区？</h5><p><code>B+</code>树的每一层中的页都会形成一个双向链表，如果是以<code>页为单位</code>来分配存储空间的话，双向链表相邻的两个页之间的<code>物理位置可能离得非常远</code>。我们介绍B+树索引的使用场景的时候特别提到范围查询只需要定位到最左边的记录和最右边的记录，然后沿着双向链表一直扫描就可以了，而如果链表中相邻的两个页物理位置离得非常远，就是所谓的<code>随机I/O</code>。再一次强调，磁盘的速度和内存的速度差了好几个数量级，<code>随机I/O是非常慢</code>的，所以我们应该尽量让链表中相邻的页的物理位置也相邻，这样进行范围查询的时候才可以使用所谓的<code>顺序I/O</code>。</p><p>引入<code>区</code>的概念，一个区就是物理位置上连续的<code>64个页</code>。因为InnoDB中的页的大小默认是16KB，所以一个区的大小是64*16KB&#x3D;<code>1MB</code>。在表中<code>数据量大</code>的时候，为某个索引分配空间的时候就不再按照页的单位分配了，而是按照<code>区为单位分配</code>，甚至在表中的数据特别多的时候，可以一次性分配多个连续的区。虽然可能造成<code>一点点空间的浪费</code>（数据不足以填充满整个区），但是从性能角度看，可以消除很多的随机I&#x2F;O，<code>功大于过</code>！</p><h5 id="4-2-为什么要有段？"><a href="#4-2-为什么要有段？" class="headerlink" title="4.2 为什么要有段？"></a>4.2 为什么要有段？</h5><p>对于范围查询，其实是对B+树叶子节点中的记录进行顺序扫描，而如果不区分叶子节点和非叶子节点，统统把节点代表的页面放到申请到的区中的话，进行范围扫描的效果就大打折扣了。所以InnoDB对B+树的<code>叶子节点</code>和<code>非叶子节点</code>进行了区别对待，也就是说叶子节点有自己独有的区，非叶子节点也有自己独有的区。存放叶子节点的区的集合就算是一个<code>段（segment）</code>，存放非叶子节点的区的集合也算是一个段。也就是说一个索引会生成2个段，一个<code>叶子节点段</code>，一个<code>非叶子节点段</code>。</p><p>除了索引的叶子节点段和非叶子节点段之外，InnoDB中还有为存储一些特殊的数据而定义的段，比如回滚段。所以，常见的段有<code>数据段</code>、<code>索引段</code>、<code>回滚段</code>。数据段即为B+树的叶子节点，索引段即为B+树的非叶子节点。</p><p>在InnoDB存储引擎中，对段的管理都是由引擎自身所完成，DBA不能也没有必要对其进行控制。这从一定程度上简化了DBA对于段的管理。</p><p>段其实不对应表空间中的某一个连续的物理区域，而是一个逻辑上的概念，由若干个零散的页面以及一些完整的区组成。</p><h5 id="4-3-为什么要有碎片区？"><a href="#4-3-为什么要有碎片区？" class="headerlink" title="4.3 为什么要有碎片区？"></a>4.3 为什么要有碎片区？</h5><p>默认情况下，一个使用InnoDB存储引擎的表只有一个聚簇索引，一个索引会生成2个段，而段是以区为单位申请存储空间的，一个区默认占用1M（64*16KB&#x3D;1024KB）存储空间，所以<strong>默认情况下一个只存在几条记录的小表也需要2M的存储空间么？</strong>以后每次添加一个索引都要多申请2M的存储空间么？这对于存储记录比较少的表简直是天大的浪费。这个问题的症结在于到现在为止我们介绍的区都是非常<code>纯粹</code>的，也就是一个区被整个分配给某一个段，或者说区中的所有页面都是为了存储同一个段的数据而存在的，即使段的数据填不满区中所有的页面，那余下的页面也不能挪作他用。</p><p>为了考虑以完整的区为单位分配给某个段对于<code>数据量较小</code>的表太浪费存储空间的这种情况，InnoDB提出了一个<code>碎片（fragment）区</code>的概念。在一个碎片区中，并不是所有的页都是为了存储同一个段的数据而存在的，而是碎片区中的页可以用于不同的目的，比如有些页面用于段A，有些页面用于段B，有些页甚至哪个段都不属于。<code>碎片区直属于表空间</code>，并不属于任何一个段。</p><p>所以此后为某个段分配存储空间的策略是这样的：</p><ul><li>在刚开始向表中插入数据的时候，段是从某个碎片区以单个页面为单位来分配存储空间的。</li><li>当某个段已经占用了<code>32个碎片区</code>页面之后，就会申请以完整的区为单位来分配存储空间。</li></ul><p>所以现在段不能仅定义为是某些区的集合，更精确的应该是<code>某些零散的页面</code>已经<code>一些完整的区</code>的集合。</p><h5 id="4-4-区的分类"><a href="#4-4-区的分类" class="headerlink" title="4.4 区的分类"></a>4.4 区的分类</h5><p>区大体上可以分为4种类型：</p><ul><li><code>空闲的区(FREE)</code>：现在还没有用到这个区中的任何页面。</li><li><code>有剩余空间的碎片区(FREE_FRAG)</code>：表示碎片区中还有可用的页面。</li><li><code>没有剩余空间的碎片区(FULL_FRAG)</code>：表示碎片区中的所有页面都被使用，没有空闲页面。</li><li><code>附属于某个段的区(FSEG)</code>：每一索引都可以分为叶子节点段和非叶子节点段</li></ul><p>处于<code>FREE</code>、<code>FREE_FRAG</code>以及<code>FULL_FRAG</code>这三种状态的区都是独立的，直属于表空间。而处于<code>FSEG</code>状态的区是附属于某个段的。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第09章 性能分析工具的使用</title>
      <link href="/2023/07/15/%E7%AC%AC09%E7%AB%A0%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/07/15/%E7%AC%AC09%E7%AB%A0%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="第09章-性能分析工具的使用"><a href="#第09章-性能分析工具的使用" class="headerlink" title="第09章 性能分析工具的使用"></a>第09章 性能分析工具的使用</h3><h4 id="1-统计SQL的查询成本：last-query-cost"><a href="#1-统计SQL的查询成本：last-query-cost" class="headerlink" title="1. 统计SQL的查询成本：last_query_cost"></a><strong>1.</strong> <strong>统计SQL的查询成本：last_query_cost</strong></h4><pre><code class="mysql">SHOW STATUS LIKE &#39;last_query_cost&#39;;</code></pre><p>使用场景：它对于比较开销是非常有用的，特别是我们有好几种查询方式可选的时候。</p><blockquote><p>SQL 查询是一个动态的过程，从页加载的角度来看，我们可以得到以下两点结论：</p><ol><li><code>位置决定效率</code>。如果页就在数据库<code>缓冲池</code>中，那么效率是最高的，否则还需要从<code>内存</code>或者<code>磁盘</code>中进行读取，当然针对单个页的读取来说，如果页存在于内存中，会比在磁盘中读取效率高很多。</li><li><code>批量决定效率</code>。如果我们从磁盘中对单一页进行随机读，那么效率是很低的（差不多10ms），而采用顺序读取的方式，批量对页进行读取，平均一页的读取效率就会提升很多，甚至要快于单个页面在内存中的随机读取。</li></ol><p>所以说，遇到I&#x2F;O并不用担心，方法找对了，效率还是很高的。我们首先要考虑数据存放的位置，如果是经常使用的数据就要尽量放到<code>缓冲池</code>中，其次我们可以充分利用磁盘的吞吐能力，一次性批量读取数据，这样单个页的读取效率也就得到了提升。</p></blockquote><h4 id="2-定位执行慢的SQL：慢查询日志"><a href="#2-定位执行慢的SQL：慢查询日志" class="headerlink" title="2. 定位执行慢的SQL：慢查询日志"></a><strong>2.</strong> <strong>定位执行慢的SQL：慢查询日志</strong></h4><p>MySQL的慢查询日志，用来记录在MySQL中<code>响应时间超过阈值</code>的语句，具体指运行时间超过<code>long_query_time</code>的值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为<code>10</code>，意思是运行10秒以上（不含10秒）的语句，认为是超出了我们的最大忍耐时间值。</p><p>默认情况下，MySQL数据库<code>没有开启慢查询日志</code>，需要我们手动来设置这个参数。<code>如果不是调优需要的话，一般不建议启动该参数</code>，因为开启慢查询日志会或多或少带来一定的性能影响。</p><h5 id="2-1-开启慢查询日志参数"><a href="#2-1-开启慢查询日志参数" class="headerlink" title="2.1 开启慢查询日志参数"></a><strong>2.1</strong> <strong>开启慢查询日志参数</strong></h5><p><strong>1.</strong> <strong>开启slow_query_log</strong></p><pre><code class="mysql">set global slow_query_log=&#39;ON&#39;;</code></pre><p>查看下慢查询日志是否开启，以及慢查询日志文件的位置：</p><pre><code class="mysql">show variables like `%slow_query_log%`;</code></pre><p><strong>2.</strong> <strong>修改long_query_time阈值</strong></p><pre><code class="mysql">show variables like &#39;%long_query_time%&#39;;</code></pre><pre><code class="mysql">#测试发现：设置global的方式对当前session的long_query_time失效。对新连接的客户端有效。所以可以一并 执行下述语句 mysql &gt; set global long_query_time = 1; mysql&gt; show global variables like &#39;%long_query_time%&#39;; mysql&gt; set long_query_time=1; mysql&gt; show variables like &#39;%long_query_time%&#39;;</code></pre><h5 id="2-2-查看慢查询数目"><a href="#2-2-查看慢查询数目" class="headerlink" title="2.2 查看慢查询数目"></a><strong>2.2</strong> <strong>查看慢查询数目</strong></h5><pre><code class="mysql">SHOW GLOBAL STATUS LIKE &#39;%Slow_queries%&#39;;</code></pre><h5 id="2-3-慢查询日志分析工具：mysqldumpslow"><a href="#2-3-慢查询日志分析工具：mysqldumpslow" class="headerlink" title="2.3 慢查询日志分析工具：mysqldumpslow"></a><strong>2.3</strong> <strong>慢查询日志分析工具：mysqldumpslow</strong></h5><pre><code class="shell">#得到返回记录集最多的10个SQL mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log #得到访问次数最多的10个SQL mysqldumpslow -s c -t 10 /var/lib/mysql/atguigu-slow.log#得到按照时间排序的前10条里面含有左连接的查询语句 mysqldumpslow -s t -t 10 -g &quot;left join&quot; /var/lib/mysql/atguigu-slow.log #另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现爆屏情况 mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log | more</code></pre><h5 id="2-4-关闭慢查询日志"><a href="#2-4-关闭慢查询日志" class="headerlink" title="2.4 关闭慢查询日志"></a><strong>2.4</strong> <strong>关闭慢查询日志</strong></h5><p><strong>方式1：永久性方式</strong></p><pre><code class="ini">[mysqld] slow_query_log=OFF#或[mysqld] #slow_query_log =OFF</code></pre><p><strong>方式2：临时性方式</strong></p><pre><code class="mysql">SET GLOBAL slow_query_log=off;</code></pre><h4 id="3-查看-SQL-执行成本：SHOW-PROFILE"><a href="#3-查看-SQL-执行成本：SHOW-PROFILE" class="headerlink" title="3. 查看 SQL 执行成本：SHOW PROFILE"></a><strong>3.</strong> <strong>查看</strong> <strong>SQL</strong> <strong>执行成本：SHOW PROFILE</strong></h4><pre><code class="mysql">show variables like &#39;profiling&#39;;#开启set profiling = &#39;ON&#39;;#查看show profiles;show profile cpu,block io for query 2;</code></pre><h4 id="4-分析查询语句：EXPLAIN"><a href="#4-分析查询语句：EXPLAIN" class="headerlink" title="4. 分析查询语句：EXPLAIN"></a><strong>4.</strong> <strong>分析查询语句：EXPLAIN</strong></h4><h5 id="4-1-基本语法"><a href="#4-1-基本语法" class="headerlink" title="4.1 基本语法"></a><strong>4.1</strong> <strong>基本语法</strong></h5><pre><code class="mysql">EXPLAIN SELECT select_options #或者DESCRIBE SELECT select_options</code></pre><p>EXPLAIN 语句输出的各个列的作用如下：</p><table><thead><tr><th>列名</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td>在一个大的查询语句中每个SELECT关键字都对应一个<code>唯一的id</code></td></tr><tr><td>select_type</td><td>SELECT关键字对应的那个查询的类型</td></tr><tr><td>table</td><td>表名</td></tr><tr><td>partitions</td><td>匹配的分区信息</td></tr><tr><td>type</td><td>针对单表的访问方法</td></tr><tr><td>possible_keys</td><td>可能用到的索引</td></tr><tr><td>key</td><td>实际上使用的索引</td></tr><tr><td>key_len</td><td>实际使用到的索引长度</td></tr><tr><td>ref</td><td>当使用索引列等值查询时，与索引列进行等值匹配的对象信息</td></tr><tr><td>rows</td><td>预估的需要读取的记录条数</td></tr><tr><td>filtered</td><td>某个表经过搜索条件过滤后剩余记录条数的百分比</td></tr><tr><td>Extra</td><td>一些额外的信息</td></tr></tbody></table><h5 id="4-2-EXPLAIN各列作用"><a href="#4-2-EXPLAIN各列作用" class="headerlink" title="4.2 EXPLAIN各列作用"></a><strong>4.2 EXPLAIN各列作用</strong></h5><p><strong>1. table</strong></p><p>不论我们的查询语句有多复杂，包含了多少个表 ，到最后也是需要对每个表进行<code>单表访问</code>的，所以MySQL规定<strong>EXPLAIN语句输出的每条记录都对应着某个单表的访问方法</strong>，该条记录的table列代表着该表的表名（有时不是真实的表名字，可能是简称）。</p><p><strong>2. id</strong></p><ul><li><strong>id如果相同，可以认为是一组，从上往下顺序执行</strong></li><li><strong>在所有组中，id值越大，优先级越高，越先执行</strong></li><li><strong>关注点：id号每个号码，表示一趟独立的查询,一个sql的查询趟数越少越好</strong></li></ul><p><strong>3. select_type</strong></p><p><strong>4. partitions</strong></p><p><strong>5. type（重点）</strong></p><p><strong>结果值从最好到最坏依次是：</strong> <strong>system &gt; const &gt; eq_ref &gt; ref</strong> <strong>&gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt;</strong> <strong>range &gt; index &gt; ALL</strong> </p><p><strong>SQL性能优化的目标：至少要达到 range级别，要求是ref级别，最好是consts级别。（阿里巴巴开发手册要求）</strong></p><p><strong>6. possible_keys和key</strong></p><p><strong>7. key_len（重点）</strong></p><p><strong>key_len的长度计算公式：</strong></p><pre><code>varchar(10)变长字段且允许NULL = 10 * ( character set： utf8=3,gbk=2,latin1=1)+1(NULL)+2(变长字段) varchar(10)变长字段且不允许NULL = 10 * ( character set：utf8=3,gbk=2,latin1=1)+2(变长字段)char(10)固定字段且允许NULL = 10 * ( character set：utf8=3,gbk=2,latin1=1)+1(NULL) char(10)固定字段且不允许NULL = 10 * ( character set：utf8=3,gbk=2,latin1=1)</code></pre><p><strong>8. ref</strong> </p><p><strong>9. rows（重点）</strong></p><p>预估的需要读取的记录条数</p><p><strong>10. filtered</strong></p><p><strong>11. Extra</strong></p><h4 id="5-EXPLAIN的进一步使用"><a href="#5-EXPLAIN的进一步使用" class="headerlink" title="5. EXPLAIN的进一步使用"></a><strong>5. EXPLAIN的进一步使用</strong></h4><h5 id="5-1-EXPLAIN四种输出格式"><a href="#5-1-EXPLAIN四种输出格式" class="headerlink" title="5.1 EXPLAIN四种输出格式"></a><strong>5.1 EXPLAIN四种输出格式</strong></h5><p>这里谈谈EXPLAIN的输出格式。EXPLAIN可以输出四种格式：<code>传统格式</code>，<code>JSON格式</code>，<code>TREE格式</code>以及<code>可视化输出</code>。用户可以根据需要选择适用于自己的格式。</p><p><strong>1.</strong> <strong>传统格式</strong></p><p><strong>2. JSON格式</strong> </p><p>JSON格式：在EXPLAIN单词和真正的查询语句中间加上<code>FORMAT=JSON</code>。用于查看执行成本<code>cost_info</code></p><p><strong>3. TREE格式</strong></p><p>TREE格式是8.0.16版本之后引入的新格式，主要根据查询的<code>各个部分之间的关系</code>和<code>各部分的执行顺序</code>来描述如何查询。</p><p><strong>4.</strong> <strong>可视化输出</strong></p><p>可视化输出，可以通过MySQL Workbench可视化查看MySQL的执行计划。</p><h5 id="5-2-SHOW-WARNINGS的使用"><a href="#5-2-SHOW-WARNINGS的使用" class="headerlink" title="5.2 SHOW WARNINGS的使用"></a><strong>5.2 SHOW WARNINGS的使用</strong></h5><pre><code class="mysql">mysql&gt; EXPLAIN SELECT s1.key1, s2.key1 FROM s1 LEFT JOIN s2 ON s1.key1 = s2.key1 WHERE s2.common_field IS NOT NULL;# 查看优化后的执行语句mysql&gt; SHOW WARNINGS\G</code></pre><h4 id="6-分析优化器执行计划：trace"><a href="#6-分析优化器执行计划：trace" class="headerlink" title="6. 分析优化器执行计划：trace"></a><strong>6.</strong> <strong>分析优化器执行计划：trace</strong></h4><pre><code class="mysql"># 开启SET optimizer_trace=&quot;enabled=on&quot;,end_markers_in_json=on; # 设置大小set optimizer_trace_max_mem_size=1000000;# 使用select * from student where id &lt; 10;select * from information_schema.optimizer_trace\G</code></pre><h4 id="7-MySQL监控分析视图-sys-schema"><a href="#7-MySQL监控分析视图-sys-schema" class="headerlink" title="7. MySQL监控分析视图-sys schema"></a><strong>7. MySQL监控分析视图-sys schema</strong></h4><p><strong>7.1 Sys schema视图使用场景</strong></p><p><strong>索引情况</strong></p><pre><code class="mysql">#1. 查询冗余索引 select * from sys.schema_redundant_indexes; #2. 查询未使用过的索引 select * from sys.schema_unused_indexes; #3. 查询索引的使用情况 select index_name,rows_selected,rows_inserted,rows_updated,rows_deleted from sys.schema_index_statistics where table_schema=&#39;dbname&#39; ;</code></pre><p><strong>表相关</strong></p><pre><code class="mysql"># 1. 查询表的访问量 select table_schema,table_name,sum(io_read_requests+io_write_requests) as io from sys.schema_table_statistics group by table_schema,table_name order by io desc; # 2. 查询占用bufferpool较多的表 select object_schema,object_name,allocated,datafrom sys.innodb_buffer_stats_by_table order by allocated limit 10; # 3. 查看表的全表扫描情况 select * from sys.statements_with_full_table_scans where db=&#39;dbname&#39;;</code></pre><p><strong>语句相关</strong></p><pre><code class="mysql">#1. 监控SQL执行的频率 select db,exec_count,query from sys.statement_analysis order by exec_count desc; #2. 监控使用了排序的SQL select db,exec_count,first_seen,last_seen,queryfrom sys.statements_with_sorting limit 1; #3. 监控使用了临时表或者磁盘临时表的SQL select db,exec_count,tmp_tables,tmp_disk_tables,queryfrom sys.statement_analysis where tmp_tables&gt;0 or tmp_disk_tables &gt;0 order by (tmp_tables+tmp_disk_tables) desc;</code></pre><p><strong>IO相关</strong></p><pre><code class="mysql">#1. 查看消耗磁盘IO的文件 select file,avg_read,avg_write,avg_read+avg_write as avg_iofrom sys.io_global_by_file_by_bytes order by avg_read limit 10;</code></pre><p><strong>Innodb</strong> <strong>相关</strong></p><pre><code class="mysql">#1. 行锁阻塞情况 select * from sys.innodb_lock_waits;</code></pre><h3 id><a href="#" class="headerlink" title></a></h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第08章 索引的创建与设计原则</title>
      <link href="/2023/07/15/%E7%AC%AC08%E7%AB%A0%20%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
      <url>/2023/07/15/%E7%AC%AC08%E7%AB%A0%20%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h3 id="第08章-索引的创建与设计原则"><a href="#第08章-索引的创建与设计原则" class="headerlink" title="第08章 索引的创建与设计原则"></a>第08章 索引的创建与设计原则</h3><h4 id="1-索引的声明与使用"><a href="#1-索引的声明与使用" class="headerlink" title="1. 索引的声明与使用"></a><strong>1.</strong> <strong>索引的声明与使用</strong></h4><h5 id="1-1-索引的分类"><a href="#1-1-索引的分类" class="headerlink" title="1.1 索引的分类"></a><strong>1.1</strong> <strong>索引的分类</strong></h5><ul><li>从<code>功能逻辑</code>上说，索引主要有 4 种，分别是普通索引、唯一索引、主键索引、全文索引。</li><li>按照<code>物理实现方式</code>，索引可以分为 2 种：聚簇索引和非聚簇索引。</li><li>按照<code>作用字段个数</code>进行划分，分成单列索引和联合索引。</li></ul><h5 id="1-2-创建索引"><a href="#1-2-创建索引" class="headerlink" title="1.2 创建索引"></a><strong>1.2</strong> <strong>创建索引</strong></h5><pre><code class="mysql">CREATE TABLE table_name [col_name data_type] [UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY] [index_name] (col_name [length]) [ASC | DESC]</code></pre><ul><li><code>UNIQUE</code>、<code>FULLTEXT</code>和<code>SPATIAL</code>为可选参数，分别表示唯一索引、全文索引和空间索引；</li><li><code>INDEX</code>与<code>KEY</code>为同义词，两者的作用相同，用来指定创建索引；</li><li><code>index_name</code>指定索引的名称，为可选参数，如果不指定，那么MySQL默认col_name为索引名；</li><li><code>col_name</code>为需要创建索引的字段列，该列必须从数据表中定义的多个列中选择；</li><li><code>length</code>为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度；</li><li><code>ASC</code>或<code>DESC</code>指定升序或者降序的索引值存储。</li></ul><p><strong>1.</strong> <strong>创建普通索引</strong></p><pre><code class="mysql">CREATE TABLE book(     book_id INT ,     book_name VARCHAR(100),     authors VARCHAR(100),     info VARCHAR(100) ,     comment VARCHAR(100),     year_publication YEAR,     INDEX(year_publication) );</code></pre><p><strong>2.</strong> <strong>创建唯一索引</strong></p><pre><code class="mysql">CREATE TABLE test1(     id INT NOT NULL,     name varchar(30) NOT NULL,     UNIQUE INDEX uk_idx_id(id) );</code></pre><p><strong>3.</strong> <strong>主键索引</strong></p><pre><code class="mysql">CREATE TABLE student (     id INT(10) UNSIGNED AUTO_INCREMENT,     student_no VARCHAR(200),    student_name VARCHAR(200),     PRIMARY KEY(id) );</code></pre><pre><code class="mysql"># 删除主键索引ALTER TABLE student drop PRIMARY KEY ;</code></pre><p><strong>4.</strong> <strong>创建单列索引</strong></p><pre><code class="mysql">CREATE TABLE test2(     id INT NOT NULL,     name CHAR(50) NULL,     INDEX single_idx_name(name(20)) );</code></pre><p><strong>5.</strong> <strong>创建组合索引</strong></p><pre><code class="mysql">CREATE TABLE test3(     id INT(11) NOT NULL,     name CHAR(30) NOT NULL,     age INT(11) NOT NULL,     info VARCHAR(255),     INDEX multi_idx(id,name,age) );</code></pre><p><strong>6.</strong> <strong>创建全文索引</strong></p><pre><code class="mysql">CREATE TABLE `papers` (     id` int(10) unsigned NOT NULL AUTO_INCREMENT,     `title` varchar(200) DEFAULT NULL,     `content` text, PRIMARY KEY (`id`),     FULLTEXT KEY `title` (`title`,`content`) ) ENGINE=MyISAM DEFAULT CHARSET=utf8;</code></pre><pre><code class="mysql">SELECT * FROM papers WHERE MATCH(title,content) AGAINST (‘查询字符串’);</code></pre><p><strong>7.</strong> <strong>创建空间索引</strong></p><pre><code class="mysql">CREATE TABLE test5(     geo GEOMETRY NOT NULL,     SPATIAL INDEX spa_idx_geo(geo) ) ENGINE=MyISAM;</code></pre><p><strong>2.</strong> <strong>在已经存在的表上创建索引</strong></p><p><strong>1.</strong> <strong>使用ALTER TABLE语句创建索引</strong></p><pre><code class="mysql">ALTER TABLE table_name ADD [UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY] [index_name] (col_name[length],...) [ASC | DESC]</code></pre><p><strong>2.</strong> <strong>使用CREATE INDEX创建索引</strong></p><pre><code class="mysql">CREATE [UNIQUE | FULLTEXT | SPATIAL] INDEX index_name ON table_name (col_name[length],...) [ASC | DESC]</code></pre><h5 id="1-3-删除索引"><a href="#1-3-删除索引" class="headerlink" title="1.3 删除索引"></a><strong>1.3</strong> <strong>删除索引</strong></h5><p><strong>1.</strong> <strong>使用ALTER TABLE删除索引</strong></p><pre><code class="mysql">ALTER TABLE table_name DROP INDEX index_name;</code></pre><p><strong>2.</strong> <strong>使用DROP INDEX语句删除索引</strong></p><pre><code class="mysql">DROP INDEX index_name ON table_name;</code></pre><h4 id="2-MySQL8-0索引新特性"><a href="#2-MySQL8-0索引新特性" class="headerlink" title="2. MySQL8.0索引新特性"></a><strong>2. MySQL8.0索引新特性</strong></h4><h5 id="2-1-支持降序索引"><a href="#2-1-支持降序索引" class="headerlink" title="2.1 支持降序索引"></a><strong>2.1</strong> <strong>支持降序索引</strong></h5><pre><code class="mysql">CREATE TABLE ts1(a int,b int,index idx_a_b(a,b desc));</code></pre><h5 id="2-2-隐藏索引"><a href="#2-2-隐藏索引" class="headerlink" title="2.2 隐藏索引"></a><strong>2.2</strong> <strong>隐藏索引</strong></h5><p>从MySQL 8.x开始支持<code>隐藏索引（invisible indexes）</code>，只需要将待删除的索引设置为隐藏索引，使查询优化器不再使用这个索引（即使使用force index（强制使用索引），优化器也不会使用该索引），确认将索引设置为隐藏索引后系统不受任何响应，就可以彻底删除索引。<code>这种通过先将索引设置为隐藏索引，再删除索引的方式就是软删除</code>。</p><p><strong>1.</strong> <strong>创建表时直接创建</strong> </p><pre><code class="mysql">CREATE TABLE tablename(     propname1 type1[CONSTRAINT1],     propname2 type2[CONSTRAINT2],     ……    propnamen typen,     INDEX [indexname](propname1 [(length)]) INVISIBLE );</code></pre><p><strong>2.</strong> <strong>在已经存在的表上创建</strong></p><pre><code class="mysql">CREATE INDEX indexname ON tablename(propname[(length)]) INVISIBLE;</code></pre><p><strong>3.</strong> <strong>通过ALTER TABLE语句创建</strong></p><pre><code class="mysql">ALTER TABLE tablename ADD INDEX indexname (propname [(length)]) INVISIBLE;</code></pre><p><strong>4.</strong> <strong>切换索引可见状态</strong></p><pre><code class="mysql">ALTER TABLE tablename ALTER INDEX index_name INVISIBLE; #切换成隐藏索引 ALTER TABLE tablename ALTER INDEX index_name VISIBLE; #切换成非隐藏索引</code></pre><h4 id="3-索引的设计原则"><a href="#3-索引的设计原则" class="headerlink" title="3. 索引的设计原则"></a><strong>3.</strong> <strong>索引的设计原则</strong></h4><h5 id="3-1-哪些情况适合创建索引"><a href="#3-1-哪些情况适合创建索引" class="headerlink" title="3.1 哪些情况适合创建索引"></a><strong>3.1</strong> <strong>哪些情况适合创建索引</strong></h5><p><strong>1.</strong> <strong>字段的数值有唯一性的限制</strong></p><p>索引本身可以起到约束的作用，比如唯一索引、主键索引都可以起到唯一性约束的，因此在我们的数据表中，如果<code>某个字段是唯一的</code>，就可以直接<code>创建唯一性索引</code>，或者<code>主键索引</code>。这样可以更快速地通过该索引来确定某条记录。</p><blockquote><p>业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。（来源：Alibaba）</p><p>说明：不要以为唯一索引影响了insert速度，这个速度损耗可以忽略，但提高查找速度是明显的。</p></blockquote><p><strong>2.</strong> <strong>频繁作为</strong> <strong>WHERE</strong> <strong>查询条件的字段</strong></p><p>某个字段在SELECT语句的 WHERE 条件中经常被使用到，那么就需要给这个字段创建索引了。尤其是在数据量大的情况下，创建普通索引就可以大幅提升数据查询的效率。</p><p><strong>3.</strong> <strong>经常</strong> <strong>GROUP BY</strong> <strong>和</strong> <strong>ORDER BY</strong> <strong>的列</strong></p><p>索引就是让数据按照某种顺序进行存储或检索，因此当我们使用 GROUP BY 对数据进行分组查询，或者使用 ORDER BY 对数据进行排序的时候，就需要<code>对分组或者排序的字段进行索引</code>。如果待排序的列有多个，那么可以在这些列上建立<code>组合索引</code>。</p><p><strong>4. UPDATE、DELETE</strong> <strong>的</strong> <strong>WHERE</strong> <strong>条件列</strong></p><p>对数据按照某个条件进行查询后再进行 UPDATE 或 DELETE 的操作，如果对 WHERE 字段创建了索引，就能大幅提升效率。原理是因为我们需要先根据 WHERE 条件列检索出来这条记录，然后再对它进行更新或删除。<strong>如果进行更新的时候，更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护。</strong></p><p><strong>5.DISTINCT</strong> <strong>字段需要创建索引</strong></p><p>有时候我们需要对某个字段进行去重，使用 DISTINCT，那么对这个字段创建索引，也会提升查询效率。</p><p><strong>6.</strong> <strong>多表</strong> <strong>JOIN</strong> <strong>连接操作时，创建索引注意事项</strong></p><p>首先，<code>连接表的数量尽量不要超过 3 张</code>，因为每增加一张表就相当于增加了一次嵌套的循环，数量级增长会非常快，严重影响查询的效率。</p><p>其次，<code>对 WHERE 条件创建索引</code>，因为 WHERE 才是对数据条件的过滤。如果在数据量非常大的情况下，没有 WHERE 条件过滤是非常可怕的。</p><p>最后，<code>对用于连接的字段创建索引</code>，并且该字段在多张表中的<code>类型必须一致</code>。</p><p><strong>7.</strong> <strong>使用列的类型小的创建索引</strong> </p><p>我们这里所说的<code>类型大小</code>指的就是该类型表示的数据范围的大小。</p><ul><li>数据类型越小，在查询时进行的比较操作越快</li><li>数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以<code>放下更多的记录</code>，从而减少磁盘<code>I/O</code>带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。</li></ul><p>这个建议对于表的<code>主键来说更加适用</code>，因为不仅是聚簇索引中会存储主键值，其他所有的二级索引的节点处都会存储一份记录的主键值，如果主键使用更小的数据类型，也就意味着节省更多的存储空间和更高效的I&#x2F;O。</p><p><strong>8.</strong> <strong>使用字符串前缀创建索引</strong></p><p>区分度计算公式：</p><pre><code class="mysql">count(distinct left(列名, 索引长度))/count(*)</code></pre><p><strong>拓展：Alibaba《Java开发手册》</strong></p><p>【<code>强制</code>】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度。</p><p>说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会<code>高达 90% 以上</code>。</p><p><strong>9.</strong> <strong>区分度高(散列性高)的列适合作为索引</strong></p><p><code>列的基数</code>指的是某一列中不重复数据的个数，比方说某个列包含值<code>2,5,8,2,5,8,2,5,8</code>，虽然有<code>9</code>条记录，但该列的基数却是<code>3</code>。也就是说，<strong>在记录行数一定的情况下，列的基数越大，该列中的值越分散；列的基数越小，该列中的值越集中。</strong>这个列的基数指标非常重要，直接影响我们是否能有效的利用索引。最好为列的基数大的列建立索引，为基数太小的列建立索引效果可能不好。</p><p>可以使用公式<code>select count(distinct a)/count(*) from t1</code>计算区分度，越接近1越好，一般超过<code>33%</code>就算是比较高效的索引了。</p><p>拓展：联合索引把区分度高（散列性高）的列放在前面。</p><p><strong>10.</strong> <strong>使用最频繁的列放到联合索引的左侧</strong></p><p><strong>11.</strong> <strong>在多个字段都要创建索引的情况下，联合索引优于单值索引</strong></p><h5 id="3-2-限制索引的数目"><a href="#3-2-限制索引的数目" class="headerlink" title="3.2 限制索引的数目"></a><strong>3.2</strong> <strong>限制索引的数目</strong></h5><p>在实际工作中，我们也需要注意平衡，索引的数目不是越多越好。我们需要限制每张表上的索引数量，建议单张表索引数量<code>不超过6个</code>。原因：</p><ul><li>每个索引都需要占用<code>磁盘空间</code>，索引越多，需要的磁盘空间就越大。</li><li>索引会影响<code>INSERT、DELETE、UPDATE等语句的性能</code>，因为表中的数据更改的同时，索引也会进行调整和更新，会造成负担。</li><li>优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的<code>索引来进行评估</code>，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，会增加MySQL优化器生成执行计划时间，降低查询性能。</li></ul><h5 id="3-3-哪些情况不适合创建索引"><a href="#3-3-哪些情况不适合创建索引" class="headerlink" title="3.3 哪些情况不适合创建索引"></a><strong>3.3</strong> <strong>哪些情况不适合创建索引</strong></h5><p><strong>1.</strong> <strong>在where中使用不到的字段，不要设置索引</strong></p><p><strong>2.</strong> <strong>数据量小的表最好不要使用索引</strong></p><p><strong>3.</strong> <strong>有大量重复数据的列上不要建立索引</strong></p><p><strong>4.</strong> <strong>避免对经常更新的表创建过多的索引</strong> </p><p><strong>5.</strong> <strong>不建议用无序的值作为索引</strong></p><p>例如身份证、UUID(在索引比较时需要转为ASCII，并且插入时可能造成页分裂)、MD5、HASH、无序长字符串等。</p><p><strong>6.</strong> <strong>删除不再使用或者很少使用的索引</strong></p><p><strong>7.</strong> <strong>不要定义冗余或重复的索引</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第11章 数据库的设计规范</title>
      <link href="/2023/07/15/%E7%AC%AC11%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/"/>
      <url>/2023/07/15/%E7%AC%AC11%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h3 id="第11章-数据库的设计规范"><a href="#第11章-数据库的设计规范" class="headerlink" title="第11章 数据库的设计规范"></a>第11章 数据库的设计规范</h3><h4 id="1-范-式"><a href="#1-范-式" class="headerlink" title="1. 范 式"></a><strong>1.</strong> <strong>范 式</strong></h4><h5 id="1-1-范式简介"><a href="#1-1-范式简介" class="headerlink" title="1.1 范式简介"></a><strong>1.1</strong> <strong>范式简介</strong></h5><p><strong>在关系型数据库中，关于数据表设计的基本原则、规则就称为范式。</strong>可以理解为，一张数据表的设计结构需要满足的某种设计标准的<code>级别</code>。要想设计一个结构合理的关系型数据库，必须满足一定的范式。</p><h5 id="1-2-范式都包括哪些"><a href="#1-2-范式都包括哪些" class="headerlink" title="1.2 范式都包括哪些"></a><strong>1.2</strong> <strong>范式都包括哪些</strong></h5><p>目前关系型数据库有六种常见范式，按照范式级别，从低到高分别是：<strong>第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204030928295.png" alt="image-20220403092826169"></p><h5 id="1-3-键和相关属性的概念"><a href="#1-3-键和相关属性的概念" class="headerlink" title="1.3 键和相关属性的概念"></a><strong>1.3</strong> <strong>键和相关属性的概念</strong></h5><p>这里有两个表：</p><p><code>球员表(player)</code>：球员编号 | 姓名 | 身份证号 | 年龄 | 球队编号</p><p><code>球队表(team)</code>：球队编号 | 主教练 | 球队所在地</p><ul><li><code>超键</code>：对于球员表来说，超键就是包括球员编号或者身份证号的任意组合，比如（球员编号）（球员编号，姓名）（身份证号，年龄）等。</li><li><code>候选键</code>：就是最小的超键，对于球员表来说，候选键就是（球员编号）或者（身份证号）。</li><li><code>主键</code>：我们自己选定，也就是从候选键中选择一个，比如（球员编号）。</li><li><code>外键</code>：球员表中的球队编号。</li><li><code>主属性</code>、<code>非主属性</code>：在球员表中，主属性是（球员编号）（身份证号），其他的属性（姓名）（年龄）（球队编号）都是非主属性。</li></ul><h5 id="1-4-第一范式-1st-NF"><a href="#1-4-第一范式-1st-NF" class="headerlink" title="1.4 第一范式(1st NF)"></a><strong>1.4</strong> <strong>第一范式(1st NF)</strong></h5><p>第一范式主要是确保数据表中每个字段的值必须具有<code>原子性</code>，也就是说数据表中每个字段的值为<code>不可再次拆分</code>的最小数据单位。</p><h5 id="1-5-第二范式-2nd-NF"><a href="#1-5-第二范式-2nd-NF" class="headerlink" title="1.5 第二范式(2nd NF)"></a><strong>1.5</strong> <strong>第二范式(2nd NF)</strong></h5><p>第二范式要求，在满足第一范式的基础上，还要<strong>满足数据表里的每一条数据记录，都是可唯一标识的。而且所有非主键字段，都必须完全依赖主键，不能只依赖主键的一部分。</strong>如果知道主键的所有属性的值，就可以检索到任何元组（行）的任何属性的任何值。</p><h5 id="1-6-第三范式-3rd-NF"><a href="#1-6-第三范式-3rd-NF" class="headerlink" title="1.6 第三范式(3rd NF)"></a><strong>1.6</strong> <strong>第三范式(3rd NF)</strong></h5><p>第三范式是在第二范式的基础上，确保数据表中的每一个非主键字段都和主键字段直接相关，也就是说，<strong>要求数据表中的所有非主键字段不能依赖于其他非主键字段。</strong>（即，不能存在非主属性A依赖于非主属性B，非主属性B依赖于主键C的情况，即存在”A–&gt;B–&gt;C”的决定关系）通俗地讲，该规则的意思是所有<code>非主键属性</code>之间不能有依赖关系，必须<code>相互独立</code>。</p><h5 id="1-7-小结"><a href="#1-7-小结" class="headerlink" title="1.7 小结"></a>1.7 小结</h5><p>关于数据表的设计，有三个范式要遵循。</p><p>（1）第一范式（1NF），确保每列保持<code>原子性</code></p><p>数据库的每一列都是不可分割的原子数据项，不可再分的最小数据单元，而不能是集合、数组、记录等非原子数据项。</p><p>（2）第二范式（2NF），确保每列都和主键<code>完全依赖</code></p><p>尤其在复合主键的情况向下，非主键部分不应该依赖于部分主键。</p><p>（3）第三范式（3NF），确保每列都和主键<code>直接相关</code>，而不是间接相关</p><p><strong>范式的优点：</strong>数据的标准化有助于消除数据库中的<code>数据冗余</code>，第三范式（3NF）通常被认为在性能、拓展性和数据完整性方面达到了最好的平衡。</p><p><strong>范式的缺点：</strong>范式的使用，可能<code>降低查询的效率</code>。因为范式等级越高，设计出来的数据表就越多、越精细，数据的冗余度就越低，进行数据查询的时候就可能需要<code>关联多张表</code>，这不但代价昂贵，也可能使一些<code>索引策略无效</code>。</p><p>范式只是提出了设计的标准，实际上设计数据表时，未必一定要符合这些标准。开发中，我们会出现为了性能和读取效率违反范式化的原则，通过<code>增加少量的冗余</code>或重复的数据来提高数据库的<code>读性能</code>，减少关联查询，join表的次数，实现<code>空间换取时间</code>的目的。因此在实际的设计过程中要理论结合实际，灵活运用。</p><h4 id="2-反范式化"><a href="#2-反范式化" class="headerlink" title="2. 反范式化"></a><strong>2.</strong> <strong>反范式化</strong></h4><h5 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a><strong>2.1</strong> <strong>概述</strong></h5><p><strong>规范化</strong> <strong>vs</strong> <strong>性能</strong></p><ol><li><p>为满足某种商业目标 , 数据库性能比规范化数据库更重要</p></li><li><p>在数据规范化的同时 , 要综合考虑数据库的性能</p></li><li><p>通过在给定的表中添加额外的字段，以大量减少需要从中搜索信息所需的时间</p></li><li><p>通过在给定的表中插入计算列，以方便查询</p></li></ol><h5 id="2-2-反范式的新问题"><a href="#2-2-反范式的新问题" class="headerlink" title="2.2 反范式的新问题"></a><strong>2.2</strong> <strong>反范式的新问题</strong></h5><ul><li>存储<code>空间变大</code>了</li><li>一个表中字段做了修改，另一个表中冗余的字段也需要做同步修改，否则<code>数据不一致</code></li><li>若采用存储过程来支持数据的更新、删除等额外操作，如果更新频繁，会非常<code>消耗系统资源</code></li><li>在<code>数据量小</code>的情况下，反范式不能体现性能的优势，可能还会让数据库的设计更加<code>复杂</code></li></ul><h5 id="2-3-反范式的适用场景"><a href="#2-3-反范式的适用场景" class="headerlink" title="2.3 反范式的适用场景"></a><strong>2.3</strong> <strong>反范式的适用场景</strong></h5><p>当冗余信息有价值或者能<code>大幅度提高查询效率</code>的时候，我们才会采取反范式的优化。</p><p><strong>1.</strong> <strong>增加冗余字段的建议</strong> </p><p>1）这个冗余字段<code>不需要经常进行修改</code></p><p>2）这个冗余字段<code>查询的时候不可或缺</code></p><p><strong>2.</strong> <strong>历史快照、历史数据的需要</strong></p><p>在现实生活中，我们经常需要一些冗余信息，比如订单中的收货人信息，包括姓名、电话和地址等。每次发生的<code>订单收货信息</code>都属于<code>历史快照</code>，需要进行保存，但用户可以随时修改自己的信息，这时保存这些冗余信息是非常有必要的。</p><p>反范式优化也常用在<code>数据仓库</code>的设计中，因为数据仓库通常<code>存储历史数据</code>，对增删改的实时性要求不强，对历史数据的分析需求强。这时适当允许数据的冗余度，更方便进行数据分析。</p><h4 id="3-BCNF-巴斯范式"><a href="#3-BCNF-巴斯范式" class="headerlink" title="3. BCNF(巴斯范式)"></a><strong>3. BCNF(巴斯范式)</strong></h4><p>主属性（仓库名）对于候选键（管理员，物品名）是部分依赖的关系，这样就有可能导致异常情况。因此引入BCNF，<strong>它在</strong> <strong>3NF</strong> <strong>的基础上消除了主属性对候选键的部分依赖或者传递依赖关系</strong>。</p><p>如果在关系R中，U为主键，A属性是主键的一个属性，若存在A-&gt;Y，Y为主属性，则该关系不属于BCNF。</p><h4 id="4-ER模型"><a href="#4-ER模型" class="headerlink" title="4. ER模型"></a><strong>4. ER模型</strong></h4><p>ER模型也叫做<code>实体关系模型</code>，是用来描述现实生活中客观存在的事物、事物的属性，以及事物之间关系的一种数据模型。<strong>在开发基于数据库的信息系统的设计阶段，通常使用ER模型来描述信息需要和信息特性，帮助我们理清业务逻辑，从而设计出优秀的数据库。</strong></p><h5 id="4-1-ER-模型包括那些要素？"><a href="#4-1-ER-模型包括那些要素？" class="headerlink" title="4.1 ER 模型包括那些要素？"></a>4.1 ER 模型包括那些要素？</h5><p><strong>ER</strong> <strong>模型中有三个要素，分别是实体、属性和关系</strong>。 </p><p><code>实体</code>，可以看做是数据对象，往往对应于现实生活中的真实存在的个体。在 ER 模型中，用<code>矩形</code>来表示。实体分为两类，分别是<code>强实体</code>和<code>弱实体</code>。强实体是指不依赖于其他实体的实体；弱实体是指对另一个实体有很强的依赖关系的实体。</p><p><code>属性</code>，则是指实体的特性。比如超市的地址、联系电话、员工数等。在 ER 模型中用<code>椭圆形</code>来表示。</p><p><code>关系</code>，则是指实体之间的联系。比如超市把商品卖给顾客，就是一种超市与顾客之间的联系。在 ER 模型中用<code>菱形</code>来表示。</p><p>注意：实体和属性不容易区分。这里提供一个原则：我们要从系统整体的角度出发去看，<strong>可以独立存在的是实体，不可再分的是属性</strong>。也就是说，属性不能包含其他属性。</p><h5 id="4-2-关系的类型"><a href="#4-2-关系的类型" class="headerlink" title="4.2 关系的类型"></a><strong>4.2</strong> <strong>关系的类型</strong></h5><p>在 ER 模型的 3 个要素中，关系又可以分为 3 种类型，分别是 一对一、一对多、多对多。</p><p><code>一对一</code>：指实体之间的关系是一一对应的</p><p><code>一对多</code>：指一边的实体通过关系，可以对应多个另外一边的实体。相反，另外一边的实体通过这个关系，则只能对应唯一的一边的实体</p><p><code>多对多</code>：指关系两边的实体都可以通过关系对应多个对方的实体</p><h4 id="5-数据表的设计原则"><a href="#5-数据表的设计原则" class="headerlink" title="5. 数据表的设计原则"></a><strong>5.</strong> <strong>数据表的设计原则</strong></h4><p>数据表设计的一般原则：”三少一多” </p><p><strong>1.</strong> <strong>数据表的个数越少越好</strong> </p><p><strong>2.</strong> <strong>数据表中的字段个数越少越好</strong></p><p><strong>3.</strong> <strong>数据表中联合主键的字段个数越少越好</strong></p><p><strong>4.</strong> <strong>使用主键和外键越多越好</strong></p><blockquote><p>注意：这个原则并不是绝对的，有时候我们需要牺牲数据的冗余度来换取数据处理的效率。</p></blockquote><h4 id="6-数据库对象编写建议"><a href="#6-数据库对象编写建议" class="headerlink" title="6. 数据库对象编写建议"></a><strong>6.</strong> <strong>数据库对象编写建议</strong></h4><h5 id="6-1-关于库"><a href="#6-1-关于库" class="headerlink" title="6.1 关于库"></a><strong>6.1</strong> <strong>关于库</strong></h5><ol><li><p>【强制】库的名称必须控制在32个字符以内，只能使用英文字母、数字和下划线，建议以英文字母开头。</p></li><li><p>【强制】库名中英文<code>一律小写</code>，不同单词采用<code>下划线</code>分割。须见名知意。</p></li><li><p>【强制】库的名称格式：业务系统名称_子系统名。</p></li><li><p>【强制】库名禁止使用关键字（如type,order等）。</p></li><li><p>【强制】创建数据库时必须<code>显式指定字符集</code>，并且字符集只能是utf8或者utf8mb4。创建数据库SQL举例：CREATE DATABASE crm_fund <code>DEFAULT CHARACTER SET &#39;utf8&#39;</code>; </p></li><li><p>【建议】对于程序连接数据库账号，遵循<code>权限最小原则</code>。使用数据库账号只能在一个DB下使用，不准跨库。程序使用的账号<code>原则上不准有drop权限</code>。 </p></li><li><p>【建议】临时库以<code>tmp_</code>为前缀，并以日期为后缀；备份库以<code>bak_</code>为前缀，并以日期为后缀。</p></li></ol><h5 id="6-2-关于表、列"><a href="#6-2-关于表、列" class="headerlink" title="6.2 关于表、列"></a><strong>6.2</strong> <strong>关于表、列</strong></h5><ol><li><p>【强制】表和列的名称必须控制在32个字符以内，表名只能使用英文字母、数字和下划线，建议以<code>英文字母开头</code>。 </p></li><li><p>【强制】 <code>表名、列名一律小写</code>，不同单词采用下划线分割。须见名知意。</p></li><li><p>【强制】表名要求有模块名强相关，同一模块的表名尽量使用<code>统一前缀</code>。比如：crm_fund_item </p></li><li><p>【强制】创建表时必须<code>显式指定字符集</code>为utf8或utf8mb4。 </p></li><li><p>【强制】表名、列名禁止使用关键字（如type,order等）。</p></li><li><p>【强制】创建表时必须<code>显式指定表存储引擎</code>类型。如无特殊需求，一律为InnoDB。 </p></li><li><p>【强制】建表必须有comment。 </p></li><li><p>【强制】字段命名应尽可能使用表达实际含义的英文单词或<code>缩写</code>。如：公司 ID，不要使用 corporation_id, 而用corp_id 即可。</p></li><li><p>【强制】布尔值类型的字段命名为<code>is_描述</code>。如member表上表示是否为enabled的会员的字段命名为 is_enabled。 </p></li><li><p>【强制】禁止在数据库中存储图片、文件等大的二进制数据。通常文件很大，短时间内造成数据量快速增长，数据库进行数据库读取时，通常会进行大量的随机IO操作，文件很大时，IO操作很耗时。通常存储于文件服务器，数据库只存储文件地址信息。</p></li><li><p>【建议】建表时关于主键：<code>表必须有主键 </code>(1)强制要求主键为id，类型为int或bigint，且为auto_increment 建议使用unsigned无符号型。 (2)标识表里每一行主体的字段不要设为主键，建议设为其他字段如user_id，order_id等，并建立unique key索引。因为如果设为主键且主键值为随机插入，则会导致innodb内部页分裂和大量随机I&#x2F;O，性能下降。</p></li><li><p>【建议】核心表（如用户表）必须有行数据的<code>创建时间字段</code>（create_time）和<code>最后更新时间字段</code>（update_time），便于查问题。</p></li><li><p>【建议】表中所有字段尽量都是<code>NOT NULL</code>属性，业务可以根据需要定义<code>DEFAULT值</code>。 因为使用NULL值会存在每一行都会占用额外存储空间、数据迁移容易出错、聚合函数计算结果偏差等问题。</p></li><li><p>【建议】所有存储相同数据的<code>列名和列类型必须一致</code>（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）。</p></li><li><p>【建议】中间表（或临时表）用于保留中间结果集，名称以<code>tmp_</code>开头。备份表用于备份或抓取源表快照，名称以<code>bak_</code>开头。中间表和备份表定期清理。</p></li><li><p>【示范】一个较为规范的建表语句：</p></li></ol><pre><code class="mysql">CREATE TABLE user_info (     `id` int unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;自增主键&#39;,     `user_id` bigint(11) NOT NULL COMMENT &#39;用户id&#39;,     `username` varchar(45) NOT NULL COMMENT &#39;真实姓名&#39;,     `email` varchar(30) NOT NULL COMMENT &#39;用户邮箱&#39;,     `nickname` varchar(45) NOT NULL COMMENT &#39;昵称&#39;,     `birthday` date NOT NULL COMMENT &#39;生日&#39;,     `sex` tinyint(4) DEFAULT &#39;0&#39; COMMENT &#39;性别&#39;,     `short_introduce` varchar(150) DEFAULT NULL COMMENT &#39;一句话介绍自己，最多50个汉字&#39;,     `user_resume` varchar(300) NOT NULL COMMENT &#39;用户提交的简历存放地址&#39;,     `user_register_ip` int NOT NULL COMMENT &#39;用户注册时的源ip&#39;,     `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,     `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#39;修改时间&#39;,     `user_review_status` tinyint NOT NULL COMMENT &#39;用户资料审核状态，1为通过，2为审核中，3为未 通过，4为还未提交审核&#39;,    PRIMARY KEY (`id`),     UNIQUE KEY `uniq_user_id` (`user_id`),     KEY `idx_username`(`username`),     KEY `idx_create_time_status`(`create_time`,`user_review_status`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&#39;网站用户基本信息&#39;</code></pre><ol start="17"><li>【建议】创建表时，可以使用可视化工具。这样可以确保表、字段相关的约定都能设置上。实际上，我们通常很少自己写 DDL 语句，可以使用一些可视化工具来创建和操作数据库和数据表。可视化工具除了方便，还能直接帮我们将数据库的结构定义转化成 SQL 语言，方便数据库和数据表结构的导出和导入。</li></ol><h5 id="6-3-关于索引"><a href="#6-3-关于索引" class="headerlink" title="6.3 关于索引"></a><strong>6.3</strong> <strong>关于索引</strong></h5><ol><li><p>【强制】InnoDB表必须主键为id int&#x2F;bigint auto_increment，且主键值<code>禁止被更新</code>。 </p></li><li><p>【强制】InnoDB和MyISAM存储引擎表，索引类型必须为<code>BTREE</code>。 </p></li><li><p>【建议】主键的名称以<code>pk_</code>开头，唯一键以<code>uni_</code>或<code>uk_</code>开头，普通索引以<code>idx_</code>开头，一律使用小写格式，以字段的名称或缩写作为后缀。</p></li><li><p>【建议】多单词组成的columnname，取前几个单词首字母，加末单词组成column_name。如: sample 表 member_id 上的索引：idx_sample_mid。 </p></li><li><p>【建议】单个表上的索引个数<code>不能超过6个</code>。 </p></li><li><p>【建议】在建立索引时，多考虑建立<code>联合索引</code>，并把区分度最高的字段放在最前面。</p></li><li><p>【建议】在多表 JOIN 的SQL里，保证被驱动表的连接列上有索引，这样JOIN 执行效率最高。</p></li><li><p>【建议】建表或加索引时，保证表里互相不存在<code>冗余索引</code>。 比如：如果表里已经存在key(a,b)， 则key(a)为冗余索引，需要删除。</p></li></ol><h5 id="6-4-SQL编写"><a href="#6-4-SQL编写" class="headerlink" title="6.4 SQL编写"></a><strong>6.4 SQL编写</strong></h5><ol><li><p>【强制】程序端SELECT语句必须指定具体字段名称，禁止写成 *。 </p></li><li><p>【建议】程序端insert语句指定具体字段名称，不要写成INSERT INTO t1 VALUES(…)。 </p></li><li><p>【建议】除静态表或小表（100行以内），DML语句必须有WHERE条件，且使用索引查找。</p></li><li><p>【建议】INSERT INTO…VALUES(XX),(XX),(XX).. 这里XX的值不要超过5000个。 值过多虽然上线很快，但会引起主从同步延迟。</p></li><li><p>【建议】SELECT语句不要使用UNION，推荐使用UNION ALL，并且UNION子句个数限制在5个以内。</p></li><li><p>【建议】线上环境，多表 JOIN 不要超过5个表。</p></li><li><p>【建议】减少使用ORDER BY，和业务沟通能不排序就不排序，或将排序放到程序端去做。ORDER BY、GROUP BY、DISTINCT 这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。</p></li><li><p>【建议】包含了ORDER BY、GROUP BY、DISTINCT 这些查询的语句，WHERE 条件过滤出来的结果集请保持在1000行以内，否则SQL会很慢。</p></li><li><p>【建议】对单表的多次alter操作必须合并为一次。对于超过100W行的大表进行alter table，必须经过DBA审核，并在业务低峰期执行，多个alter需整合在一起。 因为alter table会产生<code>表锁</code>，期间阻塞对于该表的所有写入，对于业务可能会产生极大影响。</p></li><li><p>【建议】批量操作数据时，需要控制事务处理间隔时间，进行必要的sleep。 </p></li><li><p>【建议】事务里包含SQL不超过5个。因为过长的事务会导致锁数据较久，MySQL内部缓存、连接消耗过多等问题。</p></li><li><p>【建议】事务里更新语句尽量基于主键或UNIQUE KEY，如UPDATE… WHERE id&#x3D;XX;否则会产生间隙锁，内部扩大锁定范围，导致系统性能下降，产生死锁。</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第10章 索引优化与查询优化</title>
      <link href="/2023/07/15/%E7%AC%AC10%E7%AB%A0%20%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E4%B8%8E%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/"/>
      <url>/2023/07/15/%E7%AC%AC10%E7%AB%A0%20%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E4%B8%8E%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h3 id="第10章-索引优化与查询优化"><a href="#第10章-索引优化与查询优化" class="headerlink" title="第10章 索引优化与查询优化"></a>第10章 索引优化与查询优化</h3><h4 id="1-索引失效案例"><a href="#1-索引失效案例" class="headerlink" title="1. 索引失效案例"></a><strong>1.</strong> <strong>索引失效案例</strong></h4><p>MySQL中<code>提高性能</code>的一个最有效的方式是对数据表<code>设计合理的索引</code>。索引提供了访问高效数据的方法，并且加快查询的速度，因此索引对查询的速度有着至关重要的影响。</p><ul><li>使用索引可以<code>快速地定位</code>表中的某条记录，从而提高数据库查询的速度，提高数据库的性能。</li><li>如果查询时没有使用索引，查询语句就会<code>扫描表中的所有记录</code>。在数据量大的情况下，这样查询的速度会很慢。</li></ul><p>大多数情况下都（默认）采用<code>B+树</code>来构建索引。只是空间列类型的索引使用<code>R-树</code>，并且MEMORY表还支持<code>hash索引</code>。</p><p>其实，用不用索引，最终都是优化器说了算。优化器是基于什么的优化器？基于<code>cost开销(CostBaseOptimizer)</code>，它不是基于<code>规则(Rule-BasedOptimizer)</code>，也不是基于<code>语义</code>。怎么样开销小就怎么来。另外，<strong>SQL语句是否使用索引，跟数据库版本、数据量、数据选择度都有关系。</strong></p><h5 id="1-1-全值匹配我最爱"><a href="#1-1-全值匹配我最爱" class="headerlink" title="1.1 全值匹配我最爱"></a><strong>1.1</strong> <strong>全值匹配我最爱</strong></h5><h5 id="1-2-最佳左前缀法则"><a href="#1-2-最佳左前缀法则" class="headerlink" title="1.2 最佳左前缀法则"></a><strong>1.2</strong> <strong>最佳左前缀法则</strong></h5><p>在MySQL建立联合索引时会遵守最佳左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。</p><p>结论：MySQL可以为多个字段创建索引，一个索引可以包括16个字段。对于多列索引，<strong>过滤条件要使用索引必须按照索引建立时的顺序，依次满足，一旦跳过某个字段，索引后面的字段都无法被使用。</strong>如果查询条件中没有使用这些字段中第1个字段时，多列（或联合）索引不会被使用。</p><h5 id="1-3-主键插入顺序"><a href="#1-3-主键插入顺序" class="headerlink" title="1.3 主键插入顺序"></a><strong>1.3</strong> <strong>主键插入顺序</strong></h5><p>对于一个使用<code>InnoDB</code>存储引擎的表来说，在我们没有显示的创建索引时，表中的数据实际上都是存储在<code>聚簇索引</code>的叶子节点的。而记录又存储在数据页中的，数据页和记录又是按照记录<code>主键值从小到大</code>的顺序进行排序，所以如果我们<code>插入</code>的记录的<code>主键值是依次增大</code>的话，那我们每插满一个数据页就换到下一个数据页继续插，而如果我们插入的<code>主键值忽小忽大</code>的话，则可能会造成<code>页面分裂</code>和<code>记录移位</code>。</p><h5 id="1-4-计算、函数、类型转换-自动或手动-导致索引失效"><a href="#1-4-计算、函数、类型转换-自动或手动-导致索引失效" class="headerlink" title="1.4 计算、函数、类型转换(自动或手动)导致索引失效"></a><strong>1.4</strong> <strong>计算、函数、类型转换(自动或手动)导致索引失效</strong></h5><h5 id="1-5-类型转换导致索引失效"><a href="#1-5-类型转换导致索引失效" class="headerlink" title="1.5 类型转换导致索引失效"></a><strong>1.5</strong> <strong>类型转换导致索引失效</strong></h5><h5 id="1-6-范围条件右边的列索引失效"><a href="#1-6-范围条件右边的列索引失效" class="headerlink" title="1.6 范围条件右边的列索引失效"></a><strong>1.6</strong> <strong>范围条件右边的列索引失效</strong></h5><blockquote><p>应用开发中范围查询，例如：金额查询，日期查询往往都是范围查询。应将查询条件放置where语句最后。（创建的联合索引中，务必把范围涉及到的字段写在最后）</p></blockquote><h5 id="1-7-不等于-x3D-或者-lt-gt-索引失效"><a href="#1-7-不等于-x3D-或者-lt-gt-索引失效" class="headerlink" title="1.7 不等于(!&#x3D; 或者&lt;&gt;)索引失效"></a><strong>1.7</strong> <strong>不等于(!&#x3D; 或者&lt;&gt;)索引失效</strong></h5><h5 id="1-8-is-null可以使用索引，is-not-null无法使用索引"><a href="#1-8-is-null可以使用索引，is-not-null无法使用索引" class="headerlink" title="1.8 is null可以使用索引，is not null无法使用索引"></a><strong>1.8 is null可以使用索引，is not null无法使用索引</strong></h5><blockquote><p>结论：最好在设计数据表的时候就将<code>字段设置为 NOT NULL 约束</code>，比如你可以将INT类型的字段，默认值设置为0。将字符类型的默认值设置为空字符串(‘’)</p><p>拓展：同理，在查询中使用<code>not like</code>也无法使用索引，导致全表扫描</p></blockquote><h5 id="1-9-like以通配符-开头索引失效"><a href="#1-9-like以通配符-开头索引失效" class="headerlink" title="1.9 like以通配符%开头索引失效"></a><strong>1.9 like以通配符%开头索引失效</strong></h5><blockquote><p>拓展：Alibaba《Java开发手册》</p><p>【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。</p></blockquote><h5 id="1-10-OR-前后存在非索引的列，索引失效"><a href="#1-10-OR-前后存在非索引的列，索引失效" class="headerlink" title="1.10 OR 前后存在非索引的列，索引失效"></a><strong>1.10 OR</strong> <strong>前后存在非索引的列，索引失效</strong></h5><p>在WHERE子句中，如果在OR前的条件列进行了索引，而在OR后的条件列没有进行索引，那么索引会失效。也就是说，<strong>OR前后的两个条件中的列都是索引时，查询中才使用索引。</strong></p><h5 id="1-11-数据库和表的字符集统一使用utf8mb4"><a href="#1-11-数据库和表的字符集统一使用utf8mb4" class="headerlink" title="1.11 数据库和表的字符集统一使用utf8mb4"></a><strong>1.11</strong> <strong>数据库和表的字符集统一使用utf8mb4</strong></h5><p>统一使用utf8mb4( 5.5.3版本以上支持)兼容性更好，统一字符集可以避免由于字符集转换产生的乱码。不同的<code>字符集</code>进行比较前需要进行<code>转换</code>会造成索引失效。</p><h4 id="2-关联查询优化"><a href="#2-关联查询优化" class="headerlink" title="2. 关联查询优化"></a><strong>2.</strong> <strong>关联查询优化</strong></h4><blockquote><p>结论1：对于内连接来说，查询优化器可以决定谁来作为驱动表，谁作为被驱动表出现</p><p>结论2：对于内连接来讲，如果表的连接条件中只能有一个字段有索引，则有索引的字段所在的表会被作为被驱动表</p><p>结论3：对于内连接来说，在两个表的连接条件都存在索引的情况下，会选择小表作为驱动表。<code>小表驱动大表</code></p></blockquote><h5 id="2-1-Index-Nested-Loop-Join（索引嵌套循环连接）"><a href="#2-1-Index-Nested-Loop-Join（索引嵌套循环连接）" class="headerlink" title="2.1 Index Nested-Loop Join（索引嵌套循环连接）"></a>2.1 Index Nested-Loop Join（索引嵌套循环连接）</h5><p>Index Nested-Loop Join其优化的思路主要是为了<code>减少内层表数据的匹配次数</code>，所以要求被驱动表上必须<code>有索引</code>才行。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204011826671.png" alt="image-20220401182649509"></p><h5 id="2-2-Block-Nested-Loop-Join（块嵌套循环连接）"><a href="#2-2-Block-Nested-Loop-Join（块嵌套循环连接）" class="headerlink" title="2.2 Block Nested-Loop Join（块嵌套循环连接）"></a>2.2 Block Nested-Loop Join（块嵌套循环连接）</h5><p>如果存在索引，那么会使用index的方式进行join，如果join的列没有索引，被驱动表要扫描的次数太多了。每次访问被驱动表，其表中的记录都会被加载到内存中，然后再从驱动表中取一条与其匹配，匹配结束后清除内存，然后再从驱动表中加载一条记录，然后把被驱动表的记录再加载到内存匹配，这样周而复始，大大增加了IO的次数。为了减少被驱动表的IO次数，就出现了Block Nested-Loop Join的方式。</p><p>不再是逐条获取驱动表的数据，而是一块一块的获取，引入了<code>join buffer缓冲区</code>，将驱动表join相关的部分数据列（大小受join buffer的限制）缓存到join buffer中，然后全表扫描被驱动表，被驱动表的每一条记录一次性和join buffer中的所有驱动表记录进行匹配（内存中操作），将简单嵌套循环中的多次比较合并成一次，降低了被驱动表的访问频率。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204011833000.png" alt="image-20220401183344880"></p><h5 id="2-3-Hash-Join"><a href="#2-3-Hash-Join" class="headerlink" title="2.3 Hash Join"></a>2.3 Hash Join</h5><p><strong>从MySQL的8.0.20版本开始将废弃BNLJ，因为从MySQL8.0.18版本开始就加入了hash join默认都会使用hash join</strong></p><ul><li>Nested Loop：对于被连接的数据子集较小的情况下，Nested Loop是个较好的选择。</li><li>Hash Join是做<code>大数据集连接</code>时的常用方式，优化器使用两个表中较小（相对较小）的表利用Join Key在内存中建立<code>散列值</code>，然后扫描较大的表并探测散列值，找出与Hash表匹配的行。<ul><li>这种方式适用于较小的表完全可以放入内存中的情况，这样总成本就是访问两个表的成本之和。</li><li>在表很大的情况下并不能完全放入内存，这时优化器会将它分割成<code>若干不同的分区</code>，不能放入内存的部分就把该分区写入磁盘的临时段，此时要求有较大的临时段从而尽量提高I&#x2F;O的性能。</li><li>它能够很好的工作于没有索引的大表和并行查询的环境中，并提供最好的性能。Hash Join只能应用于等值连接，这是由Hash的特点决定的。</li></ul></li></ul><h4 id="3-子查询优化"><a href="#3-子查询优化" class="headerlink" title="3. 子查询优化"></a><strong>3.</strong> <strong>子查询优化</strong></h4><p><strong>子查询是</strong> <strong>MySQL</strong> <strong>的一项重要的功能，可以帮助我们通过一个</strong> <strong>SQL</strong> <strong>语句实现比较复杂的查询。但是，子查询的执行效率不高。</strong>原因：</p><p>① 执行子查询时，MySQL需要为内层查询语句的查询结果<code>建立一个临时表</code>，然后外层查询语句从临时表中查询记录。查询完毕后，再<code>撤销这些临时表</code>。这样会消耗过多的CPU和IO资源，产生大量的慢查询。</p><p>② 子查询的结果集存储的临时表，不论是内存临时表还是磁盘临时表都<code>不会存在索引</code>，所以查询性能会受到一定的影响。</p><p>③ 对于返回结果集比较大的子查询，其对查询性能的影响也就越大。</p><p><strong>在MySQL中，可以使用连接（JOIN）查询来替代子查询。</strong>连接查询<code>不需要建立临时表</code>，其<code>速度比子查询要快</code>，如果查询中使用索引的话，性能就会更好。</p><blockquote><p>结论：尽量不要使用NOT IN 或者 NOT EXISTS，用LEFT JOIN xxx ON xx WHERE xx IS NULL替代</p></blockquote><h4 id="4-排序优化"><a href="#4-排序优化" class="headerlink" title="4. 排序优化"></a><strong>4.</strong> <strong>排序优化</strong></h4><ol><li><p>SQL 中，可以在 WHERE 子句和 ORDER BY 子句中使用索引，目的是在 WHERE 子句中 <code>避免全表扫描</code>，在 ORDER BY 子句<code>避免使用 FileSort 排序</code>。当然，某些情况下全表扫描，或者 FileSort 排序不一定比索引慢。但总的来说，我们还是要避免，以提高查询效率。</p></li><li><p>尽量使用 Index 完成 ORDER BY 排序。如果 WHERE 和 ORDER BY 后面是相同的列就使用单索引列；如果不同就使用联合索引。</p></li><li><p>无法使用 Index 时，需要对 FileSort 方式进行调优。</p></li></ol><h4 id="5-GROUP-BY优化"><a href="#5-GROUP-BY优化" class="headerlink" title="5. GROUP BY优化"></a><strong>5. GROUP BY优化</strong></h4><ul><li>group by 使用索引的原则几乎跟order by一致 ，group by 即使没有过滤条件用到索引，也可以直接使用索引。</li><li>group by 先排序再分组，遵照索引建的最佳左前缀法则</li><li>当无法使用索引列，可以增大<code>max_length_for_sort_data</code>和<code>sort_buffer_size</code>参数的设置</li><li>where效率高于having，能写在where限定的条件就不要写在having中了</li><li>减少使用order by，和业务沟通能不排序就不排序，或将排序放到程序端去做。Order by、group by、distinct这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。</li><li>包含了order by、group by、distinct这些查询的语句，where条件过滤出来的结果集请保持在1000行以内，否则SQL会很慢。</li></ul><h4 id="6-优化分页查询"><a href="#6-优化分页查询" class="headerlink" title="6. 优化分页查询"></a><strong>6.</strong> <strong>优化分页查询</strong></h4><p><strong>优化思路一</strong></p><p>在索引上完成排序分页操作，最后根据主键关联回原表查询所需要的其他列内容。</p><pre><code class="mysql">EXPLAIN SELECT * FROM student t,(SELECT id FROM student ORDER BY id LIMIT 2000000,10) aWHERE t.id = a.id;</code></pre><p><strong>优化思路二</strong></p><p>该方案适用于主键自增的表，可以把Limit 查询转换成某个位置的查询。</p><pre><code class="mysql">EXPLAIN SELECT * FROM student WHERE id &gt; 2000000 LIMIT 10;</code></pre><h4 id="7-优先考虑覆盖索引"><a href="#7-优先考虑覆盖索引" class="headerlink" title="7. 优先考虑覆盖索引"></a><strong>7.</strong> <strong>优先考虑覆盖索引</strong></h4><h5 id="7-1-什么是覆盖索引？"><a href="#7-1-什么是覆盖索引？" class="headerlink" title="7.1 什么是覆盖索引？"></a><strong>7.1</strong> <strong>什么是覆盖索引？</strong></h5><p><strong>理解方式一</strong>：索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。毕竟索引叶子节点存储了它们索引的数据；当能通过读取索引就可以得到想要的数据，那就不需要读取行了。<strong>一个索引包含了满足查询结果的数据就叫做覆盖索引。</strong></p><p><strong>理解方式二</strong>：非聚簇复合索引的一种形式，它包括在查询里的SELECT、JOIN和WHERE子句用到的所有列（即建索引的字段正好是覆盖查询条件中所涉及的字段）。</p><p>简单说就是，<code>索引列+主键</code>包含<code>SELECT 到 FROM之间查询的列</code>。</p><h5 id="7-2-覆盖索引的利弊"><a href="#7-2-覆盖索引的利弊" class="headerlink" title="7.2 覆盖索引的利弊"></a><strong>7.2</strong> <strong>覆盖索引的利弊</strong></h5><p><strong>好处：</strong></p><p><strong>1.</strong> <strong>避免Innodb表进行索引的二次查询（回表）</strong></p><p><strong>2.</strong> <strong>可以把随机IO变成顺序IO加快查询效率</strong></p><p><strong>弊端：</strong></p><p><code>索引字段的维护</code>总是有代价的。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑了。这是业务DBA，或者称为业务数据架构师的工作。</p><h4 id="8-索引条件下推"><a href="#8-索引条件下推" class="headerlink" title="8. 索引条件下推"></a><strong>8.</strong> <strong>索引条件下推</strong></h4><h5 id="8-1-使用前后的扫描过程"><a href="#8-1-使用前后的扫描过程" class="headerlink" title="8.1 使用前后的扫描过程"></a><strong>8.1</strong> <strong>使用前后的扫描过程</strong></h5><p><strong>在不使用ICP索引扫描的过程：</strong></p><p>storage层：只将满足index key条件的索引记录对应的整行记录取出，返回给server层 </p><p>server 层：对返回的数据，使用后面的where条件过滤，直至返回最后一行。</p><p><strong>使用ICP扫描的过程：</strong></p><p>storage层：首先将index key条件满足的索引记录区间确定，然后在索引上使用index filter进行过滤。将满足的index filter条件的索引记录才去回表取出整行记录返回server层。不满足index filter条件的索引记录丢弃，不回表、也不会返回server层。</p><p>server 层：对返回的数据，使用table filter条件做最后的过滤。</p><h4 id="9-其它查询优化策略"><a href="#9-其它查询优化策略" class="headerlink" title="9. 其它查询优化策略"></a><strong>9.</strong> <strong>其它查询优化策略</strong></h4><h5 id="9-1-EXISTS-和-IN-的区分"><a href="#9-1-EXISTS-和-IN-的区分" class="headerlink" title="9.1 EXISTS 和 IN 的区分"></a><strong>9.1 EXISTS</strong> <strong>和</strong> <strong>IN</strong> <strong>的区分</strong></h5><p>索引是个前提，其实选择与否还会要看表的大小。你可以将选择的标准理解为<code>小表驱动大表</code>。</p><h5 id="9-2-COUNT-与COUNT-具体字段-效率"><a href="#9-2-COUNT-与COUNT-具体字段-效率" class="headerlink" title="9.2 COUNT(*)与COUNT(具体字段)效率"></a><strong>9.2 COUNT(*)与COUNT(具体字段)效率</strong></h5><p><strong>环节1：</strong><code>COUNT(*)</code>和<code>COUNT(1)</code>都是对所有结果进行<code>COUNT</code>，<code>COUNT(*)</code>和<code>COUNT(1)</code>本质上并没有区别（二者执行时间可能略有差别，不过你还是可以把它俩的执行效率看成是相等的）。如果有WHERE子句，则是对所有符合筛选条件的数据行进行统计；如果没有WHERE子句，则是对数据表的数据行数进行统计。</p><p><strong>环节2：</strong>如果是MyISAM存储引擎，统计数据表的行数只需要<code>O(1)</code>的复杂度，这是因为每张MyISAM的数据表都有一个meta信息存储了<code>row_count</code>值，而一致性则是由表级锁来保证的。</p><p>如果是InnoDB存储引擎，因为InnoDB支持事务，采用行级锁和MVCC机制，所以无法像MyISAM一样，维护一个row_count变量，因此需要采用<code>扫描全表</code>，是<code>O(n)</code>的复杂度，进行循环+计数的方式来完成统计。</p><p><strong>环节3：</strong>在InnoDB引擎中，如果采用<code>COUNT(具体字段)</code>来统计数据行数，要尽量采用二级索引。因为主键采用的索引是聚簇索引，聚簇索引包含的信息多，明显会大于二级索引（非聚簇索引）。对于<code>COUNT(*)</code>和<code>COUNT(1)</code>来说，它们不需要查找具体的行，只是统计行数，系统会<code>自动</code>采用占用空间更小的二级索引来进行统计。</p><p>如果有多个二级索引，会使用key_len小的二级索引进行扫描。当没有二级索引的时候，才会采用主键索引来进行统计。</p><h5 id="9-3-关于SELECT"><a href="#9-3-关于SELECT" class="headerlink" title="9.3 关于SELECT(*)"></a><strong>9.3</strong> <strong>关于SELECT(*)</strong></h5><p>在表查询中，建议明确字段，不要使用 * 作为查询的字段列表，推荐使用SELECT &lt;字段列表&gt; 查询。原因：</p><p>① MySQL 在解析的过程中，会通过<code>查询数据字典</code>将”*”按序转换成所有列名，这会大大的耗费资源和时间。</p><p>② 无法使用<code>覆盖索引</code></p><h5 id="9-4-LIMIT-1-对优化的影响"><a href="#9-4-LIMIT-1-对优化的影响" class="headerlink" title="9.4 LIMIT 1 对优化的影响"></a><strong>9.4 LIMIT 1</strong> <strong>对优化的影响</strong></h5><p>针对的是会扫描全表的 SQL 语句，如果你可以确定结果集只有一条，那么加上<code>LIMIT 1</code>的时候，当找到一条结果的时候就不会继续扫描了，这样会加快查询速度。</p><p>如果数据表已经对字段建立了唯一索引，那么可以通过索引进行查询，不会全表扫描的话，就不需要加上<code>LIMIT 1</code>了。</p><h5 id="9-5-多使用COMMIT"><a href="#9-5-多使用COMMIT" class="headerlink" title="9.5 多使用COMMIT"></a><strong>9.5</strong> <strong>多使用COMMIT</strong></h5><p>只要有可能，在程序中尽量多使用 COMMIT，这样程序的性能得到提高，需求也会因为 COMMIT 所释放的资源而减少。</p><p>COMMIT 所释放的资源：</p><ul><li><p>回滚段上用于恢复数据的信息</p></li><li><p>被程序语句获得的锁</p></li><li><p>redo &#x2F; undo log buffer 中的空间</p></li><li><p>管理上述 3 种资源中的内部花费</p></li></ul><h3 id><a href="#" class="headerlink" title></a></h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第12章 数据库其它调优策略</title>
      <link href="/2023/07/15/%E7%AC%AC12%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B6%E5%AE%83%E8%B0%83%E4%BC%98%E7%AD%96%E7%95%A5/"/>
      <url>/2023/07/15/%E7%AC%AC12%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B6%E5%AE%83%E8%B0%83%E4%BC%98%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<h3 id="第12章-数据库其它调优策略"><a href="#第12章-数据库其它调优策略" class="headerlink" title="第12章 数据库其它调优策略"></a>第12章 数据库其它调优策略</h3><h4 id="1-数据库调优的措施"><a href="#1-数据库调优的措施" class="headerlink" title="1. 数据库调优的措施"></a><strong>1.</strong> <strong>数据库调优的措施</strong></h4><h5 id="1-1-调优的目标"><a href="#1-1-调优的目标" class="headerlink" title="1.1 调优的目标"></a><strong>1.1</strong> <strong>调优的目标</strong></h5><ul><li>尽可能<code>节省系统资源</code>，以便系统可以提供更大负荷的服务。（吞吐量更大）</li><li>合理的结构设计和参数调整，以提高用户操<code> 响应的速度</code>。（响应速度更快）</li><li>减少系统的瓶颈，提高MySQL数据库整体的性能。</li></ul><h5 id="1-2-如何定位调优问题"><a href="#1-2-如何定位调优问题" class="headerlink" title="1.2 如何定位调优问题"></a><strong>1.2</strong> <strong>如何定位调优问题</strong></h5><ul><li><strong>用户的反馈（主要）</strong></li><li><strong>日志分析（主要）</strong></li><li><strong>服务器资源使用监控</strong></li><li><strong>数据库内部状况监控</strong></li><li><strong>其它</strong></li></ul><h5 id="1-3-调优的维度和步骤"><a href="#1-3-调优的维度和步骤" class="headerlink" title="1.3 调优的维度和步骤"></a><strong>1.3</strong> <strong>调优的维度和步骤</strong></h5><p><strong>第1步：选择适合的</strong> <strong>DBMS</strong> </p><p><strong>第2步：优化表设计</strong> </p><p><strong>第3步：优化逻辑查询</strong></p><p><strong>第4步：优化物理查询</strong></p><p>物理查询优化是在确定了逻辑查询优化之后，采用物理优化技术（比如索引等），通过计算代价模型对各种可能的访问路径进行估算，从而找到执行方式中代价最小的作为执行计划。</p><p><strong>第5步：使用</strong> <strong>Redis</strong> <strong>或</strong> <strong>Memcached</strong> <strong>作为缓存</strong></p><p><strong>第6步：库级优化</strong> </p><p><strong>1、读写分离</strong></p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204031025279.png" alt="image-20220403102536170"></p><p><strong>2、数据分片</strong></p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204031026743.png" alt="image-20220403102618627"></p><h4 id="2-优化MySQL服务器"><a href="#2-优化MySQL服务器" class="headerlink" title="2. 优化MySQL服务器"></a><strong>2.</strong> <strong>优化MySQL服务器</strong></h4><h5 id="2-1-优化服务器硬件"><a href="#2-1-优化服务器硬件" class="headerlink" title="2.1 优化服务器硬件"></a><strong>2.1</strong> <strong>优化服务器硬件</strong></h5><p><strong>服务器的硬件性能直接决定着MySQL数据库的性能。</strong>硬件的性能瓶颈直接决定MySQL数据库的运行速度和效率。针对性能瓶颈提高硬件配置，可以提高MySQL数据库查询、更新的速度。 </p><p>（1）<code>配置较大的内存</code></p><p>（2）<code>配置高速磁盘系统</code></p><p>（3）<code>合理分布磁盘I/O</code></p><p>（4）<code>配置多处理器</code></p><h5 id="2-2-优化MySQL的参数"><a href="#2-2-优化MySQL的参数" class="headerlink" title="2.2 优化MySQL的参数"></a><strong>2.2</strong> <strong>优化MySQL的参数</strong></h5><ul><li><code>innodb_buffer_pool_size</code>：这个参数是Mysql数据库最重要的参数之一，表示InnoDB类型的<code>表和索引的最大缓存</code>。它不仅仅缓存<code>索引数据</code>，还会缓存<code>表的数据</code>。这个值越大，查询的速度就会越快。但是这个值太大会影响操作系统的性能。</li><li><code>key_buffer_size</code>：表示<code>索引缓冲区的大小</code>。索引缓冲区是所有的<code>线程共享</code>。增加索引缓冲区可以得到更好处理的索引（对所有读和多重写）。当然，这个值不是越大越好，它的大小取决于内存的大小。如果这个值太大，就会导致操作系统频繁换页，也会降低系统性能。对于内存在<code>4GB</code>左右的服务器该参数可设置为<code>256M</code>或<code>384M</code>。</li><li><code>table_cache</code>：表示<code>同时打开的表的个数</code>。这个值越大，能够同时打开的表的个数越多。物理内存越大，设置就越大。默认为2402，调到512-1024最佳。这个值不是越大越好，因为同时打开的表太多会影响操作系统的性能。</li><li><code>query_cache_size</code>：表示<code>查询缓冲区的大小</code>。可以通过在MySQL控制台观察，如果Qcache_lowmem_prunes的值非常大，则表明经常出现缓冲不够的情况，就要增加Query_cache_size的值；如果Qcache_hits的值非常大，则表明查询缓冲使用非常频繁，如果该值较小反而会影响效率，那么可以考虑不用查询缓存；Qcache_free_blocks，如果该值非常大，则表明缓冲区中碎片很多。MySQL8.0之后失效。该参数需要和query_cache_type配合使用。</li><li><code>query_cache_type</code>的值是0时，所有的查询都不使用查询缓存区。但是query_cache_type&#x3D;0并不会导致MySQL释放query_cache_size所配置的缓存区内存。<ul><li>当query_cache_type&#x3D;1时，所有的查询都将使用查询缓存区，除非在查询语句中指定<code>SQL_NO_CACHE</code>，如SELECT SQL_NO_CACHE * FROM tbl_name。 </li><li>当query_cache_type&#x3D;2时，只有在查询语句中使用<code>SQL_CACHE</code>关键字，查询才会使用查询缓存区。使用查询缓存区可以提高查询的速度，这种方式只适用于修改操作少且经常执行相同的查询操作的情况。</li></ul></li><li><code>sort_buffer_size</code>：表示每个<code>需要进行排序的线程分配的缓冲区的大小</code>。增加这个参数的值可以提高<code>ORDER BY</code>或<code>GROUP BY</code>操作的速度。默认数值是2 097 144字节（约2MB）。对于内存在4GB左右的服务器推荐设置为6-8M，如果有100个连接，那么实际分配的总共排序缓冲区大小为100 × 6 ＝ 600MB。 </li><li><code>join_buffer_size = 8M</code>：表示<code>联合查询操作所能使用的缓冲区大小</code>，和sort_buffer_size一样，该参数对应的分配内存也是每个连接独享。</li><li><code>read_buffer_size</code>：表示<code>每个线程连续扫描时为扫描的每个表分配的缓冲区的大小（字节）</code>。当线程从表中连续读取记录时需要用到这个缓冲区。SET SESSION read_buffer_size&#x3D;n可以临时设置该参数的值。默认为64K，可以设置为4M。 </li><li><code>innodb_flush_log_at_trx_commit</code>：表示<code>何时将缓冲区的数据写入日志文件</code>，并且将日志文件写入磁盘中。该参数对于innoDB引擎非常重要。该参数有3个值，分别为0、1和2。该参数的默认值为1。<ul><li>值为<code>0</code>时，表示<code>每秒1次</code>的频率将数据写入日志文件并将日志文件写入磁盘。每个事务的commit并不会触发前面的任何操作。该模式速度最快，但不太安全，mysqld进程的崩溃会导致上一秒钟所有事务数据的丢失。</li><li>值为<code>1</code>时，表示<code>每次提交事务时</code>将数据写入日志文件并将日志文件写入磁盘进行同步。该模式是最安全的，但也是最慢的一种方式。因为每次事务提交或事务外的指令都需要把日志写入（flush）硬盘。</li><li>值为<code>2</code>时，表示<code>每次提交事务时</code>将数据写入日志文件，<code>每隔1秒</code>将日志文件写入磁盘。该模式速度较快，也比0安全，只有在操作系统崩溃或者系统断电的情况下，上一秒钟所有事务数据才可能丢失。</li></ul></li><li><code>innodb_log_buffer_size</code>：这是 InnoDB 存储引擎的<code>事务日志所使用的缓冲区</code>。为了提高性能，也是先将信息写入 Innodb Log Buffer 中，当满足 innodb_flush_log_trx_commit 参数所设置的相应条件（或者日志缓冲区写满）之后，才会将日志写到文件（或者同步到磁盘）中。</li><li><code>max_connections</code>：表示 允许连接到MySQL数据库的最大数量 ，默认值是 151 。如果状态变量connection_errors_max_connections 不为零，并且一直增长，则说明不断有连接请求因数据库连接数已达到允许最大值而失败，这是可以考虑增大max_connections 的值。在Linux 平台下，性能好的服务器，支持 500-1000 个连接不是难事，需要根据服务器性能进行评估设定。这个连接数 不是越大 越好 ，因为这些连接会浪费内存的资源。过多的连接可能会导致MySQL服务器僵死。</li><li><code>back_log</code>：用于<code>控制MySQL监听TCP端口时设置的积压请求栈大小</code>。如果MySql的连接数达到max_connections时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即back_log，如果等待连接的数量超过back_log，将不被授予连接资源，将会报错。5.6.6 版本之前默认值为 50 ， 之后的版本默认为 50 + （max_connections &#x2F; 5）， 对于Linux系统推荐设置为小于512的整数，但最大不超过900。如果需要数据库在较短的时间内处理大量连接请求， 可以考虑适当增大back_log 的值。</li><li><code>thread_cache_size</code>：<code>线程池缓存线程数量的大小</code>，当客户端断开连接后将当前线程缓存起来，当在接到新的连接请求时快速响应无需创建新的线程 。这尤其对那些使用短连接的应用程序来说可以极大的提高创建连接的效率。那么为了提高性能可以增大该参数的值。默认为60，可以设置为120。</li><li><code>wait_timeout</code>：指定<code>一个请求的最大连接时间</code>，对于4GB左右内存的服务器可以设置为5-10。 </li><li><code>interactive_timeout</code>：表示服务器在关闭连接前等待行动的秒数。</li></ul><h4 id="3-优化数据库结构"><a href="#3-优化数据库结构" class="headerlink" title="3. 优化数据库结构"></a><strong>3.</strong> <strong>优化数据库结构</strong></h4><h5 id="3-1-拆分表：冷热数据分离"><a href="#3-1-拆分表：冷热数据分离" class="headerlink" title="3.1 拆分表：冷热数据分离"></a><strong>3.1</strong> <strong>拆分表：冷热数据分离</strong></h5><h5 id="3-2-增加中间表"><a href="#3-2-增加中间表" class="headerlink" title="3.2 增加中间表"></a><strong>3.2</strong> <strong>增加中间表</strong></h5><h5 id="3-3-增加冗余字段"><a href="#3-3-增加冗余字段" class="headerlink" title="3.3 增加冗余字段"></a><strong>3.3</strong> <strong>增加冗余字段</strong></h5><h5 id="3-4-优化数据类型"><a href="#3-4-优化数据类型" class="headerlink" title="3.4 优化数据类型"></a><strong>3.4</strong> <strong>优化数据类型</strong></h5><p><strong>情况1：对整数类型数据进行优化。</strong></p><p>遇到整数类型的字段可以用<code>INT 型</code>。这样做的理由是，INT 型数据有足够大的取值范围，不用担心数据超出取值范围的问题。刚开始做项目的时候，首先要保证系统的稳定性，这样设计字段类型是可以的。但在数据量很大的时候，数据类型的定义，在很大程度上会影响到系统整体的执行效率。</p><p>对于<code>非负型</code>的数据（如自增ID、整型IP）来说，要优先使用无符号整型<code>UNSIGNED</code>来存储。因为无符号相对于有符号，同样的字节数，存储的数值范围更大。如tinyint有符号为-128-127，无符号为0-255，多出一倍的存储空间。</p><p><strong>情况2：既可以使用文本类型也可以使用整数类型的字段，要选择使用整数类型</strong>。</p><p>跟文本类型数据相比，大整数往往占用<code>更少的存储空间</code>，因此，在存取和比对的时候，可以占用更少的内存空间。所以，在二者皆可用的情况下，尽量使用整数类型，这样可以提高查询的效率。如：将IP地址转换成整型数据。</p><p><strong>情况3：避免使用TEXT、BLOB数据类型</strong></p><p><strong>情况4：避免使用ENUM类型</strong></p><p><strong>情况5：使用TIMESTAMP存储时间</strong></p><p><strong>情况6：用DECIMAL代替FLOAT和DOUBLE存储精确浮点数</strong></p><p><strong>总之，遇到数据量大的项目时，一定要在充分了解业务需求的前提下，合理优化数据类型，这样才能充分发挥资源的效率，使系统达到最优</strong>。</p><h5 id="3-5-优化插入记录的速度"><a href="#3-5-优化插入记录的速度" class="headerlink" title="3.5 优化插入记录的速度"></a><strong>3.5</strong> <strong>优化插入记录的速度</strong></h5><p><strong>1. MyISAM引擎的表：</strong></p><p><strong>① 禁用索引</strong></p><p><strong>② 禁用唯一性检查</strong></p><p><strong>③ 使用批量插入</strong></p><p><strong>④ 使用LOAD DATA INFILE 批量导入</strong></p><p><strong>2. InnoDB引擎的表：</strong></p><p> <strong>① 禁用唯一性检查</strong></p><p><strong>② 禁用外键检查</strong></p><p><strong>③ 禁止自动提交</strong></p><h5 id="3-6-使用非空约束"><a href="#3-6-使用非空约束" class="headerlink" title="3.6 使用非空约束"></a><strong>3.6</strong> <strong>使用非空约束</strong></h5><p><strong>在设计字段的时候，如果业务允许，建议尽量使用非空约束</strong></p><h5 id="3-7-分析表、检查表与优化表"><a href="#3-7-分析表、检查表与优化表" class="headerlink" title="3.7 分析表、检查表与优化表"></a><strong>3.7</strong> <strong>分析表、检查表与优化表</strong></h5><p><strong>1.</strong> <strong>分析表</strong></p><pre><code class="mysql">ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name[,tbl_name]…</code></pre><p>默认的，MySQL服务会将 ANALYZE TABLE语句写到binlog中，以便在主从架构中，从服务能够同步数据。可以添加参数LOCAL 或者 NO_WRITE_TO_BINLOG取消将语句写到binlog中。</p><p>使用<code>ANALYZE TABLE</code>分析表的过程中，数据库系统会自动对表加一个<code>只读锁</code>。在分析期间，只能读取表中的记录，不能更新和插入记录。ANALYZE TABLE语句能够分析InnoDB和MyISAM类型的表，但是不能作用于视图。</p><p>ANALYZE TABLE分析后的统计结果会反应到<code>cardinality</code>的值，该值统计了表中某一键所在的列不重复的值的个数。<strong>该值越接近表中的总行数，则在表连接查询或者索引查询时，就越优先被优化器选择使用。</strong></p><p><strong>2.</strong> <strong>检查表</strong> </p><pre><code class="mysql">CHECK TABLE tbl_name [, tbl_name] ... [option] ... option = &#123;QUICK | FAST | MEDIUM | EXTENDED | CHANGED&#125;</code></pre><p>MySQL中可以使用<code>CHECK TABLE</code>语句来检查表。CHECK TABLE语句能够检查InnoDB和MyISAM类型的表是否存在错误。CHECK TABLE语句在执行过程中也会给表加上<code>只读锁</code>。</p><p><strong>3.</strong> <strong>优化表</strong></p><pre><code class="mysql">OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...</code></pre><p>MySQL中使用<code>OPTIMIZE TABLE</code>语句来优化表。但是，OPTILMIZE TABLE语句只能优化表中的<code>VARCHAR</code>、<code>BLOB</code>或<code>TEXT</code>类型的字段。一个表使用了这些字段的数据类型，若已经<code>删除</code>了表的一大部分数据，或者已经对含有可变长度行的表（含有VARCHAR、BLOB或TEXT列的表）进行了很多<code>更新</code>，则应使用OPTIMIZE TABLE来重新利用未使用的空间，并整理数据文件的<code>碎片</code>。 </p><p>OPTIMIZE TABLE 语句对InnoDB和MyISAM类型的表都有效。该语句在执行过程中也会给表加上<code>只读锁</code>。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第14章 MySql事务日志</title>
      <link href="/2023/07/15/%E7%AC%AC14%E7%AB%A0%20MySQL%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97/"/>
      <url>/2023/07/15/%E7%AC%AC14%E7%AB%A0%20MySQL%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h3 id="第14章-MySQL事务日志"><a href="#第14章-MySQL事务日志" class="headerlink" title="第14章 MySQL事务日志"></a>第14章 MySQL事务日志</h3><p>事务有4种特性：原子性、一致性、隔离性和持久性。那么事务的四种特性到底是基于什么机制实现呢？</p><ul><li>事务的隔离性由<code>锁机制</code>实现。</li><li>而事务的原子性、一致性和持久性由事务的 redo 日志和undo 日志来保证。<ul><li>REDO LOG 称为<code>重做日志</code>，提供再写入操作，恢复提交事务修改的页操作，用来保证事务的持久性。</li><li>UNDO LOG 称为<code>回滚日志</code>，回滚行记录到某个特定版本，用来保证事务的原子性、一致性。</li></ul></li></ul><h4 id="1-redo日志"><a href="#1-redo日志" class="headerlink" title="1. redo日志"></a><strong>1. redo日志</strong></h4><h5 id="1-1-为什么需要REDO日志"><a href="#1-1-为什么需要REDO日志" class="headerlink" title="1.1 为什么需要REDO日志"></a><strong>1.1</strong> <strong>为什么需要REDO日志</strong></h5><p>一方面，缓冲池可以帮助我们消除CPU和磁盘之间的鸿沟，checkpoint机制可以保证数据的最终落盘，然而由于checkpoint<code>并不是每次变更的时候就触发</code>的，而是master线程隔一段时间去处理的。所以最坏的情况就是事务提交后，刚写完缓冲池，数据库宕机了，那么这段数据就是丢失的，无法恢复。</p><p>另一方面，事务包含<code>持久性</code>的特性，就是说对于一个已经提交的事务，在事务提交后即使系统发生了崩溃，这个事务对数据库中所做的更改也不能丢失。</p><p>那么如何保证这个持久性呢？<code>一个简单的做法</code>：在事务提交完成之前把该事务所修改的所有页面都刷新到磁盘，但是这个简单粗暴的做法有些问题</p><p><code>另一个解决的思路</code>：我们只是想让已经提交了的事务对数据库中数据所做的修改永久生效，即使后来系统崩溃，在重启后也能把这种修改恢复出来。所以我们其实没有必要在每次事务提交时就把该事务在内存中修改过的全部页面刷新到磁盘，只需要把<code>修改</code>了哪些东西<code>记录一下</code>就好。比如，某个事务将系统表空间中<code>第10号</code>页面中偏移量为<code>100</code>处的那个字节的值<code>1</code>改成<code>2</code>。我们只需要记录一下：将第0号表空间的10号页面的偏移量为100处的值更新为 2 。</p><h5 id="1-2-REDO日志的好处、特点"><a href="#1-2-REDO日志的好处、特点" class="headerlink" title="1.2 REDO日志的好处、特点"></a><strong>1.2 REDO日志的好处、特点</strong></h5><p><strong>1.</strong> <strong>好处</strong></p><ul><li><strong>redo日志降低了刷盘频率</strong></li><li><strong>redo日志占用的空间非常小</strong></li></ul><p><strong>2.</strong> <strong>特点</strong></p><ul><li><strong>redo日志是顺序写入磁盘的</strong></li><li><strong>事务执行过程中，redo log不断记录</strong></li></ul><h5 id="1-3-redo的组成"><a href="#1-3-redo的组成" class="headerlink" title="1.3 redo的组成"></a><strong>1.3 redo的组成</strong></h5><p>Redo log可以简单分为以下两个部分：</p><ul><li><code>重做日志的缓冲 (redo log buffer) </code>，保存在内存中，是易失的。</li></ul><p><strong>参数设置：innodb_log_buffer_size：</strong></p><p>redo log buffer 大小，默认<code>16M</code>，最大值是4096M，最小值为1M。 </p><ul><li><code>重做日志文件 (redo log file)</code>，保存在硬盘中，是持久的。</li></ul><h5 id="1-4-redo的整体流程"><a href="#1-4-redo的整体流程" class="headerlink" title="1.4 redo的整体流程"></a><strong>1.4 redo的整体流程</strong></h5><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204031147714.png" alt="image-20220403114709581"></p><p>第1步：先将原始数据从磁盘中读入内存中来，修改数据的内存拷贝 </p><p>第2步：生成一条重做日志并写入redo log buffer，记录的是数据被修改后的值 </p><p>第3步：当事务commit时，将redo log buffer中的内容刷新到 redo log file，对 redo log file采用追加写的方式 </p><p>第4步：定期将内存中修改的数据刷新到磁盘中</p><blockquote><p>Write-Ahead Log(预先日志持久化)：在持久化一个数据页之前，先将内存中相应的日志页持久化。</p></blockquote><h5 id="1-5-redo-log的刷盘策略"><a href="#1-5-redo-log的刷盘策略" class="headerlink" title="1.5 redo log的刷盘策略"></a><strong>1.5 redo log的刷盘策略</strong></h5><p>redo log buffer刷盘到redo log file的过程并不是真正的刷到磁盘中去，只是刷入到<code>文件系统缓存</code>（page cache）中去（这是现代操作系统为了提高文件写入效率做的一个优化），真正的写入会交给系统自己来决定（比如page cache足够大了）。那么对于InnoDB来说就存在一个问题，如果交给系统来同步，同样如果系统宕机，那么数据也丢失了（虽然整个系统宕机的概率还是比较小的）。</p><p>针对这种情况，InnoDB给出<code>innodb_flush_log_at_trx_commit</code>参数，该参数控制 commit提交事务时，如何将 redo log buffer 中的日志刷新到 redo log file 中。它支持三种策略：</p><ul><li><code>设置为0</code>：表示每次事务提交时不进行刷盘操作。（系统默认master thread每隔1s进行一次重做日志的同步）</li><li><code>设置为1</code>：表示每次事务提交时都将进行同步，刷盘操作（<code>默认值</code>） </li><li><code>设置为2</code>：表示每次事务提交时都只把 redo log buffer 内容写入 page cache，不进行同步。由os自己决定什么时候同步到磁盘文件。</li></ul><h5 id="1-6-不同刷盘策略演示"><a href="#1-6-不同刷盘策略演示" class="headerlink" title="1.6 不同刷盘策略演示"></a><strong>1.6</strong> <strong>不同刷盘策略演示</strong></h5><p><strong>1.</strong> <strong>流程图</strong></p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204031152952.png" alt="image-20220403115232833"></p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204031152607.png" alt="image-20220403115249492"></p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204031153931.png" alt="image-20220403115300809"></p><h5 id="1-7-写入redo-log-buffer过程"><a href="#1-7-写入redo-log-buffer过程" class="headerlink" title="1.7 写入redo log buffer过程"></a><strong>1.7</strong> <strong>写入redo log buffer过程</strong></h5><p><strong>1.</strong> <strong>补充概念：Mini-Transaction</strong></p><p>一个事务可以包含若干条语句，每一条语句其实是由若干个<code>mtr</code>组成，每一个<code>mtr</code>又可以包含若干条redo日志</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204040912119.png" alt="image-20220404091224993"></p><p><strong>2. redo</strong> <strong>日志写入log buffer</strong></p><p>不同的事务可能是<code>并发</code>执行的，所以<code>事务T1</code>、<code>事务T2</code>之间的<code>mtr</code>可能是<code>交替执行</code>的。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204040915708.png" alt="image-20220404091511602"></p><h5 id="1-8-redo-log-file"><a href="#1-8-redo-log-file" class="headerlink" title="1.8 redo log file"></a><strong>1.8 redo log file</strong></h5><p><strong>1.</strong> <strong>相关参数设置</strong> </p><ul><li><p><code>innodb_log_group_home_dir</code>：指定 redo log 文件组所在的路径，默认值为<code>./</code>，表示在数据库的数据目录下。MySQL的默认数据目录（<code>var/lib/mysql</code>）下默认有两个名为<code>ib_logfile0</code>和<code>ib_logfile1</code>的文件，log buffer中的日志默认情况下就是刷新到这两个磁盘文件中。此redo日志文件位置还可以修改。</p></li><li><p><code>innodb_log_files_in_group</code>：指明redo log file的个数，命名方式如：ib_logfile0，ib_logfile1… ib_logfilen。默认2个，最大100个。</p></li><li><p><code>innodb_flush_log_at_trx_commit</code>：控制 redo log 刷新到磁盘的策略，默认为<code>1</code>。 </p></li><li><p><code>innodb_log_file_size</code>：单个 redo log 文件设置大小，默认值为 48M 。最大值为512G，注意最大值指的是整个 redo log 系列文件之和，即（innodb_log_files_in_group * innodb_log_file_size ）不能大于最大值512G。</p></li></ul><p><strong>2.</strong> <strong>日志文件组</strong></p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204040920532.png" alt="image-20220404092038421"></p><p><strong>3. checkpoint</strong></p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204040921715.png" alt="image-20220404092106617"></p><p>如果 write pos 追上 checkpoint ，表示<strong>日志文件组</strong>满了，这时候不能再写入新的 redo log记录，MySQL 得停下来，清空一些记录，把 checkpoint 推进一下。</p><h4 id="2-Undo日志"><a href="#2-Undo日志" class="headerlink" title="2. Undo日志"></a><strong>2. Undo日志</strong></h4><p>redo log是事务持久性的保证，undo log是事务原子性的保证。在事务中<code>更新数据</code>的<code>前置操作</code>其实是要先写入一个 undo log 。</p><h5 id="2-1-如何理解Undo日志"><a href="#2-1-如何理解Undo日志" class="headerlink" title="2.1 如何理解Undo日志"></a><strong>2.1</strong> <strong>如何理解Undo日志</strong></h5><p>事务需要保证<code>原子性</code>，也就是事务中的操作要么全部完成，要么什么也不做。但有时候事务执行到一半会出现一些情况，比如：</p><ul><li>情况一：事务执行过程中可能遇到各种错误，比如<code>服务器本身的错误</code>，<code>操作系统错误</code>，甚至是突然<code>断电</code>导致的错误。</li><li>情况二：程序员可以在事务执行过程中手动输入<code>ROLLBACK</code>语句结束当前事务的执行。</li></ul><p>以上情况出现，我们需要把数据改回原先的样子，这个过程称之为<code>回滚</code>，这样就可以造成一个假象：这个事务看起来什么都没做，所以符合<code>原子性</code>要求。</p><h5 id="2-2-Undo日志的作用"><a href="#2-2-Undo日志的作用" class="headerlink" title="2.2 Undo日志的作用"></a><strong>2.2 Undo日志的作用</strong></h5><ul><li><strong>作用1：回滚数据</strong></li><li><strong>作用2：MVCC（详情看第16章）</strong></li></ul><h5 id="2-3-undo的存储结构"><a href="#2-3-undo的存储结构" class="headerlink" title="2.3 undo的存储结构"></a><strong>2.3 undo的存储结构</strong></h5><p><strong>1.</strong> <strong>回滚段与undo页</strong></p><p>InnoDB对undo log的管理采用段的方式，也就是<code>回滚段（rollback segment）</code>。每个回滚段记录了<code>1024</code>个<code>undo log segment</code>，而在每个undo log segment段中进行<code>undo页</code>的申请。</p><p><strong>2.</strong> <strong>回滚段与事务</strong> </p><ol><li><p>每个事务只会使用一个回滚段，一个回滚段在同一时刻可能会服务于多个事务。</p></li><li><p>当一个事务开始的时候，会制定一个回滚段，在事务进行的过程中，当数据被修改时，原始的数据会被复制到回滚段。</p></li><li><p>在回滚段中，事务会不断填充盘区，直到事务结束或所有的空间被用完。如果当前的盘区不够用，事务会在段中请求扩展下一个盘区，如果所有已分配的盘区都被用完，事务会覆盖最初的盘区或者在回滚段允许的情况下扩展新的盘区来使用。</p></li><li><p>回滚段存在于undo表空间中，在数据库中可以存在多个undo表空间，但同一时刻只能使用一个undo表空间。</p></li><li><p>当事务提交时，InnoDB存储引擎会做以下两件事情：</p><ul><li>将undo log放入列表中，以供之后的purge操作</li><li>判断undo log所在的页是否可以重用，若可以分配给下个事务使用</li></ul></li></ol><p><strong>3.</strong> <strong>回滚段中的数据分类</strong></p><ol><li><p>未提交的回滚数据(uncommitted undo information) </p></li><li><p>已经提交但未过期的回滚数据(committed undo information) </p></li><li><p>事务已经提交并过期的数据(expired undo information)</p></li></ol><h5 id="2-4-undo的类型"><a href="#2-4-undo的类型" class="headerlink" title="2.4 undo的类型"></a><strong>2.4 undo的类型</strong></h5><p>在InnoDB存储引擎中，undo log分为：</p><ul><li>insert undo log </li><li>update undo log</li></ul><h5 id="2-5-undo-log的生命周期"><a href="#2-5-undo-log的生命周期" class="headerlink" title="2.5 undo log的生命周期"></a><strong>2.5 undo log的生命周期</strong></h5><p><strong>1.</strong> <strong>简要生成过程</strong></p><p><strong>只有Buffer Pool的流程：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204040937761.png" alt="image-20220404093706650"></p><p><strong>有了Redo Log和Undo Log之后：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204040938657.png" alt="image-20220404093832512"></p><p><strong>2.</strong> <strong>详细生成过程</strong></p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204040939231.png" alt="image-20220404093950136"></p><p><strong>当我们执行INSERT时：</strong></p><pre><code class="mysql">begin; INSERT INTO user (name) VALUES (&quot;tom&quot;);</code></pre><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204040940543.png" alt="image-20220404094033441"></p><p><strong>当我们执行UPDATE时：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204040941624.png" alt="image-20220404094105525"></p><pre><code class="mysql">UPDATE user SET id=2 WHERE id=1;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204040941449.png" alt="image-20220404094142337"></p><p><strong>3. undo log是如何回滚的</strong></p><p>以上面的例子来说，假设执行rollback，那么对应的流程应该是这样：</p><ol><li><p>通过undo no&#x3D;3的日志把id&#x3D;2的数据删除</p></li><li><p>通过undo no&#x3D;2的日志把id&#x3D;1的数据的deletemark还原成0 </p></li><li><p>通过undo no&#x3D;1的日志把id&#x3D;1的数据的name还原成Tom </p></li><li><p>通过undo no&#x3D;0的日志把id&#x3D;1的数据删除</p></li></ol><p><strong>4. undo log的删除</strong></p><ul><li>针对于insert undo log</li></ul><p>因为insert操作的记录，只对事务本身可见，对其他事务不可见。故该undo log可以在事务提交后直接删除，不需要进行purge操作。</p><ul><li>针对于update undo log</li></ul><p>该undo log可能需要提供MVCC机制，因此不能在事务提交时就进行删除。提交时放入undo log链表，等待purge线程进行最后的删除。</p><h5 id="2-6-小结"><a href="#2-6-小结" class="headerlink" title="2.6 小结"></a><strong>2.6</strong> <strong>小结</strong></h5><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204040944948.png" alt="image-20220404094436830"></p><p>undo log是逻辑日志，对事务回滚时，只是将数据库逻辑地恢复到原来的样子。</p><p>redo log是物理日志，记录的是数据页的物理变化，undo log不是redo log的逆过程。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第16章 多版本并发控制</title>
      <link href="/2023/07/15/%E7%AC%AC16%E7%AB%A0%20%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"/>
      <url>/2023/07/15/%E7%AC%AC16%E7%AB%A0%20%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="第16章-多版本并发控制"><a href="#第16章-多版本并发控制" class="headerlink" title="第16章 多版本并发控制"></a>第16章 多版本并发控制</h3><h4 id="1-什么是MVCC"><a href="#1-什么是MVCC" class="headerlink" title="1. 什么是MVCC"></a><strong>1.</strong> <strong>什么是MVCC</strong></h4><p>MVCC （Multiversion Concurrency Control），多版本并发控制。顾名思义，MVCC 是通过数据行的多个版本管理来实现数据库的<code>并发控制</code>。这项技术使得在InnoDB的事务隔离级别下执行<code>一致性读</code>操作有了保证。换言之，就是为了查询一些正在被另一个事务更新的行，并且可以看到它们被更新之前的值，这样在做查询的时候就不用等待另一个事务释放锁。</p><h4 id="2-快照读与当前读"><a href="#2-快照读与当前读" class="headerlink" title="2. 快照读与当前读"></a><strong>2.</strong> <strong>快照读与当前读</strong></h4><p>MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理<code>读-写冲突</code>，做到即使有读写冲突时，也能做到<code>不加锁</code>，<code>非阻塞并发读</code>，而这个读指的就是<code>快照读</code>, 而非<code>当前读</code>。当前读实际上是一种加锁的操作，是悲观锁的实现。而MVCC本质是采用乐观锁思想的一种方式。</p><h5 id="2-1-快照读"><a href="#2-1-快照读" class="headerlink" title="2.1 快照读"></a><strong>2.1</strong> <strong>快照读</strong></h5><p>快照读又叫一致性读，读取的是快照数据。<strong>不加锁的简单的</strong> <strong>SELECT</strong> <strong>都属于快照读</strong>，即不加锁的非阻塞读。</p><p>之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于MVCC，它在很多情况下，避免了加锁操作，降低了开销。</p><p>既然是基于多版本，那么快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本。</p><p>快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读。</p><h5 id="2-2-当前读"><a href="#2-2-当前读" class="headerlink" title="2.2 当前读"></a><strong>2.2</strong> <strong>当前读</strong></h5><p>当前读读取的是记录的最新版本（最新数据，而不是历史版本的数据），读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。加锁的 SELECT，或者对数据进行增删改都会进行当前读。</p><h4 id="3-复习"><a href="#3-复习" class="headerlink" title="3. 复习"></a><strong>3.</strong> <strong>复习</strong></h4><h5 id="3-1-再谈隔离级别"><a href="#3-1-再谈隔离级别" class="headerlink" title="3.1 再谈隔离级别"></a><strong>3.1</strong> <strong>再谈隔离级别</strong></h5><p>我们知道事务有 4 个隔离级别，可能存在三种并发问题：</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051536648.png" alt="image-20220405153617536"></p><p>另图：</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051536125.png" alt="image-20220405153632021"></p><h5 id="3-2-隐藏字段、Undo-Log版本链"><a href="#3-2-隐藏字段、Undo-Log版本链" class="headerlink" title="3.2 隐藏字段、Undo Log版本链"></a><strong>3.2</strong> <strong>隐藏字段、Undo Log版本链</strong></h5><p>回顾一下undo日志的版本链，对于使用<code>InnoDB</code>存储引擎的表来说，它的聚簇索引记录中都包含两个必要的隐藏列。</p><ul><li><code>trx_id</code>：每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的<code>事务id</code>赋值给trx_id 隐藏列。</li><li><code>roll_pointer</code>：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到 undo日志 中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</li></ul><h4 id="4-MVCC实现原理之ReadView"><a href="#4-MVCC实现原理之ReadView" class="headerlink" title="4. MVCC实现原理之ReadView"></a><strong>4. MVCC实现原理之ReadView</strong></h4><p>MVCC 的实现依赖于：<strong>隐藏字段、Undo Log、Read View</strong>。</p><h5 id="4-1-什么是ReadView"><a href="#4-1-什么是ReadView" class="headerlink" title="4.1 什么是ReadView"></a><strong>4.1</strong> <strong>什么是ReadView</strong></h5><p>ReadView就是事务在使用MVCC机制进行快照读操作时产生的读视图。当事务启动时，会生成数据库系统当前的一个快照，InnoDB为每个事务构造了一个数组，用来记录并维护系统当前<code>活跃事务</code>的ID（“活跃”指的就是，启动了但还没提交）。</p><h5 id="4-2-设计思路"><a href="#4-2-设计思路" class="headerlink" title="4.2 设计思路"></a><strong>4.2</strong> <strong>设计思路</strong></h5><p>使用<code>READ UNCOMMITTED</code>隔离级别的事务，由于可以读到未提交事务修改过的记录，所以直接读取记录的最新版本就好了。</p><p>使用<code>SERIALIZABLE</code>隔离级别的事务，InnoDB规定使用加锁的方式来访问记录。</p><p>使用<code>READ COMMITTED</code>和<code>REPEATABLE READ</code>隔离级别的事务，都必须保证读到<code>已经提交了的</code>事务修改过的记录。假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的，核心问题就是需要判断一下版本链中的哪个版本是当前事务可见的，这是ReadView要解决的主要问题。</p><p>这个ReadView中主要包含4个比较重要的内容，分别如下：</p><ol><li><code>creator_trx_id</code>，创建这个 Read View 的事务 ID。</li></ol><blockquote><p>说明：只有在对表中的记录做改动时（执行INSERT、DELETE、UPDATE这些语句时）才会为事务分配事务id，否则在一个只读事务中的事务id值都默认为0。 </p></blockquote><ol start="2"><li><p><code>trx_ids</code>，表示在生成ReadView时当前系统中活跃的读写事务的<code>事务id列表</code>。 </p></li><li><p><code>up_limit_id</code>，活跃的事务中最小的事务 ID。 </p></li><li><p><code>low_limit_id</code>，表示生成ReadView时系统中应该分配给下一个事务的<code>id</code>值。low_limit_id 是系统最大的事务id值，这里要注意是系统中的事务id，需要区别于正在活跃的事务ID。</p></li></ol><blockquote><p>注意：low_limit_id并不是trx_ids中的最大值，事务id是递增分配的。比如，现在有id为1， 2，3这三个事务，之后id为3的事务提交了。那么一个新的读事务在生成ReadView时，trx_ids就包括1和2，up_limit_id的值就是1，low_limit_id的值就是4。</p></blockquote><h5 id="4-3-ReadView的规则"><a href="#4-3-ReadView的规则" class="headerlink" title="4.3 ReadView的规则"></a><strong>4.3 ReadView的规则</strong></h5><p>有了这个ReadView，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见。</p><ul><li>如果被访问版本的trx_id属性值与ReadView中的<code>creator_trx_id</code>值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。</li><li>如果被访问版本的trx_id属性值小于ReadView中的<code>up_limit_id</code>值，表明生成该版本的事务在当前事务生成ReadView前已经提交，所以该版本可以被当前事务访问。</li><li>如果被访问版本的trx_id属性值大于或等于ReadView中的<code>low_limit_id</code>值，表明生成该版本的事务在当前事务生成ReadView后才开启，所以该版本不可以被当前事务访问。</li><li>如果被访问版本的trx_id属性值在ReadView的<code>up_limit_id</code>和<code>low_limit_id</code>之间，那就需要判断一下trx_id属性值是不是在 trx_ids 列表中。<ul><li>如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问。</li><li>如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。</li></ul></li></ul><h5 id="4-4-MVCC整体操作流程"><a href="#4-4-MVCC整体操作流程" class="headerlink" title="4.4 MVCC整体操作流程"></a><strong>4.4 MVCC整体操作流程</strong></h5><p>了解了这些概念之后，我们来看下当查询一条记录的时候，系统如何通过MVCC找到它：</p><ol><li><p>首先获取事务自己的版本号，也就是事务 ID； </p></li><li><p>获取 ReadView； </p></li><li><p>查询得到的数据，然后与 ReadView 中的事务版本号进行比较；</p></li><li><p>如果不符合 ReadView 规则，就需要从 Undo Log 中获取历史快照；</p></li><li><p>最后返回符合规则的数据。</p></li></ol><p>在隔离级别为读已提交（Read Committed）时，一个事务中的每一次 SELECT 查询都会重新获取一次Read View。</p><p>如表所示：</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051549618.png" alt="image-20220405154948505"></p><blockquote><p>注意，此时同样的查询语句都会重新获取一次 Read View，这时如果 Read View 不同，就可能产生不可重复读或者幻读的情况。</p></blockquote><p>当隔离级别为可重复读的时候，就避免了不可重复读，这是因为一个事务只在第一次 SELECT 的时候会获取一次 Read View，而后面所有的 SELECT 都会复用这个 Read View，如下表所示：</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051550072.png" alt="image-20220405155041964"></p><h4 id="5-举例说明"><a href="#5-举例说明" class="headerlink" title="5. 举例说明"></a><strong>5.</strong> <strong>举例说明</strong></h4><h5 id="5-1-READ-COMMITTED隔离级别下"><a href="#5-1-READ-COMMITTED隔离级别下" class="headerlink" title="5.1 READ COMMITTED隔离级别下"></a><strong>5.1 READ COMMITTED隔离级别下</strong></h5><p><strong>READ COMMITTED</strong> <strong>：每次读取数据前都生成一个ReadView</strong>。</p><h5 id="5-2-REPEATABLE-READ隔离级别下"><a href="#5-2-REPEATABLE-READ隔离级别下" class="headerlink" title="5.2 REPEATABLE READ隔离级别下"></a><strong>5.2 REPEATABLE READ隔离级别下</strong></h5><p>使用<code>REPEATABLE READ</code>隔离级别的事务来说，只会在第一次执行查询语句时生成一个 ReadView ，之后的查询就不会重复生成了。</p><h5 id="5-3-如何解决幻读"><a href="#5-3-如何解决幻读" class="headerlink" title="5.3 如何解决幻读"></a><strong>5.3</strong> <strong>如何解决幻读</strong></h5><p>假设现在表 student 中只有一条数据，数据内容中，主键 id&#x3D;1，隐藏的 trx_id&#x3D;10，它的 undo log 如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051556631.png" alt="image-20220405155640520"></p><p>假设现在有事务 A 和事务 B 并发执行，<code>事务 A</code>的事务 id 为<code>20</code>，<code>事务 B</code>的事务 id 为<code>30</code>。</p><p>步骤1：事务 A 开始第一次查询数据，查询的 SQL 语句如下。</p><pre><code class="mysql">select * from student where id &gt;= 1;</code></pre><p>在开始查询之前，MySQL 会为事务 A 产生一个 ReadView，此时 ReadView 的内容如下：<code>trx_ids= [20,30]</code>，<code>up_limit_id=20</code>，<code>low_limit_id=31</code>，<code>creator_trx_id=20</code>。</p><p>由于此时表 student 中只有一条数据，且符合 where id&gt;&#x3D;1 条件，因此会查询出来。然后根据 ReadView机制，发现该行数据的trx_id&#x3D;10，小于事务 A 的 ReadView 里 up_limit_id，这表示这条数据是事务 A 开启之前，其他事务就已经提交了的数据，因此事务 A 可以读取到。</p><p>结论：事务 A 的第一次查询，能读取到一条数据，id&#x3D;1。</p><p>步骤2：接着事务 B(trx_id&#x3D;30)，往表 student 中新插入两条数据，并提交事务。</p><pre><code class="mysql">insert into student(id,name) values(2,&#39;李四&#39;); insert into student(id,name) values(3,&#39;王五&#39;);</code></pre><p>此时表student 中就有三条数据了，对应的 undo 如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051559345.png" alt="image-20220405155909223"></p><p>步骤3：接着事务 A 开启第二次查询，根据可重复读隔离级别的规则，此时事务 A 并不会再重新生成ReadView。此时表 student 中的 3 条数据都满足 where id&gt;&#x3D;1 的条件，因此会先查出来。然后根据ReadView 机制，判断每条数据是不是都可以被事务 A 看到。</p><p>1）首先 id&#x3D;1 的这条数据，前面已经说过了，可以被事务 A 看到。</p><p>2）然后是 id&#x3D;2 的数据，它的 trx_id&#x3D;30，此时事务 A 发现，这个值处于 up_limit_id 和 low_limit_id 之间，因此还需要再判断 30 是否处于 trx_ids 数组内。由于事务 A 的 trx_ids&#x3D;[20,30]，因此在数组内，这表示 id&#x3D;2 的这条数据是与事务 A 在同一时刻启动的其他事务提交的，所以这条数据不能让事务 A 看到。</p><p>3）同理，id&#x3D;3 的这条数据，trx_id 也为 30，因此也不能被事务 A 看见。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051559867.png" alt="image-20220405155941753"></p><p>结论：最终事务 A 的第二次查询，只能查询出 id&#x3D;1 的这条数据。这和事务 A 的第一次查询的结果是一样的，因此没有出现幻读现象，所以说在 MySQL 的可重复读隔离级别下，不存在幻读问题。</p><h4 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a><strong>6.</strong> <strong>总结</strong></h4><p>这里介绍了<code>MVCC</code>在<code>READ COMMITTD</code>、<code>REPEATABLE READ</code>这两种隔离级别的事务在执行快照读操作时访问记录的版本链的过程。这样使不同事务的<code>读-写</code>、<code>写-读</code>操作并发执行，从而提升系统性能。</p><p>核心点在于 ReadView 的原理，<code>READ COMMITTD</code>、<code>REPEATABLE READ</code>这两个隔离级别的一个很大不同就是生成ReadView的时机不同：</p><ul><li><code>READ COMMITTD</code>在每一次进行普通SELECT操作前都会生成一个ReadView </li><li><code>REPEATABLE READ</code>只在第一次进行普通SELECT操作前生成一个ReadView，之后的查询操作都重复使用这个ReadView就好了。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第19章 数据库备份与恢复</title>
      <link href="/2023/07/15/%E7%AC%AC19%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/"/>
      <url>/2023/07/15/%E7%AC%AC19%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/</url>
      
        <content type="html"><![CDATA[<h3 id="第19章-数据库备份与恢复"><a href="#第19章-数据库备份与恢复" class="headerlink" title="第19章 数据库备份与恢复"></a>第19章 数据库备份与恢复</h3><h4 id="1-物理备份与逻辑备份"><a href="#1-物理备份与逻辑备份" class="headerlink" title="1. 物理备份与逻辑备份"></a><strong>1.</strong> <strong>物理备份与逻辑备份</strong></h4><p><strong>物理备份</strong>：备份数据文件，转储数据库物理文件到某一目录。物理备份恢复速度比较快，但占用空间比较大，MySQL中可以用<code>xtrabackup</code>工具来进行物理备份。</p><p><strong>逻辑备份</strong>：对数据库对象利用工具进行导出工作，汇总入备份文件内。逻辑备份恢复速度慢，但占用空间小，更灵活。MySQL 中常用的逻辑备份工具为<code>mysqldump</code>。逻辑备份就是<code>备份sql语句</code>，在恢复的时候执行备份的sql语句实现数据库数据的重现。</p><h4 id="2-mysqldump实现逻辑备份"><a href="#2-mysqldump实现逻辑备份" class="headerlink" title="2. mysqldump实现逻辑备份"></a><strong>2. mysqldump实现逻辑备份</strong></h4><h5 id="2-1-备份一个数据库"><a href="#2-1-备份一个数据库" class="headerlink" title="2.1 备份一个数据库"></a><strong>2.1</strong> <strong>备份一个数据库</strong></h5><pre><code class="shell">mysqldump –u 用户名称 –h 主机名称 –p密码 待备份的数据库名称[tbname, [tbname...]]&gt; 备份文件名 称.sql</code></pre><pre><code class="shell">mysqldump -uroot -p atguigu&gt;atguigu.sql #备份文件存储在当前目录下mysqldump -uroot -p atguigudb1 &gt; /var/lib/mysql/atguigu.sql</code></pre><h5 id="2-2-备份全部数据库"><a href="#2-2-备份全部数据库" class="headerlink" title="2.2 备份全部数据库"></a><strong>2.2</strong> <strong>备份全部数据库</strong></h5><pre><code class="shell">mysqldump -uroot -pxxxxxx --all-databases &gt; all_database.sql mysqldump -uroot -pxxxxxx -A &gt; all_database.sql</code></pre><h5 id="2-3-备份部分数据库"><a href="#2-3-备份部分数据库" class="headerlink" title="2.3 备份部分数据库"></a><strong>2.3</strong> <strong>备份部分数据库</strong></h5><pre><code class="shell">mysqldump –u user –h host –p --databases [数据库的名称1 [数据库的名称2...]] &gt; 备份文件名 称.sql</code></pre><pre><code class="shell">mysqldump -uroot -p --databases atguigu atguigu12 &gt;two_database.sqlmysqldump -uroot -p -B atguigu atguigu12 &gt; two_database.sql</code></pre><h5 id="2-4-备份部分表"><a href="#2-4-备份部分表" class="headerlink" title="2.4 备份部分表"></a><strong>2.4</strong> <strong>备份部分表</strong></h5><pre><code class="shell">mysqldump –u user –h host –p 数据库的名称 [表名1 [表名2...]] &gt; 备份文件名称.sql</code></pre><pre><code class="shell">mysqldump -uroot -p atguigu book&gt; book.sql#备份多张表 mysqldump -uroot -p atguigu book account &gt; 2_tables_bak.sql</code></pre><h5 id="2-5-备份单表的部分数据"><a href="#2-5-备份单表的部分数据" class="headerlink" title="2.5 备份单表的部分数据"></a><strong>2.5</strong> <strong>备份单表的部分数据</strong></h5><pre><code class="shell">mysqldump -uroot -p atguigu student --where=&quot;id &lt; 10 &quot; &gt; student_part_id10_low_bak.sql</code></pre><h5 id="2-6-排除某些表的备份"><a href="#2-6-排除某些表的备份" class="headerlink" title="2.6 排除某些表的备份"></a><strong>2.6</strong> <strong>排除某些表的备份</strong></h5><pre><code class="shell">mysqldump -uroot -p atguigu --ignore-table=atguigu.student &gt; no_stu_bak.sql</code></pre><h5 id="2-7-只备份结构或只备份数据"><a href="#2-7-只备份结构或只备份数据" class="headerlink" title="2.7 只备份结构或只备份数据"></a><strong>2.7</strong> <strong>只备份结构或只备份数据</strong></h5><ul><li>只备份结构</li></ul><pre><code class="shell">mysqldump -uroot -p atguigu --no-data &gt; atguigu_no_data_bak.sql</code></pre><ul><li>只备份数据</li></ul><pre><code class="shell">mysqldump -uroot -p atguigu --no-create-info &gt; atguigu_no_create_info_bak.sql</code></pre><h5 id="2-8-备份中包含存储过程、函数、事件"><a href="#2-8-备份中包含存储过程、函数、事件" class="headerlink" title="2.8 备份中包含存储过程、函数、事件"></a><strong>2.8</strong> <strong>备份中包含存储过程、函数、事件</strong></h5><pre><code class="shell">mysqldump -uroot -p -R -E --databases atguigu &gt; fun_atguigu_bak.sql</code></pre><h4 id="3-mysql命令恢复数据"><a href="#3-mysql命令恢复数据" class="headerlink" title="3. mysql命令恢复数据"></a><strong>3. mysql命令恢复数据</strong></h4><pre><code class="shell">mysql –u root –p [dbname] &lt; backup.sql</code></pre><h5 id="3-1-单库备份中恢复单库"><a href="#3-1-单库备份中恢复单库" class="headerlink" title="3.1 单库备份中恢复单库"></a><strong>3.1</strong> <strong>单库备份中恢复单库</strong></h5><pre><code class="shell">#备份文件中包含了创建数据库的语句mysql -uroot -p &lt; atguigu.sql#备份文件中不包含了创建数据库的语句mysql -uroot -p atguigu4&lt; atguigu.sql</code></pre><h5 id="3-2-全量备份恢复"><a href="#3-2-全量备份恢复" class="headerlink" title="3.2 全量备份恢复"></a><strong>3.2</strong> <strong>全量备份恢复</strong></h5><pre><code class="shell">mysql –u root –p &lt; all.sql</code></pre><h5 id="3-3-从全量备份中恢复单库"><a href="#3-3-从全量备份中恢复单库" class="headerlink" title="3.3 从全量备份中恢复单库"></a><strong>3.3</strong> <strong>从全量备份中恢复单库</strong></h5><pre><code class="shell">sed -n &#39;/^-- Current Database: `atguigu`/,/^-- Current Database: `/p&#39; all_database.sql &gt; atguigu.sql #分离完成后我们再导入atguigu.sql即可恢复单个库</code></pre><h5 id="3-4-从单库备份中恢复单表"><a href="#3-4-从单库备份中恢复单表" class="headerlink" title="3.4 从单库备份中恢复单表"></a><strong>3.4</strong> <strong>从单库备份中恢复单表</strong></h5><pre><code class="shell">cat atguigu.sql | sed -e &#39;/./&#123;H;$!d;&#125;&#39; -e &#39;x;/CREATE TABLE `class`/!d;q&#39; &gt; class_structure.sql cat atguigu.sql | grep --ignore-case &#39;insert into `class`&#39; &gt; class_data.sql #用shell语法分离出创建表的语句及插入数据的语句后 再依次导出即可完成恢复 use atguigu; mysql&gt; source class_structure.sql; Query OK, 0 rows affected, 1 warning (0.00 sec) mysql&gt; source class_data.sql; Query OK, 1 row affected (0.01 sec)</code></pre><h4 id="4-表的导出与导入"><a href="#4-表的导出与导入" class="headerlink" title="4. 表的导出与导入"></a><strong>4.</strong> <strong>表的导出与导入</strong></h4><h5 id="4-1-表的导出"><a href="#4-1-表的导出" class="headerlink" title="4.1 表的导出"></a><strong>4.1</strong> <strong>表的导出</strong></h5><p><strong>1.</strong> <strong>使用SELECT…INTO OUTFILE导出文本文件</strong> </p><pre><code class="mysql">SHOW GLOBAL VARIABLES LIKE &#39;%secure%&#39;;SELECT * FROM account INTO OUTFILE &quot;/var/lib/mysql-files/account.txt&quot;;</code></pre><p><strong>2.</strong> <strong>使用mysqldump命令导出文本文件</strong></p><pre><code class="shell">mysqldump -uroot -p -T &quot;/var/lib/mysql-files/&quot; atguigu account# 或mysqldump -uroot -p -T &quot;/var/lib/mysql-files/&quot; atguigu account --fields-terminated- by=&#39;,&#39; --fields-optionally-enclosed-by=&#39;\&quot;&#39;</code></pre><p><strong>3.</strong> <strong>使用mysql命令导出文本文件</strong></p><pre><code class="shell">mysql -uroot -p --execute=&quot;SELECT * FROM account;&quot; atguigu&gt; &quot;/var/lib/mysql-files/account.txt&quot;</code></pre><h5 id="4-2-表的导入"><a href="#4-2-表的导入" class="headerlink" title="4.2 表的导入"></a><strong>4.2</strong> <strong>表的导入</strong></h5><p><strong>1.</strong> <strong>使用LOAD DATA INFILE方式导入文本文件</strong></p><pre><code class="mysql">LOAD DATA INFILE &#39;/var/lib/mysql-files/account_0.txt&#39; INTO TABLE atguigu.account;# 或LOAD DATA INFILE &#39;/var/lib/mysql-files/account_1.txt&#39; INTO TABLE atguigu.account FIELDS TERMINATED BY &#39;,&#39; ENCLOSED BY &#39;\&quot;&#39;;</code></pre><p><strong>2.</strong> <strong>使用mysqlimport方式导入文本文件</strong></p><pre><code class="shell">mysqlimport -uroot -p atguigu &#39;/var/lib/mysql-files/account.txt&#39; --fields-terminated- by=&#39;,&#39; --fields-optionally-enclosed-by=&#39;\&quot;&#39;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第13章 事务基础知识</title>
      <link href="/2023/07/15/%E7%AC%AC13%E7%AB%A0%20%E4%BA%8B%E5%8A%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2023/07/15/%E7%AC%AC13%E7%AB%A0%20%E4%BA%8B%E5%8A%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h3 id="第13章-事务基础知识"><a href="#第13章-事务基础知识" class="headerlink" title="第13章 事务基础知识"></a>第13章 事务基础知识</h3><h4 id="1-数据库事务概述"><a href="#1-数据库事务概述" class="headerlink" title="1. 数据库事务概述"></a><strong>1.</strong> <strong>数据库事务概述</strong></h4><h5 id="1-1-基本概念"><a href="#1-1-基本概念" class="headerlink" title="1.1 基本概念"></a><strong>1.1</strong> <strong>基本概念</strong></h5><p><strong>事务：</strong>一组逻辑操作单元，使数据从一种状态变换到另一种状态。</p><p><strong>事务处理的原则：</strong>保证所有事务都作为<code>一个工作单元</code>来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都被提交(<code>commit</code>)，那么这些修改就<code>永久</code>地保存下来；要么数据库管理系统将<code>放弃</code>所作的所有<code>修改</code>，整个事务回滚(<code>rollback</code>)到最初状态。</p><h5 id="1-2-事务的ACID特性"><a href="#1-2-事务的ACID特性" class="headerlink" title="1.2 事务的ACID特性"></a><strong>1.2</strong> <strong>事务的ACID特性</strong></h5><ul><li><strong>原子性（atomicity）：</strong></li></ul><p>原子性是指事务是一个不可分割的工作单位，要么全部提交，要么全部失败回滚。</p><ul><li><strong>一致性（consistency）：</strong></li></ul><p>一致性是指事务执行前后，数据从一个<code>合法性状态</code>变换到另外一个<code>合法性状态</code>。这种状态是<code>语义上</code>的而不是语法上的，跟具体的业务有关。</p><ul><li><strong>隔离型（isolation）：</strong></li></ul><p>事务的隔离性是指一个事务的执行<code>不能被其他事务干扰</code>，即一个事务内部的操作及使用的数据对<code>并发</code>的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p><ul><li><strong>持久性（durability）：</strong></li></ul><p>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是<code>永久性的</code>，接下来的其他操作和数据库故障不应该对其有任何影响。</p><p>持久性是通过<code>事务日志</code>来保证的。日志包括了<code>重做日志</code>和<code>回滚日志</code>。当我们通过事务对数据进行修改的时候，首先会将数据库的变化信息记录到重做日志中，然后再对数据库中对应的行进行修改。这样做的好处是，即使数据库系统崩溃，数据库重启后也能找到没有更新到数据库系统中的重做日志，重新执行，从而使事务具有持久性。</p><h5 id="1-3-事务的状态"><a href="#1-3-事务的状态" class="headerlink" title="1.3 事务的状态"></a><strong>1.3</strong> <strong>事务的状态</strong></h5><ul><li><strong>活动的（active）</strong></li></ul><p>事务对应的数据库操作正在执行过程中时，我们就说该事务处在<code>活动的</code>状态。</p><ul><li><strong>部分提交的（partially committed）</strong></li></ul><p>当事务中的最后一个操作执行完成，但由于操作都在内存中执行，所造成的影响并<code>没有刷新到磁盘</code>时，我们就说该事务处在<code>部分提交的</code>状态。</p><ul><li><strong>失败的（failed）</strong></li></ul><p>当事务处在<code>活动的</code>或者<code>部分提交的</code>状态时，可能遇到了某些错误（数据库自身的错误、操作系统错误或者直接断电等）而无法继续执行，或者人为的停止当前事务的执行，我们就说该事务处在<code>失败的</code>状态。</p><ul><li><strong>中止的（aborted）</strong></li></ul><p>如果事务执行了一部分而变为<code>失败的</code>状态，那么就需要把已经修改的事务中的操作还原到事务执行前的状态。换句话说，就是要撤销失败事务对当前数据库造成的影响。我们把这个撤销的过程称之为<code>回滚</code>。当<code>回滚</code>操作执行完毕时，也就是数据库恢复到了执行事务之前的状态，我们就说该事务处在了<code>中止的</code>状态。</p><ul><li><strong>提交的（committed）</strong></li></ul><p>当一个处在<code>部分提交的</code>状态的事务将修改过的数据都<code>同步到磁盘</code>上之后，我们就可以说该事务处在了<code>提交的</code>状态。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204031104063.png" alt="image-20220403110448951"></p><h4 id="2-如何使用事务"><a href="#2-如何使用事务" class="headerlink" title="2. 如何使用事务"></a><strong>2.</strong> <strong>如何使用事务</strong></h4><h5 id="2-1-显式事务"><a href="#2-1-显式事务" class="headerlink" title="2.1 显式事务"></a><strong>2.1</strong> <strong>显式事务</strong></h5><p><strong>步骤1：</strong> <code>START TRANSACTION</code>或者<code>BEGIN</code>，作用是显式开启一个事务。</p><pre><code class="mysql">mysql&gt; BEGIN; #或者 mysql&gt; START TRANSACTION;</code></pre><p><code>START TRANSACTION</code>语句相较于<code>BEGIN</code>特别之处在于，后边能跟随几个<code>修饰符</code>： </p><p>①<code>READ ONLY</code>：标识当前事务是一个<code>只读事务</code>，也就是属于该事务的数据库操作只能读取数据，而不能修改数据。</p><p>②<code>READ WRITE</code>：标识当前事务是一个<code>读写事务</code>，也就是属于该事务的数据库操作既可以读取数据，也可以修改数据。</p><p>③<code>WITH CONSISTENT SNAPSHOT</code>：启动一致性读。</p><p><strong>步骤2：</strong>一系列事务中的操作（主要是DML，不含DDL）</p><p><strong>步骤3：</strong>提交事务 或 中止事务（即回滚事务）</p><pre><code class="mysql"># 提交事务。当提交事务后，对数据库的修改是永久性的。mysql&gt; COMMIT;</code></pre><pre><code class="mysql"># 回滚事务。即撤销正在进行的所有没有提交的修改 mysql&gt; ROLLBACK; # 将事务回滚到某个保存点。 mysql&gt; ROLLBACK TO [SAVEPOINT]</code></pre><p>其中关于SAVEPOINT相关操作有：</p><pre><code class="mysql"># 在事务中创建保存点，方便后续针对保存点进行回滚。一个事物中可以存在多个保存点。SAVEPOINT 保存点名称;</code></pre><pre><code class="mysql"># 删除某个保存点RELEASE SAVEPOINT 保存点名称;</code></pre><h5 id="2-2-隐式事务"><a href="#2-2-隐式事务" class="headerlink" title="2.2 隐式事务"></a><strong>2.2</strong> <strong>隐式事务</strong></h5><ul><li>显式的的使用<code>START TRANSACTION</code>或者<code>BEGIN</code>语句开启一个事务。这样在本次事务提交或者回滚前会暂时关闭掉自动提交的功能。</li><li>把系统变量<code>autocommit</code>的值设置为<code>OFF</code></li></ul><h5 id="2-3-隐式提交数据的情况"><a href="#2-3-隐式提交数据的情况" class="headerlink" title="2.3 隐式提交数据的情况"></a><strong>2.3</strong> <strong>隐式提交数据的情况</strong></h5><ul><li><p><strong>数据定义语言（Data definition language，缩写为：DDL）</strong></p></li><li><p><strong>隐式使用或修改mysql数据库中的表</strong></p></li><li><p><strong>事务控制或关于锁定的语句</strong></p><ul><li>当我们在一个事务还没提交或者回滚时就又使用<code>START TRANSACTION</code>或者<code>BEGIN</code>语句开启了另一个事务时，会<code>隐式的提交</code>上一个事务。</li><li>当前的<code>autocommit</code>系统变量的值为<code>OFF</code>，我们手动把它调为<code>ON</code>时，也会<code>隐式的提交</code>前边语句所属的事务。</li><li>使用<code>LOCK TABLES</code>、<code>UNLOCK TABLES</code>等关于锁定的语句也会<code>隐式的提交</code>前边语句所属的事务。</li></ul></li></ul><h4 id="3-事务隔离级别"><a href="#3-事务隔离级别" class="headerlink" title="3. 事务隔离级别"></a><strong>3.</strong> <strong>事务隔离级别</strong></h4><h5 id="3-1-数据并发问题"><a href="#3-1-数据并发问题" class="headerlink" title="3.1 数据并发问题"></a><strong>3.1</strong> <strong>数据并发问题</strong></h5><p><strong>1.</strong> <strong>脏写（</strong><code>Dirty Write</code><strong>）</strong></p><p>对于两个事务 Session A、Session B，如果事务Session A<code>修改了</code>另一个<code>未提交</code>事务Session B<code>修改过</code>的数据，那就意味着发生了<code>脏写</code></p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204031124086.png" alt="image-20220403112416944"></p><p><strong>2.</strong> <strong>脏读（</strong><code>Dirty Read</code><strong>）</strong></p><p>对于两个事务 Session A、Session B，Session A<code>读取</code>了已经被 Session B<code>更新</code>但还<code>没有被提交</code>的字段。之后若 Session B<code>回滚</code>，Session A<code>读取</code>的内容就是<code>临时且无效</code>的。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204031124136.png" alt="image-20220403112435995"></p><p><strong>3.</strong> <strong>不可重复读（</strong><code>Non-Repeatable Read</code><strong>）</strong></p><p>对于两个事务Session A、Session B，Session A<code>读取</code>了一个字段，然后 Session B<code>更新</code>了该字段。 之后Session A<code>再次读取</code>同一个字段，<code>值就不同</code>了。那就意味着发生了不可重复读。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204031124331.png" alt="image-20220403112458183"></p><p><strong>4.</strong> <strong>幻读（</strong><code>Phantom</code><strong>）</strong></p><p>对于两个事务Session A、Session B, Session A 从一个表中<code>读取</code>了一个字段, 然后 Session B 在该表中<code>插入</code>了一些新的行。 之后, 如果 Session A<code>再次读取</code>同一个表, 就会多出几行。那就意味着发生了幻读。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204031125847.png" alt="image-20220403112514712"></p><p><strong>注意1：</strong></p><p>有的同学会有疑问，那如果Session B中<code>剔除了</code>一些符合<code>studentno &gt; 0</code>的记录而不是插入新记录，那么Session A之后再根据<code>studentno &gt; 0</code>的条件读取的<code>记录变少了</code>，这种现象算不算<code>幻读</code>呢？这种现象<code>不属于幻读</code>，幻读强调的是一个事物按照某个<code>相同条件多次读取</code>记录时，后读取时读到了之前<code>没有读到的记录</code>。</p><p><strong>注意2：</strong></p><p>那对于先前已经读到的记录，之后又读取不到这种情况，算啥呢？这相当于对每一条记录都发生了<code>不可重复读</code>的现象。幻读只是重点强调了读取到之前读取没有获取到的记录。</p><h5 id="3-2-SQL中的四种隔离级别"><a href="#3-2-SQL中的四种隔离级别" class="headerlink" title="3.2 SQL中的四种隔离级别"></a><strong>3.2 SQL中的四种隔离级别</strong></h5><p><code>SQL标准</code>中设立了4个<code>隔离级别</code>：</p><ul><li><code>READ UNCOMMITTED</code>：读未提交，在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。不能避免脏读、不可重复读、幻读。</li><li><code>READ COMMITTED</code>：读已提交，它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。可以避免脏读，但不可重复读、幻读问题仍然存在。</li><li><code>REPEATABLE READ</code>：可重复读，事务A在读到一条数据之后，此时事务B对该数据进行了修改并提交，那么事务A再读该数据，读到的还是原来的内容。可以避免脏读、不可重复读，但幻读问题仍然存在。<code>这是MySQL的默认隔离级别</code>。</li><li><code>SERIALIZABLE</code>：可串行化，确保事务可以从一个表中读取相同的行。在这个事务持续期间，禁止其他事务对该表执行插入、更新和删除操作。所有的并发问题都可以避免，但性能十分低下。能避免脏读、不可重复读和幻读。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204031127542.png" alt="image-20220403112740425"></p><h5 id="3-3-如何设置事务的隔离级别"><a href="#3-3-如何设置事务的隔离级别" class="headerlink" title="3.3 如何设置事务的隔离级别"></a><strong>3.3</strong> <strong>如何设置事务的隔离级别</strong></h5><pre><code class="mysql">SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL 隔离级别; #其中，隔离级别格式： &gt; READ UNCOMMITTED &gt; READ COMMITTED &gt; REPEATABLE READ &gt; SERIALIZABLE</code></pre><p>或者：</p><pre><code class="mysql">SET [GLOBAL|SESSION] TRANSACTION_ISOLATION = &#39;隔离级别&#39; #其中，隔离级别格式： &gt; READ-UNCOMMITTED &gt; READ-COMMITTED &gt; REPEATABLE-READ &gt; SERIALIZABLE</code></pre><h3 id><a href="#" class="headerlink" title></a></h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第19章 数据库备份与恢复</title>
      <link href="/2023/07/15/%E7%AC%AC18%E7%AB%A0%20%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
      <url>/2023/07/15/%E7%AC%AC18%E7%AB%A0%20%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="第18章-主从复制"><a href="#第18章-主从复制" class="headerlink" title="第18章 主从复制"></a>第18章 主从复制</h3><h4 id="1-主从复制概述"><a href="#1-主从复制概述" class="headerlink" title="1. 主从复制概述"></a><strong>1.</strong> <strong>主从复制概述</strong></h4><h5 id="1-1-如何提升数据库并发能力"><a href="#1-1-如何提升数据库并发能力" class="headerlink" title="1.1 如何提升数据库并发能力"></a><strong>1.1</strong> <strong>如何提升数据库并发能力</strong></h5><p>一般应用对数据库而言都是“<code>读多写少</code>”，也就说对数据库读取数据的压力比较大，有一个思路就是采用数据库集群的方案，做<code>主从架构</code>、进行<code>读写分离</code>，这样同样可以提升数据库的并发处理能力。但并不是所有的应用都需要对数据库进行主从架构的设置，毕竟设置架构本身是有成本的。</p><p>如果我们的目的在于提升数据库高并发访问的效率，那么首先考虑的是如何<code>优化SQL和索引</code>，这种方式简单有效；其次才是采用<code>缓存的策略</code>，比如使用 Redis将热点数据保存在内存数据库中，提升读取的效率；最后才是对数据库采用<code>主从架构</code>，进行读写分离。</p><h5 id="1-2-主从复制的作用"><a href="#1-2-主从复制的作用" class="headerlink" title="1.2 主从复制的作用"></a><strong>1.2</strong> <strong>主从复制的作用</strong></h5><p><strong>第1个作用：读写分离。</strong></p><p><strong>第2个作用就是数据备份。</strong></p><p><strong>第3个作用是具有高可用性。</strong></p><h4 id="2-主从复制的原理"><a href="#2-主从复制的原理" class="headerlink" title="2. 主从复制的原理"></a><strong>2.</strong> <strong>主从复制的原理</strong></h4><h5 id="2-1-原理剖析"><a href="#2-1-原理剖析" class="headerlink" title="2.1 原理剖析"></a><strong>2.1</strong> <strong>原理剖析</strong></h5><p><strong>三个线程</strong></p><p>实际上主从同步的原理就是基于 binlog 进行数据同步的。在主从复制过程中，会基于<code>3 个线程</code>来操作，一个主库线程，两个从库线程。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051646097.png" alt="image-20220405164559961"></p><p><code>二进制日志转储线程</code>（Binlog dump thread）是一个主库线程。当从库线程连接的时候， 主库可以将二进制日志发送给从库，当主库读取事件（Event）的时候，会在 Binlog 上<code>加锁</code>，读取完成之后，再将锁释放掉。</p><p><code>从库 I/O 线程</code>会连接到主库，向主库发送请求更新 Binlog。这时从库的 I&#x2F;O 线程就可以读取到主库的二进制日志转储线程发送的 Binlog 更新部分，并且拷贝到本地的中继日志 （Relay log）。</p><p><code>从库 SQL 线程</code>会读取从库中的中继日志，并且执行日志中的事件，将从库中的数据与主库保持同步。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051647759.png" alt="image-20220405164718627"></p><p><strong>复制三步骤</strong></p><p>步骤1：<code>Master</code>将写操作记录到二进制日志（<code>binlog</code>）。</p><p>步骤2：<code>Slave</code>将<code>Master</code>的binary log events拷贝到它的中继日志（<code>relay log</code>）；</p><p>步骤3：<code>Slave</code>重做中继日志中的事件，将改变应用到自己的数据库中。 MySQL复制是异步的且串行化的，而且重启后从<code>接入点</code>开始复制。</p><p><strong>复制的问题</strong></p><p>复制的最大问题：<code>延时</code></p><h5 id="2-2-复制的基本原则"><a href="#2-2-复制的基本原则" class="headerlink" title="2.2 复制的基本原则"></a><strong>2.2</strong> <strong>复制的基本原则</strong></h5><ul><li><p>每个<code>Slave</code>只有一个<code>Master</code></p></li><li><p>每个<code>Slave</code>只能有一个唯一的服务器ID</p></li><li><p>每个<code>Master</code>可以有多个<code>Slave</code></p></li></ul><h4 id="3-同步数据一致性问题"><a href="#3-同步数据一致性问题" class="headerlink" title="3. 同步数据一致性问题"></a><strong>3.</strong> <strong>同步数据一致性问题</strong></h4><p><strong>主从同步的要求：</strong></p><ul><li><p>读库和写库的数据一致(最终一致)；</p></li><li><p>写数据必须写到写库；</p></li><li><p>读数据必须到读库(不一定)；</p></li></ul><h5 id="3-1-理解主从延迟问题"><a href="#3-1-理解主从延迟问题" class="headerlink" title="3.1 理解主从延迟问题"></a><strong>3.1</strong> <strong>理解主从延迟问题</strong></h5><p>进行主从同步的内容是二进制日志，它是一个文件，在进行<code>网络传输</code>的过程中就一定会<code>存在主从延迟</code>（比如 500ms），这样就可能造成用户在从库上读取的数据不是最新的数据，也就是主从同步中的<code>数据不一致性</code>问题。</p><h5 id="3-2-主从延迟问题原因"><a href="#3-2-主从延迟问题原因" class="headerlink" title="3.2 主从延迟问题原因"></a><strong>3.2</strong> <strong>主从延迟问题原因</strong></h5><p>在网络正常的时候，日志从主库传给从库所需的时间是很短的，即T2-T1的值是非常小的。即，网络正常情况下，主备延迟的主要来源是备库接收完binlog和执行完这个事务之间的时间差。</p><p><strong>主备延迟最直接的表现是，从库消费中继日志（relay log）的速度，比主库生产binlog的速度要慢。</strong>造成原因：</p><p>1、从库的机器性能比主库要差</p><p>2、从库的压力大</p><p>3、大事务的执行</p><h5 id="3-3-如何减少主从延迟"><a href="#3-3-如何减少主从延迟" class="headerlink" title="3.3 如何减少主从延迟"></a><strong>3.3</strong> <strong>如何减少主从延迟</strong></h5><p>若想要减少主从延迟的时间，可以采取下面的办法：</p><ol><li><p>降低多线程大事务并发的概率，优化业务逻辑</p></li><li><p>优化SQL，避免慢SQL，<code>减少批量操作</code>，建议写脚本以update-sleep这样的形式完成。</p></li><li><p><code>提高从库机器的配置</code>，减少主库写binlog和从库读binlog的效率差。</p></li><li><p>尽量采用<code>短的链路</code>，也就是主库和从库服务器的距离尽量要短，提升端口带宽，减少binlog传输的网络延时。</p></li><li><p>实时性要求的业务读强制走主库，从库只做灾备，备份。</p></li></ol><h5 id="3-4-如何解决一致性问题"><a href="#3-4-如何解决一致性问题" class="headerlink" title="3.4 如何解决一致性问题"></a><strong>3.4</strong> <strong>如何解决一致性问题</strong></h5><p>读写分离情况下，解决主从同步中数据不一致的问题， 就是解决主从之间 数据复制方式 的问题，如果按照数据一致性 从弱到强 来进行划分，有以下 3 种复制方式。</p><p><strong>方法</strong> <strong>1：异步复制</strong></p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051654133.png" alt="image-20220405165455998"></p><p><strong>方法</strong> <strong>2：半同步复制</strong></p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051655175.png" alt="image-20220405165513025"></p><p><strong>方法</strong> <strong>3：组复制</strong></p><p>首先我们将多个节点共同组成一个复制组，在<code>执行读写（RW）事务</code>的时候，需要通过一致性协议层（Consensus 层）的同意，也就是读写事务想要进行提交，必须要经过组里“大多数人”（对应 Node 节点）的同意，大多数指的是同意的节点数量需要大于 （N&#x2F;2+1），这样才可以进行提交，而不是原发起方一个说了算。而针对<code>只读（RO）事务</code>则不需要经过组内同意，直接 COMMIT 即可。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051656560.png" alt="image-20220405165650425"></p><h3 id><a href="#" class="headerlink" title></a></h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第17章 其它数据库日志</title>
      <link href="/2023/07/15/%E7%AC%AC17%E7%AB%A0%20%E5%85%B6%E5%AE%83%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%A5%E5%BF%97/"/>
      <url>/2023/07/15/%E7%AC%AC17%E7%AB%A0%20%E5%85%B6%E5%AE%83%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h3 id="第17章-其它数据库日志"><a href="#第17章-其它数据库日志" class="headerlink" title="第17章 其它数据库日志"></a>第17章 其它数据库日志</h3><h4 id="1-MySQL支持的日志"><a href="#1-MySQL支持的日志" class="headerlink" title="1. MySQL支持的日志"></a><strong>1. MySQL支持的日志</strong></h4><h5 id="1-1-日志类型"><a href="#1-1-日志类型" class="headerlink" title="1.1 日志类型"></a><strong>1.1</strong> <strong>日志类型</strong></h5><p>MySQL有不同类型的日志文件，用来存储不同类型的日志，分为<code>二进制日志</code>、<code>错误日志</code>、<code>通用查询日志</code>和<code>慢查询日志</code>，这也是常用的4种。MySQL 8又新增两种支持的日志：<code>中继日志</code>和<code>数据定义语句日志</code>。使用这些日志文件，可以查看MySQL内部发生的事情。</p><ul><li><p><strong>慢查询日志：</strong>记录所有执行时间超过long_query_time的所有查询，方便我们对查询进行优化。</p></li><li><p><strong>通用查询日志：</strong>记录所有连接的起始时间和终止时间，以及连接发送给数据库服务器的所有指令，对我们复原操作的实际场景、发现问题，甚至是对数据库操作的审计都有很大的帮助。</p></li><li><p><strong>错误日志：</strong>记录MySQL服务的启动、运行或停止MySQL服务时出现的问题，方便我们了解服务器的状态，从而对服务器进行维护。</p></li><li><p><strong>二进制日志：</strong>记录所有更改数据的语句，可以用于主从服务器之间的数据同步，以及服务器遇到故障时数据的无损失恢复。</p></li><li><p><strong>中继日志：</strong>用于主从服务器架构中，从服务器用来存放主服务器二进制日志内容的一个中间文件。从服务器通过读取中继日志的内容，来同步主服务器上的操作。</p></li><li><p><strong>数据定义语句日志：</strong>记录数据定义语句执行的元数据操作。</p></li></ul><p>除二进制日志外，其他日志都是<code>文本文件</code>。默认情况下，所有日志创建于<code>MySQL数据目录</code>中。</p><h5 id="1-2-日志的弊端"><a href="#1-2-日志的弊端" class="headerlink" title="1.2 日志的弊端"></a><strong>1.2</strong> <strong>日志的弊端</strong></h5><ul><li><p>日志功能会<code>降低MySQL数据库的性能</code>。</p></li><li><p>日志会<code>占用大量的磁盘空间</code>。</p></li></ul><h4 id="2-通用查询日志-general-query-log"><a href="#2-通用查询日志-general-query-log" class="headerlink" title="2. 通用查询日志(general query log)"></a><strong>2.</strong> <strong>通用查询日志(general query log)</strong></h4><p>通用查询日志用来<code>记录用户的所有操作</code>，包括启动和关闭MySQL服务、所有用户的连接开始时间和截止时间、发给 MySQL 数据库服务器的所有 SQL 指令等。当我们的数据发生异常时，<strong>查看通用查询日志，还原操作时的具体场景</strong>，可以帮助我们准确定位问题。</p><h5 id="2-1-查看当前状态"><a href="#2-1-查看当前状态" class="headerlink" title="2.1 查看当前状态"></a><strong>2.1</strong> <strong>查看当前状态</strong></h5><pre><code class="mysql">mysql&gt; SHOW VARIABLES LIKE &#39;%general%&#39;;</code></pre><h5 id="2-2-启动日志"><a href="#2-2-启动日志" class="headerlink" title="2.2 启动日志"></a><strong>2.2</strong> <strong>启动日志</strong></h5><p><strong>方式1：永久性方式</strong></p><pre><code class="ini">[mysqld] general_log=ON general_log_file=[path[filename]] #日志文件所在目录路径，filename为日志文件名</code></pre><p><strong>方式2：临时性方式</strong></p><pre><code class="mysql">SET GLOBAL general_log=on; # 开启通用查询日志SET GLOBAL general_log_file=’path/filename’; # 设置日志文件保存位置SET GLOBAL general_log=off; # 关闭通用查询日志SHOW VARIABLES LIKE &#39;general_log%&#39;; # 查看设置后情况</code></pre><h5 id="2-3-停止日志"><a href="#2-3-停止日志" class="headerlink" title="2.3 停止日志"></a><strong>2.3</strong> <strong>停止日志</strong></h5><p><strong>方式1：永久性方式</strong></p><pre><code class="ini">[mysqld] general_log=OFF</code></pre><p><strong>方式2：临时性方式</strong></p><pre><code class="mysql">SET GLOBAL general_log=off;SHOW VARIABLES LIKE &#39;general_log%&#39;;</code></pre><h4 id="3-错误日志-error-log"><a href="#3-错误日志-error-log" class="headerlink" title="3.错误日志(error log)"></a><strong>3.错误日志(error log)</strong></h4><h5 id="3-1-启动日志"><a href="#3-1-启动日志" class="headerlink" title="3.1 启动日志"></a><strong>3.1</strong> <strong>启动日志</strong></h5><p>在MySQL数据库中，错误日志功能是<code>默认开启</code>的。而且，错误日志<code>无法被禁止</code>。</p><pre><code class="ini">[mysqld] log-error=[path/[filename]] #path为日志文件所在的目录路径，filename为日志文件名</code></pre><h5 id="3-2-查看日志"><a href="#3-2-查看日志" class="headerlink" title="3.2 查看日志"></a><strong>3.2</strong> <strong>查看日志</strong></h5><pre><code class="mysql">mysql&gt; SHOW VARIABLES LIKE &#39;log_err%&#39;;</code></pre><h5 id="3-3-删除-刷新日志"><a href="#3-3-删除-刷新日志" class="headerlink" title="3.3 删除\刷新日志"></a><strong>3.3</strong> <strong>删除\刷新日志</strong></h5><pre><code class="shell">install -omysql -gmysql -m0644 /dev/null /var/log/mysqld.logmysqladmin -uroot -p flush-logs</code></pre><h4 id="4-二进制日志-bin-log"><a href="#4-二进制日志-bin-log" class="headerlink" title="4. 二进制日志(bin log)"></a><strong>4.</strong> <strong>二进制日志(bin log)</strong></h4><h5 id="4-1-查看默认情况"><a href="#4-1-查看默认情况" class="headerlink" title="4.1 查看默认情况"></a><strong>4.1</strong> <strong>查看默认情况</strong></h5><pre><code class="mysql">mysql&gt; show variables like &#39;%log_bin%&#39;;</code></pre><h5 id="4-2-日志参数设置"><a href="#4-2-日志参数设置" class="headerlink" title="4.2 日志参数设置"></a><strong>4.2</strong> <strong>日志参数设置</strong></h5><p><strong>方式1：永久性方式</strong></p><pre><code class="ini">[mysqld] #启用二进制日志 log-bin=atguigu-bin binlog_expire_logs_seconds=600 max_binlog_size=100M</code></pre><p><strong>设置带文件夹的bin-log日志存放目录</strong></p><pre><code class="ini">[mysqld] log-bin=&quot;/var/lib/mysql/binlog/atguigu-bin&quot;</code></pre><p>注意：新建的文件夹需要使用mysql用户，使用下面的命令即可。</p><pre><code class="shell">chown -R -v mysql:mysql binlog</code></pre><p><strong>方式2：临时性方式</strong></p><pre><code class="mysql"># global 级别 mysql&gt; set global sql_log_bin=0; ERROR 1228 (HY000): Variable &#39;sql_log_bin&#39; is a SESSION variable and can`t be used with SET GLOBAL # session级别 mysql&gt; SET sql_log_bin=0; Query OK, 0 rows affected (0.01 秒)</code></pre><h5 id="4-3-查看日志"><a href="#4-3-查看日志" class="headerlink" title="4.3 查看日志"></a><strong>4.3</strong> <strong>查看日志</strong></h5><pre><code class="mysql">mysqlbinlog -v &quot;/var/lib/mysql/binlog/atguigu-bin.000002&quot;# 不显示binlog格式的语句mysqlbinlog -v --base64-output=DECODE-ROWS &quot;/var/lib/mysql/binlog/atguigu-bin.000002&quot;</code></pre><pre><code class="mysql"># 可查看参数帮助 mysqlbinlog --no-defaults --help # 查看最后100行 mysqlbinlog --no-defaults --base64-output=decode-rows -vv atguigu-bin.000002 |tail -100 # 根据position查找 mysqlbinlog --no-defaults --base64-output=decode-rows -vv atguigu-bin.000002 |grep -A20 &#39;4939002&#39;</code></pre><p>上面这种办法读取出binlog日志的全文内容比较多，不容易分辨查看到pos点信息，下面介绍一种更为方便的查询命令：</p><pre><code class="mysql">mysql&gt; show binlog events [IN &#39;log_name&#39;] [FROM pos] [LIMIT [offset,] row_count];</code></pre><ul><li><code>IN &#39;log_name&#39;</code>：指定要查询的binlog文件名（不指定就是第一个binlog文件）　</li><li><code>FROM pos</code>：指定从哪个pos起始点开始查起（不指定就是从整个文件首个pos点开始算）</li><li><code>LIMIT [offset]</code>：偏移量(不指定就是0) </li><li><code>row_count</code>:查询总条数（不指定就是所有行）</li></ul><pre><code class="mysql">mysql&gt; show binlog events in &#39;atguigu-bin.000002&#39;;</code></pre><h5 id="4-4-使用日志恢复数据"><a href="#4-4-使用日志恢复数据" class="headerlink" title="4.4 使用日志恢复数据"></a><strong>4.4</strong> <strong>使用日志恢复数据</strong></h5><p>mysqlbinlog恢复数据的语法如下：</p><pre><code class="shell">mysqlbinlog [option] filename|mysql –uuser -ppass;</code></pre><ul><li><code>filename</code>：是日志文件名。</li><li><code>option</code>：可选项，比较重要的两对option参数是–start-date、–stop-date 和 –start-position、– stop-position。 <ul><li><code>--start-date 和 --stop-date</code>：可以指定恢复数据库的起始时间点和结束时间点。</li><li><code>--start-position和--stop-position</code>：可以指定恢复数据的开始位置和结束位置。</li></ul></li></ul><blockquote><p>注意：使用mysqlbinlog命令进行恢复操作时，必须是编号小的先恢复，例如atguigu-bin.000001必须在atguigu-bin.000002之前恢复。</p></blockquote><h5 id="4-5-删除二进制日志"><a href="#4-5-删除二进制日志" class="headerlink" title="4.5 删除二进制日志"></a><strong>4.5</strong> <strong>删除二进制日志</strong></h5><p><strong>1. PURGE MASTER LOGS：删除指定日志文件</strong></p><pre><code class="mysql">PURGE &#123;MASTER | BINARY&#125; LOGS TO ‘指定日志文件名’ PURGE &#123;MASTER | BINARY&#125; LOGS BEFORE ‘指定日期’</code></pre><h4 id="5-再谈二进制日志-binlog"><a href="#5-再谈二进制日志-binlog" class="headerlink" title="5. 再谈二进制日志(binlog)"></a><strong>5.</strong> <strong>再谈二进制日志(binlog)</strong></h4><h5 id="5-1-写入机制"><a href="#5-1-写入机制" class="headerlink" title="5.1 写入机制"></a><strong>5.1</strong> <strong>写入机制</strong></h5><p>binlog的写入时机也非常简单，事务执行过程中，先把日志写到<code>binlog cache</code>，事务提交的时候，再把binlog cache写到binlog文件中。因为一个事务的binlog不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为binlog cache。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051630535.png" alt="image-20220405163025361"></p><p>write和fsync的时机，可以由参数<code>sync_binlog</code>控制，默认是 <code>0</code>。为0的时候，表示每次提交事务都只write，由系统自行判断什么时候执行fsync。虽然性能得到提升，但是机器宕机，page cache里面的binglog 会丢失。如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051631346.png" alt="image-20220405163125180"></p><p>为了安全起见，可以设置为<code>1</code>，表示每次提交事务都会执行fsync，就如同<strong>redo log</strong> <strong>刷盘流程</strong>一样。最后还有一种折中方式，可以设置为N(N&gt;1)，表示每次提交事务都write，但累积N个事务后才fsync。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051632526.png" alt="image-20220405163205364"></p><p>在出现IO瓶颈的场景里，将sync_binlog设置成一个比较大的值，可以提升性能。同样的，如果机器宕机，会丢失最近N个事务的binlog日志。</p><h5 id="5-2-binlog与redolog对比"><a href="#5-2-binlog与redolog对比" class="headerlink" title="5.2 binlog与redolog对比"></a><strong>5.2 binlog与redolog对比</strong></h5><ul><li>redo log 它是<code>物理日志</code>，记录内容是“在某个数据页上做了什么修改”，属于 InnoDB 存储引擎层产生的。</li><li>而 binlog 是<code>逻辑日志</code>，记录内容是语句的原始逻辑，类似于“给 ID&#x3D;2 这一行的 c 字段加 1”，属于MySQL Server 层。</li><li>虽然它们都属于持久化的保证，但是侧重点不同。<ul><li>redo log 让InnoDB存储引擎拥有了崩溃恢复能力。</li><li>binlog保证了MySQL集群架构的数据一致性</li></ul></li></ul><h5 id="5-3-两阶段提交"><a href="#5-3-两阶段提交" class="headerlink" title="5.3 两阶段提交"></a><strong>5.3</strong> <strong>两阶段提交</strong></h5><p>在执行更新语句过程，会记录redo log与binlog两块日志，以基本的事务为单位，redo log在事务执行过程中可以不断写入，而binlog只有在提交事务时才写入，所以redo log与binlog的<code>写入时机</code>不一样。</p><p>为了解决两份日志之间的逻辑一致问题，InnoDB存储引擎使用<strong>两阶段提交</strong>方案。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051637390.png" alt="image-20220405163716222"></p><p>使用<strong>两阶段提交</strong>后，写入binlog时发生异常也不会有影响</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051639192.png" alt="image-20220405163902977"></p><p>另一个场景，redo log设置commit阶段发生异常，那会不会回滚事务呢？</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051639403.png" alt="image-20220405163927129"></p><p>并不会回滚事务，它会执行上图框住的逻辑，虽然redo log是处于prepare阶段，但是能通过事务id找到对应的binlog日志，所以MySQL认为是完整的，就会提交事务恢复数据。</p><h4 id="6-中继日志-relay-log"><a href="#6-中继日志-relay-log" class="headerlink" title="6. 中继日志(relay log)"></a><strong>6.</strong> <strong>中继日志(relay log)</strong></h4><h5 id="6-1-介绍"><a href="#6-1-介绍" class="headerlink" title="6.1 介绍"></a><strong>6.1</strong> <strong>介绍</strong></h5><p><strong>中继日志只在主从服务器架构的从服务器上存在</strong>。从服务器为了与主服务器保持一致，要从主服务器读取二进制日志的内容，并且把读取到的信息写入<code>本地的日志文件</code>中，这个从服务器本地的日志文件就叫<code>中继日志</code>。然后，从服务器读取中继日志，并根据中继日志的内容对从服务器的数据进行更新，完成主从服务器的<code>数据同步</code>。</p><h5 id="6-2-恢复的典型错误"><a href="#6-2-恢复的典型错误" class="headerlink" title="6.2 恢复的典型错误"></a><strong>6.2</strong> <strong>恢复的典型错误</strong></h5><p>如果从服务器宕机，有的时候为了系统恢复，要重装操作系统，这样就可能会导致你的<code>服务器名称</code>与之前<code>不同</code>。而中继日志里是<code>包含从服务器名</code>的。在这种情况下，就可能导致你恢复从服务器的时候，无法从宕机前的中继日志里读取数据，以为是日志文件损坏了，其实是名称不对了。</p><p>解决的方法也很简单，把从服务器的名称改回之前的名称。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第15章 Mysql锁</title>
      <link href="/2023/07/15/%E7%AC%AC15%E7%AB%A0%20%E9%94%81/"/>
      <url>/2023/07/15/%E7%AC%AC15%E7%AB%A0%20%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h3 id="第15章-锁"><a href="#第15章-锁" class="headerlink" title="第15章 锁"></a>第15章 锁</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a><strong>1.</strong> <strong>概述</strong></h4><p>在数据库中，除传统的计算资源（如CPU、RAM、I&#x2F;O等）的争用以外，数据也是一种供许多用户共享的资源。为保证数据的一致性，需要对<code>并发操作进行控制</code>，因此产生了<code>锁</code>。同时<code>锁机制</code>也为实现MySQL的各个隔离级别提供了保证。 锁冲突 也是影响数据库<code>并发访问性能</code>的一个重要因素。所以锁对数据库而言显得尤其重要，也更加复杂。</p><h4 id="2-MySQL并发事务访问相同记录"><a href="#2-MySQL并发事务访问相同记录" class="headerlink" title="2. MySQL并发事务访问相同记录"></a><strong>2. MySQL并发事务访问相同记录</strong></h4><h5 id="2-1-读-读情况"><a href="#2-1-读-读情况" class="headerlink" title="2.1 读-读情况"></a><strong>2.1</strong> <strong>读-读情况</strong></h5><p><code>读-读</code>情况，即并发事务相继<code>读取相同的记录</code>。读取操作本身不会对记录有任何影响，并不会引起什么问题，所以允许这种情况的发生。</p><h5 id="2-2-写-写情况"><a href="#2-2-写-写情况" class="headerlink" title="2.2 写-写情况"></a><strong>2.2</strong> <strong>写-写情况</strong></h5><p><code>写-写</code>情况，即并发事务相继对相同的记录做出改动。</p><p>在这种情况下会发生<code>脏写</code>的问题，任何一种隔离级别都不允许这种问题的发生。所以在多个未提交事务相继对一条记录做改动时，需要让它们<code>排队执行</code>，这个排队的过程其实是通过<code>锁</code>来实现的。</p><h5 id="2-3-读-写或写-读情况"><a href="#2-3-读-写或写-读情况" class="headerlink" title="2.3 读-写或写-读情况"></a><strong>2.3</strong> <strong>读-写或写-读情况</strong></h5><p><code>读-写</code>或<code>写-读</code>，即一个事务进行读取操作，另一个进行改动操作。这种情况下可能发生<code>脏读</code>、<code>不可重复读</code>、<code>幻读</code>的问题。</p><h5 id="2-4-并发问题的解决方案"><a href="#2-4-并发问题的解决方案" class="headerlink" title="2.4 并发问题的解决方案"></a><strong>2.4</strong> <strong>并发问题的解决方案</strong></h5><p>怎么解决<code>脏读</code>、<code>不可重复读</code>、<code>幻读</code>这些问题呢？其实有两种可选的解决方案：</p><ul><li>方案一：读操作利用多版本并发控制（<code>MVCC</code>，下章讲解），写操作进行<code>加锁</code>。</li></ul><p>所谓的<code>MVCC</code>，就是生成一个<code>ReadView</code>，通过ReadView找到符合条件的记录版本（历史版本由<code>undo日志</code>构建）。查询语句只能<code>读</code>到在生成ReadView之前<code>已提交事务所做的更改</code>，在生成ReadView之前未提交的事务或者之后才开启的事务所做的更改是看不到的。而<code>写操作</code>肯定针对的是<code>最新版本的记录</code>，读记录的历史版本和改动记录的最新版本本身并不冲突，也就是采用MVCC时，<code>读-写</code>操作并不冲突。</p><blockquote><p>普通的SELECT语句在READ COMMITTED和REPEATABLE READ隔离级别下会使用到MVCC读取记录。</p><ul><li>在<code>READ COMMITTED</code>隔离级别下，一个事务在执行过程中每次执行SELECT操作时都会生成一个ReadView，ReadView的存在本身就保证了<code>事务不可以读取到未提交的事务所做的更改</code>，也就是避免了脏读现象；</li><li>在<code>REPEATABLE READ</code>隔离级别下，一个事务在执行过程中只有<code>第一次执行SELECT操作 </code>才会生成一个ReadView，之后的SELECT操作都<code>复用</code>这ReadView，这样也就避免了不可重复读和幻读的问题。</li></ul></blockquote><ul><li><p>方案二：读、写操作都采用<code>加锁</code>的方式。</p></li><li><p>小结对比发现：</p><ul><li>采用<code>MVCC</code>方式的话，<code>读-写</code>操作彼此并不冲突，<code>性能更高</code>。</li><li>采用<code>加锁</code>方式的话，<code>读-写</code>操作彼此需要<code>排队执行</code>，影响性能。</li></ul></li></ul><p>一般情况下我们当然愿意采用<code>MVCC</code>来解决<code>读-写</code>操作并发执行的问题，但是业务在某些特殊情况下，要求必须采用<code>加锁</code>的方式执行。</p><h4 id="3-锁的不同角度分类"><a href="#3-锁的不同角度分类" class="headerlink" title="3. 锁的不同角度分类"></a><strong>3.</strong> <strong>锁的不同角度分类</strong></h4><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204050933339.png" alt="image-20220405093322184"></p><h5 id="3-1-从数据操作的类型划分：读锁、写锁"><a href="#3-1-从数据操作的类型划分：读锁、写锁" class="headerlink" title="3.1 从数据操作的类型划分：读锁、写锁"></a><strong>3.1</strong> <strong>从数据操作的类型划分：读锁、写锁</strong></h5><ul><li><code>读锁</code>：也称为<code>共享锁</code>、英文用<code>S</code>表示。针对同一份数据，多个事务的读操作可以同时进行而不会互相影响，相互不阻塞的。</li><li><code>写锁</code>：也称为<code>排他锁</code>、英文用<code>X</code>表示。当前写操作没有完成前，它会阻断其他写锁和读锁。这样就能确保在给定的时间里，只有一个事务能执行写入，并防止其他用户读取正在写入的同一资源。</li></ul><p><strong>需要注意的是对于</strong> <strong>InnoDB</strong> <strong>引擎来说，读锁和写锁可以加在表上，也可以加在行上。</strong></p><p><strong>1. 锁定读</strong></p><p>在采用<code>加锁</code>方式解决<code>脏读</code>、<code>不可重复读</code>、<code>幻读</code>这些问题时，读取一条记录时需要获取该记录的<code>S锁</code>，其实是不严谨的，有时候需要在读取记录时就获取记录的<code>X锁</code>，来禁止别的事务读写该记录，为此MySQL提出了两种比较特殊的<code>SELECT</code>语句格式：</p><ul><li>对读取的记录加<code>S锁</code>：</li></ul><pre><code class="mysql">SELECT ... LOCK IN SHARE MODE;# 或SELECT ... FOR SHARE; #(8.0新增语法)</code></pre><ul><li>对读取的记录加<code>X锁</code>：</li></ul><pre><code class="mysql">SELECT ... FOR UPDATE;</code></pre><p><strong>MySQL8.0新特性：</strong></p><p>在5.7及之前的版本，SELECT … FOR UPDATE，如果获取不到锁，会一直等待，直到<code>innodb_lock_wait_timeout</code>超时。在8.0版本中，SELECT … FOR UPDATE, SELECT … FOR SHARE 添加<code>NOWAIT</code>、<code>SKIP LOCKED</code>语法，跳过锁等待，或者跳过锁定。</p><ul><li>NOWAIT：如果查询的行已经加锁，会立即报错返回</li><li>SKIP LOCKED：如果查询的行已经加锁，只返回结果中不包含被锁定的行</li></ul><p><strong>2. 写操作</strong></p><ul><li><code>DELETE</code>：对一条记录做DELETE操作的过程其实是先在<code>B+</code>树中定位到这条记录的位置，然后获取这条记录的<code>X锁</code>，再执行<code>delete mark</code>操作。</li><li><code>UPDATE</code>：在对一条记录做UPDATE操作时分为三种情况：<ul><li>情况1：未修改该记录的键值，并且被更新的列占用的存储空间在修改前后未发生变化。则先在<code>B+</code>树中定位到这条记录的位置，然后再获取一下记录的<code>X锁</code>，最后在原纪录的位置进行修改操作。</li><li>情况2：未修改该记录的键值，并且至少有一个被更新的列占用的存储空间在修改前后发生变化。则先在<code>B+</code>树中定位到这条记录的位置，然后获取一下记录的<code>X锁</code>，将该记录彻底删除掉（就是把记录彻底移入垃圾链表），最后再插入一条新记录。新插入的记录由<code>INSERT</code>操作提供的<code>隐式锁</code>进行保护。</li><li>情况3：修改该记录的键值，则相当于在原纪录上做<code>DELECT</code>操作之后再来一次<code>INSERT</code>操作。</li></ul></li><li><code>INSERT</code>：一般情况下，新插入一条记录的操作并不加锁，通过一种称之为<code>隐式锁</code>的结构来保护这条新插入的记录在本事务提交前不被别的事务访问。</li></ul><h5 id="3-2-从数据操作的粒度划分：表级锁、页级锁、行锁"><a href="#3-2-从数据操作的粒度划分：表级锁、页级锁、行锁" class="headerlink" title="3.2 从数据操作的粒度划分：表级锁、页级锁、行锁"></a><strong>3.2</strong> <strong>从数据操作的粒度划分：表级锁、页级锁、行锁</strong></h5><p><strong>1.</strong> <strong>表锁（Table Lock）</strong> </p><p>该锁会锁定整张表，它是MySQL中最基本的锁策略，并<code>不依赖于存储引擎</code>，并且表锁是<code>开销最少</code>的策略。由于表级锁一次会将整个表锁定，所以可以很好的<code>避免死锁</code>的问题。当然，锁的粒度大所带来最大的负面影响就是出现锁资源争用的概率也会最高，导致<code>并发率大打折扣</code>。</p><p><strong>① 表级别的S锁、X锁</strong></p><p>在对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，InnoDB存储引擎是不会为这个表添加表级别的<code>S锁</code>或者<code>X锁</code>的。在对某个表执行一些诸如<code>ALTER TABLE</code>、<code>DROP TABLE</code>这类的<code>DDL</code>语句时，其他事务对这个表并发执行诸如SELECT、INSERT、DELETE、UPDATE的语句会发生阻塞。同理，某个事务中对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，在其他会话中对这个表执行<code>DDL</code>语句也会发生阻塞。这个过程其实是通过在<code>server层</code>使用一种称之为<code>元数据锁</code>（英文名：<code>Metadata Locks</code>，简称<code>MDL</code>）结构来实现的。</p><p>一般情况下，不会使用InnoDB存储引擎提供的表级别的<code>S锁</code>和<code>X锁</code>。只会在一些特殊情况下，比方说<code>崩溃恢复</code>过程中用到。比如，在系统变量<code>autocommit=0，innodb_table_locks = 1</code>时，<code>手动</code>获取InnoDB存储引擎提供的表t 的<code>S锁</code>或者<code>X锁</code>可以这么写：</p><ul><li><p><code>LOCK TABLES t READ</code>：InnoDB存储引擎会对表<code>t</code>加表级别的<code>S锁</code>。 </p></li><li><p><code>LOCK TABLES t WRITE</code>：InnoDB存储引擎会对表<code>t</code>加表级别的<code>X锁</code>。</p></li></ul><p>总结：MyISAM在执行查询语句（SELECT）前，会给涉及的所有表加读锁，在执行增删改操作前，会给涉及的表加写锁。<code>InnoDB</code>存储引擎是不会为这个表添加表级别的<code>读锁</code>或者<code>写锁</code>的。</p><p><strong>② 意向锁 （intention lock）</strong></p><p>InnoDB 支持<code>多粒度锁（multiple granularity locking）</code>，它允许<code>行级锁</code>与<code>表级锁</code>共存，而<strong>意向锁</strong>就是其中的一种<code>表锁</code>。</p><p>1、意向锁的存在是为了协调行锁和表锁的关系，支持多粒度（表锁与行锁）的锁并存。</p><p>2、意向锁是一种<code>不与行级锁冲突的表级锁</code>，这一点非常重要。</p><p>3、表明“某个事务正在某些行持有了锁或该事务准备去持有锁”</p><p>意向锁分为两种：</p><ul><li><strong>意向共享锁</strong>（intention shared lock, IS）：事务有意向对表中的某些行加<strong>共享锁</strong>（S锁）</li></ul><pre><code class="mysql">-- 事务要获取某些行的 S 锁，必须先获得表的 IS 锁。 SELECT column FROM table ... LOCK IN SHARE MODE;</code></pre><ul><li><strong>意向排他锁</strong>（intention exclusive lock, IX）：事务有意向对表中的某些行加<strong>排他锁</strong>（X锁）</li></ul><pre><code class="mysql">-- 事务要获取某些行的 X 锁，必须先获得表的 IX 锁。 SELECT column FROM table ... FOR UPDATE;</code></pre><p>即：意向锁是由存储引擎<code>自己维护的</code>，用户无法手动操作意向锁，在为数据行加共享 &#x2F; 排他锁之前，InooDB 会先获取该数据行<code>所在数据表的对应意向锁</code>。</p><p><strong>1. 意向锁要解决的问题</strong></p><p>现在有两个事务，分别是T1和T2，其中T2试图在该表级别上应用共享或排它锁，如果没有意向锁存在，那么T2就需要去检查各个页或行是否存在锁；如果存在意向锁，那么此时就会受到由T1控制的<code>表级别意向锁的阻塞</code>。T2在锁定该表前不必检查各个页或行锁，而只需检查表上的意向锁。简单来说就是给更大一级级别的空间示意里面是否已经上过锁。</p><p>在数据表的场景中，<strong>如果我们给某一行数据加上了排它锁，数据库会自动给更大一级的空间，比如数据页或数据表加上意向锁，告诉其他人这个数据页或数据表已经有人上过排它锁了</strong>，这样当其他人想要获取数据表排它锁的时候，只需要了解是否有人已经获取了这个数据表的意向排它锁即可。</p><ul><li>如果事务想要获取数据表中某些记录的共享锁，就需要在数据表上<code>添加意向共享锁</code></li><li>如果事务想要获取数据表中某些记录的排它锁，就需要在数据表上<code>添加意向排他锁</code></li></ul><p>这时，意向锁会告诉其他事务已经有人锁定了表中的某些记录。</p><p><strong>③ 自增锁（AUTO-INC锁）</strong></p><p><strong>1. “Simple inserts”</strong> <strong>（简单插入）</strong></p><p>可以<code>预先确定要插入的行数</code>（当语句被初始处理时）的语句。包括没有嵌套子查询的单行和多行<code>INSERT...VALUES()</code>和<code>REPLACE</code>语句。</p><p><strong>2. “Bulk inserts”</strong> <strong>（批量插入）</strong></p><p><code>事先不知道要插入的行数</code>（和所需自动递增值的数量）的语句。比如<code>INSERT ... SELECT</code>，<code>REPLACE ... SELECT</code>和<code>LOAD DATA</code>语句，但不包括纯INSERT。 InnoDB在每处理一行，为AUTO_INCREMENT列分配一个新值。</p><p><strong>3. “Mixed-mode inserts”</strong> <strong>（混合模式插入）</strong></p><p>这些是“Simple inserts”语句但是指定部分新行的自动递增值。例如<code>INSERT INTO teacher (id,name) VALUES (1,&#39;a&#39;), (NULL,&#39;b&#39;), (5,&#39;c&#39;), (NULL,&#39;d&#39;);</code>只是指定了部分id的值。另一种类型的“混合模式插入”是<code>INSERT ... ON DUPLICATE KEY UPDATE</code>。 </p><p>对于上面数据插入的案例，MySQL采用了<code>自增锁</code>的方式来实现，<strong>AUTO-INT锁是当向使用含有AUTO_INCREMENT列的表中插入数据时需要获取的一种特殊的表级锁</strong>，在执行插入语句时就在表级别加一个AUTO-INT锁，然后为每条待插入记录的AUTO_INCREMENT修饰的列分配递增的值，在该语句执行结束后，再把AUTO-INT锁释放掉。<strong>一个事务在持有AUTO-INC锁的过程中，其他事务的插入语句都要被阻塞</strong>，可以保证一个语句中分配的递增值是连续的。也正因为此，其并发性显然并不高，<strong>当我们向一个有AUTO_INCREMENT关键字的主键插入值的时候，每条语句都要对这个表锁进行竞争</strong>，这样的并发潜力其实是很低下的，所以innodb通过<code>innodb_autoinc_lock_mode</code>的不同取值来提供不同的锁定机制，来显著提高SQL语句的可伸缩性和性能。</p><p>innodb_autoinc_lock_mode有三种取值，分别对应与不同锁定模式：</p><p><code>（1）innodb_autoinc_lock_mode = 0(“传统”锁定模式)</code></p><p>在此锁定模式下，所有类型的insert语句都会获得一个特殊的表级AUTO-INC锁，用于插入具有AUTO_INCREMENT列的表。这种模式其实就如我们上面的例子，即每当执行insert的时候，都会得到一个表级锁(AUTO-INC锁)，使得语句中生成的auto_increment为顺序，且在binlog中重放的时候，可以保证master与slave中数据的auto_increment是相同的。因为是表级锁，当在同一时间多个事务中执行insert的时候，对于AUTO-INC锁的争夺会<code>限制并发</code>能力。</p><p><code>（2）innodb_autoinc_lock_mode = 1(“连续”锁定模式)</code></p><p>在 MySQL 8.0 之前，连续锁定模式是<code>默认</code>的。</p><p>在这个模式下，“bulk inserts”仍然使用AUTO-INC表级锁，并保持到语句结束。这适用于所有INSERT … SELECT，REPLACE … SELECT和LOAD DATA语句。同一时刻只有一个语句可以持有AUTO-INC锁。</p><p>对于“Simple inserts”（要插入的行数事先已知），则通过在<code>mutex（轻量锁）</code>的控制下获得所需数量的自动递增值来避免表级AUTO-INC锁， 它只在分配过程的持续时间内保持，而不是直到语句完成。不使用表级AUTO-INC锁，除非AUTO-INC锁由另一个事务保持。如果另一个事务保持AUTO-INC锁，则“Simple inserts”等待AUTO-INC锁，如同它是一个“bulk inserts”。 </p><p><code>（3）innodb_autoinc_lock_mode = 2(“交错”锁定模式)</code></p><p>从 MySQL 8.0 开始，交错锁模式是<code>默认</code>设置。</p><p>在这种锁定模式下，所有类INSERT语句都不会使用表级AUTO-INC锁，并且可以同时执行多个语句。这是最快和最可拓展的锁定模式，但是当使用基于语句的复制或恢复方案时，<strong>从二进制日志重播SQL语句时，这是不安全的。</strong></p><p>在此锁定模式下，自动递增值<code>保证</code>在所有并发执行的所有类型的insert语句中是<code>唯一</code>且<code>单调递增</code>的。但是，由于多个语句可以同时生成数字（即，跨语句交叉编号），<strong>为任何给定语句插入的行生成的值可能不是连续的。</strong></p><p><strong>④ 元数据锁（MDL锁）</strong></p><p>MySQL5.5引入了meta data lock，简称MDL锁，属于表锁范畴。MDL 的作用是，保证读写的正确性。比如，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个<code>表结构做变更</code>，增加了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。</p><p>因此，<strong>当对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。</strong></p><p><strong>2. InnoDB中的行锁</strong></p><p>行锁（Row Lock）也称为记录锁，顾名思义，就是锁住某一行（某条记录row）。需要注意的是，MySQL服务器层并没有实现行锁机制，<strong>行级锁只在存储引擎层实现。</strong></p><p><strong>优点：</strong>锁定力度小，发生<code>锁冲突概率低</code>，可以实现的<code>并发度高</code></p><p><strong>缺点：</strong>对于<code>锁的开销比较大</code>，加锁会比较慢，容易出现<code>死锁</code>情况</p><p>InnoDB与MyISAM的最大不同有两点：一是支持事务；二是采用了行级锁。</p><p><strong>① 记录锁（Record Locks）</strong></p><p>记录锁也就是仅仅把一条记录锁上，官方的类型名称为：<code>LOCK_REC_NOT_GAP</code>。</p><p>记录锁是有S锁和X锁之分的，称之为<code>S型记录锁</code>和<code>X型记录锁</code>。</p><ul><li>当一个事务获取了一条记录的S型记录锁后，其他事务也可以继续获取该记录的S型记录锁，但不可以继续获取X型记录锁；</li><li>当一个事务获取了一条记录的X型记录锁后，其他事务既不可以继续获取该记录的S型记录锁，也不可以继续获取X型记录锁。</li></ul><p><strong>② 间隙锁（Gap Locks）</strong></p><p><code>MySQL</code>在<code>REPEATABLE READ</code>隔离级别下是可以解决幻读问题的，解决方案有两种，可以使用<code>MVCC</code>方案解决，也可以采用<code>加锁</code>方案解决。但是在使用加锁方案解决时有个大问题，就是事务在第一次执行读取操作时，那些幻影记录尚不存在，我们无法给这些<code>幻影记录</code>加上<code>记录锁</code>。InnoDB提出了一种称之为<code>Gap Locks</code>的锁，官方的类型名称为：<code>LOCK_GAP</code>，我们可以简称为<code>gap锁</code>。</p><p><strong>gap锁的提出仅仅是为了防止插入幻影记录而提出的</strong>。虽然有<code>共享gap锁</code>和<code>独占gap锁</code>这样的说法，但是它们起到的作用是相同的。而且如果对一条记录加了gap锁（不论是共享gap锁还是独占gap锁），并不会限制其他事务对这条记录加记录锁或者继续加gap锁。</p><p><strong>③ 临键锁（Next-Key Locks）</strong></p><p>有时候我们既想<code>锁住某条记录</code>，又想<code>阻止</code>其他事务在该记录前边的<code>间隙插入新记录</code>，所以InnoDB就提出了一种称之为<code>Next-Key Locks</code>的锁，官方的类型名称为：<code>LOCK_ORDINARY</code>，我们也可以简称为<code>next-key锁</code>。Next-Key Locks是在存储引擎<code>innodb</code>、事务级别在<code>可重复读</code>的情况下使用的数据库锁，innodb默认的锁就是Next-Key locks。 </p><pre><code class="mysql">begin; select * from student where id &lt;=8 and id &gt; 3 for update;</code></pre><p><strong>④ 插入意向锁（Insert Intention Locks）</strong></p><p>我们说一个事务在<code>插入</code>一条记录时需要判断一下插入位置是不是被别的事务加了<code>gap锁</code>（<code>next-key锁</code>也包含<code>gap锁</code>），如果有的话，插入操作需要等待，直到拥有<code>gap锁</code>的那个事务提交。但是<strong>InnoDB规定事务在等待的时候也需要在内存中生成一个锁结构</strong>，表明有事务想在某个<code>间隙</code>中<code>插入</code>新记录，但是现在在等待。InnoDB就把这种类型的锁命名为<code>Insert Intention Locks</code>，官方的类型名称为：<code>LOCK_INSERT_INTENTION</code>，我们称为<code>插入意向锁</code>。插入意向锁是一种<code>Gap锁</code>，不是意向锁，在insert操作时产生。</p><p>插入意向锁是在插入一条记录行前，由<code>INSERT 操作产生的一种间隙锁</code>。</p><p>事实上<strong>插入意向锁并不会阻止别的事务继续获取该记录上任何类型的锁。</strong></p><p><strong>3.</strong> <strong>页锁</strong></p><p>页锁就是在<code>页的粒度</code>上进行锁定，锁定的数据资源比行锁要多，因为一个页中可以有多个行记录。当我们使用页锁的时候，会出现数据浪费的现象，但这样的浪费最多也就是一个页上的数据行。<strong>页锁的开销介于表锁和行锁之间，会出现死锁。锁定粒度介于表锁和行锁之间，并发度一般。</strong></p><p>每个层级的锁数量是有限制的，因为锁会占用内存空间，<code>锁空间的大小是有限的</code>。当某个层级的锁数量超过了这个层级的阈值时，就会进行<code>锁升级</code>。锁升级就是用更大粒度的锁替代多个更小粒度的锁，比如InnoDB 中行锁升级为表锁，这样做的好处是占用的锁空间降低了，但同时数据的并发度也下降了。</p><h5 id="3-3-从对待锁的态度划分-乐观锁、悲观锁"><a href="#3-3-从对待锁的态度划分-乐观锁、悲观锁" class="headerlink" title="3.3 从对待锁的态度划分:乐观锁、悲观锁"></a><strong>3.3</strong> <strong>从对待锁的态度划分:乐观锁、悲观锁</strong></h5><p>从对待锁的态度来看锁的话，可以将锁分成乐观锁和悲观锁，从名字中也可以看出这两种锁是两种看待<code>数据并发的思维方式</code>。需要注意的是，乐观锁和悲观锁并不是锁，而是锁的<code>设计思想</code>。</p><p><strong>1.</strong> <strong>悲观锁（Pessimistic Locking）</strong></p><p>悲观锁总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会<code>阻塞</code>直到它拿到锁（<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong>）。比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁，当其他线程想要访问数据时，都需要阻塞挂起。Java中<code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现。</p><p>注意：<strong>select … for update 语句执行过程中所有扫描的行都会被锁上，因此在MySQL中用悲观锁必须确定使用了索引，而不是全表扫描，否则将会把整个表锁住。</strong></p><p><strong>2.</strong> <strong>乐观锁（Optimistic Locking）</strong></p><p>乐观锁认为对同一数据的并发操作不会总发生，属于小概率事件，不用每次都对数据上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，也就是<strong>不采用数据库自身的锁机制，而是通过程序来实现</strong>。在程序上，我们可以采用<code>版本号机制</code>或者<code>CAS机制</code>实现。<strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量</strong>。在Java中<code>java.util.concurrent.atomic</code>包下的原子变量类就是使用了乐观锁的一种实现方式：CAS实现的。</p><p><strong>1.</strong> <strong>乐观锁的版本号机制</strong></p><p>在表中设计一个<code>版本字段 version</code>，第一次读的时候，会获取 version 字段的取值。然后对数据进行更新或删除操作时，会执行<code>UPDATE ... SET version=version+1 WHERE version=version</code>。此时如果已经有事务对这条数据进行了更改，修改就不会成功。</p><p><strong>2.</strong> <strong>乐观锁的时间戳机制</strong></p><p>时间戳和版本号机制一样，也是在更新提交的时候，将当前数据的时间戳和更新之前取得的时间戳进行比较，如果两者一致则更新成功，否则就是版本冲突。</p><p>你能看到乐观锁就是程序员自己控制数据并发操作的权限，基本是通过给数据行增加一个戳（版本号或者时间戳），从而证明当前拿到的数据是否最新。</p><p><strong>3.</strong> <strong>两种锁的适用场景</strong></p><p>从这两种锁的设计思想中，我们总结一下乐观锁和悲观锁的适用场景：</p><ol><li><p><code>乐观锁</code>适合<code>读操作多</code>的场景，相对来说写的操作比较少。它的优点在于<code>程序实现</code>，<code>不存在死锁</code>问题，不过适用场景也会相对乐观，因为它阻止不了除了程序以外的数据库操作。</p></li><li><p><code>悲观锁</code>适合<code>写操作多</code>的场景，因为写的操作具有<code>排它性</code>。采用悲观锁的方式，可以在数据库层面阻止其他事务对该数据的操作权限，防止<code>读 - 写</code>和<code>写 - 写</code>的冲突。</p></li></ol><h5 id="3-4-按加锁的方式划分：显式锁、隐式锁"><a href="#3-4-按加锁的方式划分：显式锁、隐式锁" class="headerlink" title="3.4 按加锁的方式划分：显式锁、隐式锁"></a><strong>3.4</strong> <strong>按加锁的方式划分：显式锁、隐式锁</strong></h5><p><strong>1.</strong> <strong>隐式锁</strong></p><ul><li><p><strong>情景一：</strong>对于聚簇索引记录来说，有一个<code>trx_id</code>隐藏列，该隐藏列记录着最后改动该记录的<code>事务id</code>。那么如果在当前事务中新插入一条聚簇索引记录后，该记录的<code>trx_id</code>隐藏列代表的的就是当前事务的<code>事务id</code>，如果其他事务此时想对该记录添加<code>S锁</code>或者<code>X锁</code>时，首先会看一下该记录的<code>trx_id</code>隐藏列代表的事务是否是当前的活跃事务，如果是的话，那么就帮助当前事务创建一个<code>X锁</code>（也就是为当前事务创建一个锁结构，<code>is_waiting</code>属性是<code>false</code>），然后自己进入等待状态（也就是为自己也创建一个锁结构，<code>is_waiting</code>属性是<code>true</code>）。</p></li><li><p><strong>情景二：</strong>对于二级索引记录来说，本身并没有<code>trx_id</code>隐藏列，但是在二级索引页面的<code>Page Header</code>部分有一个<code>PAGE_MAX_TRX_ID</code>属性，该属性代表对该页面做改动的最大的<code>事务id</code>，如果<code>PAGE_MAX_TRX_ID</code>属性值小于当前最小的活跃<code>事务id</code>，那么说明对该页面做修改的事务都已经提交了，否则就需要在页面中定位到对应的二级索引记录，然后回表找到它对应的聚簇索引记录，然后再重复<code>情景一</code>的做法。</p></li></ul><p>即：一个事务对新插入的记录可以不显示的加锁（生成一个锁结构），但是由于<code>事务id</code>的存在，相当于加了一个<code>隐式锁</code>。别的事务在对这条记录加<code>S锁</code>或者<code>X锁</code>时，由于<code>隐式锁</code>的存在，会先帮助当前事务生成一个锁结构，然后自己再生成一个锁结构后进入等待状态。隐式锁是一种<code>延迟加锁</code>的机制，从而来减少加锁的数量。</p><p><strong>2.</strong> <strong>显式锁</strong></p><p>通过特定的语句进行加锁，我们一般称之为显示加锁。</p><h5 id="3-5-其它锁之：全局锁"><a href="#3-5-其它锁之：全局锁" class="headerlink" title="3.5 其它锁之：全局锁"></a><strong>3.5</strong> <strong>其它锁之：全局锁</strong></h5><p>全局锁就是对<code>整个数据库实例</code>加锁。当你需要让整个库处于<code>只读状态</code>的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。全局锁的典型使用<code>场景</code>是：做<code>全库逻辑备份</code>。</p><p>全局锁的命令：</p><pre><code class="mysql">Flush tables with read lock</code></pre><h5 id="3-6-其它锁之：死锁"><a href="#3-6-其它锁之：死锁" class="headerlink" title="3.6 其它锁之：死锁"></a><strong>3.6</strong> <strong>其它锁之：死锁</strong></h5><p>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环。</p><p><strong>1. 如何处理死锁</strong></p><p><strong>方式1：</strong>等待，直到超时（innodb_lock_wait_timeout&#x3D;50s）</p><p>即当两个事务互相等待时，当一个事务等待时间超过设置的阈值时，就将其<code>回滚</code>，另外事务继续进行。</p><p><strong>方式2：</strong>使用死锁检测进行死锁处理</p><p>发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务（将持有最少行级排他锁的事务进行回滚），让其他事务得以继续执行。</p><h4 id="4-锁的内存结构"><a href="#4-锁的内存结构" class="headerlink" title="4. 锁的内存结构"></a><strong>4.</strong> <strong>锁的内存结构</strong></h4><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051514736.png" alt="image-20220405151409557"></p><p>结构解析：</p><p><code>1. 锁所在的事务信息</code>：</p><p>不论是<code>表锁</code>还是<code>行锁</code>，都是在事务执行过程中生成的，哪个事务生成了这个 锁结构 ，这里就记录这个事务的信息。</p><p>此<code>锁所在的事务信息</code>在内存结构中只是一个指针，通过指针可以找到内存中关于该事务的更多信息，比方说事务id等。</p><p><code>2. 索引信息</code>：</p><p>对于<code>行锁</code>来说，需要记录一下加锁的记录是属于哪个索引的。这里也是一个指针。</p><p><code>3. 表锁／行锁信息</code>： </p><p><code>表锁结构</code>和<code>行锁结构</code>在这个位置的内容是不同的：</p><ul><li>表锁：记载着是对哪个表加的锁，还有其他的一些信息。</li><li>行锁：记载了三个重要的信息：<ul><li>Space ID ：记录所在表空间。</li><li>Page Number ：记录所在页号。</li><li>n_bits ：对于行锁来说，一条记录就对应着一个比特位，一个页面中包含很多记录，用不同的比特位来区分到底是哪一条记录加了锁。为此在行锁结构的末尾放置了一堆比特位，这个n_bits 属性代表使用了多少比特位。</li></ul></li></ul><blockquote><p>n_bits的值一般都比页面中记录条数多一些。主要是为了之后在页面中插入了新记录后也不至于重新分配锁结构</p></blockquote><p><code>4. type_mode</code>：</p><p>这是一个32位的数，被分成了<code>lock_mode</code>、<code>lock_type</code>和<code>rec_lock_type</code>三个部分，如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051518659.png" alt="image-20220405151829547"></p><ul><li>锁的模式（<code>lock_mode</code>），占用低4位，可选的值如下：<ul><li><code>LOCK_IS</code>（十进制的<code>0</code>）：表示共享意向锁，也就是<code>IS锁</code>。 </li><li><code>LOCK_IX</code>（十进制的<code>1</code>）：表示独占意向锁，也就是<code>IX锁</code>。 </li><li><code>LOCK_S</code>（十进制的<code>2</code>）：表示共享锁，也就是<code>S锁</code>。 </li><li><code>LOCK_X</code>（十进制的<code>3</code>）：表示独占锁，也就是<code>X锁</code>。 </li><li><code>LOCK_AUTO_INC</code>（十进制的<code>4</code>）：表示<code>AUTO-INC锁</code>。</li></ul></li></ul><p>在InnoDB存储引擎中，LOCK_IS，LOCK_IX，LOCK_AUTO_INC都算是表级锁的模式，LOCK_S和 LOCK_X既可以算是表级锁的模式，也可以是行级锁的模式。</p><ul><li>锁的类型（<code>lock_type</code>），占用第5～8位，不过现阶段只有第5位和第6位被使用：<ul><li><code>LOCK_TABLE</code>（十进制的<code>16</code>），也就是当第5个比特位置为1时，表示表级锁。</li><li><code>LOCK_REC</code>（十进制的<code>32</code>），也就是当第6个比特位置为1时，表示行级锁。</li></ul></li><li>行锁的具体类型（<code>rec_lock_type</code>），使用其余的位来表示。只有在 <code>lock_type</code>的值为<code>LOCK_REC</code>时，也就是只有在该锁为行级锁时，才会被细分为更多的类型：<ul><li><code>LOCK_ORDINARY</code>（十进制的<code>0</code>）：表示<code>next-key锁</code>。 </li><li><code>LOCK_GAP</code>（十进制的<code>512</code>）：也就是当第10个比特位置为1时，表示<code>gap锁</code>。 </li><li><code>LOCK_REC_NOT_GAP</code>（十进制的<code>1024</code>）：也就是当第11个比特位置为1时，表示正经<code>记录锁</code>。</li><li><code>LOCK_INSERT_INTENTION</code>（十进制的<code>2048</code>）：也就是当第12个比特位置为1时，表示插入意向锁。其他的类型：还有一些不常用的类型我们就不多说了。</li></ul></li><li><code>is_waiting</code>属性呢？基于内存空间的节省，所以把 is_waiting 属性放到了 type_mode 这个32位的数字中：<ul><li><code>LOCK_WAIT</code>（十进制的<code>256</code>） ：当第9个比特位置为<code>1</code>时，表示<code>is_waiting</code>为<code>true</code>，也就是当前事务尚未获取到锁，处在等待状态；当这个比特位为<code>0</code>时，表示<code>is_waiting</code>为<code>false</code>，也就是当前事务获取锁成功。</li></ul></li></ul><p><code>5. 其他信息</code>：</p><p>为了更好的管理系统运行过程中生成的各种锁结构而设计了各种哈希表和链表。</p><p><code>6. 一堆比特位</code>：</p><p>如果是<code>行锁结构</code>的话，在该结构末尾还放置了一堆比特位，比特位的数量是由上边提到的<code>n_bits</code>属性表示的。InnoDB数据页中的每条记录在<code>记录头信息</code>中都包含一个 heap_no 属性，伪记录<code>Infimum</code>的<code>heap_no</code>值为<code>0</code>，<code>Supremum</code>的<code>heap_no</code>值为<code>1</code>，之后每插入一条记录，<code>heap_no</code>值就增1。<code>锁结构</code>最后的一堆比特位就对应着一个页面中的记录，一个比特位映射一个<code>heap_no</code>，即一个比特位映射到页内的一条记录。</p><h4 id="5-锁监控"><a href="#5-锁监控" class="headerlink" title="5. 锁监控"></a><strong>5.</strong> <strong>锁监控</strong></h4><pre><code class="mysql">mysql&gt; show status like &#39;innodb_row_lock%&#39;;</code></pre><ul><li>Innodb_row_lock_current_waits：当前正在等待锁定的数量；</li><li><code>Innodb_row_lock_time</code>：从系统启动到现在锁定总时间长度；（等待总时长）</li><li><code>Innodb_row_lock_time_avg</code>：每次等待所花平均时间；（等待平均时长）</li><li>Innodb_row_lock_time_max：从系统启动到现在等待最常的一次所花的时间；</li><li><code>Innodb_row_lock_waits</code>：系统启动后到现在总共等待的次数；（等待总次数）</li></ul><p><strong>其他监控方法：</strong></p><p>MySQL把事务和锁的信息记录在了<code>information_schema</code>库中，涉及到的三张表分别是<code>INNODB_TRX</code>、<code>INNODB_LOCKS</code>和<code>INNODB_LOCK_WAITS</code>。 </p><p><code>MySQL5.7及之前</code>，可以通过information_schema.INNODB_LOCKS查看事务的锁情况，但只能看到阻塞事务的锁；如果事务并未被阻塞，则在该表中看不到该事务的锁情况。</p><p>MySQL8.0删除了information_schema.INNODB_LOCKS，添加了<code>performance_schema.data_locks</code>，可以通过performance_schema.data_locks查看事务的锁情况，和MySQL5.7及之前不同，performance_schema.data_locks不但可以看到阻塞该事务的锁，还可以看到该事务所持有的锁。</p><p>同时，information_schema.INNODB_LOCK_WAITS也被<code>performance_schema.data_lock_waits</code>所代替。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/07/14/day06/"/>
      <url>/2023/07/14/day06/</url>
      
        <content type="html"><![CDATA[<h1 id="day06"><a href="#day06" class="headerlink" title="day06"></a>day06</h1><h2 id="一、声明式导航-导航链接"><a href="#一、声明式导航-导航链接" class="headerlink" title="一、声明式导航-导航链接"></a>一、声明式导航-导航链接</h2><h3 id="1-需求"><a href="#1-需求" class="headerlink" title="1.需求"></a>1.需求</h3><p>实现导航高亮效果</p><p><img src="/assets/1682492044744.png" alt="68249204474"></p><p>如果使用a标签进行跳转的话，需要给当前跳转的导航加样式，同时要移除上一个a标签的样式，太麻烦！！！</p><h3 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2.解决方案"></a>2.解决方案</h3><p>vue-router 提供了一个全局组件 router-link (取代 a 标签)</p><ul><li><strong>能跳转</strong>，配置 to 属性指定路径(<strong>必须</strong>) 。本质还是 a 标签 ，<strong>to 无需 #</strong></li><li><strong>能高亮</strong>，默认就会提供<strong>高亮类名</strong>，可以直接设置高亮样式</li></ul><p>语法： <router-link to="path的值">发现音乐</router-link></p><pre><code class="vue">  &lt;div&gt;    &lt;div class=&quot;footer_wrap&quot;&gt;      &lt;router-link to=&quot;/find&quot;&gt;发现音乐&lt;/router-link&gt;      &lt;router-link to=&quot;/my&quot;&gt;我的音乐&lt;/router-link&gt;      &lt;router-link to=&quot;/friend&quot;&gt;朋友&lt;/router-link&gt;    &lt;/div&gt;    &lt;div class=&quot;top&quot;&gt;      &lt;!-- 路由出口 → 匹配的组件所展示的位置 --&gt;      &lt;router-view&gt;&lt;/router-view&gt;    &lt;/div&gt;  &lt;/div&gt;</code></pre><h3 id="3-通过router-link自带的两个样式进行高亮"><a href="#3-通过router-link自带的两个样式进行高亮" class="headerlink" title="3.通过router-link自带的两个样式进行高亮"></a>3.通过router-link自带的两个样式进行高亮</h3><p>使用router-link跳转后，我们发现。当前点击的链接默认加了两个class的值 <code>router-link-exact-active</code>和<code>router-link-active</code></p><p>我们可以给任意一个class属性添加高亮样式即可实现功能</p><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h3><ul><li>router-link是什么？</li><li>router-link怎么用？</li><li>router-link的好处是什么？</li></ul><h2 id="二、声明式导航-两个类名"><a href="#二、声明式导航-两个类名" class="headerlink" title="二、声明式导航-两个类名"></a>二、声明式导航-两个类名</h2><p>当我们使用<router-link></router-link>跳转时，自动给当前导航加了<strong>两个类名</strong></p><p><img src="/assets/1682493121052.png" alt="68249312105"></p><h3 id="1-router-link-active"><a href="#1-router-link-active" class="headerlink" title="1.router-link-active"></a>1.router-link-active</h3><p><strong>模糊匹配（用的多）</strong></p><p>to&#x3D;”&#x2F;my”  可以匹配 &#x2F;my    &#x2F;my&#x2F;a    &#x2F;my&#x2F;b    ….  </p><p>只要是以&#x2F;my开头的路径 都可以和 to&#x3D;”&#x2F;my”匹配到</p><h3 id="2-router-link-exact-active"><a href="#2-router-link-exact-active" class="headerlink" title="2.router-link-exact-active"></a>2.router-link-exact-active</h3><p><strong>精确匹配</strong></p><p>to&#x3D;”&#x2F;my” 仅可以匹配  &#x2F;my</p><h3 id="3-在地址栏中输入二级路由查看类名的添加"><a href="#3-在地址栏中输入二级路由查看类名的添加" class="headerlink" title="3.在地址栏中输入二级路由查看类名的添加"></a>3.在地址栏中输入二级路由查看类名的添加</h3><h3 id="4-总结-1"><a href="#4-总结-1" class="headerlink" title="4.总结"></a>4.总结</h3><ul><li>router-link 会自动给当前导航添加两个类名，有什么区别呢？</li></ul><h2 id="三、声明式导航-自定义类名（了解）"><a href="#三、声明式导航-自定义类名（了解）" class="headerlink" title="三、声明式导航-自定义类名（了解）"></a>三、声明式导航-自定义类名（了解）</h2><h3 id="1-问题"><a href="#1-问题" class="headerlink" title="1.问题"></a>1.问题</h3><p>router-link的<strong>两个高亮类名 太长了</strong>，我们希望能定制怎么办</p><p><img src="/assets/1682493610911.png" alt="68249361091"></p><h3 id="2-解决方案-1"><a href="#2-解决方案-1" class="headerlink" title="2.解决方案"></a>2.解决方案</h3><p>我们可以在创建路由对象时，额外配置两个配置项即可。 <code>linkActiveClass</code>和<code>linkExactActiveClass</code></p><pre><code class="js">const router = new VueRouter(&#123;  routes: [...],  linkActiveClass: &quot;类名1&quot;,  linkExactActiveClass: &quot;类名2&quot;&#125;)</code></pre><p><img src="/assets/1682493729456.png" alt="68249372945"></p><h3 id="3-代码演示"><a href="#3-代码演示" class="headerlink" title="3.代码演示"></a>3.代码演示</h3><pre><code class="js">// 创建了一个路由对象const router = new VueRouter(&#123;  routes: [    ...  ],   linkActiveClass: &#39;active&#39;, // 配置模糊匹配的类名  linkExactActiveClass: &#39;exact-active&#39; // 配置精确匹配的类名&#125;)</code></pre><h3 id="4-总结-2"><a href="#4-总结-2" class="headerlink" title="4.总结"></a>4.总结</h3><p>如何自定义router-link的两个<strong>高亮类名</strong></p><h2 id="四、声明式导航-查询参数传参"><a href="#四、声明式导航-查询参数传参" class="headerlink" title="四、声明式导航-查询参数传参"></a>四、声明式导航-查询参数传参</h2><h3 id="1-目标"><a href="#1-目标" class="headerlink" title="1.目标"></a>1.目标</h3><p>在跳转路由时，进行传参</p><p><img src="/assets/1682494423923.png" alt="68249442392"></p><p>比如：现在我们在搜索页点击了热门搜索链接，跳转到详情页，<strong>需要把点击的内容带到详情页</strong>，改怎么办呢？</p><h3 id="2-跳转传参"><a href="#2-跳转传参" class="headerlink" title="2.跳转传参"></a>2.跳转传参</h3><p>我们可以通过两种方式，在跳转的时候把所需要的参数传到其他页面中</p><ul><li>查询参数传参</li><li>动态路由传参</li></ul><h3 id="3-查询参数传参"><a href="#3-查询参数传参" class="headerlink" title="3.查询参数传参"></a>3.查询参数传参</h3><ul><li><p>如何传参？</p><p><router-link to="/path?参数名=值"></router-link></p></li><li><p>如何接受参数</p><p>固定用法：$router.query.参数名</p></li></ul><h3 id="4-代码演示"><a href="#4-代码演示" class="headerlink" title="4.代码演示"></a>4.代码演示</h3><p>App.vue</p><pre><code class="vue">&lt;template&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;div class=&quot;link&quot;&gt;      &lt;router-link to=&quot;/home&quot;&gt;首页&lt;/router-link&gt;      &lt;router-link to=&quot;/search&quot;&gt;搜索页&lt;/router-link&gt;    &lt;/div&gt;    &lt;router-view&gt;&lt;/router-view&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;&#125;;&lt;/script&gt;&lt;style scoped&gt;.link &#123;  height: 50px;  line-height: 50px;  background-color: #495150;  display: flex;  margin: -8px -8px 0 -8px;  margin-bottom: 50px;&#125;.link a &#123;  display: block;  text-decoration: none;  background-color: #ad2a26;  width: 100px;  text-align: center;  margin-right: 5px;  color: #fff;  border-radius: 5px;&#125;&lt;/style&gt;</code></pre><p>Home.vue</p><pre><code class="vue">&lt;template&gt;  &lt;div class=&quot;home&quot;&gt;    &lt;div class=&quot;logo-box&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;search-box&quot;&gt;      &lt;input type=&quot;text&quot;&gt;      &lt;button&gt;搜索一下&lt;/button&gt;    &lt;/div&gt;    &lt;div class=&quot;hot-link&quot;&gt;      热门搜索：      &lt;router-link to=&quot;&quot;&gt;黑马程序员&lt;/router-link&gt;      &lt;router-link to=&quot;&quot;&gt;前端培训&lt;/router-link&gt;      &lt;router-link to=&quot;&quot;&gt;如何成为前端大牛&lt;/router-link&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;FindMusic&#39;&#125;&lt;/script&gt;&lt;style&gt;.logo-box &#123;  height: 150px;  background: url(&#39;@/assets/logo.jpeg&#39;) no-repeat center;&#125;.search-box &#123;  display: flex;  justify-content: center;&#125;.search-box input &#123;  width: 400px;  height: 30px;  line-height: 30px;  border: 2px solid #c4c7ce;  border-radius: 4px 0 0 4px;  outline: none;&#125;.search-box input:focus &#123;  border: 2px solid #ad2a26;&#125;.search-box button &#123;  width: 100px;  height: 36px;  border: none;  background-color: #ad2a26;  color: #fff;  position: relative;  left: -2px;  border-radius: 0 4px 4px 0;&#125;.hot-link &#123;  width: 508px;  height: 60px;  line-height: 60px;  margin: 0 auto;&#125;.hot-link a &#123;  margin: 0 5px;&#125;&lt;/style&gt;</code></pre><p>Search.vue</p><pre><code class="vue">&lt;template&gt;  &lt;div class=&quot;search&quot;&gt;    &lt;p&gt;搜索关键字: 黑马程序员&lt;/p&gt;    &lt;p&gt;搜索结果: &lt;/p&gt;    &lt;ul&gt;      &lt;li&gt;.............&lt;/li&gt;      &lt;li&gt;.............&lt;/li&gt;      &lt;li&gt;.............&lt;/li&gt;      &lt;li&gt;.............&lt;/li&gt;    &lt;/ul&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;MyFriend&#39;,  created () &#123;    // 在created中，获取路由参数  &#125;&#125;&lt;/script&gt;&lt;style&gt;.search &#123;  width: 400px;  height: 240px;  padding: 0 20px;  margin: 0 auto;  border: 2px solid #c4c7ce;  border-radius: 5px;&#125;&lt;/style&gt;</code></pre><p>router&#x2F;index.js</p><pre><code class="js">import Home from &#39;@/views/Home&#39;import Search from &#39;@/views/Search&#39;import Vue from &#39;vue&#39;import VueRouter from &#39;vue-router&#39;Vue.use(VueRouter) // VueRouter插件初始化// 创建了一个路由对象const router = new VueRouter(&#123;  routes: [    &#123; path: &#39;/home&#39;, component: Home &#125;,    &#123; path: &#39;/search&#39;, component: Search &#125;  ]&#125;)export default router</code></pre><p>main.js</p><pre><code>...import router from &#39;./router/index&#39;...new Vue(&#123;  render: h =&gt; h(App),  router&#125;).$mount(&#39;#app&#39;)</code></pre><h2 id="五、声明式导航-动态路由传参"><a href="#五、声明式导航-动态路由传参" class="headerlink" title="五、声明式导航-动态路由传参"></a>五、声明式导航-动态路由传参</h2><h3 id="1-动态路由传参方式"><a href="#1-动态路由传参方式" class="headerlink" title="1.动态路由传参方式"></a>1.动态路由传参方式</h3><ul><li><p>配置动态路由</p><blockquote><p>动态路由后面的参数可以随便起名，但要有语义</p></blockquote><pre><code class="js">const router = new VueRouter(&#123;  routes: [    ...,    &#123;       path: &#39;/search/:words&#39;,       component: Search     &#125;  ]&#125;)</code></pre></li><li><p>配置导航链接</p><p>to&#x3D;”&#x2F;path&#x2F;参数值”</p></li><li><p>对应页面组件<strong>接受参数</strong></p><p>$route.<strong>params</strong>.参数名</p><blockquote><p>params后面的参数名要和动态路由配置的参数保持一致</p></blockquote></li></ul><h3 id="2-查询参数传参-VS-动态路由传参"><a href="#2-查询参数传参-VS-动态路由传参" class="headerlink" title="2.查询参数传参 VS 动态路由传参"></a>2.查询参数传参 VS 动态路由传参</h3><ol><li><p>查询参数传参  (比较适合传<strong>多个参数</strong>) </p></li><li><p>跳转：to&#x3D;”&#x2F;path?参数名&#x3D;值&amp;参数名2&#x3D;值”</p></li><li><p>获取：$route.query.参数名</p></li><li><p>动态路由传参 (<strong>优雅简洁</strong>，传单个参数比较方便)</p><ol><li>配置动态路由：path: “&#x2F;path&#x2F;:参数名” </li><li>跳转：to&#x3D;”&#x2F;path&#x2F;参数值”</li><li>获取：$route.params.参数名</li></ol><p>注意：动态路由也可以传多个参数，但一般只传一个</p></li></ol><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h3><p>声明式导航跳转时, 有几种方式传值给路由页面？</p><ul><li>查询参数传参（多个参数）</li><li>动态路由传参（一个参数，优雅简洁）</li></ul><h2 id="六、动态路由参数的可选符-了解"><a href="#六、动态路由参数的可选符-了解" class="headerlink" title="六、动态路由参数的可选符(了解)"></a>六、动态路由参数的可选符(了解)</h2><h3 id="1-问题-1"><a href="#1-问题-1" class="headerlink" title="1.问题"></a>1.问题</h3><p>配了路由 path:”&#x2F;search&#x2F;:words”  为什么按下面步骤操作，会未匹配到组件，显示空白？</p><p><img src="/assets/1682497238305.png" alt="68249723830"></p><h3 id="2-原因"><a href="#2-原因" class="headerlink" title="2.原因"></a>2.原因</h3><p>&#x2F;search&#x2F;:words  表示，<strong>必须要传参数</strong>。如果不传参数，也希望匹配，可以加个可选符”？”</p><pre><code class="js">const router = new VueRouter(&#123;  routes: [     ...    &#123; path: &#39;/search/:words?&#39;, component: Search &#125;  ]&#125;)</code></pre><h2 id="七、Vue路由-重定向"><a href="#七、Vue路由-重定向" class="headerlink" title="七、Vue路由-重定向"></a>七、Vue路由-重定向</h2><h3 id="1-问题-2"><a href="#1-问题-2" class="headerlink" title="1.问题"></a>1.问题</h3><p>网页打开时， url 默认是 &#x2F; 路径，未匹配到组件时，会出现空白</p><p><img src="/assets/1682497872821.png" alt="68249787282"></p><h3 id="2-解决方案-2"><a href="#2-解决方案-2" class="headerlink" title="2.解决方案"></a>2.解决方案</h3><p><strong>重定向</strong> → 匹配 &#x2F; 后, 强制跳转 &#x2F;home 路径</p><h3 id="3-语法"><a href="#3-语法" class="headerlink" title="3.语法"></a>3.语法</h3><pre><code class="js">&#123; path: 匹配路径, redirect: 重定向到的路径 &#125;,比如：&#123; path:&#39;/&#39; ,redirect:&#39;/home&#39; &#125;</code></pre><h3 id="4-代码演示-1"><a href="#4-代码演示-1" class="headerlink" title="4.代码演示"></a>4.代码演示</h3><pre><code>const router = new VueRouter(&#123;  routes: [    &#123; path: &#39;/&#39;, redirect: &#39;/home&#39;&#125;,  ...  ]&#125;)</code></pre><h2 id="八、Vue路由-404"><a href="#八、Vue路由-404" class="headerlink" title="八、Vue路由-404"></a>八、Vue路由-404</h2><h3 id="1-作用"><a href="#1-作用" class="headerlink" title="1.作用"></a>1.作用</h3><p>当路径找不到匹配时，给个提示页面</p><h3 id="2-位置"><a href="#2-位置" class="headerlink" title="2.位置"></a>2.位置</h3><p>404的路由，虽然配置在任何一个位置都可以，但一般都<strong>配置在其他路由规则的最后面</strong></p><h3 id="3-语法-1"><a href="#3-语法-1" class="headerlink" title="3.语法"></a>3.语法</h3><p>path: “*”   (任意路径) – 前面不匹配就命中最后这个</p><pre><code class="js">import NotFind from &#39;@/views/NotFind&#39;const router = new VueRouter(&#123;  routes: [    ...    &#123; path: &#39;*&#39;, component: NotFind &#125; //最后一个  ]&#125;)</code></pre><h3 id="4-代码示例"><a href="#4-代码示例" class="headerlink" title="4.代码示例"></a>4.代码示例</h3><p>NotFound.vue</p><pre><code class="vue">&lt;template&gt;  &lt;div&gt;    &lt;h1&gt;404 Not Found&lt;/h1&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt;</code></pre><p>router&#x2F;index.js</p><pre><code class="js">...import NotFound from &#39;@/views/NotFound&#39;...// 创建了一个路由对象const router = new VueRouter(&#123;  routes: [     ...    &#123; path: &#39;*&#39;, component: NotFound &#125;  ]&#125;)export default router</code></pre><h2 id="九、Vue路由-模式设置"><a href="#九、Vue路由-模式设置" class="headerlink" title="九、Vue路由-模式设置"></a>九、Vue路由-模式设置</h2><h3 id="1-问题-3"><a href="#1-问题-3" class="headerlink" title="1.问题"></a>1.问题</h3><p>路由的路径看起来不自然, 有#，能否切成真正路径形式?</p><ul><li>hash路由(默认)        例如:  <a href="http://localhost:8080/#/home">http://localhost:8080/#/home</a></li><li>history路由(常用)     例如: <a href="http://localhost:8080/home">http://localhost:8080/home</a>   (以后上线需要服务器端支持，开发环境webpack给规避掉了history模式的问题)</li></ul><h3 id="2-语法"><a href="#2-语法" class="headerlink" title="2.语法"></a>2.语法</h3><pre><code class="js">const router = new VueRouter(&#123;    mode:&#39;histroy&#39;, //默认是hash    routes:[]&#125;)</code></pre><h2 id="十、编程式导航-两种路由跳转方式"><a href="#十、编程式导航-两种路由跳转方式" class="headerlink" title="十、编程式导航-两种路由跳转方式"></a>十、编程式导航-两种路由跳转方式</h2><h3 id="1-问题-4"><a href="#1-问题-4" class="headerlink" title="1.问题"></a>1.问题</h3><p>点击按钮跳转如何实现？</p><p><img src="/assets/1682500481059.png" alt="68250048105"></p><h3 id="2-方案"><a href="#2-方案" class="headerlink" title="2.方案"></a>2.方案</h3><p>编程式导航：用JS代码来进行跳转</p><h3 id="3-语法-2"><a href="#3-语法-2" class="headerlink" title="3.语法"></a>3.语法</h3><p>两种语法：</p><ul><li>path 路径跳转 （简易方便）</li><li>name 命名路由跳转 (适合 path 路径长的场景)</li></ul><h3 id="4-path路径跳转语法"><a href="#4-path路径跳转语法" class="headerlink" title="4.path路径跳转语法"></a>4.path路径跳转语法</h3><p>特点：简易方便</p><pre><code class="js">//简单写法this.$router.push(&#39;路由路径&#39;)//完整写法this.$router.push(&#123;  path: &#39;路由路径&#39;&#125;)</code></pre><h3 id="5-代码演示-path跳转方式"><a href="#5-代码演示-path跳转方式" class="headerlink" title="5.代码演示 path跳转方式"></a>5.代码演示 path跳转方式</h3><h3 id="6-name命名路由跳转"><a href="#6-name命名路由跳转" class="headerlink" title="6.name命名路由跳转"></a>6.name命名路由跳转</h3><p>特点：适合 path 路径长的场景</p><p>语法：</p><ul><li><p>路由规则，必须配置name配置项</p><pre><code class="js">&#123; name: &#39;路由名&#39;, path: &#39;/path/xxx&#39;, component: XXX &#125;,</code></pre></li><li><p>通过name来进行跳转</p><pre><code class="js">this.$router.push(&#123;  name: &#39;路由名&#39;&#125;)</code></pre></li></ul><h3 id="7-代码演示通过name命名路由跳转"><a href="#7-代码演示通过name命名路由跳转" class="headerlink" title="7.代码演示通过name命名路由跳转"></a>7.代码演示通过name命名路由跳转</h3><h3 id="8-总结"><a href="#8-总结" class="headerlink" title="8.总结"></a>8.总结</h3><p>编程式导航有几种跳转方式？</p><h2 id="十一、编程式导航-path路径跳转传参"><a href="#十一、编程式导航-path路径跳转传参" class="headerlink" title="十一、编程式导航-path路径跳转传参"></a>十一、编程式导航-path路径跳转传参</h2><h3 id="1-问题-5"><a href="#1-问题-5" class="headerlink" title="1.问题"></a>1.问题</h3><p>点击搜索按钮，跳转需要把文本框中输入的内容传到下一个页面如何实现？</p><p><img src="/assets/1682502720585.png" alt="68250272058"></p><h3 id="2-两种传参方式"><a href="#2-两种传参方式" class="headerlink" title="2.两种传参方式"></a>2.两种传参方式</h3><p>1.查询参数 </p><p>2.动态路由传参</p><h3 id="3-传参"><a href="#3-传参" class="headerlink" title="3.传参"></a>3.传参</h3><p>两种跳转方式，对于两种传参方式都支持：</p><p>① path 路径跳转传参</p><p>② name 命名路由跳转传参</p><h3 id="4-path路径跳转传参（query传参）"><a href="#4-path路径跳转传参（query传参）" class="headerlink" title="4.path路径跳转传参（query传参）"></a>4.path路径跳转传参（query传参）</h3><pre><code class="js">//简单写法this.$router.push(&#39;/路径?参数名1=参数值1&amp;参数2=参数值2&#39;)//完整写法this.$router.push(&#123;  path: &#39;/路径&#39;,  query: &#123;    参数名1: &#39;参数值1&#39;,    参数名2: &#39;参数值2&#39;  &#125;&#125;)</code></pre><p>接受参数的方式依然是：$route.query.参数名</p><h3 id="5-path路径跳转传参（动态路由传参）"><a href="#5-path路径跳转传参（动态路由传参）" class="headerlink" title="5.path路径跳转传参（动态路由传参）"></a>5.path路径跳转传参（动态路由传参）</h3><pre><code>//简单写法this.$router.push(&#39;/路径/参数值&#39;)//完整写法this.$router.push(&#123;  path: &#39;/路径/参数值&#39;&#125;)</code></pre><p>接受参数的方式依然是：$route.params.参数值</p><p><strong>注意：</strong>path不能配合params使用</p><h2 id="十二、编程式导航-name命名路由传参"><a href="#十二、编程式导航-name命名路由传参" class="headerlink" title="十二、编程式导航-name命名路由传参"></a>十二、编程式导航-name命名路由传参</h2><h3 id="1-name-命名路由跳转传参-query传参"><a href="#1-name-命名路由跳转传参-query传参" class="headerlink" title="1.name 命名路由跳转传参 (query传参)"></a>1.name 命名路由跳转传参 (query传参)</h3><pre><code class="js">this.$router.push(&#123;  name: &#39;路由名字&#39;,  query: &#123;    参数名1: &#39;参数值1&#39;,    参数名2: &#39;参数值2&#39;  &#125;&#125;)</code></pre><h3 id="2-name-命名路由跳转传参-动态路由传参"><a href="#2-name-命名路由跳转传参-动态路由传参" class="headerlink" title="2.name 命名路由跳转传参 (动态路由传参)"></a>2.name 命名路由跳转传参 (动态路由传参)</h3><pre><code class="js">this.$router.push(&#123;  name: &#39;路由名字&#39;,  params: &#123;    参数名: &#39;参数值&#39;,  &#125;&#125;)</code></pre><h3 id="3-总结-1"><a href="#3-总结-1" class="headerlink" title="3.总结"></a>3.总结</h3><p>编程式导航，如何跳转传参？</p><p>1.path路径跳转</p><ul><li><p>query传参</p><pre><code class="js">this.$router.push(&#39;/路径?参数名1=参数值1&amp;参数2=参数值2&#39;)this.$router.push(&#123;  path: &#39;/路径&#39;,  query: &#123;    参数名1: &#39;参数值1&#39;,    参数名2: &#39;参数值2&#39;  &#125;&#125;)</code></pre></li><li><p>动态路由传参</p><pre><code class="js">this.$router.push(&#39;/路径/参数值&#39;)this.$router.push(&#123;  path: &#39;/路径/参数值&#39;&#125;)</code></pre></li></ul><p>2.name命名路由跳转</p><ul><li><p>query传参</p><pre><code class="js">this.$router.push(&#123;  name: &#39;路由名字&#39;,  query: &#123;    参数名1: &#39;参数值1&#39;,    参数名2: &#39;参数值2&#39;  &#125;&#125;)</code></pre></li><li><p>动态路由传参 (需要配动态路由)</p><pre><code class="js">this.$router.push(&#123;  name: &#39;路由名字&#39;,  params: &#123;    参数名: &#39;参数值&#39;,  &#125;&#125;)</code></pre></li></ul><h2 id="十三、面经基础版-案例效果分析"><a href="#十三、面经基础版-案例效果分析" class="headerlink" title="十三、面经基础版-案例效果分析"></a>十三、面经基础版-案例效果分析</h2><h3 id="1-面经效果演示"><a href="#1-面经效果演示" class="headerlink" title="1.面经效果演示"></a>1.面经效果演示</h3><h3 id="2-功能分析"><a href="#2-功能分析" class="headerlink" title="2.功能分析"></a>2.功能分析</h3><ul><li>通过演示效果发现，主要的功能页面有两个，一个是<strong>列表页</strong>，一个是<strong>详情页</strong>，并且在列表页点击时可以跳转到详情页</li><li>底部导航可以来回切换，并且切换时，只有上面的主题内容在动态渲染</li></ul><p><img src="/assets/1682559784643.png" alt="68255978464"></p><h3 id="3-实现思路分析：配置路由-功能实现"><a href="#3-实现思路分析：配置路由-功能实现" class="headerlink" title="3.实现思路分析：配置路由+功能实现"></a>3.实现思路分析：配置路由+功能实现</h3><p>1.配置路由</p><ul><li>首页和面经详情页，两个一级路由</li><li>首页内嵌套4个可切换的页面（嵌套二级路由）</li></ul><p>2.实现功能</p><ul><li>首页请求渲染</li><li><strong>跳转传参</strong> 到 详情页，详情页动态渲染</li><li>组件缓存，性能优化</li></ul><p><img src="/assets/1682560255356.png" alt="68256025535"></p><h2 id="十四、面经基础版-一级路由配置"><a href="#十四、面经基础版-一级路由配置" class="headerlink" title="十四、面经基础版-一级路由配置"></a>十四、面经基础版-一级路由配置</h2><p>1.把文档中准备的素材拷贝到项目中</p><p>2.针对router&#x2F;index.js文件 进行一级路由配置</p><pre><code class="js">...import Layout from &#39;@/views/Layout.vue&#39;import ArticleDetail from &#39;@/views/ArticleDetail.vue&#39;...const router = new VueRouter(&#123;  routes: [    &#123;      path: &#39;/&#39;,      component: Layout    &#125;,    &#123;      path: &#39;/detail&#39;,      component: ArticleDetail    &#125;  ]&#125;)</code></pre><h2 id="十五、面经基础版-二级路由配置"><a href="#十五、面经基础版-二级路由配置" class="headerlink" title="十五、面经基础版-二级路由配置"></a>十五、面经基础版-二级路由配置</h2><p>二级路由也叫嵌套路由，当然也可以嵌套三级、四级…</p><h3 id="1-使用场景"><a href="#1-使用场景" class="headerlink" title="1.使用场景"></a>1.使用场景</h3><p>当在页面中点击链接跳转，只是部分内容切换时，我们可以使用嵌套路由</p><h3 id="2-语法-1"><a href="#2-语法-1" class="headerlink" title="2.语法"></a>2.语法</h3><ul><li>在一级路由下，配置children属性即可</li><li>配置二级路由的出口</li></ul><p> 1.在一级路由下，配置children属性</p><p> <strong>注意</strong>:一级的路由path 需要加 <code>/</code>   二级路由的path不需要加 <code>/</code></p><pre><code class="js">const router = new VueRouter(&#123;  routes: [    &#123;      path: &#39;/&#39;,      component: Layout,      children:[        //children中的配置项 跟一级路由中的配置项一模一样         &#123;path:&#39;xxxx&#39;,component:xxxx.vue&#125;,        &#123;path:&#39;xxxx&#39;,component:xxxx.vue&#125;,      ]    &#125;  ]&#125;)</code></pre><p>技巧：二级路由应该配置到哪个一级路由下呢？</p><p><strong>这些二级路由对应的组件渲染到哪个一级路由下，children就配置到哪个路由下边</strong></p><p>2.配置二级路由的出口 <router-view></router-view></p><p><strong>注意：</strong> 配置了嵌套路由，一定配置对应的路由出口，否则不会渲染出对应的组件</p><p>Layout.vue</p><pre><code class="vue">&lt;template&gt;  &lt;div class=&quot;h5-wrapper&quot;&gt;    &lt;div class=&quot;content&quot;&gt;      &lt;router-view&gt;&lt;/router-view&gt;    &lt;/div&gt;  ....  &lt;/div&gt;&lt;/template&gt;</code></pre><h3 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3.代码实现"></a>3.代码实现</h3><p>router&#x2F;index.js</p><pre><code class="js">...import Article from &#39;@/views/Article.vue&#39;import Collect from &#39;@/views/Collect.vue&#39;import Like from &#39;@/views/Like.vue&#39;import User from &#39;@/views/User.vue&#39;...const router = new VueRouter(&#123;  routes: [    &#123;      path: &#39;/&#39;,      component: Layout,      redirect: &#39;/article&#39;,      children:[        &#123;          path:&#39;/article&#39;,          component:Article        &#125;,        &#123;          path:&#39;/collect&#39;,          component:Collect        &#125;,        &#123;          path:&#39;/like&#39;,          component:Like        &#125;,        &#123;          path:&#39;/user&#39;,          component:User        &#125;      ]    &#125;,    ....  ]&#125;)</code></pre><p>Layout.vue</p><pre><code class="vue">&lt;template&gt;  &lt;div class=&quot;h5-wrapper&quot;&gt;    &lt;div class=&quot;content&quot;&gt;      &lt;!-- 内容部分 --&gt;      &lt;router-view&gt;&lt;/router-view&gt;    &lt;/div&gt;    &lt;nav class=&quot;tabbar&quot;&gt;      &lt;a href=&quot;#/article&quot;&gt;面经&lt;/a&gt;      &lt;a href=&quot;#/collect&quot;&gt;收藏&lt;/a&gt;      &lt;a href=&quot;#/like&quot;&gt;喜欢&lt;/a&gt;      &lt;a href=&quot;#/user&quot;&gt;我的&lt;/a&gt;    &lt;/nav&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><h2 id="十六、面经基础版-二级导航高亮"><a href="#十六、面经基础版-二级导航高亮" class="headerlink" title="十六、面经基础版-二级导航高亮"></a>十六、面经基础版-二级导航高亮</h2><h3 id="1-实现思路"><a href="#1-实现思路" class="headerlink" title="1.实现思路"></a>1.实现思路</h3><ul><li>将a标签替换成 <router-link></router-link>组件，配置to属性，不用加 #</li><li>结合高亮类名实现高亮效果 (推荐模糊匹配：router-link-active)</li></ul><h3 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2.代码实现"></a>2.代码实现</h3><p>Layout.vue</p><pre><code class="vue">....    &lt;nav class=&quot;tabbar&quot;&gt;      &lt;router-link to=&quot;/article&quot;&gt;面经&lt;/router-link&gt;      &lt;router-link to=&quot;/collect&quot;&gt;收藏&lt;/router-link&gt;      &lt;router-link to=&quot;/like&quot;&gt;喜欢&lt;/router-link&gt;      &lt;router-link to=&quot;/user&quot;&gt;我的&lt;/router-link&gt;    &lt;/nav&gt;&lt;style&gt;   a.router-link-active &#123;      color: orange;    &#125;&lt;/style&gt;</code></pre><h2 id="十七、面经基础版-首页请求渲染"><a href="#十七、面经基础版-首页请求渲染" class="headerlink" title="十七、面经基础版-首页请求渲染"></a>十七、面经基础版-首页请求渲染</h2><h3 id="1-步骤分析"><a href="#1-步骤分析" class="headerlink" title="1.步骤分析"></a>1.步骤分析</h3><p>1.安装axios </p><p>2.看接口文档，确认请求方式，请求地址，请求参数</p><p>3.created中发送请求，获取数据，存储到data中</p><p>4.页面动态渲染</p><h3 id="2-代码实现-1"><a href="#2-代码实现-1" class="headerlink" title="2.代码实现"></a>2.代码实现</h3><p>1.安装axios</p><p><code>yarn add axios </code>  <code>npm i axios</code></p><p>2.接口文档</p><pre><code class="vue">请求地址: https://mock.boxuegu.com/mock/3083/articles请求方式: get</code></pre><p>3.created中发送请求，获取数据，存储到data中</p><pre><code class="vue"> data() &#123;    return &#123;      articelList: [],    &#125;  &#125;,  async created() &#123;    const &#123;  data: &#123; result: &#123; rows &#125; &#125;&#125; = await axios.get(&#39;https://mock.boxuegu.com/mock/3083/articles&#39;)    this.articelList = rows  &#125;,</code></pre><p>4.页面动态渲染</p><pre><code class="vue">&lt;template&gt;  &lt;div class=&quot;article-page&quot;&gt;    &lt;div class=&quot;article-item&quot; v-for=&quot;item in articelList&quot; :key=&quot;item.id&quot;&gt;      &lt;div class=&quot;head&quot;&gt;        &lt;img :src=&quot;item.creatorAvatar&quot; alt=&quot;&quot; /&gt;        &lt;div class=&quot;con&quot;&gt;          &lt;p class=&quot;title&quot;&gt;&#123;&#123; item.stem &#125;&#125;&lt;/p&gt;          &lt;p class=&quot;other&quot;&gt;&#123;&#123; item.creatorName &#125;&#125; | &#123;&#123; item.createdAt &#125;&#125;&lt;/p&gt;        &lt;/div&gt;      &lt;/div&gt;      &lt;div class=&quot;body&quot;&gt;        &#123;&#123;item.content&#125;&#125;      &lt;/div&gt;      &lt;div class=&quot;foot&quot;&gt;点赞 &#123;&#123;item.likeCount&#125;&#125; | 浏览 &#123;&#123;item.views&#125;&#125;&lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><h2 id="十八、面经基础版-查询参数传参"><a href="#十八、面经基础版-查询参数传参" class="headerlink" title="十八、面经基础版-查询参数传参"></a>十八、面经基础版-查询参数传参</h2><h3 id="1-说明"><a href="#1-说明" class="headerlink" title="1.说明"></a>1.说明</h3><p>跳转详情页需要把当前点击的文章id传给详情页，获取数据</p><ul><li>查询参数传参  this.$router.push(‘&#x2F;detail?参数1&#x3D;参数值&amp;参数2&#x3D;参数值’) </li><li>动态路由传参  先改造路由 在传参  this.$router.push(‘&#x2F;detail&#x2F;参数值’)</li></ul><h3 id="2-查询参数传参实现"><a href="#2-查询参数传参实现" class="headerlink" title="2.查询参数传参实现"></a>2.查询参数传参实现</h3><p>Article.vue</p><pre><code class="vue">&lt;template&gt;  &lt;div class=&quot;article-page&quot;&gt;    &lt;div class=&quot;article-item&quot;       v-for=&quot;item in articelList&quot; :key=&quot;item.id&quot;       @click=&quot;$router.push(`/detail?id=$&#123;item.id&#125;`)&quot;&gt;     ...    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><p>ArticleDetail.vue</p><pre><code class="vue">  created()&#123;    console.log(this.$route.query.id)  &#125;</code></pre><h2 id="十九、面经基础版-动态路由传参"><a href="#十九、面经基础版-动态路由传参" class="headerlink" title="十九、面经基础版-动态路由传参"></a>十九、面经基础版-动态路由传参</h2><h3 id="1-实现步骤"><a href="#1-实现步骤" class="headerlink" title="1.实现步骤"></a>1.实现步骤</h3><ul><li>改造路由</li><li>动态传参</li><li>在详情页获取参数</li></ul><h3 id="2-代码实现-2"><a href="#2-代码实现-2" class="headerlink" title="2.代码实现"></a>2.代码实现</h3><p>改造路由</p><p>router&#x2F;index.js</p><pre><code class="js">...  &#123;      path: &#39;/detail/:id&#39;,      component: ArticleDetail  &#125;</code></pre><p>Article.vue</p><pre><code class="vue">&lt;div class=&quot;article-item&quot;      v-for=&quot;item in articelList&quot; :key=&quot;item.id&quot;      @click=&quot;$router.push(`/detail/$&#123;item.id&#125;`)&quot;&gt;       .... &lt;/div&gt;</code></pre><p>ArticleDetail.vue</p><pre><code class="vue">  created()&#123;    console.log(this.$route.params.id)  &#125;</code></pre><h3 id="3-额外优化功能点-点击回退跳转到上一页"><a href="#3-额外优化功能点-点击回退跳转到上一页" class="headerlink" title="3.额外优化功能点-点击回退跳转到上一页"></a>3.额外优化功能点-点击回退跳转到上一页</h3><p>ArticleDetail.vue</p><pre><code class="vue">&lt;template&gt;  &lt;div class=&quot;article-detail-page&quot;&gt;    &lt;nav class=&quot;nav&quot;&gt;&lt;span class=&quot;back&quot; @click=&quot;$router.back()&quot;&gt;&amp;lt;&lt;/span&gt; 面经详情&lt;/nav&gt;     ....  &lt;/div&gt;&lt;/template&gt;</code></pre><h2 id="二十、面经基础版-详情页渲染"><a href="#二十、面经基础版-详情页渲染" class="headerlink" title="二十、面经基础版-详情页渲染"></a>二十、面经基础版-详情页渲染</h2><h3 id="1-实现步骤分析"><a href="#1-实现步骤分析" class="headerlink" title="1.实现步骤分析"></a>1.实现步骤分析</h3><ul><li>导入axios</li><li>查看接口文档</li><li>在created中发送请求</li><li>页面动态渲染</li></ul><h3 id="2-代码实现-3"><a href="#2-代码实现-3" class="headerlink" title="2.代码实现"></a>2.代码实现</h3><p>接口文档</p><pre><code class="vue"> 请求地址: https://mock.boxuegu.com/mock/3083/articles/:id 请求方式: get</code></pre><p>在created中发送请求</p><pre><code class="vue"> data() &#123;    return &#123;      articleDetail:&#123;&#125;    &#125;  &#125;,  async created() &#123;    const id = this.$route.params.id    const &#123;data:&#123;result&#125;&#125; = await axios.get(      `https://mock.boxuegu.com/mock/3083/articles/$&#123;id&#125;`    )    this.articleDetail = result  &#125;,</code></pre><p>页面动态渲染</p><pre><code class="vue">&lt;template&gt;  &lt;div class=&quot;article-detail-page&quot;&gt;    &lt;nav class=&quot;nav&quot;&gt;      &lt;span class=&quot;back&quot; @click=&quot;$router.back()&quot;&gt;&amp;lt;&lt;/span&gt; 面经详情    &lt;/nav&gt;    &lt;header class=&quot;header&quot;&gt;      &lt;h1&gt;&#123;&#123;articleDetail.stem&#125;&#125;&lt;/h1&gt;      &lt;p&gt;&#123;&#123;articleDetail.createAt&#125;&#125; | &#123;&#123;articleDetail.views&#125;&#125; 浏览量 | &#123;&#123;articleDetail.likeCount&#125;&#125; 点赞数&lt;/p&gt;      &lt;p&gt;        &lt;img          :src=&quot;articleDetail.creatorAvatar&quot;          alt=&quot;&quot;        /&gt;        &lt;span&gt;&#123;&#123;articleDetail.creatorName&#125;&#125;&lt;/span&gt;      &lt;/p&gt;    &lt;/header&gt;    &lt;main class=&quot;body&quot;&gt;      &#123;&#123;articleDetail.content&#125;&#125;    &lt;/main&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><h2 id="二十一、面经基础版-缓存组件"><a href="#二十一、面经基础版-缓存组件" class="headerlink" title="二十一、面经基础版-缓存组件"></a>二十一、面经基础版-缓存组件</h2><h3 id="1-问题-6"><a href="#1-问题-6" class="headerlink" title="1.问题"></a>1.问题</h3><p>从面经列表 点到 详情页，又点返回，数据重新加载了 →  <strong>希望回到原来的位置</strong></p><p><img src="/assets/1682578630060.png" alt="68257863006"></p><h3 id="2-原因-1"><a href="#2-原因-1" class="headerlink" title="2.原因"></a>2.原因</h3><p>当路由被<strong>跳转</strong>后，原来所看到的组件就<strong>被销毁</strong>了（会执行组件内的beforeDestroy和destroyed生命周期钩子），<strong>重新返回</strong>后组件又被<strong>重新创建</strong>了（会执行组件内的beforeCreate,created,beforeMount,Mounted生命周期钩子），<strong>所以数据被加载了</strong></p><h3 id="3-解决方案"><a href="#3-解决方案" class="headerlink" title="3.解决方案"></a>3.解决方案</h3><p>利用keep-alive把原来的组件给缓存下来</p><h3 id="4-什么是keep-alive"><a href="#4-什么是keep-alive" class="headerlink" title="4.什么是keep-alive"></a>4.什么是keep-alive</h3><p>keep-alive 是 Vue 的内置组件，当它包裹动态组件时，<strong>会缓存不活动的组件实例，而不是销毁</strong>它们。</p><p>keep-alive 是一个抽象组件：它自身不会渲染成一个 DOM 元素，也不会出现在父组件中。</p><p><strong>优点：</strong></p><p>在组件切换过程中把切换出去的组件保留在内存中，防止重复渲染DOM，</p><p>减少加载时间及性能消耗，提高用户体验性。</p><p>App.vue</p><pre><code class="vue">&lt;template&gt;  &lt;div class=&quot;h5-wrapper&quot;&gt;    &lt;keep-alive&gt;      &lt;router-view&gt;&lt;/router-view&gt;    &lt;/keep-alive&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><p><strong>问题：</strong></p><p>缓存了所有被切换的组件</p><h3 id="5-keep-alive的三个属性"><a href="#5-keep-alive的三个属性" class="headerlink" title="5.keep-alive的三个属性"></a>5.keep-alive的三个属性</h3><p>① include  ： 组件名数组，只有匹配的组件<strong>会被缓存</strong></p><p>② exclude ： 组件名数组，任何匹配的组件都<strong>不会被缓存</strong></p><p>③ max       ： 最多可以<strong>缓存多少</strong>组件实例</p><p>App.vue</p><pre><code class="vue">&lt;template&gt;  &lt;div class=&quot;h5-wrapper&quot;&gt;    &lt;keep-alive :include=&quot;[&#39;LayoutPage&#39;]&quot;&gt;      &lt;router-view&gt;&lt;/router-view&gt;    &lt;/keep-alive&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><h3 id="6-额外的两个生命周期钩子"><a href="#6-额外的两个生命周期钩子" class="headerlink" title="6.额外的两个生命周期钩子"></a>6.额外的两个生命周期钩子</h3><p><strong>keep-alive的使用会触发两个生命周期函数</strong></p><p><strong>activated</strong> 当组件被激活（使用）的时候触发 →  进入这个页面的时候触发</p><p><strong>deactivated</strong> 当组件不被使用的时候触发      →  离开这个页面的时候触发</p><p>组件<strong>缓存后</strong>就<strong>不会执行</strong>组件的<strong>created, mounted, destroyed</strong> 等钩子了</p><p>所以其提供了<strong>actived 和deactived</strong>钩子，帮我们实现业务需求。</p><h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7.总结"></a>7.总结</h3><p>1.keep-alive是什么</p><p>2.keep-alive的优点</p><p>3.keep-alive的三个属性 (了解)</p><p>4.keep-alive的使用会触发两个生命周期函数(了解)</p><h2 id="二十二、VueCli-自定义创建项目"><a href="#二十二、VueCli-自定义创建项目" class="headerlink" title="二十二、VueCli 自定义创建项目"></a>二十二、VueCli 自定义创建项目</h2><p>1.安装脚手架 (已安装)</p><pre><code>npm i @vue/cli -g</code></pre><p>2.创建项目</p><pre><code>vue create hm-exp-mobile</code></pre><ul><li>选项</li></ul><pre><code class="js">Vue CLI v5.0.8? Please pick a preset:  Default ([Vue 3] babel, eslint)  Default ([Vue 2] babel, eslint)&gt; Manually select features     选自定义</code></pre><ul><li>手动选择功能</li></ul><p><img src="/assets/1682941856172.png" alt="68294185617"></p><ul><li>选择vue的版本</li></ul><pre><code class="jsx">  3.x&gt; 2.x</code></pre><ul><li>是否使用history模式</li></ul><p><img src="/assets/1682941888453.png" alt="image-20201025150602129"></p><ul><li>选择css预处理</li></ul><p><img src="/assets/1682941900018.png" alt="image-20220629175133593"></p><ul><li>选择eslint的风格 （eslint 代码规范的检验工具，检验代码是否符合规范）</li><li>比如：const age &#x3D; 18;   &#x3D;&gt;  报错！多加了分号！后面有工具，一保存，全部格式化成最规范的样子</li></ul><p><img src="/assets/1682941918562.png" alt="68294191856"></p><ul><li>选择校验的时机 （直接回车）</li></ul><p><img src="/assets/1682941935794.png" alt="68294193579"></p><ul><li>选择配置文件的生成方式 （直接回车）</li></ul><p><img src="/assets/1682941947985.png" alt="68294194798"></p><ul><li>是否保存预设，下次直接使用？  &#x3D;&gt;   不保存，输入 N</li></ul><p><img src="/assets/1682941961551.png" alt="68294196155"></p><ul><li>等待安装，项目初始化完成</li></ul><p><img src="/assets/1682941974763.png" alt="68294197476"></p><ul><li>启动项目</li></ul><pre><code>npm run serve</code></pre><p><img src="/2023/07/14/day06/personboke\blog\source_posts\day06\image-20230725223111863.png" alt="image-20230725223111863"></p><h2 id="二十三、ESlint代码规范及手动修复"><a href="#二十三、ESlint代码规范及手动修复" class="headerlink" title="二十三、ESlint代码规范及手动修复"></a>二十三、ESlint代码规范及手动修复</h2><p>代码规范：一套写代码的约定规则。例如：赋值符号的左右是否需要空格？一句结束是否是要加;？… </p><blockquote><p> 没有规矩不成方圆  </p></blockquote><p>ESLint:是一个代码检查工具，用来检查你的代码是否符合指定的规则(你和你的团队可以自行约定一套规则)。在创建项目时，我们使用的是 <a href="https://standardjs.com/readme-zhcn.html">JavaScript Standard Style</a> 代码风格的规则。</p><h4 id="1-JavaScript-Standard-Style-规范说明"><a href="#1-JavaScript-Standard-Style-规范说明" class="headerlink" title="1.JavaScript Standard Style 规范说明"></a>1.JavaScript Standard Style 规范说明</h4><p>建议把：<a href="https://standardjs.com/rules-zhcn.html">https://standardjs.com/rules-zhcn.html</a> 看一遍，然后在写的时候,  遇到错误就查询解决。</p><p>下面是这份规则中的一小部分：</p><ul><li><em>字符串使用单引号</em> – 需要转义的地方除外</li><li><em>无分号</em> – <a href="http://blog.izs.me/post/2353458699/an-open-letter-to-javascript-leaders-regarding">这</a><a href="http://inimino.org/~inimino/blog/javascript_semicolons">没什么不好。</a><a href="https://www.youtube.com/watch?v=gsfbh17Ax9I">不骗你！</a></li><li><em>关键字后加空格</em> <code>if (condition) &#123; ... &#125;</code></li><li><em>函数名后加空格</em> <code>function name (arg) &#123; ... &#125;</code></li><li>坚持使用全等 <code>===</code> 摒弃 <code>==</code> 一但在需要检查 <code>null || undefined</code> 时可以使用 <code>obj == null</code></li><li>……</li></ul><h4 id="2-代码规范错误"><a href="#2-代码规范错误" class="headerlink" title="2.代码规范错误"></a>2.代码规范错误</h4><p>如果你的代码不符合standard的要求，eslint会跳出来刀子嘴，豆腐心地提示你。</p><p>下面我们在main.js中随意做一些改动：添加一些空行，空格。</p><pre><code class="js">import Vue from &#39;vue&#39;import App from &#39;./App.vue&#39;import &#39;./styles/index.less&#39;import router from &#39;./router&#39;Vue.config.productionTip = falsenew Vue ( &#123;  render: h =&gt; h(App),  router&#125;).$mount(&#39;#app&#39;)</code></pre><p>按下保存代码之后：</p><p>你将会看在控制台中输出如下错误：</p><blockquote></blockquote><h4 id="3-手动修正"><a href="#3-手动修正" class="headerlink" title="3.手动修正"></a>3.手动修正</h4><p>根据错误提示来一项一项手动修正。</p><p>如果你不认识命令行中的语法报错是什么意思，你可以根据错误代码（func-call-spacing, space-in-parens,…..）去 ESLint 规则列表中查找其具体含义。</p><p>打开 <a href="https://zh-hans.eslint.org/docs/latest/rules/">ESLint 规则表</a>，使用页面搜索（Ctrl + F）这个代码，查找对该规则的一个释义。</p><p><img src="/assets/1682942792219.png" alt="68294279221"></p><h2 id="二十四、通过eslint插件来实现自动修正"><a href="#二十四、通过eslint插件来实现自动修正" class="headerlink" title="二十四、通过eslint插件来实现自动修正"></a>二十四、通过eslint插件来实现自动修正</h2><blockquote><ol><li>eslint会自动高亮错误显示</li><li>通过配置，eslint会自动帮助我们修复错误</li></ol></blockquote><ul><li>如何安装</li></ul><p><img src="/assets/1682942920986.png" alt="68294292098"></p><ul><li>如何配置</li></ul><pre><code class="js">// 当保存的时候，eslint自动帮我们修复错误&quot;editor.codeActionsOnSave&quot;: &#123;    &quot;source.fixAll&quot;: true&#125;,// 保存代码，不自动格式化&quot;editor.formatOnSave&quot;: false</code></pre><ul><li>注意：eslint的配置文件必须在根目录下，这个插件才能才能生效。打开项目必须以根目录打开，一次打开一个项目</li><li>注意：使用了eslint校验之后，把vscode带的那些格式化工具全禁用了 Beatify</li></ul><p>settings.json 参考</p><pre><code class="jsx">&#123;    &quot;window.zoomLevel&quot;: 2,    &quot;workbench.iconTheme&quot;: &quot;vscode-icons&quot;,    &quot;editor.tabSize&quot;: 2,    &quot;emmet.triggerExpansionOnTab&quot;: true,    // 当保存的时候，eslint自动帮我们修复错误    &quot;editor.codeActionsOnSave&quot;: &#123;        &quot;source.fixAll&quot;: true    &#125;,    // 保存代码，不自动格式化    &quot;editor.formatOnSave&quot;: false&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/05/07/day07/"/>
      <url>/2023/05/07/day07/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Vuex-概述"><a href="#一、Vuex-概述" class="headerlink" title="一、Vuex 概述"></a>一、<a href="https://vuex.vuejs.org/zh/">Vuex</a> 概述</h2><p>目标：明确<a href="https://vuex.vuejs.org/zh/">Vuex</a>是什么，应用场景以及优势</p><h3 id="1-是什么"><a href="#1-是什么" class="headerlink" title="1.是什么"></a>1.是什么</h3><p>Vuex 是一个 Vue 的 状态管理工具，状态就是数据。</p><p>大白话：Vuex 是一个插件，可以帮我们管理 Vue 通用的数据 (多组件共享的数据)。例如：购物车数据   个人信息数</p><h3 id="2-使用场景"><a href="#2-使用场景" class="headerlink" title="2.使用场景"></a>2.使用场景</h3><ul><li><p>某个状态 在 很多个组件 来使用 (个人信息)</p></li><li><p>多个组件 共同维护 一份数据 (购物车)</p></li></ul><p><img src="/assets/1683178186642.png" alt="68317818664"></p><h3 id="3-优势"><a href="#3-优势" class="headerlink" title="3.优势"></a>3.优势</h3><ul><li>共同维护一份数据，<strong>数据集中化管理</strong></li><li><strong>响应式变化</strong></li><li>操作简洁 (vuex提供了一些辅助函数)</li></ul><p><img src="/assets/1683178293366.png" alt="68317829336"></p><h3 id="4-注意："><a href="#4-注意：" class="headerlink" title="4.注意："></a>4.注意：</h3><p>官方原文：</p><ul><li>不是所有的场景都适用于vuex，只有在必要的时候才使用vuex</li><li>使用了vuex之后，会附加更多的框架中的概念进来，增加了项目的复杂度  （数据的操作更便捷，数据的流动更清晰）</li></ul><p>Vuex就像《近视眼镜》, 你自然会知道什么时候需要用它~</p><h2 id="二、需求-多组件共享数据"><a href="#二、需求-多组件共享数据" class="headerlink" title="二、需求: 多组件共享数据"></a>二、需求: 多组件共享数据</h2><p>目标：基于脚手架创建项目，构建 vuex 多组件数据共享环境</p><p><img src="/assets/1683178912695.png" alt="68317891269"></p><p>效果是三个组件共享一份数据:</p><ul><li>任意一个组件都可以修改数据</li><li>三个组件的数据是同步的</li></ul><h3 id="1-创建项目"><a href="#1-创建项目" class="headerlink" title="1.创建项目"></a>1.创建项目</h3><pre><code>vue create vuex-demo</code></pre><h3 id="2-创建三个组件-目录如下"><a href="#2-创建三个组件-目录如下" class="headerlink" title="2.创建三个组件, 目录如下"></a>2.创建三个组件, 目录如下</h3><pre><code>|-components|--Son1.vue|--Son2.vue|-App.vue</code></pre><h3 id="3-源代码如下"><a href="#3-源代码如下" class="headerlink" title="3.源代码如下"></a>3.源代码如下</h3><p><code>App.vue</code>在入口组件中引入 Son1 和 Son2 这两个子组件</p><pre><code class="html">&lt;template&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;h1&gt;根组件&lt;/h1&gt;    &lt;input type=&quot;text&quot;&gt;    &lt;Son1&gt;&lt;/Son1&gt;    &lt;hr&gt;    &lt;Son2&gt;&lt;/Son2&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Son1 from &#39;./components/Son1.vue&#39;import Son2 from &#39;./components/Son2.vue&#39;export default &#123;  name: &#39;app&#39;,  data: function () &#123;    return &#123;    &#125;  &#125;,  components: &#123;    Son1,    Son2  &#125;&#125;&lt;/script&gt;&lt;style&gt;#app &#123;  width: 600px;  margin: 20px auto;  border: 3px solid #ccc;  border-radius: 3px;  padding: 10px;&#125;&lt;/style&gt;</code></pre><p><code>main.js</code></p><pre><code class="js">import Vue from &#39;vue&#39;import App from &#39;./App.vue&#39;Vue.config.productionTip = falsenew Vue(&#123;  render: h =&gt; h(App)&#125;).$mount(&#39;#app&#39;)</code></pre><p><code>Son1.vue</code></p><pre><code class="html">&lt;template&gt;  &lt;div class=&quot;box&quot;&gt;    &lt;h2&gt;Son1 子组件&lt;/h2&gt;    从vuex中获取的值: &lt;label&gt;&lt;/label&gt;    &lt;br&gt;    &lt;button&gt;值 + 1&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;Son1Com&#39;&#125;&lt;/script&gt;&lt;style lang=&quot;css&quot; scoped&gt;.box&#123;  border: 3px solid #ccc;  width: 400px;  padding: 10px;  margin: 20px;&#125;h2 &#123;  margin-top: 10px;&#125;&lt;/style&gt;</code></pre><p><code>Son2.vue</code></p><pre><code class="html">&lt;template&gt;  &lt;div class=&quot;box&quot;&gt;    &lt;h2&gt;Son2 子组件&lt;/h2&gt;    从vuex中获取的值:&lt;label&gt;&lt;/label&gt;    &lt;br /&gt;    &lt;button&gt;值 - 1&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;Son2Com&#39;&#125;&lt;/script&gt;&lt;style lang=&quot;css&quot; scoped&gt;.box &#123;  border: 3px solid #ccc;  width: 400px;  padding: 10px;  margin: 20px;&#125;h2 &#123;  margin-top: 10px;&#125;&lt;/style&gt;</code></pre><h2 id="三、vuex-的使用-创建仓库"><a href="#三、vuex-的使用-创建仓库" class="headerlink" title="三、vuex 的使用 - 创建仓库"></a>三、vuex 的使用 - 创建仓库</h2><p><img src="/assets/1683212784179.png" alt="68321278417"></p><h3 id="1-安装-vuex"><a href="#1-安装-vuex" class="headerlink" title="1.安装 vuex"></a>1.安装 vuex</h3><p>安装vuex与vue-router类似，vuex是一个独立存在的插件，如果脚手架初始化没有选 vuex，就需要额外安装。</p><pre><code class="bash">yarn add vuex@3 或者 npm i vuex@3</code></pre><h3 id="2-新建-store-index-js-专门存放-vuex"><a href="#2-新建-store-index-js-专门存放-vuex" class="headerlink" title="2.新建 store/index.js 专门存放 vuex"></a>2.新建 <code>store/index.js</code> 专门存放 vuex</h3><p>​为了维护项目目录的整洁，在src目录下新建一个store目录其下放置一个index.js文件。 (和 <code>router/index.js</code> 类似)</p><p>​<img src="/assets/1683212805824.png" alt="68321280582"></p><h3 id="3-创建仓库-store-index-js"><a href="#3-创建仓库-store-index-js" class="headerlink" title="3.创建仓库 store/index.js"></a>3.创建仓库 <code>store/index.js</code></h3><pre><code class="jsx">// 导入 vueimport Vue from &#39;vue&#39;// 导入 vueximport Vuex from &#39;vuex&#39;// vuex也是vue的插件, 需要use一下, 进行插件的安装初始化Vue.use(Vuex)// 创建仓库 storeconst store = new Vuex.Store()// 导出仓库export default store</code></pre><h3 id="4-在-main-js-中导入挂载到-Vue-实例上"><a href="#4-在-main-js-中导入挂载到-Vue-实例上" class="headerlink" title="4 在 main.js 中导入挂载到 Vue 实例上"></a>4 在 main.js 中导入挂载到 Vue 实例上</h3><pre><code class="js">import Vue from &#39;vue&#39;import App from &#39;./App.vue&#39;import store from &#39;./store&#39;Vue.config.productionTip = falsenew Vue(&#123;  render: h =&gt; h(App),  store&#125;).$mount(&#39;#app&#39;)</code></pre><p>此刻起, 就成功创建了一个 <strong>空仓库!!</strong></p><h3 id="5-测试打印Vuex"><a href="#5-测试打印Vuex" class="headerlink" title="5.测试打印Vuex"></a>5.测试打印Vuex</h3><p>App.vue</p><pre><code class="js">created()&#123;  console.log(this.$store)&#125;</code></pre><h2 id="四、核心概念-state-状态"><a href="#四、核心概念-state-状态" class="headerlink" title="四、核心概念 - state 状态"></a>四、核心概念 - state 状态</h2><h3 id="1-目标"><a href="#1-目标" class="headerlink" title="1.目标"></a>1.目标</h3><p>明确如何给仓库 提供 数据，如何 使用 仓库的数据</p><h3 id="2-提供数据"><a href="#2-提供数据" class="headerlink" title="2.提供数据"></a>2.提供数据</h3><p>State提供唯一的公共数据源，所有共享的数据都要统一放到Store中的State中存储。</p><p>打开项目中的store.js文件，在state对象中可以添加我们要共享的数据。</p><pre><code class="jsx">// 创建仓库 storeconst store = new Vuex.Store(&#123;  // state 状态, 即数据, 类似于vue组件中的data,  // 区别：  // 1.data 是组件自己的数据,   // 2.state 中的数据整个vue项目的组件都能访问到  state: &#123;    count: 101  &#125;&#125;)</code></pre><h3 id="3-访问Vuex中的数据"><a href="#3-访问Vuex中的数据" class="headerlink" title="3.访问Vuex中的数据"></a>3.访问Vuex中的数据</h3><p>问题: 如何在组件中获取count?</p><ol><li>通过$store直接访问  —&gt;  </li><li>通过辅助函数mapState 映射计算属性  —&gt;  </li></ol><h3 id="4-通过-store访问的语法"><a href="#4-通过-store访问的语法" class="headerlink" title="4.通过$store访问的语法"></a>4.通过$store访问的语法</h3><pre><code class="js">获取 store： 1.Vue模板中获取 this.$store 2.js文件中获取 import 导入 store模板中：     &#123;&#123; $store.state.xxx &#125;&#125;组件逻辑中：  this.$store.state.xxxJS模块中：   store.state.xxx</code></pre><h3 id="5-代码实现"><a href="#5-代码实现" class="headerlink" title="5.代码实现"></a>5.代码实现</h3><h4 id="5-1模板中使用"><a href="#5-1模板中使用" class="headerlink" title="5.1模板中使用"></a>5.1模板中使用</h4><p>组件中可以使用  <strong>$store</strong> 获取到vuex中的store对象实例，可通过<strong>state</strong>属性属性获取<strong>count</strong>， 如下</p><pre><code class="vue">&lt;h1&gt;state的数据 - &#123;&#123; $store.state.count &#125;&#125;&lt;/h1&gt;</code></pre><h4 id="5-2组件逻辑中使用"><a href="#5-2组件逻辑中使用" class="headerlink" title="5.2组件逻辑中使用"></a>5.2组件逻辑中使用</h4><p>将state属性定义在计算属性中 <a href="https://vuex.vuejs.org/zh/guide/state.html">https://vuex.vuejs.org/zh/guide/state.html</a></p><pre><code class="js">&lt;h1&gt;state的数据 - &#123;&#123; count &#125;&#125;&lt;/h1&gt;// 把state中数据，定义在组件内的计算属性中  computed: &#123;    count () &#123;      return this.$store.state.count    &#125;  &#125;</code></pre><h4 id="5-3-js文件中使用"><a href="#5-3-js文件中使用" class="headerlink" title="5.3 js文件中使用"></a>5.3 js文件中使用</h4><pre><code class="vue">//main.jsimport store from &quot;@/store&quot;console.log(store.state.count)</code></pre><p>每次都像这样一个个的提供计算属性, 太麻烦了,我们有没有简单的语法帮我们获取state中的值呢？</p><h2 id="五、通过辅助函数-mapState获取-state中的数据"><a href="#五、通过辅助函数-mapState获取-state中的数据" class="headerlink" title="五、通过辅助函数  - mapState获取 state中的数据"></a>五、通过辅助函数  - mapState获取 state中的数据</h2><blockquote><p>mapState是辅助函数，帮助我们把store中的数据映射到 组件的计算属性中, 它属于一种方便的用法</p></blockquote><p>用法 ：</p><p><img src="/assets/1683214719574.png" alt="68321471957"> </p><h3 id="1-第一步：导入mapState-mapState是vuex中的一个函数"><a href="#1-第一步：导入mapState-mapState是vuex中的一个函数" class="headerlink" title="1.第一步：导入mapState (mapState是vuex中的一个函数)"></a>1.第一步：导入mapState (mapState是vuex中的一个函数)</h3><pre><code class="js">import &#123; mapState &#125; from &#39;vuex&#39;</code></pre><h3 id="2-第二步：采用数组形式引入state属性"><a href="#2-第二步：采用数组形式引入state属性" class="headerlink" title="2.第二步：采用数组形式引入state属性"></a>2.第二步：采用数组形式引入state属性</h3><pre><code class="js">mapState([&#39;count&#39;]) </code></pre><blockquote><p>上面代码的最终得到的是 <strong>类似于</strong></p></blockquote><pre><code class="js">count () &#123;    return this.$store.state.count&#125;</code></pre><h3 id="3-第三步：利用展开运算符将导出的状态映射给计算属性"><a href="#3-第三步：利用展开运算符将导出的状态映射给计算属性" class="headerlink" title="3.第三步：利用展开运算符将导出的状态映射给计算属性"></a>3.第三步：利用<strong>展开运算符</strong>将导出的状态映射给计算属性</h3><pre><code class="js">  computed: &#123;    ...mapState([&#39;count&#39;])  &#125;</code></pre><pre><code class="vue"> &lt;div&gt; state的数据：&#123;&#123; count &#125;&#125;&lt;/div&gt;</code></pre><h2 id="六、开启严格模式及Vuex的单项数据流"><a href="#六、开启严格模式及Vuex的单项数据流" class="headerlink" title="六、开启严格模式及Vuex的单项数据流"></a>六、开启严格模式及Vuex的单项数据流</h2><h3 id="1-目标-1"><a href="#1-目标-1" class="headerlink" title="1.目标"></a>1.目标</h3><p>明确 vuex 同样遵循单向数据流，组件中不能直接修改仓库的数据</p><h3 id="2-直接在组件中修改Vuex中state的值"><a href="#2-直接在组件中修改Vuex中state的值" class="headerlink" title="2.直接在组件中修改Vuex中state的值"></a>2.直接在组件中修改Vuex中state的值</h3><p><img src="/assets/1683215892288.png" alt="68321589228"></p><p>Son1.vue</p><pre><code class="vue">button @click=&quot;handleAdd&quot;&gt;值 + 1&lt;/button&gt;methods:&#123;     handleAdd (n) &#123;      // 错误代码(vue默认不会监测，监测需要成本)       this.$store.state.count++      // console.log(this.$store.state.count)     &#125;,&#125;</code></pre><h3 id="3-开启严格模式"><a href="#3-开启严格模式" class="headerlink" title="3.开启严格模式"></a>3.开启严格模式</h3><p>通过 <code>strict: true</code> 可以开启严格模式,开启严格模式后，直接修改state中的值会报错</p><blockquote><p><strong>state数据的修改只能通过mutations，并且mutations必须是同步的</strong></p></blockquote><p><img src="/assets/1683215821033.png" alt="68321471957"></p><h2 id="七、核心概念-mutations"><a href="#七、核心概念-mutations" class="headerlink" title="七、核心概念-mutations"></a>七、核心概念-mutations</h2><h3 id="1-定义mutations"><a href="#1-定义mutations" class="headerlink" title="1.定义mutations"></a>1.定义mutations</h3><pre><code class="js">const store  = new Vuex.Store(&#123;  state: &#123;    count: 0  &#125;,  // 定义mutations  mutations: &#123;       &#125;&#125;)</code></pre><h3 id="2-格式说明"><a href="#2-格式说明" class="headerlink" title="2.格式说明"></a>2.格式说明</h3><p>mutations是一个对象，对象中存放修改state的方法</p><pre><code class="js">mutations: &#123;    // 方法里参数 第一个参数是当前store的state属性    // payload 载荷 运输参数 调用mutaiions的时候 可以传递参数 传递载荷    addCount (state) &#123;      state.count += 1    &#125;  &#125;,</code></pre><h3 id="3-组件中提交-mutations"><a href="#3-组件中提交-mutations" class="headerlink" title="3.组件中提交 mutations"></a>3.组件中提交 mutations</h3><pre><code class="jsx">this.$store.commit(&#39;addCount&#39;)</code></pre><h3 id="4-练习"><a href="#4-练习" class="headerlink" title="4.练习"></a>4.练习</h3><p>1.在mutations中定义个点击按钮进行 +5 的方法</p><p>2.在mutations中定义个点击按钮进行 改变title 的方法</p><p>3.在组件中调用mutations修改state中的值</p><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h3><p>通过mutations修改state的步骤</p><p>1.定义 mutations 对象，对象中存放修改 state 的方法</p><p>2.组件中提交调用 mutations(通过$store.commit(‘mutations的方法名’))</p><h2 id="八、带参数的-mutations"><a href="#八、带参数的-mutations" class="headerlink" title="八、带参数的 mutations"></a>八、带参数的 mutations</h2><h3 id="1-目标："><a href="#1-目标：" class="headerlink" title="1.目标："></a>1.目标：</h3><p>掌握 mutations 传参语法</p><h3 id="2-语法"><a href="#2-语法" class="headerlink" title="2.语法"></a>2.语法</h3><p>看下面这个案例，每次点击不同的按钮，加的值都不同，每次都要定义不同的mutations处理吗？</p><p><img src="/assets/1683217004239.png" alt="68321700423"></p><p>提交 mutation 是可以传递参数的  <code>this.$store.commit(&#39;xxx&#39;,  参数)</code></p><h4 id="2-1-提供mutation函数（带参数）"><a href="#2-1-提供mutation函数（带参数）" class="headerlink" title="2.1 提供mutation函数（带参数）"></a>2.1 提供mutation函数（带参数）</h4><pre><code class="js">mutations: &#123;  ...  addCount (state, count) &#123;    state.count = count  &#125;&#125;,</code></pre><h4 id="2-2-提交mutation"><a href="#2-2-提交mutation" class="headerlink" title="2.2 提交mutation"></a>2.2 提交mutation</h4><pre><code class="jsx">handle ( ) &#123;  this.$store.commit(&#39;addCount&#39;, 10)&#125;</code></pre><p><strong>小tips: 提交的参数只能是一个, 如果有多个参数要传, 可以传递一个对象</strong></p><pre><code class="jsx">this.$store.commit(&#39;addCount&#39;, &#123;  count: 10&#125;)</code></pre><h2 id="九、练习-mutations的减法功能"><a href="#九、练习-mutations的减法功能" class="headerlink" title="九、练习-mutations的减法功能"></a>九、练习-mutations的减法功能</h2><p><img src="/assets/1683217248752.png" alt="68321724875"></p><h3 id="1-步骤"><a href="#1-步骤" class="headerlink" title="1.步骤"></a>1.步骤</h3><p><img src="/assets/1683217268256.png" alt="68321726825"></p><h3 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2.代码实现"></a>2.代码实现</h3><p>Son2.vue</p><pre><code class="vue">    &lt;button @click=&quot;subCount(1)&quot;&gt;值 - 1&lt;/button&gt;    &lt;button @click=&quot;subCount(5)&quot;&gt;值 - 5&lt;/button&gt;    &lt;button @click=&quot;subCount(10)&quot;&gt;值 - 10&lt;/button&gt;    export default &#123;        methods:&#123;             subCount (n) &#123;                 this.$store.commit(&#39;addCount&#39;, n)        &#125;,        &#125;    &#125;</code></pre><p>store&#x2F;index.js</p><pre><code class="js">mutations:&#123;    subCount (state, n) &#123;      state.count -= n    &#125;,&#125;</code></pre><h2 id="十、练习-Vuex中的值和组件中的input双向绑定"><a href="#十、练习-Vuex中的值和组件中的input双向绑定" class="headerlink" title="十、练习-Vuex中的值和组件中的input双向绑定"></a>十、练习-Vuex中的值和组件中的input双向绑定</h2><h3 id="1-目标-2"><a href="#1-目标-2" class="headerlink" title="1.目标"></a>1.目标</h3><p>实时输入，实时更新，巩固 mutations 传参语法</p><p><img src="/assets/1683217697064.png" alt="68321769706"></p><h3 id="2-实现步骤"><a href="#2-实现步骤" class="headerlink" title="2.实现步骤"></a>2.实现步骤</h3><p><img src="/assets/1683217717788.png" alt="68321771778"></p><h3 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3.代码实现"></a>3.代码实现</h3><p>App.vue</p><pre><code class="vue">&lt;input :value=&quot;count&quot; @input=&quot;handleInput&quot; type=&quot;text&quot;&gt;export default &#123;  methods: &#123;    handleInput (e) &#123;      // 1. 实时获取输入框的值      const num = +e.target.value      // 2. 提交mutation，调用mutation函数      this.$store.commit(&#39;changeCount&#39;, num)    &#125;  &#125;&#125;</code></pre><p>store&#x2F;index.js</p><pre><code class="js">mutations: &#123;    changeCount (state, newCount) &#123;      state.count = newCount   &#125;&#125;,</code></pre><h2 id="十一、辅助函数-mapMutations"><a href="#十一、辅助函数-mapMutations" class="headerlink" title="十一、辅助函数- mapMutations"></a>十一、辅助函数- mapMutations</h2><blockquote><p>mapMutations和mapState很像，它把位于mutations中的方法提取了出来，我们可以将它导入</p></blockquote><pre><code class="js">import  &#123; mapMutations &#125; from &#39;vuex&#39;methods: &#123;    ...mapMutations([&#39;addCount&#39;])&#125;</code></pre><blockquote><p>上面代码的含义是将mutations的方法导入了methods中，等价于</p></blockquote><pre><code class="js">methods: &#123;      // commit(方法名, 载荷参数)      addCount () &#123;          this.$store.commit(&#39;addCount&#39;)      &#125; &#125;</code></pre><p>此时，就可以直接通过this.addCount调用了</p><pre><code class="jsx">&lt;button @click=&quot;addCount&quot;&gt;值+1&lt;/button&gt;</code></pre><p>但是请注意： Vuex中mutations中要求不能写异步代码，如果有异步的ajax请求，应该放置在actions中</p><h2 id="十二、核心概念-actions"><a href="#十二、核心概念-actions" class="headerlink" title="十二、核心概念 - actions"></a>十二、核心概念 - actions</h2><blockquote><p>state是存放数据的，mutations是同步更新数据 (便于监测数据的变化, 更新视图等, 方便于调试工具查看变化)，</p><p>actions则负责进行异步操作</p></blockquote><p><strong>说明：mutations必须是同步的</strong></p><p><strong>需求: 一秒钟之后, 要给一个数 去修改state</strong></p><p><img src="/assets/1683218603674.png" alt="68321860367"></p><h3 id="1-定义actions"><a href="#1-定义actions" class="headerlink" title="1.定义actions"></a><strong>1.定义actions</strong></h3><pre><code class="js">mutations: &#123;  changeCount (state, newCount) &#123;    state.count = newCount  &#125;&#125;actions: &#123;  setAsyncCount (context, num) &#123;    // 一秒后, 给一个数, 去修改 num    setTimeout(() =&gt; &#123;      context.commit(&#39;changeCount&#39;, num)    &#125;, 1000)  &#125;&#125;,</code></pre><h3 id="2-组件中通过dispatch调用"><a href="#2-组件中通过dispatch调用" class="headerlink" title="2.组件中通过dispatch调用"></a><strong>2.组件中通过dispatch调用</strong></h3><pre><code class="js">setAsyncCount () &#123;  this.$store.dispatch(&#39;setAsyncCount&#39;, 666)&#125;</code></pre><p><img src="/assets/1683441987572.png" alt="68344198757"></p><h2 id="十三、辅助函数-mapActions"><a href="#十三、辅助函数-mapActions" class="headerlink" title="十三、辅助函数 -mapActions"></a>十三、辅助函数 -mapActions</h2><p>1.目标：掌握辅助函数 mapActions，映射方法</p><blockquote><p>mapActions 是把位于 actions中的方法提取了出来，映射到组件methods中</p></blockquote><p>Son2.vue</p><pre><code class="js">import &#123; mapActions &#125; from &#39;vuex&#39;methods: &#123;   ...mapActions([&#39;changeCountAction&#39;])&#125;//mapActions映射的代码 本质上是以下代码的写法//methods: &#123;//  changeCountAction (n) &#123;//    this.$store.dispatch(&#39;changeCountAction&#39;, n)//  &#125;,//&#125;</code></pre><p>直接通过 this.方法 就可以调用</p><pre><code class="vue">&lt;button @click=&quot;changeCountAction(200)&quot;&gt;+异步&lt;/button&gt;</code></pre><h2 id="十四、核心概念-getters"><a href="#十四、核心概念-getters" class="headerlink" title="十四、核心概念 - getters"></a>十四、核心概念 - getters</h2><blockquote><p>除了state之外，有时我们还需要从state中<strong>筛选出符合条件的一些数据</strong>，这些数据是依赖state的，此时会用到getters</p></blockquote><p>例如，state中定义了list，为1-10的数组，</p><pre><code class="js">state: &#123;    list: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]&#125;</code></pre><p>组件中，需要显示所有大于5的数据，正常的方式，是需要list在组件中进行再一步的处理，但是getters可以帮助我们实现它</p><h3 id="1-定义getters"><a href="#1-定义getters" class="headerlink" title="1.定义getters"></a>1.定义getters</h3><pre><code class="js">  getters: &#123;    // getters函数的第一个参数是 state    // 必须要有返回值     filterList:  state =&gt;  state.list.filter(item =&gt; item &gt; 5)  &#125;</code></pre><h3 id="2-使用getters"><a href="#2-使用getters" class="headerlink" title="2.使用getters"></a>2.使用getters</h3><h4 id="2-1原始方式-store"><a href="#2-1原始方式-store" class="headerlink" title="2.1原始方式-$store"></a>2.1原始方式-$store</h4><pre><code class="vue">&lt;div&gt;&#123;&#123; $store.getters.filterList &#125;&#125;&lt;/div&gt;</code></pre><h4 id="2-2辅助函数-mapGetters"><a href="#2-2辅助函数-mapGetters" class="headerlink" title="2.2辅助函数 - mapGetters"></a>2.2辅助函数 - mapGetters</h4><pre><code class="js">computed: &#123;    ...mapGetters([&#39;filterList&#39;])&#125;</code></pre><pre><code class="vue"> &lt;div&gt;&#123;&#123; filterList &#125;&#125;&lt;/div&gt;</code></pre><h2 id="十五、使用小结"><a href="#十五、使用小结" class="headerlink" title="十五、使用小结"></a>十五、使用小结</h2><p><img src="/assets/1683442133911.png" alt="68344213391"></p><h2 id="十六、核心概念-module"><a href="#十六、核心概念-module" class="headerlink" title="十六、核心概念 - module"></a>十六、核心概念 - module</h2><h3 id="1-目标-3"><a href="#1-目标-3" class="headerlink" title="1.目标"></a>1.目标</h3><p>掌握核心概念 module 模块的创建</p><h3 id="2-问题"><a href="#2-问题" class="headerlink" title="2.问题"></a>2.问题</h3><p>由于使用<strong>单一状态树</strong>，应用的所有状态<strong>会集中到一个比较大的对象</strong>。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。</p><p>这句话的意思是，如果把所有的状态都放在state中，当项目变得越来越大的时候，Vuex会变得越来越难以维护</p><p>由此，又有了Vuex的模块化</p><p><img src="/assets/1683425758358.png" alt="68342575835"></p><h3 id="3-模块定义-准备-state"><a href="#3-模块定义-准备-state" class="headerlink" title="3.模块定义 - 准备 state"></a><strong>3.模块定义</strong> - 准备 state</h3><p>定义两个模块   <strong>user</strong> 和  <strong>setting</strong></p><p>user中管理用户的信息状态  userInfo  <code>modules/user.js</code></p><pre><code class="jsx">const state = &#123;  userInfo: &#123;    name: &#39;zs&#39;,    age: 18  &#125;&#125;const mutations = &#123;&#125;const actions = &#123;&#125;const getters = &#123;&#125;export default &#123;  state,  mutations,  actions,  getters&#125;</code></pre><p>setting中管理项目应用的  主题色 theme，描述 desc， <code>modules/setting.js</code></p><pre><code class="jsx">const state = &#123;  theme: &#39;dark&#39;  desc: &#39;描述真呀真不错&#39;&#125;const mutations = &#123;&#125;const actions = &#123;&#125;const getters = &#123;&#125;export default &#123;  state,  mutations,  actions,  getters&#125;</code></pre><p>在<code>store/index.js</code>文件中的modules配置项中，注册这两个模块</p><pre><code class="js">import user from &#39;./modules/user&#39;import setting from &#39;./modules/setting&#39;const store = new Vuex.Store(&#123;    modules:&#123;        user,        setting    &#125;&#125;)</code></pre><p>使用模块中的数据,  可以直接通过模块名访问 <code>$store.state.模块名.xxx</code>  &#x3D;&gt;  <code>$store.state.setting.desc</code></p><p>也可以通过 mapState 映射</p><h2 id="十七、获取模块内的state数据"><a href="#十七、获取模块内的state数据" class="headerlink" title="十七、获取模块内的state数据"></a>十七、获取模块内的state数据</h2><h3 id="1-目标：-1"><a href="#1-目标：-1" class="headerlink" title="1.目标："></a>1.目标：</h3><p>掌握模块中 state 的访问语法</p><p>尽管已经分模块了，但其实子模块的状态，还是会挂到根级别的 state 中，属性名就是模块名</p><p><img src="/assets/1683427841660.png" alt="68342784166"></p><h3 id="2-使用模块中的数据"><a href="#2-使用模块中的数据" class="headerlink" title="2.使用模块中的数据"></a>2.使用模块中的数据</h3><ol><li>直接通过模块名访问 $store.state.模块名.xxx</li><li>通过 mapState 映射：</li><li>默认根级别的映射  mapState([ ‘xxx’ ])     </li><li>子模块的映射 ：mapState(‘模块名’, [‘xxx’])  -  需要开启命名空间 <strong>namespaced:true</strong></li></ol><p><code>modules/user.js</code></p><pre><code class="jsx">const state = &#123;  userInfo: &#123;    name: &#39;zs&#39;,    age: 18  &#125;,  myMsg: &#39;我的数据&#39;&#125;const mutations = &#123;  updateMsg (state, msg) &#123;    state.myMsg = msg  &#125;&#125;const actions = &#123;&#125;const getters = &#123;&#125;export default &#123;  namespaced: true,  state,  mutations,  actions,  getters&#125;</code></pre><h3 id="3-代码示例"><a href="#3-代码示例" class="headerlink" title="3.代码示例"></a>3.代码示例</h3><p>$store直接访问</p><pre><code class="js">$store.state.user.userInfo.name</code></pre><p>mapState辅助函数访问</p><pre><code class="js">...mapState(&#39;user&#39;, [&#39;userInfo&#39;]),...mapState(&#39;setting&#39;, [&#39;theme&#39;, &#39;desc&#39;]),</code></pre><h2 id="十八、获取模块内的getters数据"><a href="#十八、获取模块内的getters数据" class="headerlink" title="十八、获取模块内的getters数据"></a>十八、获取模块内的getters数据</h2><h3 id="1-目标：-2"><a href="#1-目标：-2" class="headerlink" title="1.目标："></a>1.目标：</h3><p>掌握模块中 getters 的访问语</p><h3 id="2-语法："><a href="#2-语法：" class="headerlink" title="2.语法："></a>2.语法：</h3><p>使用模块中 getters 中的数据： </p><ol><li>直接通过模块名访问<code> $store.getters[&#39;模块名/xxx &#39;]</code></li><li>通过 mapGetters 映射      <ol><li>默认根级别的映射  <code>mapGetters([ &#39;xxx&#39; ]) </code></li><li>子模块的映射  <code>mapGetters(&#39;模块名&#39;, [&#39;xxx&#39;])</code> -  需要开启命名空间</li></ol></li></ol><h3 id="3-代码演示"><a href="#3-代码演示" class="headerlink" title="3.代码演示"></a>3.代码演示</h3><p><code>modules/user.js</code></p><pre><code class="js">const getters = &#123;  // 分模块后，state指代子模块的state  UpperCaseName (state) &#123;    return state.userInfo.name.toUpperCase()  &#125;&#125;</code></pre><p>Son1.vue 直接访问getters</p><pre><code class="html">&lt;!-- 测试访问模块中的getters - 原生 --&gt;&lt;div&gt;&#123;&#123; $store.getters['user/UpperCaseName'] &#125;&#125;&lt;/div&gt;</code></pre><p>Son2.vue 通过命名空间访问</p><pre><code class="js">computed:&#123;  ...mapGetters(&#39;user&#39;, [&#39;UpperCaseName&#39;])&#125;</code></pre><h2 id="十九、获取模块内的mutations方法"><a href="#十九、获取模块内的mutations方法" class="headerlink" title="十九、获取模块内的mutations方法"></a>十九、获取模块内的mutations方法</h2><h3 id="1-目标：-3"><a href="#1-目标：-3" class="headerlink" title="1.目标："></a>1.目标：</h3><p>掌握模块中 mutation 的调用语法</p><h3 id="2-注意："><a href="#2-注意：" class="headerlink" title="2.注意："></a>2.注意：</h3><p>默认模块中的 mutation 和 actions 会被挂载到全局，<strong>需要开启命名空间</strong>，才会挂载到子模块。</p><h3 id="3-调用方式："><a href="#3-调用方式：" class="headerlink" title="3.调用方式："></a>3.调用方式：</h3><ol><li>直接通过 store 调用   $store.commit(‘模块名&#x2F;xxx ‘,  额外参数)</li><li>通过 mapMutations 映射    <ol><li>默认根级别的映射  mapMutations([ ‘xxx’ ])     </li><li>子模块的映射 mapMutations(‘模块名’, [‘xxx’])  -  需要开启命名空间</li></ol></li></ol><h3 id="4-代码实现"><a href="#4-代码实现" class="headerlink" title="4.代码实现"></a>4.代码实现</h3><p><code>modules/user.js</code></p><pre><code class="js">const mutations = &#123;  setUser (state, newUserInfo) &#123;    state.userInfo = newUserInfo  &#125;&#125;</code></pre><p><code>modules/setting.js</code></p><pre><code class="js">const mutations = &#123;  setTheme (state, newTheme) &#123;    state.theme = newTheme  &#125;&#125;</code></pre><p>Son1.vue</p><pre><code class="vue">&lt;button @click=&quot;updateUser&quot;&gt;更新个人信息&lt;/button&gt; &lt;button @click=&quot;updateTheme&quot;&gt;更新主题色&lt;/button&gt;export default &#123;  methods: &#123;    updateUser () &#123;      // $store.commit(&#39;模块名/mutation名&#39;, 额外传参)      this.$store.commit(&#39;user/setUser&#39;, &#123;        name: &#39;xiaowang&#39;,        age: 25      &#125;)    &#125;,     updateTheme () &#123;      this.$store.commit(&#39;setting/setTheme&#39;, &#39;pink&#39;)    &#125;  &#125;&#125;</code></pre><p>Son2.vue</p><pre><code class="vue">&lt;button @click=&quot;setUser(&#123; name: &#39;xiaoli&#39;, age: 80 &#125;)&quot;&gt;更新个人信息&lt;/button&gt;&lt;button @click=&quot;setTheme(&#39;skyblue&#39;)&quot;&gt;更新主题&lt;/button&gt;methods:&#123;// 分模块的映射...mapMutations(&#39;setting&#39;, [&#39;setTheme&#39;]),...mapMutations(&#39;user&#39;, [&#39;setUser&#39;]),&#125;</code></pre><h2 id="二十、获取模块内的actions方法"><a href="#二十、获取模块内的actions方法" class="headerlink" title="二十、获取模块内的actions方法"></a>二十、获取模块内的actions方法</h2><h3 id="1-目标：-4"><a href="#1-目标：-4" class="headerlink" title="1.目标："></a>1.目标：</h3><p>掌握模块中 action 的调用语法 (同理 - 直接类比 mutation 即可)</p><h3 id="2-注意：-1"><a href="#2-注意：-1" class="headerlink" title="2.注意："></a>2.注意：</h3><p>默认模块中的 mutation 和 actions 会被挂载到全局，<strong>需要开启命名空间</strong>，才会挂载到子模块。</p><h3 id="3-调用语法："><a href="#3-调用语法：" class="headerlink" title="3.调用语法："></a>3.调用语法：</h3><ol><li>直接通过 store 调用   $store.dispatch(‘模块名&#x2F;xxx ‘,  额外参数)</li><li>通过 mapActions 映射     <ol><li>默认根级别的映射  mapActions([ ‘xxx’ ])     </li><li>子模块的映射 mapActions(‘模块名’, [‘xxx’])  -  需要开启命名空间</li></ol></li></ol><h3 id="4-代码实现-1"><a href="#4-代码实现-1" class="headerlink" title="4.代码实现"></a>4.代码实现</h3><p>需求：</p><p><img src="/assets/1683431615694.png" alt="68343161569"></p><p><code>modules/user.js</code></p><pre><code class="js">const actions = &#123;  setUserSecond (context, newUserInfo) &#123;    // 将异步在action中进行封装    setTimeout(() =&gt; &#123;      // 调用mutation   context上下文，默认提交的就是自己模块的action和mutation      context.commit(&#39;setUser&#39;, newUserInfo)    &#125;, 1000)  &#125;&#125;</code></pre><p>Son1.vue  直接通过store调用</p><pre><code class="vue">&lt;button @click=&quot;updateUser2&quot;&gt;一秒后更新信息&lt;/button&gt;methods:&#123;    updateUser2 () &#123;      // 调用action dispatch      this.$store.dispatch(&#39;user/setUserSecond&#39;, &#123;        name: &#39;xiaohong&#39;,        age: 28      &#125;)    &#125;,&#125;</code></pre><p>Son2.vue mapActions映射</p><pre><code class="js">&lt;button @click=&quot;setUserSecond(&#123; name: &#39;xiaoli&#39;, age: 80 &#125;)&quot;&gt;一秒后更新信息&lt;/button&gt;methods:&#123;  ...mapActions(&#39;user&#39;, [&#39;setUserSecond&#39;])&#125;</code></pre><h2 id="二十一、Vuex模块化的使用小结"><a href="#二十一、Vuex模块化的使用小结" class="headerlink" title="二十一、Vuex模块化的使用小结"></a>二十一、Vuex模块化的使用小结</h2><h3 id="1-直接使用"><a href="#1-直接使用" class="headerlink" title="1.直接使用"></a>1.直接使用</h3><ol><li>state –&gt; $store.state.<strong>模块名</strong>.数据项名</li><li>getters –&gt; $store.getters[‘<strong>模块名</strong>&#x2F;属性名’]</li><li>mutations –&gt; $store.commit(‘<strong>模块名</strong>&#x2F;方法名’, 其他参数)</li><li>actions –&gt; $store.dispatch(‘<strong>模块名</strong>&#x2F;方法名’, 其他参数)</li></ol><h3 id="2-借助辅助方法使用"><a href="#2-借助辅助方法使用" class="headerlink" title="2.借助辅助方法使用"></a>2.借助辅助方法使用</h3><p>1.import { mapXxxx, mapXxx } from ‘vuex’</p><p>computed、methods: {</p><p>​     &#x2F;&#x2F; <strong>…mapState、…mapGetters放computed中；</strong></p><p>​    &#x2F;&#x2F;  <strong>…mapMutations、…mapActions放methods中；</strong></p><p>​    …mapXxxx(<strong>‘模块名’</strong>, [‘数据项|方法’]),</p><p>​    …mapXxxx(<strong>‘模块名’</strong>, { 新的名字: 原来的名字 }),</p><p>}</p><p>2.组件中直接使用 属性 <code>&#123;&#123; age &#125;&#125;</code> 或 方法 <code>@click=&quot;updateAge(2)&quot;</code></p><h2 id="二十二、综合案例-创建项目"><a href="#二十二、综合案例-创建项目" class="headerlink" title="二十二、综合案例 - 创建项目"></a>二十二、综合案例 - 创建项目</h2><ol><li><p>脚手架新建项目 (注意：<strong>勾选vuex</strong>)      </p><p>版本说明：</p><p>vue2   vue-router3   vuex3               </p><p>vue3  vue-router4  vuex4&#x2F;pinia</p></li></ol><pre><code>vue create vue-cart-demo</code></pre><ol start="2"><li>将原本src内容清空，替换成教学资料的《vuex-cart-准备代码》</li></ol><p><img src="/assets/1683432959356.png" alt="68343295935"></p><p>需求：</p><ol><li>发请求动态渲染购物车，数据存vuex （存cart模块， 将来还会有user模块，article模块…）</li><li>数字框可以修改数据</li><li>动态计算总价和总数量</li></ol><h2 id="二十三、综合案例-构建vuex-cart模块"><a href="#二十三、综合案例-构建vuex-cart模块" class="headerlink" title="二十三、综合案例-构建vuex-cart模块"></a>二十三、综合案例-构建vuex-cart模块</h2><ol><li>新建 <code>store/modules/cart.js</code></li></ol><pre><code class="jsx">export default &#123;  namespaced: true,  state () &#123;    return &#123;      list: []    &#125;  &#125;,&#125;</code></pre><ol start="2"><li>挂载到 vuex 仓库上 <code>store/cart.js</code></li></ol><pre><code class="jsx">import Vuex from &#39;vuex&#39;import Vue from &#39;vue&#39;import cart from &#39;./modules/cart&#39;Vue.use(Vuex)const store = new Vuex.Store(&#123;  modules: &#123;    cart  &#125;&#125;)export default store</code></pre><h2 id="二十四、综合案例-准备后端接口服务环境-了解"><a href="#二十四、综合案例-准备后端接口服务环境-了解" class="headerlink" title="二十四、综合案例-准备后端接口服务环境(了解)"></a>二十四、综合案例-准备后端接口服务环境(了解)</h2><ol><li>安装全局工具 json-server （全局工具仅需要安装一次）</li></ol><pre><code>yarn global add json-server 或 npm i json-server  -g</code></pre><ol start="2"><li>代码根目录新建一个 db 目录</li><li>将资料 index.json 移入 db 目录</li><li>进入 db 目录，执行命令，启动后端接口服务 (使用–watch 参数 可以实时监听 json 文件的修改)</li></ol><pre><code>json-server  --watch  index.json</code></pre><h2 id="二十五、综合案例-请求动态渲染数据"><a href="#二十五、综合案例-请求动态渲染数据" class="headerlink" title="二十五、综合案例-请求动态渲染数据"></a>二十五、综合案例-请求动态渲染数据</h2><h3 id="1-目标-4"><a href="#1-目标-4" class="headerlink" title="1.目标"></a>1.目标</h3><p>请求获取数据存入 vuex, 映射渲染</p><p><img src="/assets/1683436471929.png" alt="68343647192"></p><ol><li>安装 axios</li></ol><pre><code class="jsx">yarn add axios</code></pre><ol start="2"><li>准备actions 和 mutations</li></ol><pre><code class="jsx">import axios from &#39;axios&#39;export default &#123;  namespaced: true,  state () &#123;    return &#123;      list: []    &#125;  &#125;,  mutations: &#123;    updateList (state, payload) &#123;      state.list = payload    &#125;  &#125;,  actions: &#123;    async getList (ctx) &#123;      const res = await axios.get(&#39;http://localhost:3000/cart&#39;)      ctx.commit(&#39;updateList&#39;, res.data)    &#125;  &#125;&#125;</code></pre><ol start="3"><li><code>App.vue</code>页面中调用 action,  获取数据</li></ol><pre><code class="jsx">import &#123; mapState &#125; from &#39;vuex&#39;export default &#123;  name: &#39;App&#39;,  components: &#123;    CartHeader,    CartFooter,    CartItem  &#125;,  created () &#123;    this.$store.dispatch(&#39;cart/getList&#39;)  &#125;,  computed: &#123;    ...mapState(&#39;cart&#39;, [&#39;list&#39;])  &#125;&#125;</code></pre><ol start="4"><li>动态渲染</li></ol><pre><code class="jsx">&lt;!-- 商品 Item 项组件 --&gt;&lt;cart-item v-for=&quot;item in list&quot; :key=&quot;item.id&quot; :item=&quot;item&quot;&gt;&lt;/cart-item&gt;</code></pre><p><code>cart-item.vue</code></p><pre><code class="jsx">&lt;template&gt;  &lt;div class=&quot;goods-container&quot;&gt;    &lt;!-- 左侧图片区域 --&gt;    &lt;div class=&quot;left&quot;&gt;      &lt;img :src=&quot;item.thumb&quot; class=&quot;avatar&quot; alt=&quot;&quot;&gt;    &lt;/div&gt;    &lt;!-- 右侧商品区域 --&gt;    &lt;div class=&quot;right&quot;&gt;      &lt;!-- 标题 --&gt;      &lt;div class=&quot;title&quot;&gt;&#123;&#123;item.name&#125;&#125;&lt;/div&gt;      &lt;div class=&quot;info&quot;&gt;        &lt;!-- 单价 --&gt;        &lt;span class=&quot;price&quot;&gt;￥&#123;&#123;item.price&#125;&#125;&lt;/span&gt;        &lt;div class=&quot;btns&quot;&gt;          &lt;!-- 按钮区域 --&gt;          &lt;button class=&quot;btn btn-light&quot;&gt;-&lt;/button&gt;          &lt;span class=&quot;count&quot;&gt;&#123;&#123;item.count&#125;&#125;&lt;/span&gt;          &lt;button class=&quot;btn btn-light&quot;&gt;+&lt;/button&gt;        &lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;CartItem&#39;,  props: &#123;    item: Object  &#125;,  methods: &#123;  &#125;&#125;&lt;/script&gt;</code></pre><h2 id="二十六、综合案例-修改数量"><a href="#二十六、综合案例-修改数量" class="headerlink" title="二十六、综合案例-修改数量"></a>二十六、综合案例-修改数量</h2><p><img src="/assets/1683437346997.png" alt="68343734699"></p><ol><li>注册点击事件</li></ol><pre><code class="jsx">&lt;!-- 按钮区域 --&gt;&lt;button class=&quot;btn btn-light&quot; @click=&quot;onBtnClick(-1)&quot;&gt;-&lt;/button&gt;&lt;span class=&quot;count&quot;&gt;&#123;&#123;item.count&#125;&#125;&lt;/span&gt;&lt;button class=&quot;btn btn-light&quot; @click=&quot;onBtnClick(1)&quot;&gt;+&lt;/button&gt;</code></pre><ol start="2"><li>页面中dispatch action</li></ol><pre><code class="jsx">onBtnClick (step) &#123;  const newCount = this.item.count + step  if (newCount &lt; 1) return  // 发送修改数量请求  this.$store.dispatch(&#39;cart/updateCount&#39;, &#123;    id: this.item.id,    count: newCount  &#125;)&#125;</code></pre><ol start="3"><li>提供action函数</li></ol><pre><code class="jsx">async updateCount (ctx, payload) &#123;  await axios.patch(&#39;http://localhost:3000/cart/&#39; + payload.id, &#123;    count: payload.count  &#125;)  ctx.commit(&#39;updateCount&#39;, payload)&#125;</code></pre><ol start="4"><li>提供mutation处理函数</li></ol><pre><code class="jsx">mutations: &#123;  ...,  updateCount (state, payload) &#123;    const goods = state.list.find((item) =&gt; item.id === payload.id)    goods.count = payload.count  &#125;&#125;,</code></pre><h2 id="二十七、综合案例-底部总价展示"><a href="#二十七、综合案例-底部总价展示" class="headerlink" title="二十七、综合案例-底部总价展示"></a>二十七、综合案例-底部总价展示</h2><ol><li>提供getters</li></ol><pre><code class="jsx">getters: &#123;  total(state) &#123;    return state.list.reduce((p, c) =&gt; p + c.count, 0);  &#125;,  totalPrice (state) &#123;    return state.list.reduce((p, c) =&gt; p + c.count * c.price, 0);  &#125;,&#125;,</code></pre><ol start="2"><li>动态渲染</li></ol><pre><code class="jsx">&lt;template&gt;  &lt;div class=&quot;footer-container&quot;&gt;    &lt;!-- 中间的合计 --&gt;    &lt;div&gt;      &lt;span&gt;共 &#123;&#123;total&#125;&#125; 件商品，合计：&lt;/span&gt;      &lt;span class=&quot;price&quot;&gt;￥&#123;&#123;totalPrice&#125;&#125;&lt;/span&gt;    &lt;/div&gt;    &lt;!-- 右侧结算按钮 --&gt;    &lt;button class=&quot;btn btn-success btn-settle&quot;&gt;结算&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; mapGetters &#125; from &#39;vuex&#39;export default &#123;  name: &#39;CartFooter&#39;,  computed: &#123;    ...mapGetters(&#39;cart&#39;, [&#39;total&#39;, &#39;totalPrice&#39;])  &#125;&#125;&lt;/script&gt;</code></pre>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
