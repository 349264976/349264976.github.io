<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>图灵商城开发</title>
      <link href="/2023/08/02/%E5%9B%BE%E7%81%B5%E5%95%86%E5%9F%8E%E5%BC%80%E5%8F%91/"/>
      <url>/2023/08/02/%E5%9B%BE%E7%81%B5%E5%95%86%E5%9F%8E%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="图片一"><a href="#图片一" class="headerlink" title="图片一"></a>图片一</h1><p><img src="/2023/08/02/%E5%9B%BE%E7%81%B5%E5%95%86%E5%9F%8E%E5%BC%80%E5%8F%91/personboke\blog\source_posts\图灵商城开发\Snipaste_2023-08-02_23-19-04.png" alt="Snipaste_2023-08-02_23-19-04"></p><h1 id="图片2直接截图"><a href="#图片2直接截图" class="headerlink" title="图片2直接截图"></a>图片2直接截图</h1><p><img src="/2023/08/02/%E5%9B%BE%E7%81%B5%E5%95%86%E5%9F%8E%E5%BC%80%E5%8F%91/personboke/blog/source/_posts/图灵商城开发/01.png" alt="01"><img src="/2023/08/02/%E5%9B%BE%E7%81%B5%E5%95%86%E5%9F%8E%E5%BC%80%E5%8F%91/personboke\blog\source_posts\图灵商城开发\image-20230802233505512.png" alt="image-20230802233505512"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java集成短信服务</title>
      <link href="/2023/08/01/java%E9%9B%86%E6%88%90%E7%9F%AD%E4%BF%A1%E6%9C%8D%E5%8A%A1/"/>
      <url>/2023/08/01/java%E9%9B%86%E6%88%90%E7%9F%AD%E4%BF%A1%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="java集成短信服务"><a href="#java集成短信服务" class="headerlink" title="java集成短信服务"></a>java集成短信服务</h1><h2 id="注册一个帐号"><a href="#注册一个帐号" class="headerlink" title="注册一个帐号"></a>注册一个帐号</h2><p>使用的是<strong>容联云</strong>，百度搜一下官网</p><p>用手机注册一个帐号就行，免费体验不需要认证<br>注册后会有八块钱送，可以使用免费的给自己设置三个固定手机号发送短信，不需要认证。</p><p><img src="/2023/08/01/java%E9%9B%86%E6%88%90%E7%9F%AD%E4%BF%A1%E6%9C%8D%E5%8A%A1/personboke\blog\source_posts\java集成短信服务\image-20230801212907523.png" alt="image-20230801212907523"></p><p><strong>此页面的 三个信息需要在代码中去进行填写认证</strong></p><p>主账户</p><p>账户授权令牌</p><p>访问的Rest URl</p><p>APP id</p><h1 id="绑定用于接收短信的手机号"><a href="#绑定用于接收短信的手机号" class="headerlink" title="绑定用于接收短信的手机号"></a>绑定用于接收短信的手机号</h1><p>控制台—管理—号码管理—测试号码”绑定 测试号码</p><p><img src="/2023/08/01/java%E9%9B%86%E6%88%90%E7%9F%AD%E4%BF%A1%E6%9C%8D%E5%8A%A1/personboke\blog\source_posts\java集成短信服务\image-20230801213129678.png" alt="image-20230801213129678"></p><h3 id="添加maven依赖"><a href="#添加maven依赖" class="headerlink" title="添加maven依赖"></a>添加maven依赖</h3><p>jdk要使用8以上</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;com.cloopen&lt;/groupId&gt;    &lt;artifactId&gt;java-sms-sdk&lt;/artifactId&gt;    &lt;version&gt;1.0.3&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><p>我们需要把以上<strong>四个信息</strong>填入，还有接收短信的<strong>手机号码</strong>，<strong>验证码</strong>需要自己手动生成，（这里使用四位随机整数），然后将这些信息传到短信服务平台帮我们发送。</p><pre><code class="java">@Componentpublic class SendMessage &#123;        public static String message(String phone)&#123;            //返回产生的验证码            String code= null;            //生产环境请求地址：app.cloopen.com            String serverIp = &quot;app.cloopen.com&quot;;            //请求端口            String serverPort = &quot;8883&quot;;            //主账号,登陆云通讯网站后,可在控制台首页看到开发者主账号ACCOUNT SID和主账号令牌AUTH TOKEN            String accountSId =&quot;自己的&quot;;            String accountToken = &quot;自己的&quot;;            //请使用管理控制台中已创建应用的APPID            String appId = &quot;自己的&quot;;            CCPRestSmsSDK sdk = new CCPRestSmsSDK();            sdk.init(serverIp, serverPort);            sdk.setAccount(accountSId, accountToken);            sdk.setAppId(appId);            sdk.setBodyType(BodyType.Type_JSON);            //手机号码            String to = phone;            String templateId= &quot;1&quot;;//使用的模板id            //生成四位随机数            int random=(int)(Math.random()*10000);            code = String.valueOf(random);            String[] datas = &#123;code,&quot;2&quot;&#125;;//格式:你的验证码是&#123;code&#125;，请于&#123;2&#125;分钟内正确输入            //HashMap&lt;String, Object&gt; result = sdk.sendTemplateSMS(to,templateId,datas);            HashMap&lt;String, Object&gt; result = sdk.sendTemplateSMS(to,templateId,datas);            if(&quot;000000&quot;.equals(result.get(&quot;statusCode&quot;)))&#123;                //正常返回输出data包体信息（map）                HashMap&lt;String,Object&gt; data = (HashMap&lt;String, Object&gt;) result.get(&quot;data&quot;);                Set&lt;String&gt; keySet = data.keySet();                for(String key:keySet)&#123;                    Object object = data.get(key);                    System.out.println(key +&quot; = &quot;+object);                &#125;            &#125;else&#123;                //异常返回输出错误码和错误信息                System.out.println(&quot;错误码=&quot; + result.get(&quot;statusCode&quot;) +&quot; 错误信息= &quot;+result.get(&quot;statusMsg&quot;));            &#125;            return code;        &#125;&#125;</code></pre><h2 id="调用方法一并附上防止有看不懂的"><a href="#调用方法一并附上防止有看不懂的" class="headerlink" title="调用方法一并附上防止有看不懂的"></a>调用方法一并附上防止有看不懂的</h2><pre><code>package com.atheima.reggie.controller;import com.atheima.reggie.Utils.SendMessageUtils;import com.atheima.reggie.Utils.ValidateCodeUtils;import com.atheima.reggie.common.R;import com.atheima.reggie.common.SendMessage;import com.atheima.reggie.entity.User;import com.atheima.reggie.service.UserService;import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;import java.util.Map;import java.util.concurrent.TimeUnit;import javax.servlet.http.HttpSession;import lombok.extern.slf4j.Slf4j;import org.apache.commons.lang.StringUtils;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.core.TimeoutUtils;import org.springframework.web.bind.annotation.*;@RestController@RequestMapping(&quot;/user&quot;)@Slf4jpublic class UserController &#123;    @Autowired    private UserService userService;    @Autowired    private RedisTemplate redisTemplate;    @Autowired    private SendMessage sendMessage;    @PostMapping(&quot;/sendMsg&quot;)    public R&lt;String&gt; sendMessage(@RequestBody User user, HttpSession session)&#123;        String phone=user.getPhone();        //获取手机号//        if (StringUtils.isNotEmpty(phone))&#123;//            //生成随机的四位验证码//            Integer integer = ValidateCodeUtils.generateValidateCode(4);//            String code = integer.toString();////            SendMessageUtils.message(phone);//            //调用api短信//            //需要生成的验证码保存到session////            session.setAttribute(phone,code);//            //将生成的验证码缓存到redis中并且设置有效期5分钟//            redisTemplate.opsForValue().set(phone,code,5,TimeUnit.MINUTES);//            log.info(&quot;Sent message&quot;+code);//        SendMessage()        String code=sendMessage.message(phone);        if (StringUtils.isNotEmpty(code))&#123;            session.setAttribute(phone,code);          //将生成的验证码缓存到redis中并且设置有效期5分钟            redisTemplate.opsForValue().set(phone,code,5,TimeUnit.MINUTES);            log.info(&quot;Sent message&quot;+code);            return R.success(&quot;验证码登录成功&quot;);        &#125;        return R.success(&quot;验证码登录失败&quot;);        &#125;    @PostMapping(&quot;/login&quot;)    public R&lt;User&gt; login(@RequestBody Map map,HttpSession session)&#123;        log.info(map.toString());        String phone = map.get(&quot;phone&quot;).toString();        String code = map.get(&quot;code&quot;).toString();        //从cookie中//        String phonecodeinsessoin =(String) session.getAttribute(phone);        //从Redis中获取缓存验证码        String phonecodeinsessoin=(String) redisTemplate.opsForValue().get(phone);        if (phonecodeinsessoin!=null&amp;&amp;phonecodeinsessoin.equals(code))&#123;            LambdaQueryWrapper&lt;User&gt; lambdaQueryWrapper=new LambdaQueryWrapper&lt;&gt;();            lambdaQueryWrapper.eq(User::getPhone,phone);            User user = userService.getOne(lambdaQueryWrapper);            if (user==null)&#123;                user=new User();                user.setPhone(phone);                user.setStatus(1);                userService.save(user);            &#125;            session.setAttribute(&quot;user&quot;,user.getId());            //如果用户登陆成功则删除缓存验证码            redisTemplate.delete(phone);            return R.success(user);        &#125;        return R.error(&quot;登陆失败&quot;);    &#125;    @PostMapping(&quot;/loginout&quot;)    public R&lt;String&gt; loginout(@RequestBody Map map,HttpSession session)&#123;        session.removeAttribute(&quot;user&quot;);        return R.success(&quot;退出成功&quot;);    &#125;&#125;</code></pre><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img src="/2023/08/01/java%E9%9B%86%E6%88%90%E7%9F%AD%E4%BF%A1%E6%9C%8D%E5%8A%A1/personboke\blog\source_posts\java集成短信服务\image-20230801213715539.png" alt="image-20230801213715539"></p><p>Springboot集成qq邮箱<br>自己以前做过就不多赘述<br>以下文章来自博客<br><a href="https://blog.csdn.net/sdrfghb/article/details/126845550">https://blog.csdn.net/sdrfghb/article/details/126845550</a>?<br>提示：以下是本篇文章正文内容，下面案例可供参考</p><p>邮箱设置<br>这边主要展示qq邮箱设置，网易或别的邮箱请自行百度设置</p><p>qq邮箱地址<br>打开账号POP3&#x2F;SMTP服务</p><p>注意保存授权码</p><p>添加依赖，为了让验证码页面好看点，咱们可以使用thymeleaf</p><p>org.springframework.boot spring-boot-starter-mail org.springframework.boot spring-boot-starter-thymeleaf<br>yaml 配置<br>spring:<br>mail:</p><h1 id="邮箱服务器地址"><a href="#邮箱服务器地址" class="headerlink" title="邮箱服务器地址"></a>邮箱服务器地址</h1><p>host: smtp.qq.com</p><h1 id="账号"><a href="#账号" class="headerlink" title="账号"></a>账号</h1><p>username: qq号</p><h1 id="密码"><a href="#密码" class="headerlink" title="密码"></a>密码</h1><p>password: 上面qq邮箱的授权码</p><h1 id="编码格式"><a href="#编码格式" class="headerlink" title="编码格式"></a>编码格式</h1><p>default-encoding: UTF-8</p><h1 id="超时时间"><a href="#超时时间" class="headerlink" title="超时时间"></a>超时时间</h1><p>properties:<br>mail:<br>smtp:<br>auth: true<br>enable: true<br>connectiontimeout: 10000<br>timeout: 10000<br>writetimeout: 10000</p><h1 id="配置SSL-加密工厂"><a href="#配置SSL-加密工厂" class="headerlink" title="配置SSL 加密工厂"></a>配置SSL 加密工厂</h1><p>socketFactoryClass: javax.net.ssl.SSLSocketFactory</p><h1 id="表示开启-DEBUG-模式，这样，邮件发送过程的日志会在控制台打印出来，方便排查错误"><a href="#表示开启-DEBUG-模式，这样，邮件发送过程的日志会在控制台打印出来，方便排查错误" class="headerlink" title="表示开启 DEBUG 模式，这样，邮件发送过程的日志会在控制台打印出来，方便排查错误"></a>表示开启 DEBUG 模式，这样，邮件发送过程的日志会在控制台打印出来，方便排查错误</h1><p>debug: true</p><p>封装工具类<br>&#x2F;**</p><ul><li><p>description: 使用thymeleaf模板发送邮件</p></li><li></li><li><p>@param subject 主题</p></li><li><p>@param map Thymeleaf html模板参数</p></li><li><p>@param htmlName 模板名称</p></li><li><p>@param addressee 收件人</p></li><li><p>@return boolean</p></li><li><p>@author Tigger<br>*&#x2F;<br>public boolean sendThymeleafMail(String subject, Map&lt;String, Object&gt; map, String htmlName, String… addressee) {<br>boolean flag &#x3D; false;<br>try {<br>MimeMessage mimeMessage &#x3D; javaMailSender.createMimeMessage();<br>MimeMessageHelper mimeMessageHelper &#x3D; null;<br>mimeMessageHelper &#x3D; new MimeMessageHelper(mimeMessage, true);<br>&#x2F;&#x2F; 邮件发送者<br>mimeMessageHelper.setFrom(from);<br>&#x2F;&#x2F; 邮件接受者<br>mimeMessageHelper.setTo(addressee);<br>&#x2F;&#x2F; 主题<br>mimeMessageHelper.setSubject(subject);</p><pre><code>  // 这里引入的是Template的Context  Context context = new Context();  // 设置模板中的变量  context.setVariables(map);  // 第一个参数为模板的名称  String process = templateEngine.process(htmlName, context);  // 第二个参数true表示这是一个html文本  mimeMessageHelper.setText(process,true);  javaMailSender.send(mimeMessage);  flag = true;</code></pre><p>  }<br>  catch (MessagingException e) {<br>  e.printStackTrace();<br>  }<br>  return flag;</p></li></ul><p>}</p><p>16<br>使用，这边使用了lombok和redis，需要的自己引下依赖，不需要的自行删除。<br>&#x2F;**</p><p>description: 生成指定位数短信验证码<br>@param count 指定位数<br>@return java.lang.String<br>@author Tigger<br><em>&#x2F;<br>private String getRandCode(int count) {<br>return String.valueOf((int)((Math.random()9+1) Math.pow(10,count-1)));<br>}<br>&#x2F;</em>*</p><p>description: 发送邮箱验证码<br>@param mailNumber 发送邮箱账号<br>@return java.lang.String<br>@author Tigger<br>*&#x2F;<br>public String sendCodeMailInfo(String mailNumber) {<br>String sendMessage &#x3D; null;<br>String randCode &#x3D; getRandCode(6);<br>log.info(“邮箱验证码-{}”, randCode);<br>Map&lt;String, Object&gt; stringObjectMap &#x3D; new HashMap&lt;&gt;(1);<br>stringObjectMap.put(“codeMessage”, randCode);<br>boolean mail &#x3D; mailUtil.sendThymeleafMail(“验证码”, stringObjectMap, “mailAssign.html”, mailNumber);<br>if (mail) {<br>log.info(“邮箱验证码发送成功”);<br>&#x2F;&#x2F; 将验证码放入redis<br>boolean set &#x3D; redisUtil.set(mailNumber + FinalCode.REDIS_Mail_SMS, randCode, FinalCode.SECOND_NUMBER);<br>if (set) {<br>log.info(“短信验证码缓存成功”);<br>}<br>sendMessage &#x3D; “邮箱验证码发送成功”;<br>}<br>return sendMessage;<br>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>javascript关键点</title>
      <link href="/2023/07/17/javascript%E5%85%B3%E9%94%AE%E7%82%B9/"/>
      <url>/2023/07/17/javascript%E5%85%B3%E9%94%AE%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="javascript关键点"><a href="#javascript关键点" class="headerlink" title="javascript关键点"></a>javascript关键点</h1><h3 id="object的属性"><a href="#object的属性" class="headerlink" title="object的属性"></a>object的属性</h3><p>给object对象拓展一个属性 dosome方法</p><p>这里所有的对象都可以用这个拓展方法</p><pre><code>Object.prototype.dosome=function（）&#123;        .........&#125;</code></pre><h3 id="js中怎样定义类"><a href="#js中怎样定义类" class="headerlink" title="js中怎样定义类"></a>js中怎样定义类</h3><p><strong>方式一</strong></p><pre><code>function 类名(形参1，形参....)&#123;this.属性=参数；this.属性=参数；.....&#125;</code></pre><p><strong>方式二</strong></p><pre><code>类名=function(形参1，形参....)&#123;this.属性=参数；this.属性=参数；.....&#125;</code></pre><p>这里为什么这么熟悉？</p><p>没错很熟悉，这里就是函数的定义</p><p>关键看如何调用</p><p>如果直接使用</p><pre><code>function example(形参1，形参....)&#123;this.属性=参数；this.属性=参数；.....&#125;example();</code></pre><p>这种写法即是简单函数的调用不会再浏览器堆里开辟空间</p><pre><code>function example(形参1，形参....)&#123;this.属性=参数；this.属性=参数；.....&#125;var obj=new example();</code></pre><p>这种写法即表示创建了一个对象</p><p>example</p><pre><code>function student(形参1，形参....)&#123;this.属性=参数；this.属性=参数；this.work=function()&#123;    .......&#125;.....&#125;var student1=new student(x1,x2,x3);</code></pre><h4 id="访问一个对象属性方式"><a href="#访问一个对象属性方式" class="headerlink" title="访问一个对象属性方式"></a>访问一个对象属性方式</h4><p>object.属性</p><p>object[属性]</p><h4 id="null-NaN-undefine的区别"><a href="#null-NaN-undefine的区别" class="headerlink" title="null NaN undefine的区别"></a>null NaN undefine的区别</h4><p><strong>&#x3D;&#x3D;&#x3D; 和&#x3D;&#x3D; 和&#x3D;的区别</strong></p><p>&#x3D;赋值操作 赋值操作</p><p>&#x3D;&#x3D;比较值是否相等 等同运算符</p><p>&#x3D;&#x3D;&#x3D;比较内容以及数据类型是否相同 全等运算符</p><p>typeof（null） &#x3D; object</p><p>typeof（NaN） &#x3D;number</p><p>typeof（undefine） &#x3D;undefine</p><p>&#x3D;&#x3D;的时候 null&#x3D;&#x3D;undefine 为true其余皆为false</p><h1 id="js的常用事件操作"><a href="#js的常用事件操作" class="headerlink" title="js的常用事件操作"></a>js的常用事件操作</h1><p><strong>JS的常用事件</strong>：</p><pre><code>                （1）blur失去焦点                （5）focus获得焦点                                （3）click鼠标单击                （4）dblclick鼠标双击                                （6）keydown键盘按下                （7）keyup键盘弹起                                （9）mousedown鼠标按下                （10）mouseover鼠标经过                （11）mousemove鼠标移动                （12）mouseout鼠标离开                （13）mouseup鼠标弹起                                （16）submit表单提交                （14）reset表单重置                                （15）select文本被选定                （2）change下拉列表选中项改变，或文本框内容改变                （8）load页面加载完毕                            提醒：任何一个事件都有对应的事件句柄。事件句柄是在事件名称前添加on就行。</code></pre><p><strong>注意：当页面加载的过程中我们定义的事件都会加载 但是并不会执行</strong></p><p><strong>当我们触发到某一事件之后会调用函数 此时调用函数的是浏览器的监听器调用的</strong></p><p><strong>此时这些函数被称为回调函数</strong></p><p>BOM操作简单来说是修改浏览器的操作比如迁建后退 或者…</p><p>顶级对象即为 window.属性</p><p><strong>获取html的id对应的标签</strong> 也就是DOM操作</p><p>顶级对象为Document.对象</p><pre><code>alert(&quot;阻止程序的执行！&quot;)            // 根据id获取元素/节点对象            // 在JS当中有一个内置的隐含的对象叫做:document            // document代表整个HTML文档.            // 在JS当中有一个内置的隐含的对象叫做:window            // window代表整个浏览器窗口.            // window对象是BOM的顶级对象,BOM中的老大.            // document对象是DOM的顶级对象,DOM中的老大.            // 严格意义上来说,window是包含document的.            var mybtnElt = document.getElementById(&quot;mybtn&quot;);                        //console.log(mybtnElt)            //alert(mybtnElt) //[object HTMLInputElement]                        // 重点:在JS当中,当你获取了一个节点之后,这个节点中有什么属性你就可以&quot;点&quot;什么.            //mybtnElt.type = &quot;checkbox&quot;;            //mybtnElt.type = &quot;text&quot;;            mybtnElt.value = &quot;我是一个按钮对象哦！&quot;;</code></pre><p><strong>注册事件的第二种方式</strong></p><pre><code>    /* 定义一个函数 */            function sum()&#123;                console.log(&quot;sum function invoke!&quot;)            &#125;                        /* 根据id获取button对象 */            var hellobtnElt = document.getElementById(&quot;hellobtn&quot;);                        // 元素中有什么属性,就能&quot;点&quot;什么.            /* 这行代码在页面打开的时候会执行，这行代码执行的意义是：将sum这个回调函数绑定到hellobtn的click事件上 */            /* 这个回调函数sum在什么时候执行？click事件发生之后才会被监听器调用！ */            //hellobtnElt.onclick = sum  //不要这样写: hellobtnElt.onclick = sum()                        // 回调函数可以是一个匿名函数            // 这行代码的执行只是完成事件click的注册,给click事件注册一个回调函数.            // 这行代码执行的时候，回调函数并不会被执行。            // 只有当这个按钮发生click事件之后,这个回调函数会自动被监听器来调用.            hellobtnElt.onclick = function()&#123;                console.log(&quot;我是一个回调函数，同时我没有名字，叫做匿名函数！&quot;)            &#125;            </code></pre><h3 id="onload事件的绑定"><a href="#onload事件的绑定" class="headerlink" title="onload事件的绑定"></a>onload事件的绑定</h3><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;onload事件句柄&lt;/title&gt;    &lt;/head&gt;    &lt;!-- 页面加载完毕之后监听器调用myfun()回调函数 --&gt;    &lt;!-- &lt;body onload=&quot;myfun()&quot;&gt; --&gt;    &lt;!-- &lt;body id=&quot;mybody&quot;&gt; --&gt;    &lt;body&gt;                &lt;script type=&quot;text/javascript&quot;&gt;                        /* function myfun()&#123;                console.log(&quot;myfun execute!~~~~~~~~~~~~~~&quot;)            &#125; */                        // 这种方式可以,就是代码有点多,在JS当中,window对象也可以onload.            //var mybodyElt = document.getElementById(&quot;mybody&quot;);            //mybodyElt.onload = myfun                        /* 在页面打开的时候，以下这行代码会执行，这行代码执行的作用是：将回调函数myfun注册到load事件上 */            /* 当页面全部加载完毕之后，会发生load事件，load事件发生之后，监听器负责调用回调函数myfun */            //window.onload = myfun                        // load事件发生之后,后面的“匿名回调函数”会被监听器调用.            window.onload = function()&#123;                console.log(&quot;hello world!&quot;)            &#125;                        // 页面打开的过程中实际上是各种事件的绑定.            // 等这些事件一个一个发生之后,回调函数统一都是由监听器来负责调用的.            /* xxxElt.onclick = function()&#123;&#125;            xxxElt.onblur = function()&#123;&#125; */                    &lt;/script&gt;                    &lt;/body&gt;    &lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt;    alert(&quot;页面加载过程中！&quot;)&lt;/script&gt;</code></pre><h1 id="捕捉键盘回车进行确认登陆"><a href="#捕捉键盘回车进行确认登陆" class="headerlink" title="捕捉键盘回车进行确认登陆"></a>捕捉键盘回车进行确认登陆</h1><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;捕捉回车键（怎么在JS中捕捉键值。）&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;                &lt;script type=&quot;text/javascript&quot;&gt;                        /* function sum(x , y)&#123;                            &#125;                        sum();            sum(1);            sum(1,2);            sum(1,2,3);            */                       /* function myfun()&#123;                console.log(&quot;执行了myfun....没有参数的！&quot;)            &#125; */                        /* function myfun(fdsafdsafds)&#123;                console.log(&quot;执行了myfun....有参数的！&quot;)            &#125;                        myfun(&quot;abc&quot;) */                                    // x, y都是变量名,随意的,随便写.只要符合标识符命名规范就行.            window.onload = function(x)&#123; // x代表的就是load事件对象.                // 给id=&quot;username&quot;的节点绑定keydown事件                // 后面的这个回调函数是我们负责编写的,但是调用者是监听器.                // 监听器调用这个回调函数的时候会传过来一个事件对象.                // 你如果需要使用这个事件对象的时候,你可以写上,你不需要这个事件对象的时候,可以省略.                document.getElementById(&quot;username&quot;).onkeydown = function(y)&#123; // y代表的就是一个keydown事件对象.                    //console.log(&quot;keydown.....&quot;)                    // 在这里捕捉键值,当用户敲回车键了,则登录                    // 新知识点:所有的“键盘事件对象”,有keyCode属性,这个keyCode属性可以获取键值.                    // keyCode是键盘事件对象的属性.                    // 记住:键盘上回车键的键值永远都是13.ECS键的键值永远都是27.                    if(y.keyCode == 13) &#123;                        console.log(&quot;登录，正在进行身份认证，请稍后...&quot;);                    &#125;else if(y.keyCode == 27)&#123;                        console.log(&quot;系统安全退出了！&quot;)                    &#125;                &#125;            &#125;                    &lt;/script&gt;                用户名：&lt;input type=&quot;text&quot; id=&quot;username&quot; /&gt;            &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="事件的完美案例"><a href="#事件的完美案例" class="headerlink" title="事件的完美案例"></a>事件的完美案例</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;事件的最后一个完美的案例&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;script type=&quot;text/javascript&quot;&gt;                        /* 这段代码有3个回调函数。 */            /* 最外层的回调函数是在load事件发生之后才会执行！ */            window.onload = function()&#123;                            /* //给id=&quot;btn1&quot;的元素绑定鼠标单击                var btn1Elt = document.getElementById(&quot;btn1&quot;);                btn1Elt.onclick = function()&#123; // btn1被单击click之后,这个事件发生了,才会执行这个回调函数                    console.log(&quot;按钮1被点击了！&quot;)                &#125;                                //给id=&quot;btn2&quot;的元素绑定鼠标单击                var btn2Elt = document.getElementById(&quot;btn2&quot;);                btn2Elt.onclick = function()&#123;// btn2被单击click之后,这个事件发生了,才会执行这个回调函数                    console.log(&quot;按钮2被点击了！&quot;)                &#125; */                                document.getElementById(&quot;btn1&quot;).onclick = function()&#123;                    console.log(&quot;按钮1单击&quot;)                &#125;                                document.getElementById(&quot;btn2&quot;).onclick = function()&#123;                    console.log(&quot;按钮2单击&quot;)                &#125;                                document.getElementById(&quot;username&quot;).onblur = function()&#123;                    console.log(&quot;失去焦点了&quot;)                &#125;                            &#125;                    &lt;/script&gt;                &lt;input type=&quot;button&quot; id=&quot;btn1&quot; value=&quot;按钮1&quot;/&gt;        &lt;br&gt;        &lt;input type=&quot;button&quot; id=&quot;btn2&quot; value=&quot;按钮2&quot;/&gt;        &lt;br&gt;        &lt;input type=&quot;text&quot; id=&quot;username&quot; /&gt;            &lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="js的void函数"><a href="#js的void函数" class="headerlink" title="js的void函数"></a>js的void函数</h3><p>一般只用在href后面用于点击不跳转</p><h3 id="js的循环语句"><a href="#js的循环语句" class="headerlink" title="js的循环语句"></a>js的循环语句</h3><p>for in 这里面的循环遍历数组得到的是数组的下标</p><pre><code>for(var index in arr)&#123;&#125;</code></pre><p>循环遍历一个对象的话就会得到对象的属性</p><pre><code>for(var 属性 in person)&#123;        &#125;</code></pre><h3 id="js的数组中的基本方法"><a href="#js的数组中的基本方法" class="headerlink" title="js的数组中的基本方法"></a>js的数组中的基本方法</h3><pre><code>arr.push（）添加的元素都是加到最后arr.pop（）弹出末尾元素弹出并且数组长度减一可以模拟栈的数据结构先进后出arr.reverse()反转数组连接数组arr.join（$）数组中的元素将按照下标拼接arr[0]$arr[1]$......</code></pre><h3 id="js中的日期类型"><a href="#js中的日期类型" class="headerlink" title="js中的日期类型"></a>js中的日期类型</h3><p>…….</p><p><a href="file:///C:/Users/李开恩/AppData/Roaming/Typora/typora-user-images/image-20230716125505572.png"><img src="file:///C:/Users/%E6%9D%8E%E5%BC%80%E6%81%A9/AppData/Roaming/Typora/typora-user-images/image-20230716125505572.png" alt="image-20230716125505572"></a></p><h3 id="BOM和DOM区别"><a href="#BOM和DOM区别" class="headerlink" title="BOM和DOM区别"></a>BOM和DOM区别</h3><h4 id="1-BOM和DOM的区别与联系"><a href="#1-BOM和DOM的区别与联系" class="headerlink" title="1. BOM和DOM的区别与联系"></a>1. <strong>BOM和DOM的区别与联系</strong></h4><p>BOM: Browser Object Model（浏览器对象模型），通过BOM的对象和方法可以完成浏览器窗口的操作，例如：关闭浏览器，前进，后退，修改地址栏上的地址等，这些操作都属于BOM。BOM的顶级内置对象是window。</p><p>DOM: Document Object Model（文档对象模型），通过DOM的对象和方法可以完成网页中元素的增删改，让网页产生动态效果，DOM的顶级内置对象是document。</p><p><a href="file:///C:/Users/李开恩/AppData/Local/Temp/ksohtml17920/wps2.png"><img src="file:///C:/Users/%E6%9D%8E%E5%BC%80%E6%81%A9/AppData/Local/Temp/ksohtml17920/wps2.png" alt="img"></a></p><h3 id="BOM操作"><a href="#BOM操作" class="headerlink" title="BOM操作"></a>BOM操作</h3><p>onclick&#x3D; Window.open（’网址’）</p><p>开启一个新窗口</p><p><a href="file:///C:/Users/李开恩/AppData/Roaming/Typora/typora-user-images/image-20230716150220309.png"><img src="file:///C:/Users/%E6%9D%8E%E5%BC%80%E6%81%A9/AppData/Roaming/Typora/typora-user-images/image-20230716150220309.png" alt="image-20230716150220309"></a></p><p>window.confirm弹窗 点击确认返回true 取消则返回false</p><p>window.alert(内容) 弹出内容</p><p>跳转页面可以通过多种方式：（这些都是发送请求！！！！）</p><h3 id="JS中发送请求的几种方式"><a href="#JS中发送请求的几种方式" class="headerlink" title="JS中发送请求的几种方式"></a>JS中发送请求的几种方式</h3><pre><code>            第一种方式：直接在浏览器地址栏上写URL。（重点）                        第二种方式：可以点击超链接（重点）                        第三种方式：提交表单（重点）                        第四种方式：window.open(url,target)  （了解）                        第五种方式：js代码（重点）                        window.location.href                        window.location                        document.location.href                        document.location                                    通过浏览器向服务器发送请求，通常是以上的五种方式。</code></pre><p>eval（字符串）</p><p>这个函数可以解析并执行以字符串来写的js代码</p><h3 id="js中的json-对象解析以及字符串拼接实现table中的tbody内容"><a href="#js中的json-对象解析以及字符串拼接实现table中的tbody内容" class="headerlink" title="js中的json 对象解析以及字符串拼接实现table中的tbody内容"></a>js中的json 对象解析以及字符串拼接实现table中的tbody内容</h3><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;My Cesium.js App&lt;/title&gt;   &lt;/head&gt;&lt;body&gt;            &lt;script type=&quot;text/javascript&quot;&gt;        /* 从java过来一个json格式的字符串 */        var fromJava = &quot;&#123;\&quot;total\&quot; : 2, \&quot;students\&quot; : [&#123;\&quot;name\&quot;:\&quot;李四\&quot;,\&quot;age\&quot;:19&#125;,&#123;\&quot;name\&quot;:\&quot;王五\&quot;,\&quot;age\&quot;:18&#125;]&#125;&quot;;                window.onload = function()&#123;            document.getElementById(&quot;displaybtn&quot;).onclick = function()&#123;                // 解析上面的json格式的字符串,将解析出来的数据放到tbody当中.                // 转化json对象                window.eval(&quot;var json = &quot; + fromJava) //json对象有了.                // 设置总记录条数                document.getElementById(&quot;totalSpan&quot;).innerHTML = json.total;                // 拼接HTML                var studentArray = json.students;                var html = &quot;&quot;;                for(var i = 0; i &lt; studentArray.length; i++)&#123;                    var s = studentArray[i]                    html += &quot;&lt;tr&gt;&quot;;                    html += &quot;&lt;td&gt;&quot;+(i+1)+&quot;&lt;/td&gt;&quot;;                    html += &quot;&lt;td&gt;&quot;+s.name+&quot;&lt;/td&gt;&quot;;                    html += &quot;&lt;td&gt;&quot;+s.age+&quot;&lt;/td&gt;&quot;;                    html += &quot;&lt;/tr&gt;&quot;;                &#125;                // 将以上拼接的HTML设置到tbody当中                document.getElementById(&quot;stutbody&quot;).innerHTML = html;            &#125;        &#125;            &lt;/script&gt;        &lt;input type=&quot;button&quot; value=&quot;查看学生信息列表&quot; id=&quot;displaybtn&quot; /&gt;    &lt;hr &gt;        &lt;table border=&quot;1px&quot; width=&quot;40%&quot;&gt;        &lt;tr&gt;            &lt;th&gt;序号&lt;/th&gt;            &lt;th&gt;学生姓名&lt;/th&gt;            &lt;th&gt;学生年龄&lt;/th&gt;        &lt;/tr&gt;        &lt;tbody id=&quot;stutbody&quot;&gt;            &lt;!-- &lt;tr&gt;                &lt;td&gt;1&lt;/td&gt;                &lt;td&gt;张三&lt;/td&gt;                &lt;td&gt;20&lt;/td&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td&gt;2&lt;/td&gt;                &lt;td&gt;李四&lt;/td&gt;                &lt;td&gt;22&lt;/td&gt;            &lt;/tr&gt; --&gt;        &lt;/tbody&gt;    &lt;/table&gt;    总记录条数：&lt;span id=&quot;totalSpan&quot;&gt;0&lt;/span&gt;条    &lt;!-- 总记录条数：2条 --&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="正则表达式东西"><a href="#正则表达式东西" class="headerlink" title="正则表达式东西"></a>正则表达式东西</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;正则表达式&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;script type=&quot;text/javascript&quot;&gt;            /*                 1、什么是正则表达式，有什么用？                    正则表达式是一门独立的学科，基本每个语言都支持。                    正则表达式不是JS专属的。不过在JS中使用居多。                    通常使用正则表达式进行字符串格式匹配。                                        正则表达式是有一堆特殊的符号组成的一个表达式。                    每一个特殊的符号都有特殊的代表含义。                                        例如：                        qq号的正则表达式。                        邮箱地址的正则表达式。                                            邮箱地址格式验证：                        程序中有一个邮箱地址的正则表达式。                        用户输入了一个邮箱地址。                        那么邮箱地址的正则表达式和邮箱地址进行匹配，能匹配成功，表示合法，反之表示不合法。                                        2、对于javascript程序员来说，我们对于正则表达式掌握到什么程度呢？                    第一：能够看懂正则表达式                    第二：简单的正则要会写                    第三：要能够独立的从网络当中搜索到你想要的正则表达式（搜索能力要有）                    第四：要会创建JS的正则表达式对象。                    第五：要会调用JS正则表达式对象的方法。                                3、常见的正则表达式符号有哪些？                    . 匹配除换行符以外的任意字符                     \w 匹配字母或数字或下划线或汉字                     \s 匹配任意的空白符                     \d 匹配数字                     \b 匹配单词的开始或结束                     ^ 匹配字符串的开始                     $ 匹配字符串的结束                                         * 重复零次或更多次 0-N次                    + 重复一次或更多次  1-N次                    ? 重复零次或一次  0或1次                    &#123;n&#125; 重复n次  n次                    &#123;n,&#125; 重复n次或更多次  n+次                    &#123;n,m&#125; 重复n到m次  n到m次                    注意：数量永远匹配的都是前面的那个字符出现的次数。                                        \W 匹配任意不是字母，数字，下划线，汉字的字符                     \S 匹配任意不是空白符的字符                     \D 匹配任意非数字的字符                     \B 匹配不是单词开头或结束的位置                     [^x] 匹配除了x以外的任意字符                     [^aeiou] 匹配除了aeiou这几个字母以外的任意字符                                         | 表示或者                                        [a-z]&#123;1&#125; a到z所有的字符中的任意1个。                                        [a-zA-Z0-9]&#123;3,&#125; 前面这堆中的任意字符至少出现3个。                                        [1-9][0-9]&#123;4,&#125;    qq号的正则表达式，最小的qq号是10000                                        [1-9] 没有指定数量的时候，默认是1个。                                    4、邮箱的正则表达式：                    ^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$                    这个邮箱地址从网上找了之后不一定能用，你需要测试。反复测试。                                5、在JS中怎么创建正则表达式对象呢？                                    包括两种方式，重点使用第一种                                        第一种方式：直接量语法                        var regExp = /正则表达式/标记                                            第二种方式：使用内置类RegExp类。                        var regExp = new RegExp(&quot;正则表达式&quot;, &quot;标记&quot;)                                        标记是可选项！！！！！都有哪些值可选呢？                        g：全局 global                        i: 忽略大小写 ignorecase                        gi: 全局扫描，并且忽略大小写。                                6、正则表达式对象有一个很重要的方法：                    var emailRegExp = /^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$/                    var ok = emailRegExp.test(&quot;用户输入的字符串&quot;);                    返回值ok是true表示，匹配成功了。                                        其实在JS中，字符串String也是支持正则表达式的。             */            // 字符串对象使用正则表达式            console.log(&quot;1980-11-10&quot;.replace(&quot;-&quot;, &quot;/&quot;))            // g表示global全局的,所有的 - 替换成/            console.log(&quot;1980-11-10&quot;.replace(/-/g, &quot;/&quot;))                        function checkEmail()&#123;                //获取邮箱地址                var email = document.getElementById(&quot;email&quot;).value;                // 创建正则表达式对象                var regExp = /^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$/;                // 验证                var ok = regExp.test(email);                if(ok)&#123;                    alert(&quot;邮箱地址合法&quot;)                &#125;else&#123;                    alert(&quot;邮箱地址不合法&quot;);                &#125;            &#125;                    &lt;/script&gt;                邮箱地址：&lt;input type=&quot;text&quot; id=&quot;email&quot; /&gt;        &lt;input type=&quot;button&quot; value=&quot;验证邮箱地址&quot; onclick=&quot;checkEmail()&quot;/&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="表单的验证实现"><a href="#表单的验证实现" class="headerlink" title="表单的验证实现"></a>表单的验证实现</h3><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;                &lt;style type=&quot;text/css&quot;&gt;            span &#123;                font-size: 12px;                color: red;            &#125;        &lt;/style&gt;            &lt;/head&gt;    &lt;body&gt;        &lt;script type=&quot;text/javascript&quot;&gt;            /*             （1）用户名不能为空            （2）用户名必须在6-14位之间            （3）用户名只能有数字和字母组成，不能含有其它符号（正则表达式）            （4）密码和确认密码一致            （5）统一失去焦点验证            （6）错误提示信息统一在span标签中提示，并且要求字体12号，红色。            （7）文本框再次获得焦点后，清空错误提示信息            （8）最终表单中所有项均合法方可提交             */            window.onload = function()&#123;                                var nameErrorSpan = document.getElementById(&quot;nameError&quot;);                                // 给id=&quot;username&quot;的节点绑定blur事件                var usernameElt = document.getElementById(&quot;username&quot;);                usernameElt.onblur = function()&#123;                    // 获取用户名                    var username = usernameElt.value;                    // 去除掉前后空白                    username = username.trim();                    // 用户名不能为空,不能为空串                    //if(username.length == 0)&#123;&#125;                    if(username == &quot;&quot;)&#123;                        nameErrorSpan.innerHTML = &quot;用户名不能为空&quot;;                    &#125;else&#123;                        // 用户名不是空,继续判断长度是否合法                        if(username.length &lt; 6 || username.length &gt; 14)&#123;                            nameErrorSpan.innerHTML = &quot;用户名长度必须在[6-14]之间&quot;;                        &#125;else&#123;                            // 用户名不为空,并且长度也合法,接下来继续判断用户名中是否有特殊符号                            var regExp = /^[a-zA-Z0-9]+$/                            var ok = regExp.test(username)                            if(ok)&#123;                                // 合法                                nameErrorSpan.innerHTML = &quot;&quot;;                            &#125;else&#123;                                // 不合法                                nameErrorSpan.innerHTML = &quot;用户名只能由数字和字母组成&quot;;                            &#125;                        &#125;                    &#125;                &#125;                                // 获得焦点:清空span的错误信息.                usernameElt.onfocus = function()&#123;                    nameErrorSpan.innerHTML = &quot;&quot;;                &#125;                                var pwdErrorSpan = document.getElementById(&quot;pwdError&quot;);                // 确认密码失去焦点就验证.                document.getElementById(&quot;confirmpwd&quot;).onblur = function()&#123;                    //获取密码                    var userpwd = document.getElementById(&quot;userpwd&quot;).value;                    //获取确认密码                    var confirmpwd = document.getElementById(&quot;confirmpwd&quot;).value;                    //进行比对                    if(userpwd != confirmpwd)&#123;                        pwdErrorSpan.innerHTML = &quot;密码和确认密码不一致&quot;;                    &#125;else&#123;                        pwdErrorSpan.innerHTML = &quot;&quot;;                    &#125;                &#125;                                                document.getElementById(&quot;confirmpwd&quot;).onfocus = function()&#123;                    pwdErrorSpan.innerHTML = &quot;&quot;;                &#125;                                document.getElementById(&quot;regbtn&quot;).onclick = function()&#123;                                        // 验证用户名,怎么验证用户名？让用户名文本框失去焦点                    // 重点:使用JS代码怎么触发事件？？？？？？                    usernameElt.focus(); //触发文本框的获取焦点事件                    usernameElt.blur();//触发文本框的失去焦点事件                                        // 验证密码,怎么验证密码？让确认密码失去焦点                    document.getElementById(&quot;confirmpwd&quot;).focus();                    document.getElementById(&quot;confirmpwd&quot;).blur();                                        // 当所有的span都是空的表示表单合法                    if(nameErrorSpan.innerHTML == &quot;&quot; &amp;&amp; pwdErrorSpan.innerHTML == &quot;&quot;)&#123;                        //提交                        var formObj = document.getElementById(&quot;userForm&quot;);                        // 通过调用submit()方法来完成表单的提交                        formObj.submit();                    &#125;                &#125;            &#125;                    &lt;/script&gt;                &lt;form id=&quot;userForm&quot; action=&quot;http://localhost:8080/oa/save&quot;&gt;            用户名&lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;username&quot;/&gt;&lt;span id=&quot;nameError&quot;&gt;&lt;/span&gt;            &lt;br&gt;            密码&lt;input type=&quot;password&quot; name=&quot;userpwd&quot; id=&quot;userpwd&quot;/&gt;            &lt;br&gt;            &lt;!-- 确认密码是不需要提交给服务器的，这个name不要写！ --&gt;            确认密码&lt;input type=&quot;password&quot; id=&quot;confirmpwd&quot;/&gt; &lt;span id=&quot;pwdError&quot;&gt;&lt;/span&gt;            &lt;br&gt;            &lt;!-- 表单所有项目都合法才能提交 --&gt;            &lt;!-- &lt;input type=&quot;submit&quot; value=&quot;注册&quot; /&gt; --&gt;            &lt;!-- button不能提交表单，但是JS代码可以提交表单 --&gt;            &lt;input type=&quot;button&quot; value=&quot;注册&quot; id=&quot;regbtn&quot;/&gt;        &lt;/form&gt;             &lt;/body&gt;&lt;/html&gt;</code></pre><h1 id="AJAX发送异步请求过程"><a href="#AJAX发送异步请求过程" class="headerlink" title="AJAX发送异步请求过程"></a>AJAX发送异步请求过程</h1><p>这个过程是利用了</p><p>var xhr &#x3D;new XMLHttpRequest();</p><p>这个异步请求对象</p><p>并且将表单的体检按钮换成button 并且设置单击事件</p><p>根据js的函数可以发送请求实现此过程</p><pre><code>function 函数（）&#123;//1.0创建异步对象var xhr =new XMLHttpRequest();//2.绑定事件xhr.onreadystatechange=function()&#123;    if(xhr.readyState==4&amp;&amp;xhr.status==20)&#123;    //获取数据    var data =xhr.responseText；    //更新dom    .......获取数据绑定到标签上面    &#125;&#125;    //3.初始化请求参数    //queryNameproid=1    xhr.open（”get“，URL，true）；        //4.发起请求    xhr.send；&#125;function 函数（）&#123;//1.0创建异步对象var xhr =new XMLHttpRequest();//2.绑定事件xhr.onreadystatechange=function()&#123;    if(xhr.readyState==4&amp;&amp;xhr.status==20)&#123;    //获取数据    var data =xhr.responseText；    //返回对象如果是json格式那么需要去转换个格式    var obj=json.parse(data);    //更新dom    .......获取数据绑定到标签上面    &#125;&#125;    //3.初始化请求参数    //queryNameproid=1    xhr.open（”get“，URL，true）；        //4.发起请求    xhr.send；&#125;</code></pre><h1 id="第一章-Ajax-前端技术"><a href="#第一章-Ajax-前端技术" class="headerlink" title="第一章 Ajax 前端技术"></a>第一章 Ajax 前端技术</h1><p>前端技术： 在浏览器中执行的程序都是前端， html ， css，js等等</p><p>后端技术：在服务器中执行的程序， 使用java语言开发的后端程序。 servlet,jsp, jdbc,mysql,tomcat等等</p><h1 id="1-全局刷新和局部刷新"><a href="#1-全局刷新和局部刷新" class="headerlink" title="1 全局刷新和局部刷新"></a>1 全局刷新和局部刷新</h1><p>1）全局刷新： 使用form， href等发起的请求是全局刷新。</p><p> 用户发起请求， 视图改变了， 跳转视图，使用新的数据添加到页面。</p><p>缺点：</p><pre><code> 1. 传递数据量比较大。 占用网络的带宽    2. 浏览器需要重新的渲染整个页面。     3. 用户的体验不是那么好</code></pre><p>2）局部刷新： 在当前页面中，发起请求，获取数据，更新当前页面的dom对象。 对视图部分刷新。</p><p> 特点：</p><pre><code> 1. 数量比较小， 在网络中传输速度快。    2. 更新页面内容， 是部分更新页面， 浏览器不用全部渲染视图。    3. 在一个页面中，可以做多个 局部刷新    4. 从服务器获取的是数据， 拿到更新视图</code></pre><h1 id="2-异步请求对象"><a href="#2-异步请求对象" class="headerlink" title="2 异步请求对象"></a>2 异步请求对象</h1><p>在局部刷新中，使用异步请求对象，在浏览器内部发起请求，获取数据。</p><p><a href="file:///E:/BaiduNetdiskDownload/HTML+css+JavaScript资料/06-笔记/Ajax/images/image-20201012092218113.png"><img src="file:///E:/BaiduNetdiskDownload/HTML+css+JavaScript%E8%B5%84%E6%96%99/06-%E7%AC%94%E8%AE%B0/Ajax/images/image-20201012092218113.png" alt="image-20201012092218113"></a></p><p>异步对象是在浏览器内部的一种 javascript对象。 各大浏览器都能支持异步对象的使用。chrome ,firework, ie, opper ,</p><p>异步对象 XMLHttpRequest</p><h1 id="3-异步对象XMLHttpRequest介绍"><a href="#3-异步对象XMLHttpRequest介绍" class="headerlink" title="3. 异步对象XMLHttpRequest介绍"></a>3. 异步对象XMLHttpRequest介绍</h1><p>js中的一种对象， 使用js语法创建和使用这个对象。</p><p>var xhr &#x3D; new XMLHttpRequest();</p><p>之后就可以 使用xhr对象的属性或者函数，进行异步对象的操作。</p><p>使用异步对象实现局部刷新， 异步对象主要负责发起请求，传递请求的参数，并从服务器接收数据。</p><p>局部刷新需要使用那些技术：</p><p>1）javascript ： 创建XMLHttpRequest对象， 调用它的属性或者方法</p><p>2）dom：处理dom，更新select的数据</p><p>3）css: 处理视图， 更新，美化。</p><p>4）servlet：服务器端技术</p><p>5）数据格式：json。 它之前是xml</p><p>把上面这些技术的综合使用叫做ajax（阿贾克斯）。</p><h1 id="4-Ajax"><a href="#4-Ajax" class="headerlink" title="4 Ajax"></a>4 Ajax</h1><p>AJAX &#x3D; Asynchronous JavaScript and XML（异步的 JavaScript 和XML）。<br>AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分页面内容的新方法</p><p>AJAX不是新的编程语言，它是多种技术的综合使用。 包含了javascript, dom</p><p>,css, 服务器端技术， servlet ，jsp ，jdbc等等， 还有 json数据格式。</p><p>使用AJAX实现局部刷新。</p><p>Ajax核心是 javascript 和 xml （json）：使用javascript操作异步对象XMLHttpRequest. 和服务器交换使用json数据格式。</p><h1 id="5-异步对象XMLHttpRequest属性和方法"><a href="#5-异步对象XMLHttpRequest属性和方法" class="headerlink" title="5. 异步对象XMLHttpRequest属性和方法"></a>5. 异步对象XMLHttpRequest属性和方法</h1><ol><li><p>创建异步对象，使用js的语法</p><p>var xhr &#x3D; new XMLHttpRequest();</p></li><li><p>XMLHttpRequest方法</p><p>①）open(请求方式, 服务器端的访问地址，异步还是同步)</p><p>例如：xhr.open(“get”,”loginServlet”,true);</p><p>②）send(): 使用异步对象发送请求</p></li><li><p>XMLHttpRequest属性</p><p>readyState属性：请求的状态</p><p> 0：表示创建异步对象时，new XMLHttpRequest();</p><p> 1：表示初始异步对象的请求参数。 执行open()方法</p><p> 2：使用send()方法发送请求。</p><p> 3：使用异步对象从服务器接收了数据</p><p> 4：异步对象接收了数据，并在异步对象内部处理完成后。</p><p>status属性：网络的状态，和Http的状态码对应</p><p> 200：请求成功</p><p> 404： 服务器资源没有找到</p><p> 500： 服务器内部代码有错误</p><p>responseText属性：表示服务器端返回的数据</p><p> 例如： var data &#x3D; xhr.responseText;</p></li></ol><h1 id="6-异步对象XMLHttpRequest使用步骤"><a href="#6-异步对象XMLHttpRequest使用步骤" class="headerlink" title="6. 异步对象XMLHttpRequest使用步骤"></a>6. 异步对象XMLHttpRequest使用步骤</h1><p>1）使用js创建异步对象</p><p> var xhr &#x3D; new XMLHttpRequest();</p><p>2)给异步对象绑定事件。事件名称 onreadystatechange</p><p>例如button增加单击事件 onclick</p><p>xhr绑定事件</p><p>xhr.onreadysatechange&#x3D;function() { 当事件发生时执行的代码 }</p><pre><code>&lt;input type=&quot;button&quot; onclick=&quot;btnClick()&quot; /&gt;&lt;script type=&quot;text/javascript&quot;&gt;    function btnClick()&#123;       按钮单击的处理代码         &#125;&lt;/script&gt;</code></pre><p>在绑定事件中做什么，根据readyState值做请求的处理</p><pre><code>xhr.readystatechagne=function()&#123;   if( xhr.readyState==4 &amp;&amp; xhr.status==200 )&#123;        从服务器获取了数据， 更新当前页面的dom对象，完成请求的处理        var data = xhr.responseText;        更新dom对象        document.getElementById(&quot;#mydiv&quot;).innertHTML = data;   &#125;&#125;</code></pre><ol><li><p>初始请求的参数，执行open()函数</p><p>xhr.open(“get”,”loginServlet”,true)</p></li></ol><p>4)发送请求，执行send()</p><p>xhr.send()</p><h1 id="7-第一个例子"><a href="#7-第一个例子" class="headerlink" title="7. 第一个例子"></a>7. 第一个例子</h1><p>使用全局刷新， 实现计算bmi</p><p>可以使用jsp显示request作用域中的数据，使用el表达式</p><p>也可以使用HttpServletResponse对象输出数据， 数据给了浏览器。 浏览器可以接收HttpServletResponse对象print的数据</p><h1 id="8-同步请求和异步请求"><a href="#8-同步请求和异步请求" class="headerlink" title="8 同步请求和异步请求"></a>8 同步请求和异步请求</h1><p>看open(请求方式， 访问uri地址，boolean是不是异步的)</p><p>true：异步请求</p><p>false：同步请求</p><h1 id="第二章-jQuery"><a href="#第二章-jQuery" class="headerlink" title="第二章 jQuery"></a>第二章 jQuery</h1><ol><li><p>jquery的介绍</p><p>jquery就是js函数库， 里面有大量的js函数， 使用这些函数操作dom对象， 做事件，动画， ajax处理</p><p>地址： <a href="https://jquery.com/">https://jquery.com/</a></p></li><li><p>下载</p><p>下载地址：<a href="https://jquery.com/download/">https://jquery.com/download/</a></p><p>压缩版本： 文件体积比较小，适合项目上线后使用。 jquery-3.4.1.min.js</p><p>未压缩：体积比较大，可读性比较好，适合开发阶段使用 jquery-3.4.1.js</p></li></ol><h2 id="2-1-使用jquery"><a href="#2-1-使用jquery" class="headerlink" title="2.1 使用jquery"></a>2.1 使用jquery</h2><p>步骤：</p><ol><li><p>需要在你的项目中加入jquery的文件， idea中是把jquery放在webapp目录。一般是创建一个js目录。存放js文件的。 对于hbuilder工具， 放在项目的js目录中就可以了</p></li><li><p>创建一个html文件或者jsp都可以， 在文件中使用</p><pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;jquery的文件的相对路径&quot; /&gt; 这样是不行的&lt;script type=&quot;text/javascript&quot; src=&quot;jquery的文件的相对路径&quot; /&gt;&lt;/script&gt;这样是可以的</code></pre></li><li><p>在js代码中，调用jquery中函数</p></li></ol><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;第一个jquery例子&lt;/title&gt;        &lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-3.4.1.js&quot;&gt;&lt;/script&gt;        &lt;script type=&quot;text/javascript&quot;&gt;                        /*              $:jquery中的函数名              document:是参数              $(document): 把js中的document对象变成jquery可以使用的对象。                           然后调用ready()的函数。 这个ready()是jquery中的函数                                                      ready()的执行时间在页面dom对象加载后执行的。相当于js中onload事件                                  ready(函数):表示在页面对象加载后执行 这个函数            */            /* $(document).ready(function()&#123;                alert(&quot;使用jquery了&quot;)            &#125;) */                        /* $(document).ready( myinit() )            function myinit()&#123;                alert(&quot;====相当于onload==&quot;)            &#125; */                        //jquery提供了简单方式,使用ready()            //$(  参数是一个函数 )            $( function()&#123;                alert(&quot;简单的方式使用ready&quot;)            &#125; )                    &lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="2-2-对象的分类"><a href="#2-2-对象的分类" class="headerlink" title="2.2 对象的分类"></a>2.2 对象的分类</h2><p>dom对象和jquery对象。 在一个文件中同时存在两种对象</p><p>dom对象： 使用js的代码获取，创建的对象。 html中的对象都是dom对象。</p><p>jquery对象： 使用jquery获取获取的对象。</p><p>为什么要使用dom对象，还有jquery对象？</p><p>目的是要dom对象的函数或者属性， 以及使用使用jquery中提供的函数或者属性。</p><p>要 dom中的内容就需要使用dom对象， 要使用jquery函数库中的函数需要使用jquery对象。</p><p>dom对象和jquery对象可以相互转换的</p><h3 id="2-2-1-dom对象转为jquery对象。"><a href="#2-2-1-dom对象转为jquery对象。" class="headerlink" title="2.2.1. dom对象转为jquery对象。"></a>2.2.1. dom对象转为jquery对象。</h3><p>语法： $( dom对象 ) 得到的是一个jquery对象， 可以调用jquery中提供的函数</p><pre><code>&lt;input type=&quot;text&quot; id=&quot;t1&quot; /&gt;//通过js的函数，获取dom对象var dom= document.getElementById(&quot;t1&quot;);//把dom转为jqueryvar jqueryObj = $(dom);//调用jquery中的函数jqueryObject.val();//获取dom对象的value属性的值提示：为了区分dom对象和jquery对象，可以在jquery对象变量名上，加一个$ , 例如 $obj </code></pre><h3 id="2-2-2-jquery对象转为dom对象。"><a href="#2-2-2-jquery对象转为dom对象。" class="headerlink" title="2.2.2 jquery对象转为dom对象。"></a>2.2.2 jquery对象转为dom对象。</h3><p>语法： jquery对象是一个数组， 数组成员是dom对象。 使用 [下标] 或 get(下标)</p><pre><code>&lt;input type=&quot;text&quot; id=&quot;txt1&quot;/&gt;使用jquery的方式表示这个dom对象$(&quot;#txt1&quot;):获取id是txt1的dom对象。 var  obj = $(&quot;#txt1&quot;); //obj是一个jquery对象，是一个包含了一个成员的dom数组。  obj[0]就是dom对象var dom = obj[0]; 或者 obj.get(0)//使用dom对象的函数或者属性alert(dom.value)</code></pre><h2 id="2-3-选择器"><a href="#2-3-选择器" class="headerlink" title="2.3 选择器"></a>2.3 选择器</h2><p>什么是选择器： 选择器就是一个字符串， 是一个定位dom对象的字符串。 使用这个字符串作为条件定位dom对象。 可以使用 id ，class样式名称， 标签名称等作为选择器使用，定位dom对象</p><h3 id="2-3-1-基本选择器"><a href="#2-3-1-基本选择器" class="headerlink" title="2.3.1 基本选择器"></a>2.3.1 基本选择器</h3><p>使用dom对象的id， class名称， 标签名称等作为条件定位dom对象。</p><ol><li><p>使用dom对象的id作为条件</p><p>语法： $(“#id”) document.getElementById(“id”)</p></li><li><p>class选择器，使用对象的class名称定位dom对象</p><p>语法：$(“.class名称”) document.getElementsByClassName()</p></li><li><p>标签选择器，使用标签名称作为条件定位dom对象</p><p>语法：$(“标签名称”) document.getElementsByTagName()</p></li><li><p>所有选择器</p><p>语法： $(“*”)</p></li><li><p>组合选择器</p><p>语法：$(“#id,.class,标签名称”)</p><p>组合选择器使用 id 或者class名称或者标签名称定位dom对象， id，class，标签名称可以任意组合。</p></li></ol><h3 id="2-3-2-表单选择器"><a href="#2-3-2-表单选择器" class="headerlink" title="2.3.2 表单选择器"></a>2.3.2 表单选择器</h3><p>表单选择器使用 dom对象的type属性值定位dom对象的， 和form标签无关。</p><p>语法： $(“:type属性值”)</p><p>例如：</p><pre><code>&lt;input type=&quot;text&quot; /&gt;&lt;input type=&quot;text&quot; /&gt;    使用表单选择器： $(&quot;:text&quot;)</code></pre><h2 id="2-4-过滤器"><a href="#2-4-过滤器" class="headerlink" title="2.4 过滤器"></a>2.4 过滤器</h2><p>过滤器是一个字符串，用了筛选dom对象的， 过滤器是和选择器一起使用的。 在选择了dom对象后，在进行过滤筛选。</p><h3 id="2-4-1-基本过滤器"><a href="#2-4-1-基本过滤器" class="headerlink" title="2.4.1 基本过滤器"></a>2.4.1 基本过滤器</h3><p>使用dom对象在数组中的位置，作为过滤条件的。</p><p>1）选择数组中第一个dom成员</p><p>语法：$(“选择器:first”)</p><ol><li>选择数组中最后一个成员</li></ol><p>语法：$(“选择器:last”)</p><ol><li>选择等于指定下标的dom成员</li></ol><p>语法：$(“选择器:eq(下标)”)</p><p>4）选择大于某个下标的所有成员</p><p>语法：$(“选择器:gt(下标)”)</p><p>5）选择小于某个下标的所有成员</p><p>语法：$(“选择器:lt(下标)”)</p><h3 id="2-4-2-表单过滤器"><a href="#2-4-2-表单过滤器" class="headerlink" title="2.4.2 表单过滤器"></a>2.4.2 表单过滤器</h3><p>根据对象的状态作为条件，筛选dom对象</p><p>1）获取可用的文本框</p><p>语法：$(“:text:enabled”)</p><ol><li>获取不可用的文本框</li></ol><p>语法： $(“:text:disabled”)</p><p>3）获取选中的复选框</p><p>语法：$(“:checkbox:checked”)</p><ol><li>获取选中下拉列表框</li></ol><p>语法： $(“选择器 &gt; option:selected”)</p><pre><code>&lt;select id=&quot;lang&quot;&gt;    &lt;option value=&quot;java&quot;&gt;java&lt;/option&gt;    &lt;option value=&quot;sql&quot;&gt;sql&lt;/option&gt;&lt;/select&gt;</code></pre><h2 id="2-5-函数"><a href="#2-5-函数" class="headerlink" title="2.5 函数"></a>2.5 函数</h2><h3 id="2-5-1-第一组函数"><a href="#2-5-1-第一组函数" class="headerlink" title="2.5.1 第一组函数"></a>2.5.1 第一组函数</h3><p>1）val()：操作dom对象的value值</p><p>val(): 没有参数， 获取dom数组中第一个dom对象的value值</p><p>val(参数)： 有参数， 给dom数组中所有dom对象的value属性赋值</p><p>2）text() : 操作标签的文本内容，标签开始和结束之间的内容</p><p>text(): 没有参数， 把dom数组中所有dom对象的文本内容链接起来，形成一个字符串，并返回这个这个字符串。</p><p>text(参数)：给dom数组中的所有成员统一赋予新的文本</p><p>3）attr(): 操作value ，文本以外的属性时。</p><p>attr(“属性名”)：获取dom数组中第一个dom成员的此属性值</p><p>attr(“属性名”,”属性值”)：给dom数组中所有dom成员此属性赋值</p><h3 id="2-5-2-第二组函数"><a href="#2-5-2-第二组函数" class="headerlink" title="2.5.2 第二组函数"></a>2.5.2 第二组函数</h3><p>1） remove()</p><p>删除选择的dom对象和他的子对象</p><p>语法： $(”选择器“).remove()</p><p>2） empty()</p><p>删除dom对象的子对象</p><p>语法： $(“选择器”).empty()</p><ol><li>append()</li></ol><p>给dom对象在他的后面增加新的dom对象</p><p>语法： $(“选择器”).append( 子dom 对象 )</p><ol><li>html()</li></ol><p>html(): 获取dom数组中第一个dom对象的文本值（ html()返回结果相当于innertHTML ）</p><p>html(参数)：给dom数组中所有成员设置新的文本内容。 （html()返回结果相当于innertHTML ）</p><p>5)each()</p><p>each是循环函数， 可以循环数组， json ， dom对象数组</p><p>① $.each( 要循环的内容， function(index,element ){ 处理函数} )</p><p>要循环的内容: 可以是数组， json对象， dom对象数组。</p><p>function： 循环的处理函数， 每个成员都会执行函数一次。</p><p> index：是循环变量的值， 名称自定义</p><p> element： 和index对应的成员， element名称是自定义的</p><p>例如</p><p>doArrayContent： function(index,element ){ 处理函数} )</p><p>② $(“选择器”).each(function(index,element){ 处理函数} )</p><p>可以对jquery对象进行循环处理。 jquery对象就是dom数组</p><h2 id="2-6-事件"><a href="#2-6-事件" class="headerlink" title="2.6 事件"></a>2.6 事件</h2><p>jquery可以给dom对象绑定事件，在程序执行期间动态的处理事件</p><h3 id="2-6-1-第一种事件绑定语法"><a href="#2-6-1-第一种事件绑定语法" class="headerlink" title="2.6.1 第一种事件绑定语法"></a>2.6.1 第一种事件绑定语法</h3><p>语法： $(“选择器”).事件名称(事件的处理函数)</p><p>$(“选择器”)：选择0或多个dom对象。给他们绑定事件</p><p>事件名称： 就是js中的 去掉on的部分。 例如单击事件onclick, 这里的事件名称就是 click</p><p>事件的处理函数: 函数定义， 当事件发生时，执行这个函数。</p><pre><code>例如：&lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;绑定事件&quot;/&gt; 绑定事件$(&quot;#btn&quot;).click( function()&#123; 单击的处理代码 &#125; )$(&quot;:button&quot;).click(function()&#123; 单击处理代码&#125;)&lt;script type=&quot;text/javascript&quot;&gt;                        $(function()&#123;                //页面dom对象加载后执行, 相当于onload事件                //绑定事件                $(&quot;#btn&quot;).click(function()&#123;                    alert(&quot;==button单击了，执行处理函数==&quot;)                &#125;)            &#125;)                            &lt;/script&gt;&lt;body&gt;    &lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;绑定事件&quot; /&gt;&lt;br/&gt;&lt;/body&gt;</code></pre><h3 id="2-6-2-第二种事件绑定方式，-on"><a href="#2-6-2-第二种事件绑定方式，-on" class="headerlink" title="2.6.2 第二种事件绑定方式， on"></a>2.6.2 第二种事件绑定方式， on</h3><p>语法： $(“选择器”).on( 事件名称, function(){事件处理函数})</p><p>事件： 就是js中去掉on的部分。</p><p>function： 事件处理函数</p><pre><code>&lt;body&gt;    &lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;绑定事件&quot; /&gt;&lt;br/&gt;&lt;/body&gt;&lt;script&gt;    $(&quot;#btn&quot;).on(&quot;click&quot;,function()&#123; alert(&quot;按钮单击了&quot;)&#125;)&lt;/script&gt;        </code></pre><h2 id="2-7-Ajax"><a href="#2-7-Ajax" class="headerlink" title="2.7 Ajax"></a>2.7 Ajax</h2><p>使用jquery提供的函数实现ajax请求的处理。 代替直接使用XMLHttpRequest. 但是jquery实际还是使用的异步对象。</p><h3 id="2-7-1-ajax-核心的函数"><a href="#2-7-1-ajax-核心的函数" class="headerlink" title="2.7.1 $.ajax() 核心的函数"></a>2.7.1 $.ajax() 核心的函数</h3><p>语法： $.ajax( { json格式的参数} )</p><p>json格式的参数：key是定义好的， 需要开发人员给key赋值。 这些key是用来表示ajax请求必须的参数</p><p>例如，请求的uri地址， 是不是异步请求， 请求的方式等等。</p><pre><code>$.ajax(  &#123;      url:&quot;queryProvinceServlet&quot;,      type:&quot;get&quot;,      data:&#123;&quot;name&quot;:&quot;李四&quot;,&quot;age&quot;:20&#125;,      dataType:&quot;json&quot;,      success:function(resp) &#123; 开发人员获取数据，更新dom对象 &#125;,      error:function()&#123; alert(&quot;请求错误&quot;)&#125;  &#125;)</code></pre><p>url：服务器的地址，例如某个servlet的访问地址。 queryProvinceServlet</p><p>type:表示请求的方式，get，post。 默认是get。 这个值不用区分大小写</p><p>data：表示提交的请求参数。 可以是string， 数组， json类型的。 推荐使用json格式。</p><p> 例如： data: {“name”:”李四”,”age”:20}</p><p> jquery在发送请求时，会把json中的key作为请求的参数使用， key对应的值作为参数数据。</p><p> 转为的结果： <a href="http://localhost:8080/myweb/queryProvinceServlet?name=%E6%9D%8E%E5%9B%9B&age=20">http://localhost:8080/myweb/queryProvinceServlet?name=李四&amp;age=20</a></p><p>dataType: 数据格式， 可以是 html， text ， xml ，json等等。 表示发起请求后，希望服务器端返回的数据格式。 jquery可以尝试使用对应格式处理返回的数据。 比如你指定了 dataType:json,表示希望服务器返回的是json格式数据。 然后jquery把json数据转为json对象。服务器代码可以获取到 dataType的内容。</p><p> 例如： 请求中 dataType:”json”, jquery发起请求后，</p><p> 在请求头中 Accept: application&#x2F;json, text&#x2F;javascript, <em>&#x2F;</em>; q&#x3D;0.01</p><p> 如果dataType:”text”, 请求中</p><p> Accept: text&#x2F;plain, <em>&#x2F;</em>; q&#x3D;0.01</p><p>success: 函数function。 当服务器端返回了数据，jquery处理完数据后，执行这个函数。 等同于异步对象的 readyState&#x3D;&#x3D;4 $$ status&#x3D;200的情况</p><p> 例如： success:function( data){ 开发人员处理服务器返回的数据 }</p><p> data是自定义形参， 相当于 data&#x3D; xhr.responseText</p><p>error:function(), 当请求错误时，执行这个函数。</p><p>contentType:表示请求的参数数据格式。例如 application&#x2F;json , 这个内容可以不写。</p><p>async: 是一个boolean表示请求是同步的还是异步的。 true是异步的，默认是true； false同步的.</p><h3 id="2-7-2-get"><a href="#2-7-2-get" class="headerlink" title="2.7.2 $.get()"></a>2.7.2 $.get()</h3><p>$.get()这个函数就是执行get请求方式的ajax</p><p>语法： $.get(url, 请求参数， success函数， dataType)</p><p>例如：</p><pre><code>$.get(&quot;queryName&quot;,&#123;&quot;proid&quot;:1&#125;, function(resp)&#123; 获取省份名称 &#125;, &quot;text&quot;)</code></pre><h3 id="2-7-3-post"><a href="#2-7-3-post" class="headerlink" title="2.7.3 $.post()"></a>2.7.3 $.post()</h3><p>$.post() 执行post请求的ajax。</p><p>语法： $.post(url, 请求参数， success函数， dataType)</p><p>例如：</p><pre><code>$.post(&quot;queryName&quot;,&#123;&quot;proid&quot;:1&#125;, function(resp)&#123; 获取省份名称 &#125;, &quot;text&quot;)</code></pre><h2 id="2-8-级联查询"><a href="#2-8-级联查询" class="headerlink" title="2.8 级联查询"></a>2.8 级联查询</h2><p>思路：有两个数据库的查询 1： 查询所有的省份名称和id ； 2 根据提交的省份id ，查询city表，得到城市列表</p><p> 有两个servlet接收请求， 一个查询所有的省份 ；一个是接收省份id的参数，查询省份对应的城市列表。</p><p> 数据格式使用 json</p><p> 发起请求使用 $.ajax, $.get, $.post</p><p> 事件： onChange()</p><p>实现步骤：</p><p>1.数据表province( 获取全部的id和name列的值)，</p><p>city表根据provinceid的值，得到id，name列</p><p>2.创建web应用。 加入mysql驱动的jar 和jackson的jar</p><p>3.创建实体类， Province , City</p><p>4.创建Dao类， QueryDao类，有两个方法</p><p>5.创建Servlet， 两个servlet ，一个是查询所有的省份名称， 一个是查询城市列表</p><p>6.创建jsp， 发起两个ajax请求。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>VUE学习</title>
      <link href="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="vue学习"><a href="#vue学习" class="headerlink" title="vue学习"></a>vue学习</h1><p>要求： 使用数据需要存在</p><p>​不能再插值表达式中使用关键字等语句</p><p>​不能再标签中使用插值表达式</p><pre><code class="vue">&lt;div id=&quot;app&quot;&gt;        &lt;!-- 编写一些用于渲染的代码逻辑 --&gt;        &#123;&#123;name+name&#125;&#125;        &#123;&#123;name.toUpperCase()&#125;&#125;    &lt;/div&gt;    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.7.14/dist/vue.js&quot;&gt;&lt;/script&gt;    &lt;script&gt;        const app=new Vue(            &#123;                el: &#39;#app&#39;,                data: &#123;                    //这个数据是响应式数据                    name: &#39;tony&#39;                &#125;            &#125;        )    &lt;/script&gt;</code></pre><p>VUE中数据改变页面中的渲染也会改变</p><p>VUE中的特点响应式显示</p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230717203822221.png" alt="image-20230717203822221"></p><h4 id="VUE的指令操作"><a href="#VUE的指令操作" class="headerlink" title="VUE的指令操作"></a>VUE的指令操作</h4><p>V-HTML ：可以替换 document.innerHtml 可以解析html语句并且展示到标签内容</p><p>v-show </p><p>1.控制元素隐藏</p><p>2.语法：v-show&#x3D;”表达式” 表达式的值 true显示 ，false 隐藏</p><p>实际上是控制标签的display：none来控制内容是否显示 是显示与不显示的问题</p><p>频繁操作的页面用</p><p>v-if </p><p>1.控制元素隐藏(条件渲染)</p><p>2.语法 v-if&#x3D;”表达式“ 表达式值 true显示，false 隐藏</p><p>实际上是控制判断条件决定是否创建标签 是存在与不存在的问题</p><p> 不经常操作的用v-if</p><p>v-else v-else-if</p><p>1.作用：辅助v-if 进行判断渲染</p><p>2.语法：v-else v-else-if&#x3D;”表达式“</p><p>3.注意：需要紧挨着v-if一起使用</p><p>ag</p><pre><code class="vue">               &lt;div&gt;                &lt;div v-if=&quot;score &gt;= 90&quot;&gt;优秀&lt;/div&gt;                &lt;div v-else-if=&quot;score &gt;= 70&quot;&gt;普通&lt;/div&gt;                &lt;div v-else-if=&quot;score &gt;= 60&quot;&gt;及格&lt;/div&gt;                &lt;div v-else&gt;成绩过低建议重开&lt;/div&gt;              &lt;/div&gt;</code></pre><p>v-on</p><p>1.作用：注册时间&#x3D;添加监听+提供处理逻辑</p><p>2.语法：</p><p>1.v-on：事件名&#x3D;”内敛语句”</p><p>v-on:&#x3D;&#x3D;@</p><pre><code class="vue">           &lt;button v-on:click=&quot;count--&quot;&gt;-&lt;/button&gt;           &lt;span&gt;&#123;&#123;count&#125;&#125;&lt;/span&gt;             &lt;button v-on:click=&quot;count++&quot;&gt;+&lt;/button&gt;            &lt;button @click=&quot;count--&quot;&gt;-&lt;/button&gt;           &lt;span&gt;&#123;&#123;count&#125;&#125;&lt;/span&gt;             &lt;button @click=&quot;count++&quot;&gt;+&lt;/button&gt;  </code></pre><p>2.v-on：时间名&#x3D;”methods中的函数名字“</p><pre><code class="vue">  &lt;/div&gt;      &lt;button @click=&quot;fn&quot;&gt;显示or隐藏&lt;/button&gt;    &lt;h1 v-show=&quot;flag&quot;&gt;黑马程序员&lt;/h1&gt;    &lt;/div&gt;          methods:                  &#123;                    fn()&#123;                        this.flag=!this.flag;                    &#125;                &#125;</code></pre><p>v-on调用传参数</p><p>v-bind：属性名&#x3D;“表达式”</p><p>1.作用：动态的设置html的标签属性-》 src url title ….</p><p>2.语法： v-bind:属性名&#x3D;“表达式”</p><p>可以将v-bind改写成：</p><pre><code class="vue">    &lt;img v-bind:src=&quot;imgurl&quot; alt=&quot;&quot;&gt; tup&lt;/img&gt;</code></pre><p>v-for</p><p>v-for&#x3D;”(item,index) in 数组”</p><p>item 每一项，index 下标</p><pre><code class="vue"> &lt;ul&gt;      &lt;li v-for=&quot;(item, index) in booksList&quot;                                     :key=&quot;item.id&quot;&gt;        &lt;span&gt;&#123;&#123; item.name &#125;&#125;&lt;/span&gt;        &lt;span&gt;&#123;&#123; item.author &#125;&#125;&lt;/span&gt;        &lt;!-- 注册点击事件 →  通过 id 进行删除数组中的 对应项 --&gt;        &lt;button @click=&quot;del(item.id)&quot;&gt;删除&lt;/button&gt;      &lt;/li&gt;    &lt;/ul&gt; &lt;script&gt;    const app = new Vue(&#123;      el: &#39;#app&#39;,      data: &#123;        booksList: [          &#123; id: 1, name: &#39;《红楼梦》&#39;, author: &#39;曹雪芹&#39; &#125;,          &#123; id: 2, name: &#39;《西游记》&#39;, author: &#39;吴承恩&#39; &#125;,          &#123; id: 3, name: &#39;《水浒传》&#39;, author: &#39;施耐庵&#39; &#125;,          &#123; id: 4, name: &#39;《三国演义》&#39;, author: &#39;罗贯中&#39; &#125;        ]      &#125;,      methods: &#123;        del (id) &#123;          // console.log(&#39;删除&#39;, id)          // 通过 id 进行删除数组中的 对应项 → filter(不会改变原数组)          // filter: 根据条件，保留满足条件的对应项，得到一个新数组。          // console.log(this.booksList.filter(item =&gt; item.id !== id))          this.booksList = this.booksList.filter(item =&gt; item.id !== id)        &#125;      &#125;    &#125;)  &lt;/script&gt;</code></pre><p>v-model</p><p>1.作用：给表单元素使用，双向的绑定 –&gt;可以快速获取或者设置表单内容</p><p>v-model&#x3D;”变量”</p><p>数据变化 视图自动更新 </p><p>视图变化数据自动更新</p><p>双向绑定</p><pre><code> &lt;div id=&quot;app&quot;&gt;    &lt;!--       v-model 可以让数据和视图，形成双向数据绑定      (1) 数据变化，视图自动更新      (2) 视图变化，数据自动更新      可以快速[获取]或[设置]表单元素的内容     --&gt;    账户：&lt;input type=&quot;text&quot; v-model=&quot;username&quot;&gt; &lt;br&gt;&lt;br&gt;    密码：&lt;input type=&quot;password&quot; v-model=&quot;password&quot;&gt; &lt;br&gt;&lt;br&gt;    &lt;button @click=&quot;login&quot;&gt;登录&lt;/button&gt;    &lt;button @click=&quot;reset&quot;&gt;重置&lt;/button&gt;  &lt;/div&gt;  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt;  &lt;script&gt;    const app = new Vue(&#123;      el: &#39;#app&#39;,      data: &#123;        username: &#39;&#39;,        password: &#39;&#39;      &#125;,      methods: &#123;        login () &#123;          console.log(this.username, this.password)        &#125;,        reset () &#123;          this.username = &#39;&#39;          this.password = &#39;&#39;        &#125;      &#125;    &#125;)  &lt;/script&gt;</code></pre><h4 id="第一个小案例"><a href="#第一个小案例" class="headerlink" title="第一个小案例"></a>第一个小案例</h4><pre><code class="vue">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot; /&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;./index.css&quot; /&gt;&lt;title&gt;记事本&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 主体区域 --&gt;&lt;section id=&quot;app&quot;&gt;  &lt;!-- 输入框 --&gt;  &lt;header class=&quot;header&quot;&gt;    &lt;h1&gt;小黑记事本&lt;/h1&gt;    &lt;input v-model=&quot;todoName&quot; placeholder=&quot;请输入任务&quot; class=&quot;new-todo&quot; /&gt;    &lt;button class=&quot;add&quot; @click=&quot;add()&quot;&gt;添加任务&lt;/button&gt;  &lt;/header&gt;  &lt;!-- 列表区域 --&gt;  &lt;section class=&quot;main&quot;&gt;    &lt;ul class=&quot;todo-list&quot;&gt;      &lt;li class=&quot;todo&quot; v-for=&quot;(item,index) in list&quot; v-bind:key=&quot;list&quot;&gt;        &lt;div class=&quot;view&quot;&gt;          &lt;span class=&quot;index&quot;&gt;&#123;&#123;index+1&#125;&#125;.&lt;/span&gt; &lt;label&gt;&#123;&#123;item.name&#125;&#125;&lt;/label&gt;          &lt;button @click=&quot;del(item.id)&quot; class=&quot;destroy&quot;&gt;删除&lt;/button&gt;        &lt;/div&gt;      &lt;/li&gt;    &lt;/ul&gt;  &lt;/section&gt;  &lt;!-- 统计和清空 --&gt;  &lt;footer class=&quot;footer&quot;&gt;    &lt;!-- 统计 --&gt;    &lt;span class=&quot;todo-count&quot;&gt;合 计:&lt;strong&gt; &#123;&#123;list.length&#125;&#125; &lt;/strong&gt;&lt;/span&gt;    &lt;!-- 清空 --&gt;    &lt;button v-show=&quot;list.length&gt;0&quot; class=&quot;clear-completed&quot; @click=&quot;qk&quot;&gt;      清空任务    &lt;/button&gt;  &lt;/footer&gt;&lt;/section&gt;&lt;!-- 底部 --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt;  const app = new Vue(&#123;    el: &#39;#app&#39;,    data: &#123;      list:[        &#123;id:1,name: &quot;跑步一公里&quot;&#125;,        &#123;id:2,name: &quot;洗澡一小时&quot;&#125;,      ]    &#125;,  methods:&#123;    del(id)&#123;      this.list=this.list.filter(item=&gt;item.id !==id)    &#125;,    add()&#123;      if(this.todoName.trim()===&quot;&quot;)&#123;        alert(&quot;名称不能为空&quot;)        return      &#125;      this.list.unshift(&#123;        id: +new Date(),        name: this.todoName      &#125;)      this.todoName=&quot;&quot;    &#125;,    qk()&#123;      this.list=[]    &#125;  &#125;  &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><pre><code class="css">html,body &#123;  margin: 0;  padding: 0;&#125;body &#123;  background: #fff;&#125;button &#123;  margin: 0;  padding: 0;  border: 0;  background: none;  font-size: 100%;  vertical-align: baseline;  font-family: inherit;  font-weight: inherit;  color: inherit;  -webkit-appearance: none;  appearance: none;  -webkit-font-smoothing: antialiased;  -moz-osx-font-smoothing: grayscale;&#125;body &#123;  font: 14px &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif;  line-height: 1.4em;  background: #f5f5f5;  color: #4d4d4d;  min-width: 230px;  max-width: 550px;  margin: 0 auto;  -webkit-font-smoothing: antialiased;  -moz-osx-font-smoothing: grayscale;  font-weight: 300;&#125;:focus &#123;  outline: 0;&#125;.hidden &#123;  display: none;&#125;#app &#123;  background: #fff;  margin: 180px 0 40px 0;  padding: 15px;  position: relative;  box-shadow: 0 2px 4px 0 rgba(0, 0, 0, 0.2), 0 25px 50px 0 rgba(0, 0, 0, 0.1);&#125;#app .header input &#123;  border: 2px solid rgba(175, 47, 47, 0.8);  border-radius: 10px;&#125;#app .add &#123;  position: absolute;  right: 15px;  top: 15px;  height: 68px;  width: 140px;  text-align: center;  background-color: rgba(175, 47, 47, 0.8);  color: #fff;  cursor: pointer;  font-size: 18px;  border-radius: 0 10px 10px 0;&#125;#app input::-webkit-input-placeholder &#123;  font-style: italic;  font-weight: 300;  color: #e6e6e6;&#125;#app input::-moz-placeholder &#123;  font-style: italic;  font-weight: 300;  color: #e6e6e6;&#125;#app input::input-placeholder &#123;  font-style: italic;  font-weight: 300;  color: gray;&#125;#app h1 &#123;  position: absolute;  top: -120px;  width: 100%;  left: 50%;  transform: translateX(-50%);  font-size: 60px;  font-weight: 100;  text-align: center;  color: rgba(175, 47, 47, 0.8);  -webkit-text-rendering: optimizeLegibility;  -moz-text-rendering: optimizeLegibility;  text-rendering: optimizeLegibility;&#125;.new-todo,.edit &#123;  position: relative;  margin: 0;  width: 100%;  font-size: 24px;  font-family: inherit;  font-weight: inherit;  line-height: 1.4em;  border: 0;  color: inherit;  padding: 6px;  box-shadow: inset 0 -1px 5px 0 rgba(0, 0, 0, 0.2);  box-sizing: border-box;  -webkit-font-smoothing: antialiased;  -moz-osx-font-smoothing: grayscale;&#125;.new-todo &#123;  padding: 16px;  border: none;  background: rgba(0, 0, 0, 0.003);  box-shadow: inset 0 -2px 1px rgba(0, 0, 0, 0.03);&#125;.main &#123;  position: relative;  z-index: 2;&#125;.todo-list &#123;  margin: 0;  padding: 0;  list-style: none;  overflow: hidden;&#125;.todo-list li &#123;  position: relative;  font-size: 24px;  height: 60px;  box-sizing: border-box;  border-bottom: 1px solid #e6e6e6;&#125;.todo-list li:last-child &#123;  border-bottom: none;&#125;.todo-list .view .index &#123;  position: absolute;  color: gray;  left: 10px;  top: 20px;  font-size: 22px;&#125;.todo-list li .toggle &#123;  text-align: center;  width: 40px;  /* auto, since non-WebKit browsers doesn&#39;t support input styling */  height: auto;  position: absolute;  top: 0;  bottom: 0;  margin: auto 0;  border: none; /* Mobile Safari */  -webkit-appearance: none;  appearance: none;&#125;.todo-list li .toggle &#123;  opacity: 0;&#125;.todo-list li .toggle + label &#123;  /*        Firefox requires `#` to be escaped - https://bugzilla.mozilla.org/show_bug.cgi?id=922433        IE and Edge requires *everything* to be escaped to render, so we do that instead of just the `#` - https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/7157459/    */  background-image: url(&#39;data:image/svg+xml;utf8,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2240%22%20height%3D%2240%22%20viewBox%3D%22-10%20-18%20100%20135%22%3E%3Ccircle%20cx%3D%2250%22%20cy%3D%2250%22%20r%3D%2250%22%20fill%3D%22none%22%20stroke%3D%22%23ededed%22%20stroke-width%3D%223%22/%3E%3C/svg%3E&#39;);  background-repeat: no-repeat;  background-position: center left;&#125;.todo-list li .toggle:checked + label &#123;  background-image: url(&#39;data:image/svg+xml;utf8,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2240%22%20height%3D%2240%22%20viewBox%3D%22-10%20-18%20100%20135%22%3E%3Ccircle%20cx%3D%2250%22%20cy%3D%2250%22%20r%3D%2250%22%20fill%3D%22none%22%20stroke%3D%22%23bddad5%22%20stroke-width%3D%223%22/%3E%3Cpath%20fill%3D%22%235dc2af%22%20d%3D%22M72%2025L42%2071%2027%2056l-4%204%2020%2020%2034-52z%22/%3E%3C/svg%3E&#39;);&#125;.todo-list li label &#123;  word-break: break-all;  padding: 15px 15px 15px 60px;  display: block;  line-height: 1.2;  transition: color 0.4s;&#125;.todo-list li.completed label &#123;  color: #d9d9d9;  text-decoration: line-through;&#125;.todo-list li .destroy &#123;  display: none;  position: absolute;  top: 0;  right: 10px;  bottom: 0;  width: 40px;  height: 40px;  margin: auto 0;  font-size: 30px;  color: #cc9a9a;  margin-bottom: 11px;  transition: color 0.2s ease-out;&#125;.todo-list li .destroy:hover &#123;  color: #af5b5e;&#125;.todo-list li .destroy:after &#123;  content: &#39;×&#39;;&#125;.todo-list li:hover .destroy &#123;  display: block;&#125;.todo-list li .edit &#123;  display: none;&#125;.todo-list li.editing:last-child &#123;  margin-bottom: -1px;&#125;.footer &#123;  color: #777;  padding: 10px 15px;  height: 20px;  text-align: center;  border-top: 1px solid #e6e6e6;&#125;.footer:before &#123;  content: &#39;&#39;;  position: absolute;  right: 0;  bottom: 0;  left: 0;  height: 50px;  overflow: hidden;  box-shadow: 0 1px 1px rgba(0, 0, 0, 0.2), 0 8px 0 -3px #f6f6f6,    0 9px 1px -3px rgba(0, 0, 0, 0.2), 0 16px 0 -6px #f6f6f6,    0 17px 2px -6px rgba(0, 0, 0, 0.2);&#125;.todo-count &#123;  float: left;  text-align: left;&#125;.todo-count strong &#123;  font-weight: 300;&#125;.filters &#123;  margin: 0;  padding: 0;  list-style: none;  position: absolute;  right: 0;  left: 0;&#125;.filters li &#123;  display: inline;&#125;.filters li a &#123;  color: inherit;  margin: 3px;  padding: 3px 7px;  text-decoration: none;  border: 1px solid transparent;  border-radius: 3px;&#125;.filters li a:hover &#123;  border-color: rgba(175, 47, 47, 0.1);&#125;.filters li a.selected &#123;  border-color: rgba(175, 47, 47, 0.2);&#125;.clear-completed,html .clear-completed:active &#123;  float: right;  position: relative;  line-height: 20px;  text-decoration: none;  cursor: pointer;&#125;.clear-completed:hover &#123;  text-decoration: underline;&#125;.info &#123;  margin: 50px auto 0;  color: #bfbfbf;  font-size: 15px;  text-shadow: 0 1px 0 rgba(255, 255, 255, 0.5);  text-align: center;&#125;.info p &#123;  line-height: 1;&#125;.info a &#123;  color: inherit;  text-decoration: none;  font-weight: 400;&#125;.info a:hover &#123;  text-decoration: underline;&#125;/*    Hack to remove background from Mobile Safari.    Can&#39;t use it globally since it destroys checkboxes in Firefox*/@media screen and (-webkit-min-device-pixel-ratio: 0) &#123;  .toggle-all,  .todo-list li .toggle &#123;    background: none;  &#125;  .todo-list li .toggle &#123;    height: 40px;  &#125;&#125;@media (max-width: 430px) &#123;  .footer &#123;    height: 50px;  &#125;  .filters &#123;    bottom: 10px;  &#125;&#125;</code></pre><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230718001533335.png" alt="image-20230718001533335"></p><p>@keyup.enter 键盘回车监听</p><p>v-model修饰符</p><p>v-model.trim  -》 取出首尾空格</p><p>v-model.number-》 转数字</p><p>@时间名.stop  -》 阻止冒泡</p><p>@时间名.prevent -》阻止默认行为</p><p>v-bind的样式增强</p><p>对.class操作</p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230718205311938.png" alt="image-20230718205311938"></p><pre><code class="vue"> &lt;div id=&quot;app&quot;&gt;    &lt;ul&gt;      &lt;li v-for=&quot;(item,index) in list&quot;&gt;&lt;a :class=&quot;&#123;active: index===activeIndex&#125;&quot; href=&quot;#&quot; @click=&quot;activeIndex= index&quot;&gt;&#123;&#123;item.name&#125;&#125;&lt;/a&gt;&lt;/li&gt;    &lt;/ul&gt;  &lt;/div&gt;  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt;  &lt;script&gt;    const app = new Vue(&#123;      el: &#39;#app&#39;,      data: &#123;        activeIndex: 0,        list: [          &#123; id: 1, name: &#39;京东秒杀&#39; &#125;,          &#123; id: 2, name: &#39;每日特价&#39; &#125;,          &#123; id: 3, name: &#39;品类秒杀&#39; &#125;        ]      &#125;    &#125;)</code></pre><p>对stytle操作</p><pre><code class="vue">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;Document&lt;/title&gt;  &lt;style&gt;    .progress &#123;      height: 25px;      width: 400px;      border-radius: 15px;      background-color: #272425;      border: 3px solid #272425;      box-sizing: border-box;      margin-bottom: 30px;    &#125;    .inner &#123;      width: 50%;      height: 20px;      border-radius: 10px;      text-align: right;      position: relative;      background-color: #409eff;      background-size: 20px 20px;      box-sizing: border-box;      transition: all 1s;    &#125;    .inner span &#123;      position: absolute;      right: -20px;      bottom: -25px;    &#125;  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;div class=&quot;progress&quot;&gt;      &lt;div :style=&quot;&#123;width: percent+&#39;%&#39;&#125;&quot; class=&quot;inner&quot;&gt;        &lt;span&gt;&#123;&#123;percent+'%'&#125;&#125;&lt;/span&gt;      &lt;/div&gt;    &lt;/div&gt;    &lt;button @click=&quot;setpercent(25)&quot;&gt;设置25%&lt;/button&gt;    &lt;button @click=&quot;setpercent(50)&quot;&gt;设置50%&lt;/button&gt;    &lt;button @click=&quot;setpercent(75)&quot;&gt;设置75%&lt;/button&gt;    &lt;button @click=&quot;setpercent(100)&quot;&gt;设置100%&lt;/button&gt;  &lt;/div&gt;  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt;  &lt;script&gt;    const app = new Vue(&#123;      el: &#39;#app&#39;,      data: &#123;        percent: 30      &#125;,      methods: &#123;        setpercent(x)&#123;            this.percent=x;        &#125;      &#125;    &#125;)  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230718210424696.png" alt="image-20230718210424696"></p><p>v-model在表单其他属性的使用</p><pre><code class="vue"> &lt;div id=&quot;app&quot;&gt;    &lt;h3&gt;小黑学习网&lt;/h3&gt;    姓名：      &lt;input v-model=&quot;username&quot; type=&quot;text&quot;&gt;       &lt;br&gt;&lt;br&gt;    是否单身：      &lt;input type=&quot;checkbox&quot; v-model=&quot;isSingle&quot;&gt;       &lt;br&gt;&lt;br&gt;    &lt;!--       前置理解：        1. name:  给单选框加上 name 属性 可以分组 → 同一组互相会互斥        2. value: 给单选框加上 value 属性，用于提交给后台的数据      结合 Vue 使用 → v-model    --&gt;    性别:       &lt;input v-model=&quot;gender&quot; type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;1&quot;&gt;男      &lt;input v-model=&quot;gender&quot; type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;0&quot;&gt;女      &lt;br&gt;&lt;br&gt;    &lt;!--       前置理解：        1. option 需要设置 value 值，提交给后台        2. select 的 value 值，关联了选中的 option 的 value 值      结合 Vue 使用 → v-model    --&gt;    所在城市:      &lt;select v-model=&quot;cityname&quot;&gt;        &lt;option value=&quot;bj&quot;&gt;北京&lt;/option&gt;        &lt;option value=&quot;sh&quot;&gt;上海&lt;/option&gt;        &lt;option value=&quot;cd&quot;&gt;成都&lt;/option&gt;        &lt;option value=&quot;nj&quot;&gt;南京&lt;/option&gt;      &lt;/select&gt;      &lt;br&gt;&lt;br&gt;    自我描述：      &lt;textarea v-model=&quot;desc&quot;&gt;&lt;/textarea&gt;     &lt;button&gt;立即注册&lt;/button&gt;  &lt;/div&gt;  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt;  &lt;script&gt;    const app = new Vue(&#123;      el: &#39;#app&#39;,      data: &#123;        username: &#39;2314&#39;,        isSingle: false,        gender: 1,        cityname: &#39;sh&#39;,        desc: 264452      &#125;    &#125;)  &lt;/script&gt;</code></pre><p>计算属性</p><h5 id="computed计算属性"><a href="#computed计算属性" class="headerlink" title="computed计算属性"></a>computed计算属性</h5><pre><code>&lt;body&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;h3&gt;小黑的礼物清单&lt;/h3&gt;    &lt;table&gt;      &lt;tr&gt;        &lt;th&gt;名字&lt;/th&gt;        &lt;th&gt;数量&lt;/th&gt;      &lt;/tr&gt;      &lt;tr v-for=&quot;(item, index) in list&quot; :key=&quot;item.id&quot;&gt;        &lt;td&gt;&#123;&#123; item.name &#125;&#125;&lt;/td&gt;        &lt;td&gt;&#123;&#123; item.num &#125;&#125;个&lt;/td&gt;      &lt;/tr&gt;    &lt;/table&gt;    &lt;!-- 目标：统计求和，求得礼物总数 --&gt;    &lt;p&gt;礼物总数：&#123;&#123;totalCount&#125;&#125;个&lt;/p&gt;  &lt;/div&gt;  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt;  &lt;script&gt;    const app = new Vue(&#123;      el: &#39;#app&#39;,      data: &#123;        // 现有的数据        list: [          &#123; id: 1, name: &#39;篮球&#39;, num: 1 &#125;,          &#123; id: 2, name: &#39;玩具&#39;, num: 2 &#125;,          &#123; id: 3, name: &#39;铅笔&#39;, num: 5 &#125;,        ]      &#125;,      computed: &#123;        totalCount()&#123;                      //需求： 对this.list数组里面的num进行求和          let total= this.list.reduce((sum,item)=&gt; sum+item.num,0)          return total;        &#125;      &#125;    &#125;)  &lt;/script&gt;&lt;/body&gt;</code></pre><p>这里面的totalCount只是一个属性 他不是一个函数 只是一个属性 可以直接用 </p><p>另外 reduce（sum，item）&#x3D;》sum +item.num，0</p><pre><code>computed: &#123;        totalCount()&#123;                      //需求： 对this.list数组里面的num进行求和          let total= this.list.reduce((sum,item)=&gt; sum+item.num,0)          return total;        &#125;      &#125;</code></pre><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230718213627406.png" alt="image-20230718213627406"></p><p>计算属性的完整写法</p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230718214407703.png" alt="image-20230718214407703"></p><pre><code class="vue">  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt;  &lt;script&gt;    const app = new Vue(&#123;      el: &#39;#app&#39;,      data: &#123;        fname: &#39;李&#39;,        lname: &#39;99&#39;,      &#125;,      methods: &#123;        changename()&#123;          this.updatename=&#39;吕布&#39;        &#125;      &#125;,      computed: &#123;        updatename:&#123;          get()&#123;            this.fullname=this.fname+this.lname           return this.fullname;          &#125;,          // 当updatename计算属性被修改时 执行set函数 并且          // 这个操作是双向的 但是具体的逻辑是自己实现          set(value)&#123;            this.fname=value.slice(0,1),            this.lname=value.slice(1)          &#125;        &#125;      &#125;,          &#125;)  &lt;/script&gt;</code></pre><p>综合大案例</p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230718224255059.png" alt="image-20230718224255059"></p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230718224323286.png" alt="image-20230718224323286"></p><pre><code class="vue"> &lt;body&gt;    &lt;div id=&quot;app&quot; class=&quot;score-case&quot;&gt;      &lt;div class=&quot;table&quot;&gt;        &lt;table&gt;          &lt;thead&gt;            &lt;tr&gt;              &lt;th&gt;编号&lt;/th&gt;              &lt;th&gt;科目&lt;/th&gt;              &lt;th&gt;成绩&lt;/th&gt;              &lt;th&gt;操作&lt;/th&gt;            &lt;/tr&gt;          &lt;/thead&gt;          &lt;tbody v-if=&quot;list.length&gt;0&quot;&gt;            &lt;tr v-for=&quot;(item,index) in list&quot; :key=&quot;item.id&quot;&gt;              &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt;              &lt;td&gt;&#123;&#123;item.subject&#125;&#125;&lt;/td&gt;              &lt;td :class=&quot;&#123;red: item.score&lt;60&#125;&quot;&gt;&#123;&#123;item.score&#125;&#125;&lt;/td&gt;              &lt;td&gt;&lt;a @click.prevent=&quot;del(item.id)&quot; href=&quot;www.baidu.comwww.baidu.com&quot;&gt;删除&lt;/a&gt;&lt;/td&gt;            &lt;/tr&gt;          &lt;/tbody&gt;          &lt;tbody v-else&gt;            &lt;tr&gt;              &lt;td colspan=&quot;5&quot;&gt;                &lt;span class=&quot;none&quot;&gt;暂无数据&lt;/span&gt;              &lt;/td&gt;            &lt;/tr&gt;          &lt;/tbody&gt;          &lt;tfoot&gt;            &lt;tr&gt;              &lt;td colspan=&quot;5&quot;&gt;                &lt;span&gt;总分：&#123;&#123;totalScore&#125;&#125;&lt;/span&gt;                &lt;span style=&quot;margin-left: 50px&quot;&gt;平均分：&#123;&#123;averageScorce&#125;&#125;&lt;/span&gt;              &lt;/td&gt;            &lt;/tr&gt;          &lt;/tfoot&gt;        &lt;/table&gt;      &lt;/div&gt;      &lt;div class=&quot;form&quot;&gt;        &lt;div class=&quot;form-item&quot;&gt;          &lt;div class=&quot;label&quot;&gt;科目：&lt;/div&gt;          &lt;div class=&quot;input&quot;&gt;            &lt;input               type=&quot;text&quot;              placeholder=&quot;请输入科目&quot;            v-model.trim=&quot;subject&quot; /&gt;          &lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;form-item&quot;&gt;          &lt;div class=&quot;label&quot;&gt;分数：&lt;/div&gt;          &lt;div class=&quot;input&quot;&gt;            &lt;input              type=&quot;text&quot;              placeholder=&quot;请输入分数&quot;             v-model=&quot;score&quot;/&gt;          &lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;form-item&quot;&gt;          &lt;div class=&quot;label&quot;&gt;&lt;/div&gt;          &lt;div class=&quot;input&quot;&gt;            &lt;button class=&quot;submit&quot; @click=&quot;add()&quot; &gt;添加&lt;/button&gt;          &lt;/div&gt;        &lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt;    &lt;script&gt;      const app = new Vue(&#123;        el: &#39;#app&#39;,        data: &#123;          list: [            &#123; id: 1, subject: &#39;语文&#39;, score: 20 &#125;,            &#123; id: 7, subject: &#39;数学&#39;, score: 99 &#125;,            &#123; id: 12, subject: &#39;英语&#39;, score: 70 &#125;,          ],          subject: &#39;&#39;,          score: 0,        &#125;,        methods:&#123;          del(id)&#123;            this.list=this.list.filter(item=&gt; item.id!=id);          &#125;,          add()&#123;            if(!this.subject)&#123;              alert(&quot;请输入科目&quot;);              return            &#125;            if(typeof this.score !==&#39;number&#39;)&#123;              alert(&quot;输入正确的分数&quot;)              return            &#125;            this.list.unshift(&#123;              id: +new Date(),              subject: this.subject,              score: this.score            &#125;)            this.subject=&#39;&#39;,            this.score=&#39;&#39;          &#125;        &#125;,        computed:&#123;          totalScore()&#123;            return this.list.reduce((sum,item)=&gt;sum+item.score,0)          &#125;,          averageScorce()&#123;            if(this.list.length===0)&#123;              return 0;            &#125;              return (this.totalScore/this.list.length).toFixed(2)          &#125;                  &#125;      &#125;)    &lt;/script&gt;</code></pre><p>watch监听器</p><p>监听frutilist数据一旦改变获得最新值</p><pre><code>        watch:&#123;          fruitList:&#123;            deep:true,            handler(newValue)&#123;              localStorage.setItem(&quot;fruit&quot;,JSON.stringify(newValue))            &#125;          &#125;        &#125;</code></pre><h3 id="重要方法"><a href="#重要方法" class="headerlink" title="重要方法"></a>重要方法</h3><p>数组.reduce</p><p>可以实现累加效果</p><pre><code>return this.fruitList.reduce((sum, item) =&gt; sum + item, 0);</code></pre><p>在这里，累加器函数 <code>(sum, item) =&gt; sum + item</code> 将每个元素依次加到累加器 <code>sum</code> 上，最终返回总和。初始值为 0，确保了当 <code>fruitList</code> 为空数组时，也能得到正确的结果。</p><p>array.find 实现找到指定id的数组元素</p><p>你的代码 <code>fruit.num--;</code> 是想要将找到的水果对象的 <code>num</code> 属性减 1。不过，在使用 <code>find</code> 方法找到对象后，需要确保对象存在才能执行减法操作，否则可能会导致错误。</p><pre><code>const fruit = this.fruitList.find(item =&gt; item.id === id);if (fruit) &#123;  fruit.num--;&#125;</code></pre><p>通过添加条件判断，<code>if (fruit)</code> 确保了对象存在时才执行减法操作。这样可以避免在找不到对象时出现错误，确保代码的稳定性。</p><p>数组.filter 可以实现数组元素的删除</p><p>你的代码 <code>this.fruitList = this.fruitList.filter(item =&gt; item.id !== id);</code> 是想要从 <code>fruitList</code> 数组中移除指定 <code>id</code> 的水果对象。</p><p><code>filter</code> 方法用于创建一个新数组，其中包含满足指定条件的所有元素。在这里，你可以使用 <code>filter</code> 方法来过滤掉指定 <code>id</code> 的水果对象。</p><p>以下是修正后的代码示例：</p><pre><code>javascriptCopy Codethis.fruitList = this.fruitList.filter(item =&gt; item.id !== id);</code></pre><p>通过使用 <code>filter</code> 方法并指定条件 <code>item.id !== id</code>，我们将筛选出 <code>id</code> 不等于给定值的水果对象，然后将结果赋值给 <code>fruitList</code> 数组。这样就实现了从数组中移除指定 <code>id</code> 的水果对象的操作。</p><h1 id="综合案例购物车"><a href="#综合案例购物车" class="headerlink" title="综合案例购物车"></a>综合案例购物车</h1><p><strong>实现功能</strong></p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230719223605712.png" alt="image-20230719223605712"></p><p>需求</p><p>1.渲染功能</p><p>2.删除功能</p><p>3.修改功能</p><p>4.全选反选</p><p>5.统计选中的总价和总数量</p><p>6.持久化到本地</p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230719223714850.png" alt="image-20230719223714850"></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;./css/inputnumber.css&quot; /&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;./css/index.css&quot; /&gt;    &lt;title&gt;购物车&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div class=&quot;app-container&quot; id=&quot;app&quot;&gt;      &lt;!-- 顶部banner --&gt;      &lt;div class=&quot;banner-box&quot;&gt;&lt;img src=&quot;http://autumnfish.cn/static/fruit.jpg&quot; alt=&quot;&quot; /&gt;&lt;/div&gt;      &lt;!-- 面包屑 --&gt;      &lt;div class=&quot;breadcrumb&quot;&gt;        &lt;span&gt;🏠&lt;/span&gt;        /        &lt;span&gt;购物车&lt;/span&gt;      &lt;/div&gt;      &lt;!-- 购物车主体 --&gt;      &lt;div class=&quot;main&quot; v-if=&quot;fruitList.length&gt;0&quot;&gt;        &lt;div class=&quot;table&quot;&gt;          &lt;!-- 头部 --&gt;          &lt;div class=&quot;thead&quot;&gt;            &lt;div class=&quot;tr&quot;&gt;              &lt;div class=&quot;th&quot;&gt;选中&lt;/div&gt;              &lt;div class=&quot;th th-pic&quot;&gt;图片&lt;/div&gt;              &lt;div class=&quot;th&quot;&gt;单价&lt;/div&gt;              &lt;div class=&quot;th num-th&quot;&gt;个数&lt;/div&gt;              &lt;div class=&quot;th&quot;&gt;小计&lt;/div&gt;              &lt;div class=&quot;th&quot;&gt;操作&lt;/div&gt;            &lt;/div&gt;          &lt;/div&gt;          &lt;!-- 身体 --&gt;          &lt;div class=&quot;tbody&quot;&gt;            &lt;div  v-for=&quot;(item,index) in fruitList&quot; :key=&quot;item.id&quot; class=&quot;tr&quot; :class=&quot;&#123;active: item.isChecked&#125;&quot;&gt;              &lt;div class=&quot;td&quot;&gt;&lt;input type=&quot;checkbox&quot; v-model=&quot;item.isChecked&quot; /&gt;&lt;/div&gt;              &lt;div class=&quot;td&quot;&gt;&lt;img :src=&quot;item.icon&quot; alt=&quot;&quot; /&gt;&lt;/div&gt;              &lt;div class=&quot;td&quot;&gt;&#123;&#123;item.price&#125;&#125;&lt;/div&gt;              &lt;div class=&quot;td&quot;&gt;                &lt;div class=&quot;my-input-number&quot;&gt;                  &lt;button :disabled=&quot;item.num&lt;=1&quot; class=&quot;decrease&quot; @click=&quot;inc(item.id)&quot;&gt; - &lt;/button&gt;                  &lt;span class=&quot;my-input__inner&quot;&gt;&#123;&#123;item.num&#125;&#125;&lt;/span&gt;                  &lt;button class=&quot;increase&quot; @click=&quot;su(item.id)&quot;&gt; + &lt;/button&gt;                &lt;/div&gt;              &lt;/div&gt;              &lt;div class=&quot;td&quot;&gt;&#123;&#123;item.price * item.num&#125;&#125;&lt;/div&gt;              &lt;div class=&quot;td&quot;&gt;&lt;button @click=&quot;del(item.id)&quot;&gt;删除&lt;/button&gt;&lt;/div&gt;            &lt;/div&gt;          &lt;/div&gt;        &lt;/div&gt;        &lt;!-- 底部 --&gt;        &lt;div class=&quot;bottom&quot;&gt;          &lt;!-- 全选 --&gt;          &lt;label class=&quot;check-all&quot; &gt;            &lt;input type=&quot;checkbox&quot; v-model=&quot;isall&quot; /&gt;            全选          &lt;/label&gt;          &lt;div class=&quot;right-box&quot;&gt;            &lt;!-- 所有商品总价 --&gt;            &lt;span class=&quot;price-box&quot;&gt;总价&amp;nbsp;&amp;nbsp;:&amp;nbsp;&amp;nbsp;¥&amp;nbsp;&lt;span class=&quot;price&quot;&gt;&#123;&#123;totalprice&#125;&#125;&lt;/span&gt;&lt;/span&gt;            &lt;!-- 结算按钮 --&gt;            &lt;button class=&quot;pay&quot;&gt;结算( &#123;&#123;totalcount&#125;&#125; )&lt;/button&gt;          &lt;/div&gt;        &lt;/div&gt;      &lt;/div&gt;      &lt;!-- 空车 --&gt;      &lt;div class=&quot;empty&quot; v-else&gt;🛒空空如也&lt;/div&gt;    &lt;/div&gt;    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt;    &lt;script&gt;      const defaltArr= [            &#123;              id: 1,              icon: &#39;http://autumnfish.cn/static/火龙果.png&#39;,              isChecked: true,              num: 2,              price: 6,            &#125;,            &#123;              id: 2,              icon: &#39;http://autumnfish.cn/static/荔枝.png&#39;,              isChecked: false,              num: 7,              price: 20,            &#125;,            &#123;              id: 3,              icon: &#39;http://autumnfish.cn/static/榴莲.png&#39;,              isChecked: false,              num: 3,              price: 40,            &#125;,            &#123;              id: 4,              icon: &#39;http://autumnfish.cn/static/鸭梨.png&#39;,              isChecked: true,              num: 10,              price: 3,            &#125;,            &#123;              id: 5,              icon: &#39;http://autumnfish.cn/static/樱桃.png&#39;,              isChecked: false,              num: 20,              price: 34,            &#125;,          ]      const app = new Vue(&#123;        el: &#39;#app&#39;,        data: &#123;          fruitList: JSON.parse(localStorage.getItem(&#39;fruit&#39;))||defaltArr,        &#125;,        methods:&#123;          del(id)&#123;              this.fruitList=this.fruitList.filter(item=&gt; item.id!==id)          &#125;,          su(id)&#123;            const fruit=this.fruitList.find(item=&gt;item.id===id)            fruit.num++;          &#125;,          inc(id)&#123;            const fruit=this.fruitList.find(iteitem=&gt;item.id===id)            fruit.num--;          &#125;        &#125;,        computed: &#123;          isall:&#123;            get()&#123;            return this.fruitList.every(item=&gt; item.isChecked);          &#125;,          set(value)&#123;            this.fruitList.forEach(item =&gt; item.isChecked= value);          &#125;          &#125;,          totalcount()&#123;            return this.fruitList.reduce((sum,item)=&gt;item.isChecked?item.num+sum:sum=sum,0);          &#125;,          totalprice()&#123;            return this.fruitList.reduce((sum,item)=&gt;item.isChecked?item.num*item.price+sum:sum=sum,0);          &#125;          // isall()&#123;          //   //必须苏哦有的小选择框都选中我们才选中这个-every          //   return this.fruitList.every(item=&gt;item.isChecked)          // &#125;        &#125;,        watch:&#123;          fruitList:&#123;            deep:true,            handler(newValue)&#123;              localStorage.setItem(&quot;fruit&quot;,JSON.stringify(newValue))            &#125;          &#125;        &#125;      &#125;)    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><h1 id="VUE的生命周期"><a href="#VUE的生命周期" class="headerlink" title="VUE的生命周期"></a>VUE的生命周期</h1><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230719224810721.png" alt="image-20230719224810721"></p><p><strong>vue的生命周期函数（钩子函数）</strong></p><pre><code class="vue"> &lt;script&gt;    const app = new Vue(&#123;      el: &#39;#app&#39;,      data: &#123;        count: 100,        title: &#39;计数器&#39;      &#125;,      // 1. 创建阶段（准备数据）      beforeCreate () &#123;        console.log(&#39;beforeCreate 响应式数据准备好之前&#39;, this.count)      &#125;,      created () &#123;        console.log(&#39;created 响应式数据准备好之后&#39;, this.count)        // this.数据名 = 请求回来的数据        // 可以开始发送初始化渲染的请求了      &#125;,      // 2. 挂载阶段（渲染模板）      beforeMount () &#123;        console.log(&#39;beforeMount 模板渲染之前&#39;, document.querySelector(&#39;h3&#39;).innerHTML)      &#125;,      mounted () &#123;        console.log(&#39;mounted 模板渲染之后&#39;, document.querySelector(&#39;h3&#39;).innerHTML)        // 可以开始操作dom了      &#125;,      // 3. 更新阶段(修改数据 → 更新视图)      beforeUpdate () &#123;        console.log(&#39;beforeUpdate 数据修改了，视图还没更新&#39;, document.querySelector(&#39;span&#39;).innerHTML)      &#125;,      updated () &#123;        console.log(&#39;updated 数据修改了，视图已经更新&#39;, document.querySelector(&#39;span&#39;).innerHTML)      &#125;,      // 4. 卸载阶段      beforeDestroy () &#123;        console.log(&#39;beforeDestroy, 卸载前&#39;)        console.log(&#39;清除掉一些Vue以外的资源占用，定时器，延时器...&#39;)      &#125;,      destroyed () &#123;        console.log(&#39;destroyed，卸载后&#39;)      &#125;    &#125;)  &lt;/script&gt;</code></pre><p>此函数是在数据创建完毕</p><p>钩子函数 一般操作数据需要在created（）函数中进行</p><p>此钩子函数是视图渲染完毕</p><p>一般操作mounted中进行dom操作</p><h1 id="VUECLI-工程化构建"><a href="#VUECLI-工程化构建" class="headerlink" title="VUECLI 工程化构建"></a>VUECLI 工程化构建</h1><p>在想要创建的目录下面按着shift 点击右键打开vuecli 创建命令为vue create project </p><p>前提是你已经安装了 npm 和vue 然后 启动项目是npm run server 启动命令可以在在</p><p>package.json下修改</p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230721231242849.png" alt="image-20230721231242849"></p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230720223909148.png" alt="image-20230720223909148"></p><p><strong>工程化页面不在index.html下写代码</strong></p><p>index只是容器功能  App.vue是页面编写页面代码</p><p>main.js 是打包的入口文件</p><p>index.html第一个index</p><pre><code class="vue">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;utf-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt;    &lt;link rel=&quot;icon&quot; href=&quot;&lt;%= BASE_URL %&gt;favicon.ico&quot;&gt;    &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;!-- 兼容：给不支持js的浏览器一个提示 --&gt;    &lt;noscript&gt;      &lt;strong&gt;We&#39;re sorry but &lt;%= htmlWebpackPlugin.options.title %&gt; doesn&#39;t work properly without JavaScript enabled. Please enable it to continue.&lt;/strong&gt;    &lt;/noscript&gt;    &lt;!-- Vue所管理的容器：将来创建结构动态渲染这个容器 --&gt;    &lt;div id=&quot;app&quot;&gt;      &lt;!-- 工程化开发模式中：这里不再直接编写模板语法，通过 App.vue 提供结构渲染 --&gt;    &lt;/div&gt;    &lt;!-- built files will be auto injected --&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><p>main.js</p><pre><code></code></pre><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230720233732764.png" alt="image-20230720233732764"></p><h3 id="局部注册和全局注册"><a href="#局部注册和全局注册" class="headerlink" title="局部注册和全局注册"></a>局部注册和全局注册</h3><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230721001822698.png" alt="image-20230721001822698"></p><p>实例在APp.vue局部注册</p><p>import HmHeader from ‘.&#x2F;components&#x2F;HmHeader.vue’</p><p>import HmMain from ‘.&#x2F;components&#x2F;HmMain.vue’</p><p>import HmFooter from ‘.&#x2F;components&#x2F;HmFooter.vue’</p><p>export default {</p><p> components: {</p><p>  &#x2F;&#x2F; ‘组件名’: 组件对象</p><p>  HmHeader: HmHeader,</p><p>  HmMain,</p><p>  HmFooter</p><p> }</p><p>}</p><pre><code>&lt;template&gt;  &lt;div class=&quot;App&quot;&gt;    &lt;!-- 头部组件 --&gt;    &lt;HmHeader&gt;&lt;/HmHeader&gt;    &lt;!-- 主体组件 --&gt;    &lt;HmMain&gt;&lt;/HmMain&gt;    &lt;!-- 底部组件 --&gt;    &lt;HmFooter&gt;&lt;/HmFooter&gt;    &lt;!-- 如果 HmFooter + tab 出不来 → 需要配置 vscode         设置中搜索 trigger on tab → 勾上    --&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import HmHeader from &#39;./components/HmHeader.vue&#39;import HmMain from &#39;./components/HmMain.vue&#39;import HmFooter from &#39;./components/HmFooter.vue&#39;export default &#123;  components: &#123;    // &#39;组件名&#39;: 组件对象    HmHeader: HmHeader,    HmMain,    HmFooter  &#125;&#125;&lt;/script&gt;&lt;style&gt;.App &#123;  width: 600px;  height: 700px;  background-color: #87ceeb;  margin: 0 auto;  padding: 20px;&#125;&lt;/style&gt;</code></pre><p>全局注册注册到mian.js</p><p>用Vue.component(‘HmButton’, HmButton)</p><pre><code>// 文件核心作用：导入App.vue，基于App.vue创建结构渲染index.htmlimport Vue from &#39;vue&#39;import App from &#39;./App.vue&#39;// 编写导入的代码，往代码的顶部编写(规范)import HmButton from &#39;./components/HmButton&#39;Vue.config.productionTip = false// 进行全局注册 → 在所有的组件范围内都能直接使用// Vue.component(组件名，组件对象)Vue.component(&#39;HmButton&#39;, HmButton)// Vue实例化，提供render方法 → 基于App.vue创建结构渲染index.htmlnew Vue(&#123;  // render: h =&gt; h(App),  render: (createElement) =&gt; &#123;    // 基于App创建元素结构    return createElement(App)  &#125;&#125;).$mount(&#39;#app&#39;)</code></pre><h1 id="便捷开发按键"><a href="#便捷开发按键" class="headerlink" title="便捷开发按键"></a>便捷开发按键</h1><p>ctrl+k ctrl+0 组合按 全部合并</p><p>ctrl+k ctrl+j 组合按 全部展开</p><p>shift+alt可以魔法粘贴</p><h3 id="关于vue中的style的局部影响和全局影响"><a href="#关于vue中的style的局部影响和全局影响" class="headerlink" title="关于vue中的style的局部影响和全局影响"></a>关于vue中的style的局部影响和全局影响</h3><style scoped></style><p>加上scoped表示只影响当前组件</p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230722120016634.png" alt="image-20230722120016634"></p><h2 id="补充在Vue中，export和export-default是用于导出模块的两种不同方式。"><a href="#补充在Vue中，export和export-default是用于导出模块的两种不同方式。" class="headerlink" title="补充在Vue中，export和export default是用于导出模块的两种不同方式。****"></a>补充在Vue中，<code>export</code>和<code>export default</code>是用于导出模块的两种不同方式。****</h2><p>在Vue中，<code>export</code>和<code>export default</code>是用于导出模块的两种不同方式。</p><p><code>export</code>用于导出模块中的一个或多个具名变量、函数或类。例如：</p><p>javascript</p><p>Copy</p><pre><code>// module.jsexport const name = &#39;John&#39;;export function sayHello() &#123;  console.log(&#39;Hello!&#39;);&#125;export class Person &#123;  constructor(name) &#123;    this.name = name;  &#125;&#125;</code></pre><p>在另一个文件中，可以使用<code>import</code>关键字导入模块中的具名变量、函数或类。例如：</p><p>javascript</p><p>Copy</p><pre><code>// main.jsimport &#123; name, sayHello, Person &#125; from &#39;./module.js&#39;;console.log(name); // &#39;John&#39;sayHello(); // &#39;Hello!&#39;const person = new Person(&#39;Tom&#39;);console.log(person.name); // &#39;Tom&#39;</code></pre><p><code>export default</code>用于导出模块中的默认值。每个模块只能有一个默认导出。例如：</p><p>javascript</p><p>Copy</p><pre><code>// module.jsexport default &#123;  name: &#39;John&#39;,  sayHello() &#123;    console.log(&#39;Hello!&#39;);  &#125;&#125;</code></pre><p>在另一个文件中，可以使用<code>import</code>关键字导入模块的默认导出。例如：</p><p>javascript</p><p>Copy</p><pre><code>// main.jsimport person from &#39;./module.js&#39;;console.log(person.name); // &#39;John&#39;person.sayHello(); // &#39;Hello!&#39;</code></pre><p>注意：当使用<code>export default</code>时，可以在导入模块时使用任何名称，而不需要使用花括号。但是，当使用<code>export</code>时，必须使用相应的名称（如上例中的<code>&#123; name, sayHello, Person &#125;</code>）。</p><h1 id="父子组件传值"><a href="#父子组件传值" class="headerlink" title="父子组件传值"></a>父子组件传值</h1><p>1.两种组件关系分类和对应的组件通信方案</p><p>父子关系 -》 props $ emit</p><p>非父子关系 -》 provide ￥ inject 或者eventbus</p><p>通用方案 vuex</p><p>2.父子痛惜方案核心流程</p><p>2.1父传子 props：</p><p>1.父中给子添加属性 2.子中props接受 3.使用</p><p>2.子传父</p><p>$emit:父类事件 $em it（”父类事件”，传入参数）</p><h1 id="props参数传递详解"><a href="#props参数传递详解" class="headerlink" title="props参数传递详解"></a>props参数传递详解</h1><p>这是一个接收数据的案例包括了校验规则的使用</p><p>但是这些校验只是警告数据并不会真实不接收 </p><pre><code>&lt;script&gt;export default &#123;  // props:[&#39;username&#39;,&#39;age&#39;,&#39;isSingle&#39;,&#39;car&#39;,&#39;hobby&#39;]  props:&#123;    username: &#123;      type: Number,      required: true,      default: 0,//类型校验非空校验以及默认值      validator(value)&#123;          console.log(value)          if(value&gt;=0&amp;&amp;value&lt;=100)&#123;            return true          &#125;else&#123;            console.log(&quot;传入参数不符合&quot;);            return false;          &#125;      &#125;    &#125;,    age:String,    isSingle: Boolean,    car:Array,    hobby:Array  &#125;&#125;&lt;/script&gt;</code></pre><h1 id="非父子组件的事件触发-通信"><a href="#非父子组件的事件触发-通信" class="headerlink" title="非父子组件的事件触发 通信"></a>非父子组件的事件触发 通信</h1><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230722164544091.png" alt="image-20230722164544091"></p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230722165441242.png" alt="image-20230722165441242"></p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230722165622724.png" alt="image-20230722165622724"></p><h1 id="v-model深入了解"><a href="#v-model深入了解" class="headerlink" title="v-model深入了解"></a>v-model深入了解</h1><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230722170403075.png" alt="image-20230722170403075"></p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230722170712475.png" alt="image-20230722170712475"></p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230722180341321.png" alt="image-20230722180341321"></p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230722180545693.png" alt="image-20230722180545693"></p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230722181212604.png" alt="image-20230722181212604"></p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230722190802738.png" alt="image-20230722190802738"></p><h3 id="在vue中获取dom元素"><a href="#在vue中获取dom元素" class="headerlink" title="在vue中获取dom元素"></a>在vue中获取dom元素</h3><p>在标签里面设置 ref&#x3D;‘名字’</p><p>在使用的地址进行使用    this.$refs.名字</p><p>ag.</p><pre><code class="vue">&lt;template&gt;  &lt;div class=&quot;base-chart-box&quot; ref=&quot;baseChartBox&quot;&gt;子组件&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import * as echarts from &#39;echarts&#39;export default &#123;  mounted() &#123;    // 基于准备好的dom，初始化echarts实例    // document.querySelector 会查找项目中所有的元素    // $refs只会在当前组件查找盒子    // var myChart = echarts.init(document.querySelector(&#39;.base-chart-box&#39;))    var myChart = echarts.init(this.$refs.baseChartBox)    // 绘制图表    myChart.setOption(&#123;      title: &#123;        text: &#39;ECharts 入门示例&#39;,      &#125;,      tooltip: &#123;&#125;,      xAxis: &#123;        data: [&#39;衬衫&#39;, &#39;羊毛衫&#39;, &#39;雪纺衫&#39;, &#39;裤子&#39;, &#39;高跟鞋&#39;, &#39;袜子&#39;],      &#125;,      yAxis: &#123;&#125;,      series: [        &#123;          name: &#39;销量&#39;,          type: &#39;bar&#39;,          data: [5, 20, 36, 10, 10, 20],        &#125;,      ],    &#125;)  &#125;,&#125;&lt;/script&gt;&lt;style scoped&gt;.base-chart-box &#123;  width: 400px;  height: 300px;  border: 3px solid #000;  border-radius: 6px;&#125;&lt;/style&gt;</code></pre><pre><code>&lt;template&gt;  &lt;div class=&quot;app&quot;&gt;    &lt;div class=&quot;base-chart-box&quot;&gt;      这是一个捣乱的盒子    &lt;/div&gt;    &lt;BaseChart&gt;&lt;/BaseChart&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import BaseChart from &#39;./components/BaseChart.vue&#39;export default &#123;  components:&#123;    BaseChart  &#125;&#125;&lt;/script&gt;&lt;style&gt;.base-chart-box &#123;  width: 300px;  height: 200px;&#125;&lt;/style&gt;</code></pre><p>注意 vue中的dom操作时异步执行的 时进行一定dom操作后异步执行 ，所以在使用 获取dom操作的时候 </p><p>更新dom资源后直接使用 可能会爆未定义的错误，</p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230723095303774.png" alt="image-20230723095303774"></p><p>需要放到操作</p><p>this.$nextTick（（）{</p><p>​this.$refs.名字.属性</p><p>}）</p><p>设置setTimeout（</p><p>（）{</p><p>​this.$refs.名字.属性</p><p>}</p><p>）函数也可以操作但是由于这个延迟时间不够精准所以不建议使用</p><h1 id="自定义之指令"><a href="#自定义之指令" class="headerlink" title="自定义之指令"></a>自定义之指令</h1><p>自定义指令：自己定义指定 封装dom操作 拓展额外功能</p><p>全局注册语法</p><p>Vue.directive（‘指令名’，{</p><p>”inserted“（）{</p><p>el.focus</p><p>}}）</p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230723101241674.png" alt="image-20230723101241674"></p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230723134533947.png" alt="image-20230723134533947"></p><p>自定义指令案例</p><pre><code class="vue">&lt;template&gt;  &lt;div&gt;    &lt;h1 v-color=&quot;color1&quot;&gt;指令的值1测试&lt;/h1&gt;    &lt;h1 v-color=&quot;color2&quot;&gt;指令的值2测试&lt;/h1&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  data () &#123;    return &#123;      color1: &#39;red&#39;,      color2: &#39;orange&#39;    &#125;  &#125;,  directives: &#123;    color: &#123;      // 1. inserted 提供的是元素被添加到页面中时的逻辑      inserted (el, binding) &#123;        // console.log(el, binding.value);        // binding.value 就是指令的值        el.style.color = binding.value        debugger      &#125;,      // 2. update 指令的值修改的时候触发，提供值变化后，dom更新的逻辑      update (el, binding) &#123;        console.log(&#39;指令的值修改了&#39;);        el.style.color = binding.value        debugger      &#125;    &#125;  &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt;</code></pre><p>vue3实现</p><pre><code>&lt;template&gt;  &lt;div&gt;    &lt;h1 v-color=&quot;color1&quot;&gt;指令的值1测试&lt;/h1&gt;    &lt;h1 v-color=&quot;color2&quot;&gt;指令的值2测试&lt;/h1&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  data () &#123;    return &#123;      color1: &#39;bule&#39;,      color2: &#39;orange&#39;    &#125;  &#125;,  directives: &#123;    color: &#123;      beforeMount(el, binding) &#123;        el.style.color = binding.value      &#125;,      updated(el, binding) &#123;        console.log(&#39;指令的值修改了&#39;);        el.style.color = binding.value      &#125;    &#125;  &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt;</code></pre><p>veu2实现</p><pre><code>&lt;template&gt;  &lt;div&gt;    &lt;h1 v-color=&quot;color1&quot;&gt;指令的值1测试&lt;/h1&gt;    &lt;h1 v-color=&quot;color2&quot;&gt;指令的值2测试&lt;/h1&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  data () &#123;    return &#123;      color1: &#39;&#39;,      color2: &#39;orange&#39;    &#125;  &#125;,  directives: &#123;    color: &#123;      // 1. inserted 提供的是元素被添加到页面中时的逻辑      inserted (el, binding) &#123;        // console.log(el, binding.value);        // binding.value 就是指令的值        el.style.color = binding.value        debugger      &#125;,      // 2. update 指令的值修改的时候触发，提供值变化后，dom更新的逻辑      update (el, binding) &#123;        console.log(&#39;指令的值修改了&#39;);        el.style.color = binding.value        debugger      &#125;    &#125;  &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt;</code></pre><pre><code></code></pre><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230723151115128.png" alt="image-20230723151115128"></p><pre><code>&lt;template&gt;  &lt;div class=&quot;main&quot;&gt;    &lt;div class=&quot;box&quot; v-loading=&quot;isLoading&quot;&gt;      &lt;ul&gt;        &lt;li v-for=&quot;item in list&quot; :key=&quot;item.id&quot; class=&quot;news&quot;&gt;          &lt;div class=&quot;left&quot;&gt;            &lt;div class=&quot;title&quot;&gt;&#123;&#123; item.title &#125;&#125;&lt;/div&gt;            &lt;div class=&quot;info&quot;&gt;              &lt;span&gt;&#123;&#123; item.source &#125;&#125;&lt;/span&gt;              &lt;span&gt;&#123;&#123; item.time &#125;&#125;&lt;/span&gt;            &lt;/div&gt;          &lt;/div&gt;          &lt;div class=&quot;right&quot;&gt;            &lt;img :src=&quot;item.img&quot; alt=&quot;&quot;&gt;          &lt;/div&gt;        &lt;/li&gt;      &lt;/ul&gt;    &lt;/div&gt;    &lt;div class=&quot;box2&quot; v-loading=&quot;isLoading2&quot;&gt;&lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// 安装axios =&gt;  yarn add axiosimport axios from &#39;axios&#39;// 接口地址：http://hmajax.itheima.net/api/news// 请求方式：getexport default &#123;  data () &#123;    return &#123;      list: [],      isLoading: true,      isLoading2: true    &#125;  &#125;,  async created () &#123;    // 1. 发送请求获取数据    const res = await axios.get(&#39;http://hmajax.itheima.net/api/news&#39;)        setTimeout(() =&gt; &#123;      // 2. 更新到 list 中，用于页面渲染 v-for      this.list = res.data.data      this.isLoading = false      debugger    &#125;, 2)  &#125;,  directives: &#123;    loading: &#123;      beforeMount (el, binding) &#123;        binding.value ? el.classList.add(&#39;loading&#39;) : el.classList.remove(&#39;loading&#39;)      &#125;,      updated (el, binding) &#123;        binding.value ? el.classList.add(&#39;loading&#39;) : el.classList.remove(&#39;loading&#39;)      &#125;    &#125;  &#125;&#125;&lt;/script&gt;&lt;style&gt;.loading:before &#123;  content: &#39;&#39;;  position: absolute;  left: 0;  top: 0;  width: 100%;  height: 100%;  background: #fff url(&#39;./loading.gif&#39;) no-repeat center;&#125;.box2 &#123;  width: 400px;  height: 400px;  border: 2px solid #000;  position: relative;&#125;.box &#123;  width: 800px;  min-height: 500px;  border: 3px solid orange;  border-radius: 5px;  position: relative;&#125;.news &#123;  display: flex;  height: 120px;  width: 600px;  margin: 0 auto;  padding: 20px 0;  cursor: pointer;&#125;.news .left &#123;  flex: 1;  display: flex;  flex-direction: column;  justify-content: space-between;  padding-right: 10px;&#125;.news .left .title &#123;  font-size: 20px;&#125;.news .left .info &#123;  color: #999999;&#125;.news .left .info span &#123;  margin-right: 20px;&#125;.news .right &#123;  width: 160px;  height: 120px;&#125;.news .right img &#123;  width: 100%;  height: 100%;  object-fit: cover;&#125;&lt;/style&gt;</code></pre><h5 id="slot插槽"><a href="#slot插槽" class="headerlink" title="slot插槽"></a>slot插槽</h5><p>插槽如果不起名字就是默认插槽</p><p>起名字就是 具名插槽 可以被选择</p><slot name><p>使用的时候在组件中直接</p><p>&lt;组件名字&gt;</p><p>&lt;template v-slot:插槽名&gt;内容 可以使用html语法 </p><p>&lt;&#x2F;组件名字&gt;</p><p>v-solt：可以简写为#</p><p>v-solt：插槽名字     作为选择某个插槽</p><p>当组件某些内容不确定，可以用slot进行插槽占用</p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230723152145263.png" alt="image-20230723152145263"></p><pre><code>&lt;template&gt;  &lt;div class=&quot;dialog&quot;&gt;    &lt;div class=&quot;dialog-header&quot;&gt;      &lt;h3&gt;友情提示&lt;/h3&gt;      &lt;span class=&quot;close&quot;&gt;✖️&lt;/span&gt;    &lt;/div&gt;    &lt;div class=&quot;dialog-content&quot;&gt;      &lt;!-- 1. 在需要定制的位置，使用slot占位 --&gt;      &lt;slot&gt;&lt;/slot&gt;    &lt;/div&gt;    &lt;div class=&quot;dialog-footer&quot;&gt;      &lt;button&gt;取消&lt;/button&gt;      &lt;button&gt;确认&lt;/button&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  data () &#123;    return &#123;    &#125;  &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;* &#123;  margin: 0;  padding: 0;&#125;.dialog &#123;  width: 470px;  height: 230px;  padding: 0 25px;  background-color: #ffffff;  margin: 40px auto;  border-radius: 5px;&#125;.dialog-header &#123;  height: 70px;  line-height: 70px;  font-size: 20px;  border-bottom: 1px solid #ccc;  position: relative;&#125;.dialog-header .close &#123;  position: absolute;  right: 0px;  top: 0px;  cursor: pointer;&#125;.dialog-content &#123;  height: 80px;  font-size: 18px;  padding: 15px 0;&#125;.dialog-footer &#123;  display: flex;  justify-content: flex-end;&#125;.dialog-footer button &#123;  width: 65px;  height: 35px;  background-color: #ffffff;  border: 1px solid #e1e3e9;  cursor: pointer;  outline: none;  margin-left: 10px;  border-radius: 3px;&#125;.dialog-footer button:last-child &#123;  background-color: #007acc;  color: #fff;&#125;&lt;/style&gt;</code></pre><pre><code>&lt;template&gt;  &lt;div&gt;    &lt;!-- 2. 在使用组件时，组件标签内填入内容 --&gt;    &lt;MyDialog&gt;      &lt;div&gt;你确认要删除么&lt;/div&gt;    &lt;/MyDialog&gt;    &lt;MyDialog&gt;      &lt;p&gt;你确认要退出么&lt;/p&gt;    &lt;/MyDialog&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import MyDialog from &#39;./components/MyDialog.vue&#39;export default &#123;  data () &#123;    return &#123;    &#125;  &#125;,  components: &#123;    MyDialog  &#125;&#125;&lt;/script&gt;&lt;style&gt;body &#123;  background-color: #b3b3b3;&#125;&lt;/style&gt;</code></pre><p><strong>作用域插槽</strong></p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230723173516211.png" alt="image-20230723173516211"></p><pre><code>&lt;template&gt;  &lt;table class=&quot;my-table&quot;&gt;    &lt;thead&gt;      &lt;tr&gt;        &lt;th&gt;序号&lt;/th&gt;        &lt;th&gt;姓名&lt;/th&gt;        &lt;th&gt;年纪&lt;/th&gt;        &lt;th&gt;操作&lt;/th&gt;      &lt;/tr&gt;    &lt;/thead&gt;    &lt;tbody&gt;      &lt;tr v-for=&quot;(item, index) in data&quot; :key=&quot;item.id&quot;&gt;        &lt;td&gt;&#123;&#123; index + 1 &#125;&#125;&lt;/td&gt;        &lt;td&gt;&#123;&#123; item.name &#125;&#125;&lt;/td&gt;        &lt;td&gt;&#123;&#123; item.age &#125;&#125;&lt;/td&gt;        &lt;td&gt;          &lt;!-- 1. 给slot标签，添加属性的方式传值 --&gt;          &lt;slot :row=&quot;item&quot; msg=&quot;测试文本&quot;&gt;&lt;/slot&gt;          &lt;!-- 2. 将所有的属性，添加到一个对象中 --&gt;          &lt;!--              &#123;               row: &#123; id: 2, name: &#39;孙大明&#39;, age: 19 &#125;,               msg: &#39;测试文本&#39;             &#125;           --&gt;        &lt;/td&gt;      &lt;/tr&gt;    &lt;/tbody&gt;  &lt;/table&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  props: &#123;    data: Array  &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;.my-table &#123;  width: 450px;  text-align: center;  border: 1px solid #ccc;  font-size: 24px;  margin: 30px auto;&#125;.my-table thead &#123;  background-color: #1f74ff;  color: #fff;&#125;.my-table thead th &#123;  font-weight: normal;&#125;.my-table thead tr &#123;  line-height: 40px;&#125;.my-table th,.my-table td &#123;  border-bottom: 1px solid #ccc;  border-right: 1px solid #ccc;&#125;.my-table td:last-child &#123;  border-right: none;&#125;.my-table tr:last-child td &#123;  border-bottom: none;&#125;.my-table button &#123;  width: 65px;  height: 35px;  font-size: 18px;  border: 1px solid #ccc;  outline: none;  border-radius: 3px;  cursor: pointer;  background-color: #ffffff;  margin-left: 5px;&#125;&lt;/style&gt;</code></pre><pre><code>&lt;template&gt;  &lt;div&gt;    &lt;MyTable :data=&quot;list&quot;&gt;      &lt;!-- 3. 通过template #插槽名=&quot;变量名&quot; 接收 --&gt;      &lt;template #default=&quot;obj&quot;&gt;        &lt;button @click=&quot;del(obj.row.id)&quot;&gt;          删除        &lt;/button&gt;      &lt;/template&gt;    &lt;/MyTable&gt;        &lt;MyTable :data=&quot;list2&quot;&gt;      &lt;template #default=&quot;&#123; row &#125;&quot;&gt;        &lt;button @click=&quot;show(row)&quot;&gt;查看&lt;/button&gt;      &lt;/template&gt;    &lt;/MyTable&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import MyTable from &#39;./components/MyTable.vue&#39;export default &#123;  data () &#123;    return &#123;      list: [        &#123; id: 1, name: &#39;张小花&#39;, age: 18 &#125;,        &#123; id: 2, name: &#39;孙大明&#39;, age: 19 &#125;,        &#123; id: 3, name: &#39;刘德忠&#39;, age: 17 &#125;,      ],      list2: [        &#123; id: 1, name: &#39;赵小云&#39;, age: 18 &#125;,        &#123; id: 2, name: &#39;刘蓓蓓&#39;, age: 19 &#125;,        &#123; id: 3, name: &#39;姜肖泰&#39;, age: 17 &#125;,      ]    &#125;  &#125;,  methods: &#123;    del (id) &#123;      this.list = this.list.filter(item =&gt; item.id !== id)    &#125;,    show (row) &#123;      // console.log(row);      alert(`姓名：$&#123;row.name&#125;; 年纪：$&#123;row.age&#125;`)    &#125;  &#125;,  components: &#123;    MyTable  &#125;&#125;&lt;/script&gt;</code></pre><p>子控件传值给父</p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230723175418428.png" alt="image-20230723175418428"></p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230723175715061.png" alt="image-20230723175715061"></p><p>父控件进行接受数据</p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230723175457310.png" alt="image-20230723175457310"></p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230723175801432.png" alt="image-20230723175801432"></p><h1 id="综合案例抽取table和tag"><a href="#综合案例抽取table和tag" class="headerlink" title="综合案例抽取table和tag"></a>综合案例抽取table和tag</h1><p>···</p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230723210008642.png" alt="image-20230723210008642"></p><pre><code>&lt;template&gt;  &lt;table class=&quot;my-table&quot;&gt;    &lt;thead&gt;      &lt;tr&gt;        &lt;slot name=&quot;head&quot;&gt;&lt;/slot&gt;      &lt;/tr&gt;    &lt;/thead&gt;    &lt;tbody&gt;      &lt;tr v-for=&quot;(item, index) in data&quot; :key=&quot;item.id&quot;&gt;        &lt;slot name=&quot;body&quot; :item=&quot;item&quot; :index=&quot;index&quot; &gt;&lt;/slot&gt;      &lt;/tr&gt;    &lt;/tbody&gt;  &lt;/table&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  props: &#123;    data: &#123;      type: Array,      required: true    &#125;  &#125;&#125;;&lt;/script&gt;&lt;style lang=&quot;less&quot; scoped&gt;.my-table &#123;  width: 100%;  border-spacing: 0;  img &#123;    width: 100px;    height: 100px;    object-fit: contain;    vertical-align: middle;  &#125;  th &#123;    background: #f5f5f5;    border-bottom: 2px solid #069;  &#125;  td &#123;    border-bottom: 1px dashed #ccc;  &#125;  td,  th &#123;    text-align: center;    padding: 10px;    transition: all .5s;    &amp;.red &#123;      color: red;    &#125;  &#125;  .none &#123;    height: 100px;    line-height: 100px;    color: #999;  &#125;&#125;&lt;/style&gt;</code></pre><pre><code>&lt;template&gt;  &lt;div class=&quot;my-tag&quot;&gt;    &lt;input      v-if=&quot;isEdit&quot;      v-focus      ref=&quot;inp&quot;      class=&quot;input&quot;      type=&quot;text&quot;      placeholder=&quot;输入标签&quot;      :value=&quot;value&quot;      @blur=&quot;isEdit = false&quot;      @keyup.enter=&quot;handleEnter&quot;    /&gt;    &lt;div       v-else      @dblclick=&quot;handleClick&quot;      class=&quot;text&quot;&gt;      &#123;&#123; value &#125;&#125;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  props: &#123;    value: String  &#125;,  data () &#123;    return &#123;      isEdit: false    &#125;  &#125;,  methods: &#123;    handleClick () &#123;      // 双击后，切换到显示状态 (Vue是异步dom更新)      this.isEdit = true            // // 等dom更新完了，再获取焦点      // this.$nextTick(() =&gt; &#123;      //   // 立刻获取焦点      //   this.$refs.inp.focus()      // &#125;)    &#125;,    handleEnter (e) &#123;      // 非空处理      if (e.target.value.trim() === &#39;&#39;) return alert(&#39;标签内容不能为空&#39;)      // 子传父，将回车时，[输入框的内容] 提交给父组件更新      // 由于父组件是v-model，触发事件，需要触发 input 事件      this.$emit(&#39;input&#39;, e.target.value)      // 提交完成，关闭输入状态      this.isEdit = false    &#125;  &#125;&#125;&lt;/script&gt;&lt;style lang=&quot;less&quot; scoped&gt;.my-tag &#123;  cursor: pointer;  .input &#123;    appearance: none;    outline: none;    border: 1px solid #ccc;    width: 100px;    height: 40px;    box-sizing: border-box;    padding: 10px;    color: #666;    &amp;::placeholder &#123;      color: #666;    &#125;  &#125;&#125;&lt;/style&gt;</code></pre><pre><code>&lt;template&gt;  &lt;div class=&quot;table-case&quot;&gt;    &lt;MyTable :data=&quot;goods&quot;&gt;      &lt;template #head&gt;        &lt;th&gt;编号&lt;/th&gt;        &lt;th&gt;名称&lt;/th&gt;        &lt;th&gt;图片&lt;/th&gt;        &lt;th width=&quot;100px&quot;&gt;标签&lt;/th&gt;      &lt;/template&gt;      &lt;template #body=&quot;&#123; item, index &#125;&quot;&gt;        &lt;td&gt;&#123;&#123; index + 1 &#125;&#125;&lt;/td&gt;        &lt;td&gt;&#123;&#123; item.name &#125;&#125;&lt;/td&gt;        &lt;td&gt;          &lt;img            :src=&quot;item.picture&quot;          /&gt;        &lt;/td&gt;        &lt;td&gt;          &lt;MyTag v-model=&quot;item.tag&quot;&gt;&lt;/MyTag&gt;        &lt;/td&gt;      &lt;/template&gt;    &lt;/MyTable&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// my-tag 标签组件的封装// 1. 创建组件 - 初始化// 2. 实现功能//    (1) 双击显示，并且自动聚焦//        v-if v-else @dbclick 操作 isEdit//        自动聚焦：//        1. $nextTick =&gt; $refs 获取到dom，进行focus获取焦点//        2. 封装v-focus指令//    (2) 失去焦点，隐藏输入框//        @blur 操作 isEdit 即可//    (3) 回显标签信息//        回显的标签信息是父组件传递过来的//        v-model实现功能 (简化代码)  v-model =&gt; :value 和 @input//        组件内部通过props接收, :value设置给输入框//    (4) 内容修改了，回车 =&gt; 修改标签信息//        @keyup.enter, 触发事件 $emit(&#39;input&#39;, e.target.value)// ---------------------------------------------------------------------// my-table 表格组件的封装// 1. 数据不能写死，动态传递表格渲染的数据  props// 2. 结构不能写死 - 多处结构自定义 【具名插槽】//    (1) 表头支持自定义//    (2) 主体支持自定义import MyTag from &#39;./components/MyTag.vue&#39;import MyTable from &#39;./components/MyTable.vue&#39;export default &#123;  name: &#39;TableCase&#39;,  components: &#123;    MyTag,    MyTable  &#125;,  data () &#123;    return &#123;      // 测试组件功能的临时数据      tempText: &#39;水杯&#39;,      tempText2: &#39;钢笔&#39;,      goods: [        &#123; id: 101, picture: &#39;https://yanxuan-item.nosdn.127.net/f8c37ffa41ab1eb84bff499e1f6acfc7.jpg&#39;, name: &#39;梨皮朱泥三绝清代小品壶经典款紫砂壶&#39;, tag: &#39;茶具&#39; &#125;,        &#123; id: 102, picture: &#39;https://yanxuan-item.nosdn.127.net/221317c85274a188174352474b859d7b.jpg&#39;, name: &#39;全防水HABU旋钮牛皮户外徒步鞋山宁泰抗菌&#39;, tag: &#39;男鞋&#39; &#125;,        &#123; id: 103, picture: &#39;https://yanxuan-item.nosdn.127.net/cd4b840751ef4f7505c85004f0bebcb5.png&#39;, name: &#39;毛茸茸小熊出没，儿童羊羔绒背心73-90cm&#39;, tag: &#39;儿童服饰&#39; &#125;,        &#123; id: 104, picture: &#39;https://yanxuan-item.nosdn.127.net/56eb25a38d7a630e76a608a9360eec6b.jpg&#39;, name: &#39;基础百搭，儿童套头针织毛衣1-9岁&#39;, tag: &#39;儿童服饰&#39; &#125;,      ]    &#125;  &#125;&#125;&lt;/script&gt;&lt;style lang=&quot;less&quot; scoped&gt;.table-case &#123;  width: 1000px;  margin: 50px auto;  img &#123;    width: 100px;    height: 100px;    object-fit: contain;    vertical-align: middle;  &#125;&#125;&lt;/style&gt;</code></pre><h1 id="路由的介绍"><a href="#路由的介绍" class="headerlink" title="路由的介绍"></a>路由的介绍</h1><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230723210927117.png" alt="image-20230723210927117"></p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230723211053650.png" alt="image-20230723211053650"></p><p>路由的使用步骤</p><ol><li><p>下载</p><p>npm add vue</p></li><li><p>引入</p></li><li><p>安装注册</p></li><li><p>创建路由对象</p></li><li><p>注入 将路由对象注入到nie VUE实例中，建立联系</p></li></ol><p>在 Vue 3 中，使用 Vue Router 来实现路由功能，以下是使用 Vue Router 的基本步骤：</p><ol><li><p>安装 Vue Router：在项目中使用 npm 或 yarn 安装 Vue Router。</p><pre><code>npm install vue-router# 或者yarn add vue-router```</code></pre></li><li><p>创建路由实例：在项目中创建一个路由实例，并定义路由表和路由规则。您可以在创建路由实例时，使用 <code>createRouter</code> 工厂函数来创建一个路由实例，例如：</p><pre><code>import &#123; createRouter, createWebHistory &#125; from &#39;vue-router&#39;import Home from &#39;./views/Home.vue&#39;import About from &#39;./views/About.vue&#39;const routes = [  &#123;    path: &#39;/&#39;,    name: &#39;Home&#39;,    component: Home  &#125;,  &#123;    path: &#39;/about&#39;,    name: &#39;About&#39;,    component: About  &#125;]const router = createRouter(&#123;  history: createWebHistory(),  routes&#125;)export default router```在上面的代码中，我们使用 `createRouter` 工厂函数创建了一个路由实例，并定义了两个路由规则，分别对应 `&#39;/&#39;` 和 `&#39;/about&#39;` 路径。`createWebHistory` 函数用于创建一个基于 HTML5 history 模式的路由模式。</code></pre></li><li><p>在根组件中使用路由：在根组件中使用路由，并将路由实例传递给应用程序。您可以通过在 <code>main.js</code> 文件中引入路由实例，并将其传递给根组件来使用路由。例如：</p><pre><code>import &#123; createApp &#125; from &#39;vue&#39;import App from &#39;./App.vue&#39;import router from &#39;./router&#39;createApp(App).use(router).mount(&#39;#app&#39;)```</code></pre></li><li><p>定义路由出口：在根组件中定义一个路由出口，用于显示路由组件。您可以在根组件的模板中使用 <code>&lt;router-view&gt;</code> 标签来定义路由出口，例如：</p><pre><code>&lt;template&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;router-view /&gt;  &lt;/div&gt;&lt;/template&gt;```在上面的代码中，我们使用 `&lt;router-view&gt;` 标签来定义路由出口，并在其中显示路由组件。</code></pre></li><li><p>创建路由组件：在项目中创建多个路由组件，用于根据不同的路由规则来显示不同的内容。您可以在项目中创建多个路由组件，并在路由表中定义相应的路由规则，例如：</p><pre><code>// Home.vue&lt;template&gt;  &lt;div&gt;    &lt;h1&gt;Home&lt;/h1&gt;    &lt;p&gt;This is the home page.&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;// About.vue&lt;template&gt;  &lt;div&gt;    &lt;h1&gt;About&lt;/h1&gt;    &lt;p&gt;This is the about page.&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;```在上面的代码中，我们分别创建了 `Home` 和 `About` 两个路由组件，并定义了它们的模板。</code></pre></li><li><p>使用路由链接：在项目中使用路由链接，用于在不同的路由之间进行导航。您可以在项目中使用 <code>&lt;router-link&gt;</code> 标签来创建路由链接，例如：</p><pre><code>&lt;router-link to=&quot;/&quot;&gt;Home&lt;/router-link&gt;&lt;router-link to=&quot;/about&quot;&gt;About&lt;/router-link&gt;```在上面的代码中，我们使用 `&lt;router-link&gt;` 标签分别创建了两个路由链接，用于在 `Home` 和 `About` 之间进行导航。</code></pre></li></ol><p>这些是使用 Vue Router 的基本步骤，您可以根据您的实际需求进行相应的修改和扩展。</p><pre><code>import Vue from &#39;vue&#39;import App from &#39;./App.vue&#39;// 路由的使用步骤 5 + 2// 5个基础步骤// 1. 下载 v3.6.5// 2. 引入// 3. 安装注册 Vue.use(Vue插件)// 4. 创建路由对象// 5. 注入到new Vue中，建立关联// 2个核心步骤// 1. 建组件(views目录)，配规则// 2. 准备导航链接，配置路由出口(匹配的组件展示的位置) import Find from &#39;./views/Find&#39;import My from &#39;./views/My&#39;import Friend from &#39;./views/Friend&#39;import VueRouter from &#39;vue-router&#39;Vue.use(VueRouter) // VueRouter插件初始化const router = new VueRouter(&#123;  // routes 路由规则们  // route  一条路由规则 &#123; path: 路径, component: 组件 &#125;  routes: [    &#123; path: &#39;/find&#39;, component: Find &#125;,    &#123; path: &#39;/my&#39;, component: My &#125;,    &#123; path: &#39;/friend&#39;, component: Friend &#125;,  ]&#125;)Vue.config.productionTip = falsenew Vue(&#123;  render: h =&gt; h(App),  router&#125;).$mount(&#39;#app&#39;)</code></pre><p>router拆分模块</p><p>router&#x2F;index.js</p><pre><code>// 路由的使用步骤 5 + 2// 5个基础步骤// 1. 下载 v3.6.5// 2. 引入// 3. 安装注册 Vue.use(Vue插件)// 4. 创建路由对象// 5. 注入到new Vue中，建立关联// 2个核心步骤// 1. 建组件(views目录)，配规则// 2. 准备导航链接，配置路由出口(匹配的组件展示的位置) import Find from &#39;@/views/Find&#39;import My from &#39;@/views/My&#39;import Friend from &#39;@/views/Friend&#39;import VueRouter from &#39;vue-router&#39;import Vue from &#39;vue&#39;Vue.use(VueRouter) // VueRouter插件初始化const router = new VueRouter(&#123;  // routes 路由规则们  // route  一条路由规则 &#123; path: 路径, component: 组件 &#125;  routes: [    &#123; path: &#39;/find&#39;, component: Find &#125;,    &#123; path: &#39;/my&#39;, component: My &#125;,    &#123; path: &#39;/friend&#39;, component: Friend &#125;,  ]&#125;)export default router</code></pre><p>main.js引入router</p><pre><code>import Vue from &#39;vue&#39;import App from &#39;./App.vue&#39;import router from &#39;./router&#39;Vue.config.productionTip = falsenew Vue(&#123;  render: h =&gt; h(App),  router&#125;).$mount(&#39;#app&#39;)</code></pre><h2 id="追加"><a href="#追加" class="headerlink" title="追加"></a>追加</h2><p>vue的路由一般定义再view文件夹 </p><p>步骤流程</p><p>再view 下面创建路由设置路由规则</p><p> 然后暴露此路由对象</p><pre><code>const router=new VueRouter(&#123;  routes:[    &#123; path: &#39;/find&#39;,component: Find&#125;    ,&#123;path: &#39;/my&#39;,component: My&#125;,    &#123;path: &#39;/friend&#39;,component: Friend&#125;  ]&#125;)export default router</code></pre><p>路由规则是path ‘&#x2F;路径’，comonement：组件引入名字 此时是用的router-link 而不是a标签</p><p>路由规则是path ‘#&#x2F;路径’，comonement：组件引入名字 此时是a标签</p><p>配置好路由之后需要再main.js引入路由对象</p><pre><code>new Vue(&#123;  render: h =&gt; h(App),  router&#125;).$mount(&#39;#app&#39;)</code></pre><p>这一切做好之后再展示的页面即App.vue下配置自己的模块以及对应的路由信息</p><pre><code>&lt;template&gt;  &lt;div&gt;    &lt;div class=&quot;footer_wrap&quot;&gt;      &lt;router-link to=&quot;/find&quot;&gt;发现音乐&lt;/router-link &gt;      &lt;router-link to=&quot;/my&quot;&gt;我的音乐&lt;/router-link &gt;      &lt;router-link to=&quot;/friend&quot;&gt;朋友&lt;/router-link &gt;    &lt;/div&gt;    &lt;div class=&quot;top&quot;&gt;      &lt;!-- 路由出口 → 匹配的组件所展示的位置 --&gt;      &lt;router-view&gt;&lt;/router-view&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><p>此代码router-link可以换成a标签但是这样a标签格式需要再路由的path前面加一个#</p><h2 id="router-link声明式路由"><a href="#router-link声明式路由" class="headerlink" title="router-link声明式路由"></a>router-link声明式路由</h2><pre><code> &lt;a href=&quot;#/find&quot;&gt;发现音乐&lt;/a &gt;</code></pre><p>这样才是a标签的模式因为路由有个#非常难看不建议使用</p><p>然后就是为什么要用router-link？</p><p>router-link 在渲染组件的时候其实还是a标签</p><p>但是 它会在a标签上面追加一个router-link-active属性和router-link-exact-active</p><p>这两个数据可以设置高亮方便我们操作</p><p>如下展示</p><p>.footer_wrap a.router-link-active{</p><p> background-color: aqua;</p><p>}</p><p>router-link-exact-active精准操作</p><p>另一个标签是模糊操作 例如 to&#x3D;‘&#x2F;my’ 可以匹配到&#x2F;my&#x2F;a &#x2F;my&#x2F;b这样的路径仍旧有个router-link-active属性</p><p>而精准只存在于to&#x3D;‘&#x2F;my’</p><h2 id="router-link声明式跳转传参"><a href="#router-link声明式跳转传参" class="headerlink" title="router-link声明式跳转传参"></a>router-link声明式跳转传参</h2><p>案例2</p><p>在router文件夹下创建路由.js</p><p>重复过程配置路由规则</p><pre><code>import Home from &#39;@/views/Home&#39;import Search from &#39;@/views/Search&#39;// import NotFound from &#39;@/views/NotFound&#39;import Vue from &#39;vue&#39;import VueRouter from &#39;vue-router&#39;Vue.use(VueRouter) // VueRouter插件初始化// 创建了一个路由对象const router = new VueRouter(&#123;  // 注意：一旦采用了 history 模式，地址栏就没有 #，需要后台配置访问规则  mode: &#39;history&#39;,  routes: [    &#123; path: &#39;/home&#39;, component: Home &#125;,    &#123; path: &#39;/search&#39;, component: Search &#125;,    // &#123; path: &#39;*&#39;, component: NotFound &#125;  ]&#125;)export default router</code></pre><p>在main.js引入路由对象</p><p>new Vue({</p><p> render: h &#x3D;&gt; h(App),</p><p> router</p><p>}).$mount(‘#app’)</p><p>在app.vue下设置路由组件的对应路由出口</p><p>这里使用的router-link</p><pre><code>&lt;template&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;div class=&quot;link&quot;&gt;      &lt;router-link to=&quot;/home&quot;&gt;首页&lt;/router-link&gt;      &lt;router-link to=&quot;/search&quot;&gt;搜索页&lt;/router-link&gt;    &lt;/div&gt;    &lt;router-view&gt;&lt;/router-view&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;&#125;;&lt;/script&gt;</code></pre><p>此时我们需要传参怎么办》？</p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke\blog\source_posts\VUE学习\image-20230724213914128.png" alt="image-20230724213914128"></p><p>在点击首页之后通过路由规则最终转到home页面</p><p>home页面点击黑马程序员  前端培训  如何成为前端大牛</p><p>三个连接跳转到搜索页面并且携带 自己的标签内容</p><p>  <router-link to="/search?key=黑马程序员">黑马程序员</router-link></p><p>最简单的写法直接在地址后面拼接一个param&#x3D;值的形式</p><p>接受页面用</p><p>在js中可以直接这样写</p><p><strong>$router.query.key</strong> 接受即可</p><p>在vue的created中需要加一个this.$router.query.key</p><p>因为是标识是vue对象的作用域</p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke\blog\source_posts\VUE学习\image-20230724214531226.png" alt="image-20230724214531226"></p><h3 id="声明式导航-跳转传参之动态传参"><a href="#声明式导航-跳转传参之动态传参" class="headerlink" title="声明式导航-跳转传参之动态传参"></a>声明式导航-跳转传参之动态传参</h3><p>  { path: ‘&#x2F;search&#x2F;:keys’, component: Search },</p><p>配置路由的时候需要在路径中传毒参数的地方设置 :动态参数名字</p><p>在传递参数的过程只需</p><pre><code>  &lt;router-link to=&quot;/search/前端培训&quot;&gt;前端培训&lt;/router-link&gt;</code></pre><p>直接把参数写道路径中即可</p><p>接收的时候只需要通过这总方式</p><pre><code>    &lt;p&gt;搜索关键字: &#123;&#123; $route.params.keys &#125;&#125; &lt;/p&gt;</code></pre><pre><code>&#123; path: &#39;/search/:keys/:wd&#39;, component: Search &#125;,多个参数很方便 &lt;router-link to=&quot;/search/前端培训/后端无敌&quot;&gt;前端培训&lt;/router-link&gt;    &lt;p&gt;搜索关键字: &#123;&#123; $route.params.keys &#125;&#125;       &#123;&#123; $route.params.wd &#125;&#125;&lt;/p&gt;## </code></pre><p>另外提一下我们这边设置了动态传参就必须传不穿的话有问题可以设置不必须传参</p><p>  { path: ‘&#x2F;search&#x2F;:keys?’, component: Search },</p><p>只需要在动态路由添加个？即可代表为不必须获得参数</p><p>但是我觉得这样如果有多个参数可能会有冲突</p><p>解答 ： &#x3D;&#x3D;》</p><p>由<code>/user/:userId/:optionalParam1?/:optionalParam2?</code>，其中<code>:optionalParam1</code>和<code>:optionalParam2</code>是可选参数。如果我们只传递了<code>userId</code>参数，则<code>$route.params.optionalParam1</code>和<code>$route.params.optionalParam2</code>都会是undefined，我们可以在路由组件中根据这些参数是否存在来进行相应的处理。</p><p>会变成未定义而不是冲突传值</p><p><strong>追加</strong></p><p>routes: [</p><p>  { path: ‘&#x2F;‘, redirect: ‘&#x2F;home’ },</p><p>  { path: ‘*’, component: NotFound }</p><p> ]</p><p>})</p><p>设置重定向页和404页</p><p>只需要  { path: ‘&#x2F;‘, redirect: ‘&#x2F;home’ },在路由中配置一下啊rediect即可</p><p>路由找不到即可配置个* 转到404页面</p><p>设置路径中不包含#</p><pre><code>http://localhost:8080/search?key=%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98#/home</code></pre><p>路由默认模式是hash模式路径中会包含#</p><p>const router &#x3D; new VueRouter({</p><p> &#x2F;&#x2F; 注意：一旦采用了 history 模式，地址栏就没有 #，需要后台配置访问规则</p><p> mode: ‘history’,</p><p> routes: [</p><p>  { path: ‘&#x2F;‘, redirect: ‘&#x2F;home’ },</p><p>  { path: ‘&#x2F;home’, component: Home },</p><p>  { name: ‘search’, path: ‘&#x2F;search&#x2F;:words?’, component: Search },</p><p>  { path: ‘*’, component: NotFound }</p><p> ]</p><p>})</p><p>只需把 mode: ‘history’,配置为history即可</p><h2 id="router-link"><a href="#router-link" class="headerlink" title="router-link"></a>router-link</h2><p>高亮展示</p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230723224616654.png" alt="image-20230723224616654"></p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230723225120110.png" alt="image-20230723225120110"></p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230723225224395.png" alt="image-20230723225224395"></p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230723225621524.png" alt="image-20230723225621524"></p><p>更换router高亮的的类名字 </p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230723225723812.png" alt="image-20230723225723812"></p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230723230135381.png" alt="image-20230723230135381"></p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230723231449780.png" alt="image-20230723231449780"></p><p>路径传参</p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230723231839856.png" alt="image-20230723231839856"></p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230723232203645.png" alt="image-20230723232203645"></p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230723232305841.png" alt="image-20230723232305841"></p><p><strong>路径传参变为可选参数</strong></p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230723232418201.png" alt="image-20230723232418201"></p><h2 id="重定向操作"><a href="#重定向操作" class="headerlink" title="重定向操作"></a>重定向操作</h2><p>Vue路由重定向</p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230723232636853.png" alt="image-20230723232636853"></p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230723232840692.png" alt="image-20230723232840692"></p><p>由hash模式转变为history模式去掉#</p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230723233124721.png" alt="image-20230723233124721"></p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230723233509019.png" alt="image-20230723233509019"></p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke\blog\source_posts\VUE学习\image-20230724202640978.png" alt="image-20230724202640978"></p><p>路由的案例</p><pre><code>&lt;template&gt;  &lt;div class=&quot;home&quot;&gt;    &lt;div class=&quot;logo-box&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;search-box&quot;&gt;      &lt;input type=&quot;text&quot;&gt;      &lt;button @click=&quot;goSearch&quot;&gt;搜索一下&lt;/button&gt;    &lt;/div&gt;    &lt;div class=&quot;hot-link&quot;&gt;      热门搜索：      &lt;router-link to=&quot;/search/黑马程序员&quot;&gt;黑马程序员&lt;/router-link&gt;      &lt;router-link to=&quot;/search/前端培训&quot;&gt;前端培训&lt;/router-link&gt;      &lt;router-link to=&quot;/search/如何成为前端大牛&quot;&gt;如何成为前端大牛&lt;/router-link&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;FindMusic&#39;,  methods: &#123;    goSearch () &#123;      // 1. 通过路径的方式跳转      // (1) this.$router.push(&#39;路由路径&#39;) [简写]      // this.$router.push(&#39;/search&#39;)      // (2) this.$router.push(&#123;     [完整写法]      //         path: &#39;路由路径&#39;       //     &#125;)      // this.$router.push(&#123;      //   path: &#39;/search&#39;      // &#125;)      // 2. 通过命名路由的方式跳转 (需要给路由起名字) 适合长路径      //    this.$router.push(&#123;      //        name: &#39;路由名&#39;      //    &#125;)      this.$router.push(&#123;        name: &#39;search&#39;      &#125;)    &#125;  &#125;&#125;&lt;/script&gt;&lt;style&gt;.logo-box &#123;  height: 150px;  background: url(&#39;@/assets/logo.jpeg&#39;) no-repeat center;&#125;.search-box &#123;  display: flex;  justify-content: center;&#125;.search-box input &#123;  width: 400px;  height: 30px;  line-height: 30px;  border: 2px solid #c4c7ce;  border-radius: 4px 0 0 4px;  outline: none;&#125;.search-box input:focus &#123;  border: 2px solid #ad2a26;&#125;.search-box button &#123;  width: 100px;  height: 36px;  border: none;  background-color: #ad2a26;  color: #fff;  position: relative;  left: -2px;  border-radius: 0 4px 4px 0;&#125;.hot-link &#123;  width: 508px;  height: 60px;  line-height: 60px;  margin: 0 auto;&#125;.hot-link a &#123;  margin: 0 5px;&#125;&lt;/style&gt;</code></pre><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke\blog\source_posts\VUE学习\image-20230724205858339.png" alt="image-20230724205858339"></p><h1 id="编程式导航-基本跳转"><a href="#编程式导航-基本跳转" class="headerlink" title="编程式导航-基本跳转"></a>编程式导航-基本跳转</h1><p>点击搜索一下跳转页面</p><pre><code>  &lt;button @click=&quot;goSearch&quot;&gt;搜索一下&lt;/button&gt;</code></pre><p>配置一个单击事件</p><pre><code>goSearch () &#123;   // 1. 通过路径的方式跳转   // (1) this.$router.push(&#39;路由路径&#39;) [简写]   // this.$router.push(&#39;/search&#39;)   // (2) this.$router.push(&#123;   [完整写法]   //     path: &#39;路由路径&#39;    //   &#125;)   // this.$router.push(&#123;   //  path: &#39;/search&#39;   // &#125;)</code></pre><p>简化设置用名字跳转</p><p>这样的话需要在路由规则中设置</p><pre><code>    mode: &#39;history&#39;,  routes: [    &#123; name: &#39;search&#39;, path: &#39;/search/:words?&#39;, component: Search &#125;,    &#123; path: &#39;*&#39;, component: NotFound &#125;  ]&#125;)</code></pre><pre><code>  // 2. 通过命名路由的方式跳转 (需要给路由起名字) 适合长路径      //    this.$router.push(&#123;      //        name: &#39;路由名&#39;      //    &#125;)       this.$router.push(&#123;        name: &#39;search&#39;      &#125;)</code></pre><p>编程时路由传参</p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke\blog\source_posts\VUE学习\image-20230724221911887.png" alt="image-20230724221911887"></p><pre><code>   this.$router.push(`/search?key=$&#123;this.inpValue&#125;`)   获取参数   &lt;p&gt;搜索关键字: &#123;&#123; $route.query.key &#125;&#125;    </code></pre><pre><code> this.$router.push(&#123;        path: &#39;/search&#39;,        query:&#123;          key: this.inpValue,        &#125;      &#125;)这样写更方便</code></pre><p>动态路由传参</p><p>这样记得看一下 &#96;&#96; 是支持js语法的</p><p>遵循路由中的规则</p><p> { path: ‘&#x2F;search&#x2F;:words?’, component: Search },</p><p>   this.$router.push(<code>/serch/$&#123;this.inpValue&#125;</code>)</p><h1 id="路由精美案例"><a href="#路由精美案例" class="headerlink" title="路由精美案例"></a>路由精美案例</h1><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke\blog\source_posts\VUE学习\image-20230724225532216.png" alt="image-20230724225532216"></p><p>二级路由配置</p><pre><code>const router = new VueRouter(&#123;  //通过children配置可一嵌套路由  //1.在children配置规则  //2.准备二级路由入口也就是在一级路由的页面配置 router-view  routes: [    &#123;path:&quot;/&quot;, component: Layout,children:[&#123;path:&quot;/article&quot;, component: Article&#125;,    &#123;path:&quot;/collect&quot;, component: Collect&#125;,  ]&#125;,    &#123;path:&quot;/detail&quot;, component: ArticleDetail&#125;,    &#123;path:&quot;/like&quot;, component: Like&#125;,    &#123;path:&quot;/user&quot;, component: User&#125;,      ]&#125;)</code></pre><pre><code>&lt;template&gt;  &lt;div class=&quot;h5-wrapper&quot;&gt;    &lt;div class=&quot;content&quot;&gt;      &lt;router-view&gt;&lt;/router-view&gt;    &lt;/div&gt;    &lt;nav class=&quot;tabbar&quot;&gt;      &lt;!-- 导航高亮操作      1.a标签换成router-link        2.结合高亮类操作 --&gt;      &lt;router-link to=&quot;#/article&quot;&gt;面经&lt;/router-link&gt;       &lt;router-link  to=&quot;#/collect&quot;&gt;收藏&lt;/router-link &gt;      &lt;router-link  to=&quot;#/like&quot;&gt;喜欢&lt;/router-link &gt;      &lt;router-link  to=&quot;#/user&quot;&gt;我的&lt;/router-link &gt;    &lt;/nav&gt;  &lt;/div&gt;&lt;/template&gt;style  a.router-link-active&#123;    color: aqua;  &#125;</code></pre><h2 id="十六、面经基础版-二级导航高亮"><a href="#十六、面经基础版-二级导航高亮" class="headerlink" title="十六、面经基础版-二级导航高亮"></a>十六、面经基础版-二级导航高亮</h2><h3 id="1-实现思路"><a href="#1-实现思路" class="headerlink" title="1.实现思路"></a>1.实现思路</h3><ul><li>将a标签替换成 <router-link></router-link>组件，配置to属性，不用加 #</li><li>结合高亮类名实现高亮效果 (推荐模糊匹配：router-link-active)</li></ul><h3 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2.代码实现"></a>2.代码实现</h3><p>Layout.vue</p><pre><code class="vue">....    &lt;nav class=&quot;tabbar&quot;&gt;      &lt;router-link to=&quot;/article&quot;&gt;面经&lt;/router-link&gt;      &lt;router-link to=&quot;/collect&quot;&gt;收藏&lt;/router-link&gt;      &lt;router-link to=&quot;/like&quot;&gt;喜欢&lt;/router-link&gt;      &lt;router-link to=&quot;/user&quot;&gt;我的&lt;/router-link&gt;    &lt;/nav&gt;&lt;style&gt;   a.router-link-active &#123;      color: orange;    &#125;&lt;/style&gt;</code></pre><h2 id="十七、面经基础版-首页请求渲染"><a href="#十七、面经基础版-首页请求渲染" class="headerlink" title="十七、面经基础版-首页请求渲染"></a>十七、面经基础版-首页请求渲染</h2><h3 id="1-步骤分析"><a href="#1-步骤分析" class="headerlink" title="1.步骤分析"></a>1.步骤分析</h3><p>1.安装axios </p><p>2.看接口文档，确认请求方式，请求地址，请求参数</p><p>3.created中发送请求，获取数据，存储到data中</p><p>4.页面动态渲染</p><h3 id="2-代码实现-1"><a href="#2-代码实现-1" class="headerlink" title="2.代码实现"></a>2.代码实现</h3><p>1.安装axios</p><p><code>yarn add axios </code>  <code>npm i axios</code></p><p>2.接口文档</p><pre><code class="vue">请求地址: https://mock.boxuegu.com/mock/3083/articles请求方式: get</code></pre><p>3.created中发送请求，获取数据，存储到data中</p><pre><code class="vue"> data() &#123;    return &#123;      articelList: [],    &#125;  &#125;,  async created() &#123;    const &#123;  data: &#123; result: &#123; rows &#125; &#125;&#125; = await axios.get(&#39;https://mock.boxuegu.com/mock/3083/articles&#39;)    this.articelList = rows  &#125;,</code></pre><p>4.页面动态渲染</p><pre><code class="vue">&lt;template&gt;  &lt;div class=&quot;article-page&quot;&gt;    &lt;div class=&quot;article-item&quot; v-for=&quot;item in articelList&quot; :key=&quot;item.id&quot;&gt;      &lt;div class=&quot;head&quot;&gt;        &lt;img :src=&quot;item.creatorAvatar&quot; alt=&quot;&quot; /&gt;        &lt;div class=&quot;con&quot;&gt;          &lt;p class=&quot;title&quot;&gt;&#123;&#123; item.stem &#125;&#125;&lt;/p&gt;          &lt;p class=&quot;other&quot;&gt;&#123;&#123; item.creatorName &#125;&#125; | &#123;&#123; item.createdAt &#125;&#125;&lt;/p&gt;        &lt;/div&gt;      &lt;/div&gt;      &lt;div class=&quot;body&quot;&gt;        &#123;&#123;item.content&#125;&#125;      &lt;/div&gt;      &lt;div class=&quot;foot&quot;&gt;点赞 &#123;&#123;item.likeCount&#125;&#125; | 浏览 &#123;&#123;item.views&#125;&#125;&lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><h2 id="十八、面经基础版-查询参数传参"><a href="#十八、面经基础版-查询参数传参" class="headerlink" title="十八、面经基础版-查询参数传参"></a>十八、面经基础版-查询参数传参</h2><h3 id="1-说明"><a href="#1-说明" class="headerlink" title="1.说明"></a>1.说明</h3><p>跳转详情页需要把当前点击的文章id传给详情页，获取数据</p><ul><li>查询参数传参  this.$router.push(‘&#x2F;detail?参数1&#x3D;参数值&amp;参数2&#x3D;参数值’) </li><li>动态路由传参  先改造路由 在传参  this.$router.push(‘&#x2F;detail&#x2F;参数值’)</li></ul><h3 id="2-查询参数传参实现"><a href="#2-查询参数传参实现" class="headerlink" title="2.查询参数传参实现"></a>2.查询参数传参实现</h3><p>Article.vue</p><pre><code class="vue">&lt;template&gt;  &lt;div class=&quot;article-page&quot;&gt;    &lt;div class=&quot;article-item&quot;       v-for=&quot;item in articelList&quot; :key=&quot;item.id&quot;       @click=&quot;$router.push(`/detail?id=$&#123;item.id&#125;`)&quot;&gt;     ...    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><p>ArticleDetail.vue</p><pre><code class="vue">  created()&#123;    console.log(this.$route.query.id)  &#125;</code></pre><h2 id="十九、面经基础版-动态路由传参"><a href="#十九、面经基础版-动态路由传参" class="headerlink" title="十九、面经基础版-动态路由传参"></a>十九、面经基础版-动态路由传参</h2><h3 id="1-实现步骤"><a href="#1-实现步骤" class="headerlink" title="1.实现步骤"></a>1.实现步骤</h3><ul><li>改造路由</li><li>动态传参</li><li>在详情页获取参数</li></ul><h3 id="2-代码实现-2"><a href="#2-代码实现-2" class="headerlink" title="2.代码实现"></a>2.代码实现</h3><p>改造路由</p><p>router&#x2F;index.js</p><pre><code class="js">...  &#123;      path: &#39;/detail/:id&#39;,      component: ArticleDetail  &#125;</code></pre><p>Article.vue</p><pre><code class="vue">&lt;div class=&quot;article-item&quot;      v-for=&quot;item in articelList&quot; :key=&quot;item.id&quot;      @click=&quot;$router.push(`/detail/$&#123;item.id&#125;`)&quot;&gt;       .... &lt;/div&gt;</code></pre><p>ArticleDetail.vue</p><pre><code class="vue">  created()&#123;    console.log(this.$route.params.id)  &#125;</code></pre><h3 id="3-额外优化功能点-点击回退跳转到上一页"><a href="#3-额外优化功能点-点击回退跳转到上一页" class="headerlink" title="3.额外优化功能点-点击回退跳转到上一页"></a>3.额外优化功能点-点击回退跳转到上一页</h3><p>ArticleDetail.vue</p><pre><code class="vue">&lt;template&gt;  &lt;div class=&quot;article-detail-page&quot;&gt;    &lt;nav class=&quot;nav&quot;&gt;&lt;span class=&quot;back&quot; @click=&quot;$router.back()&quot;&gt;&amp;lt;&lt;/span&gt; 面经详情&lt;/nav&gt;     ....  &lt;/div&gt;&lt;/template&gt;</code></pre><h2 id="二十、面经基础版-详情页渲染"><a href="#二十、面经基础版-详情页渲染" class="headerlink" title="二十、面经基础版-详情页渲染"></a>二十、面经基础版-详情页渲染</h2><h3 id="1-实现步骤分析"><a href="#1-实现步骤分析" class="headerlink" title="1.实现步骤分析"></a>1.实现步骤分析</h3><ul><li>导入axios</li><li>查看接口文档</li><li>在created中发送请求</li><li>页面动态渲染</li></ul><h3 id="2-代码实现-3"><a href="#2-代码实现-3" class="headerlink" title="2.代码实现"></a>2.代码实现</h3><p>接口文档</p><pre><code class="vue"> 请求地址: https://mock.boxuegu.com/mock/3083/articles/:id 请求方式: get</code></pre><p>在created中发送请求</p><pre><code class="vue"> data() &#123;    return &#123;      articleDetail:&#123;&#125;    &#125;  &#125;,  async created() &#123;    const id = this.$route.params.id    const &#123;data:&#123;result&#125;&#125; = await axios.get(      `https://mock.boxuegu.com/mock/3083/articles/$&#123;id&#125;`    )    this.articleDetail = result  &#125;,</code></pre><p>页面动态渲染</p><pre><code class="vue">&lt;template&gt;  &lt;div class=&quot;article-detail-page&quot;&gt;    &lt;nav class=&quot;nav&quot;&gt;      &lt;span class=&quot;back&quot; @click=&quot;$router.back()&quot;&gt;&amp;lt;&lt;/span&gt; 面经详情    &lt;/nav&gt;    &lt;header class=&quot;header&quot;&gt;      &lt;h1&gt;&#123;&#123;articleDetail.stem&#125;&#125;&lt;/h1&gt;      &lt;p&gt;&#123;&#123;articleDetail.createAt&#125;&#125; | &#123;&#123;articleDetail.views&#125;&#125; 浏览量 | &#123;&#123;articleDetail.likeCount&#125;&#125; 点赞数&lt;/p&gt;      &lt;p&gt;        &lt;img          :src=&quot;articleDetail.creatorAvatar&quot;          alt=&quot;&quot;        /&gt;        &lt;span&gt;&#123;&#123;articleDetail.creatorName&#125;&#125;&lt;/span&gt;      &lt;/p&gt;    &lt;/header&gt;    &lt;main class=&quot;body&quot;&gt;      &#123;&#123;articleDetail.content&#125;&#125;    &lt;/main&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><h2 id="二十一、面经基础版-缓存组件"><a href="#二十一、面经基础版-缓存组件" class="headerlink" title="二十一、面经基础版-缓存组件"></a>二十一、面经基础版-缓存组件</h2><h3 id="1-问题"><a href="#1-问题" class="headerlink" title="1.问题"></a>1.问题</h3><p>从面经列表 点到 详情页，又点返回，数据重新加载了 →  <strong>希望回到原来的位置</strong></p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke\blog\source_posts\assets\1682578630060.png" alt="68257863006"></p><h3 id="2-原因"><a href="#2-原因" class="headerlink" title="2.原因"></a>2.原因</h3><p>当路由被<strong>跳转</strong>后，原来所看到的组件就<strong>被销毁</strong>了（会执行组件内的beforeDestroy和destroyed生命周期钩子），<strong>重新返回</strong>后组件又被<strong>重新创建</strong>了（会执行组件内的beforeCreate,created,beforeMount,Mounted生命周期钩子），<strong>所以数据被加载了</strong></p><h3 id="3-解决方案"><a href="#3-解决方案" class="headerlink" title="3.解决方案"></a>3.解决方案</h3><p>利用keep-alive把原来的组件给缓存下来</p><h3 id="4-什么是keep-alive"><a href="#4-什么是keep-alive" class="headerlink" title="4.什么是keep-alive"></a>4.什么是keep-alive</h3><p>keep-alive 是 Vue 的内置组件，当它包裹动态组件时，<strong>会缓存不活动的组件实例，而不是销毁</strong>它们。</p><p>keep-alive 是一个抽象组件：它自身不会渲染成一个 DOM 元素，也不会出现在父组件中。</p><p><strong>优点：</strong></p><p>在组件切换过程中把切换出去的组件保留在内存中，防止重复渲染DOM，</p><p>减少加载时间及性能消耗，提高用户体验性。</p><p>App.vue</p><pre><code class="vue">&lt;template&gt;  &lt;div class=&quot;h5-wrapper&quot;&gt;    &lt;keep-alive&gt;      &lt;router-view&gt;&lt;/router-view&gt;    &lt;/keep-alive&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><p><strong>问题：</strong></p><p>缓存了所有被切换的组件</p><h3 id="5-keep-alive的三个属性"><a href="#5-keep-alive的三个属性" class="headerlink" title="5.keep-alive的三个属性"></a>5.keep-alive的三个属性</h3><p>① include  ： 组件名数组，只有匹配的组件<strong>会被缓存</strong></p><p>② exclude ： 组件名数组，任何匹配的组件都<strong>不会被缓存</strong></p><p>③ max       ： 最多可以<strong>缓存多少</strong>组件实例</p><p>App.vue</p><pre><code class="vue">&lt;template&gt;  &lt;div class=&quot;h5-wrapper&quot;&gt;    &lt;keep-alive :include=&quot;[&#39;LayoutPage&#39;]&quot;&gt;      &lt;router-view&gt;&lt;/router-view&gt;    &lt;/keep-alive&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><h3 id="6-额外的两个生命周期钩子"><a href="#6-额外的两个生命周期钩子" class="headerlink" title="6.额外的两个生命周期钩子"></a>6.额外的两个生命周期钩子</h3><p><strong>keep-alive的使用会触发两个生命周期函数</strong></p><p><strong>activated</strong> 当组件被激活（使用）的时候触发 →  进入这个页面的时候触发</p><p><strong>deactivated</strong> 当组件不被使用的时候触发      →  离开这个页面的时候触发</p><p>组件<strong>缓存后</strong>就<strong>不会执行</strong>组件的<strong>created, mounted, destroyed</strong> 等钩子了</p><p>所以其提供了<strong>actived 和deactived</strong>钩子，帮我们实现业务需求。</p><h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7.总结"></a>7.总结</h3><p>1.keep-alive是什么</p><p>2.keep-alive的优点</p><p>3.keep-alive的三个属性 (了解)</p><p>4.keep-alive的使用会触发两个生命周期函数(了解)</p><h2 id="二十二、VueCli-自定义创建项目"><a href="#二十二、VueCli-自定义创建项目" class="headerlink" title="二十二、VueCli 自定义创建项目"></a>二十二、VueCli 自定义创建项目</h2><p>1.安装脚手架 (已安装)</p><pre><code>npm i @vue/cli -g</code></pre><p>2.创建项目</p><pre><code>vue create hm-exp-mobile</code></pre><ul><li>选项</li></ul><pre><code class="js">Vue CLI v5.0.8? Please pick a preset:  Default ([Vue 3] babel, eslint)  Default ([Vue 2] babel, eslint)&gt; Manually select features     选自定义</code></pre><ul><li>手动选择功能</li></ul><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke\blog\source_posts\assets\1682941856172.png" alt="68294185617"></p><ul><li>选择vue的版本</li></ul><pre><code class="jsx">  3.x&gt; 2.x</code></pre><ul><li>是否使用history模式</li></ul><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke\blog\source_posts\assets\1682941888453.png" alt="image-20201025150602129"></p><ul><li>选择css预处理</li></ul><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke\blog\source_posts\assets\1682941900018.png" alt="image-20220629175133593"></p><ul><li>选择eslint的风格 （eslint 代码规范的检验工具，检验代码是否符合规范）</li><li>比如：const age &#x3D; 18;   &#x3D;&gt;  报错！多加了分号！后面有工具，一保存，全部格式化成最规范的样子</li></ul><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke\blog\source_posts\assets\1682941918562.png" alt="68294191856"></p><ul><li>选择校验的时机 （直接回车）</li></ul><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke\blog\source_posts\assets\1682941935794.png" alt="68294193579"></p><ul><li>选择配置文件的生成方式 （直接回车）</li></ul><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke\blog\source_posts\assets\1682941947985.png" alt="68294194798"></p><ul><li>是否保存预设，下次直接使用？  &#x3D;&gt;   不保存，输入 N</li></ul><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke\blog\source_posts\assets\1682941961551.png" alt="68294196155"></p><ul><li>等待安装，项目初始化完成</li></ul><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke\blog\source_posts\assets\1682941974763.png" alt="68294197476"></p><ul><li>启动项目</li></ul><pre><code>npm run serve</code></pre><h2 id="二十三、ESlint代码规范及手动修复"><a href="#二十三、ESlint代码规范及手动修复" class="headerlink" title="二十三、ESlint代码规范及手动修复"></a>二十三、ESlint代码规范及手动修复</h2><p>代码规范：一套写代码的约定规则。例如：赋值符号的左右是否需要空格？一句结束是否是要加;？… </p><blockquote><p> 没有规矩不成方圆  </p></blockquote><p>ESLint:是一个代码检查工具，用来检查你的代码是否符合指定的规则(你和你的团队可以自行约定一套规则)。在创建项目时，我们使用的是 <a href="https://standardjs.com/readme-zhcn.html">JavaScript Standard Style</a> 代码风格的规则。</p><h4 id="1-JavaScript-Standard-Style-规范说明"><a href="#1-JavaScript-Standard-Style-规范说明" class="headerlink" title="1.JavaScript Standard Style 规范说明"></a>1.JavaScript Standard Style 规范说明</h4><p>建议把：<a href="https://standardjs.com/rules-zhcn.html">https://standardjs.com/rules-zhcn.html</a> 看一遍，然后在写的时候,  遇到错误就查询解决。</p><p>下面是这份规则中的一小部分：</p><ul><li><em>字符串使用单引号</em> – 需要转义的地方除外</li><li><em>无分号</em> – <a href="http://blog.izs.me/post/2353458699/an-open-letter-to-javascript-leaders-regarding">这</a><a href="http://inimino.org/~inimino/blog/javascript_semicolons">没什么不好。</a><a href="https://www.youtube.com/watch?v=gsfbh17Ax9I">不骗你！</a></li><li><em>关键字后加空格</em> <code>if (condition) &#123; ... &#125;</code></li><li><em>函数名后加空格</em> <code>function name (arg) &#123; ... &#125;</code></li><li>坚持使用全等 <code>===</code> 摒弃 <code>==</code> 一但在需要检查 <code>null || undefined</code> 时可以使用 <code>obj == null</code></li><li>……</li></ul><h4 id="2-代码规范错误"><a href="#2-代码规范错误" class="headerlink" title="2.代码规范错误"></a>2.代码规范错误</h4><p>如果你的代码不符合standard的要求，eslint会跳出来刀子嘴，豆腐心地提示你。</p><p>下面我们在main.js中随意做一些改动：添加一些空行，空格。</p><pre><code class="js">import Vue from &#39;vue&#39;import App from &#39;./App.vue&#39;import &#39;./styles/index.less&#39;import router from &#39;./router&#39;Vue.config.productionTip = falsenew Vue ( &#123;  render: h =&gt; h(App),  router&#125;).$mount(&#39;#app&#39;)</code></pre><p>按下保存代码之后：</p><p>你将会看在控制台中输出如下错误：</p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke\blog\source_posts\VUE学习\image-20230725223826641.png" alt="image-20230725223826641"></p><blockquote><p>eslint 是来帮助你的。心态要好，有错，就改。</p></blockquote><h4 id="3-手动修正"><a href="#3-手动修正" class="headerlink" title="3.手动修正"></a>3.手动修正</h4><p>根据错误提示来一项一项手动修正。</p><p>如果你不认识命令行中的语法报错是什么意思，你可以根据错误代码（func-call-spacing, space-in-parens,…..）去 ESLint 规则列表中查找其具体含义。</p><p>打开 <a href="https://zh-hans.eslint.org/docs/latest/rules/">ESLint 规则表</a>，使用页面搜索（Ctrl + F）这个代码，查找对该规则的一个释义。</p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke\blog\source_posts\assets\1682942792219.png" alt="68294279221"></p><h2 id="二十四、通过eslint插件来实现自动修正"><a href="#二十四、通过eslint插件来实现自动修正" class="headerlink" title="二十四、通过eslint插件来实现自动修正"></a>二十四、通过eslint插件来实现自动修正</h2><blockquote><ol><li>eslint会自动高亮错误显示</li><li>通过配置，eslint会自动帮助我们修复错误</li></ol></blockquote><ul><li>如何安装</li></ul><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke\blog\source_posts\assets\1682942920986.png" alt="68294292098"></p><ul><li>如何配置</li></ul><pre><code class="js">// 当保存的时候，eslint自动帮我们修复错误&quot;editor.codeActionsOnSave&quot;: &#123;    &quot;source.fixAll&quot;: true&#125;,// 保存代码，不自动格式化&quot;editor.formatOnSave&quot;: false</code></pre><ul><li>注意：eslint的配置文件必须在根目录下，这个插件才能才能生效。打开项目必须以根目录打开，一次打开一个项目</li><li>注意：使用了eslint校验之后，把vscode带的那些格式化工具全禁用了 Beatify</li></ul><p>settings.json 参考</p><pre><code class="jsx">&#123;    &quot;window.zoomLevel&quot;: 2,    &quot;workbench.iconTheme&quot;: &quot;vscode-icons&quot;,    &quot;editor.tabSize&quot;: 2,    &quot;emmet.triggerExpansionOnTab&quot;: true,    // 当保存的时候，eslint自动帮我们修复错误    &quot;editor.codeActionsOnSave&quot;: &#123;        &quot;source.fixAll&quot;: true    &#125;,    // 保存代码，不自动格式化    &quot;editor.formatOnSave&quot;: false&#125;</code></pre><h2 id="一、Vuex-概述"><a href="#一、Vuex-概述" class="headerlink" title="一、Vuex 概述"></a>一、<a href="https://vuex.vuejs.org/zh/">Vuex</a> 概述</h2><p>目标：明确<a href="https://vuex.vuejs.org/zh/">Vuex</a>是什么，应用场景以及优势</p><h3 id="1-是什么"><a href="#1-是什么" class="headerlink" title="1.是什么"></a>1.是什么</h3><p>Vuex 是一个 Vue 的 状态管理工具，状态就是数据。</p><p>大白话：Vuex 是一个插件，可以帮我们管理 Vue 通用的数据 (多组件共享的数据)。例如：购物车数据   个人信息数</p><h3 id="2-使用场景"><a href="#2-使用场景" class="headerlink" title="2.使用场景"></a>2.使用场景</h3><ul><li><p>某个状态 在 很多个组件 来使用 (个人信息)</p></li><li><p>多个组件 共同维护 一份数据 (购物车)</p></li></ul><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke/blog/source/_posts/assets/1683178186642.png" alt="68317818664"></p><h3 id="3-优势"><a href="#3-优势" class="headerlink" title="3.优势"></a>3.优势</h3><ul><li>共同维护一份数据，<strong>数据集中化管理</strong></li><li><strong>响应式变化</strong></li><li>操作简洁 (vuex提供了一些辅助函数)</li></ul><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke/blog/source/_posts/assets/1683178293366.png" alt="68317829336"></p><h3 id="4-注意："><a href="#4-注意：" class="headerlink" title="4.注意："></a>4.注意：</h3><p>官方原文：</p><ul><li>不是所有的场景都适用于vuex，只有在必要的时候才使用vuex</li><li>使用了vuex之后，会附加更多的框架中的概念进来，增加了项目的复杂度  （数据的操作更便捷，数据的流动更清晰）</li></ul><p>Vuex就像《近视眼镜》, 你自然会知道什么时候需要用它~</p><h2 id="二、需求-多组件共享数据"><a href="#二、需求-多组件共享数据" class="headerlink" title="二、需求: 多组件共享数据"></a>二、需求: 多组件共享数据</h2><p>目标：基于脚手架创建项目，构建 vuex 多组件数据共享环境</p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke/blog/source/_posts/assets/1683178912695.png" alt="68317891269"></p><p>效果是三个组件共享一份数据:</p><ul><li>任意一个组件都可以修改数据</li><li>三个组件的数据是同步的</li></ul><h3 id="1-创建项目"><a href="#1-创建项目" class="headerlink" title="1.创建项目"></a>1.创建项目</h3><pre><code>vue create vuex-demo</code></pre><h3 id="2-创建三个组件-目录如下"><a href="#2-创建三个组件-目录如下" class="headerlink" title="2.创建三个组件, 目录如下"></a>2.创建三个组件, 目录如下</h3><pre><code>|-components|--Son1.vue|--Son2.vue|-App.vue</code></pre><h3 id="3-源代码如下"><a href="#3-源代码如下" class="headerlink" title="3.源代码如下"></a>3.源代码如下</h3><p><code>App.vue</code>在入口组件中引入 Son1 和 Son2 这两个子组件</p><pre><code class="html">&lt;template&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;h1&gt;根组件&lt;/h1&gt;    &lt;input type=&quot;text&quot;&gt;    &lt;Son1&gt;&lt;/Son1&gt;    &lt;hr&gt;    &lt;Son2&gt;&lt;/Son2&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Son1 from &#39;./components/Son1.vue&#39;import Son2 from &#39;./components/Son2.vue&#39;export default &#123;  name: &#39;app&#39;,  data: function () &#123;    return &#123;    &#125;  &#125;,  components: &#123;    Son1,    Son2  &#125;&#125;&lt;/script&gt;&lt;style&gt;#app &#123;  width: 600px;  margin: 20px auto;  border: 3px solid #ccc;  border-radius: 3px;  padding: 10px;&#125;&lt;/style&gt;</code></pre><p><code>main.js</code></p><pre><code class="js">import Vue from &#39;vue&#39;import App from &#39;./App.vue&#39;Vue.config.productionTip = falsenew Vue(&#123;  render: h =&gt; h(App)&#125;).$mount(&#39;#app&#39;)</code></pre><p><code>Son1.vue</code></p><pre><code class="html">&lt;template&gt;  &lt;div class=&quot;box&quot;&gt;    &lt;h2&gt;Son1 子组件&lt;/h2&gt;    从vuex中获取的值: &lt;label&gt;&lt;/label&gt;    &lt;br&gt;    &lt;button&gt;值 + 1&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;Son1Com&#39;&#125;&lt;/script&gt;&lt;style lang=&quot;css&quot; scoped&gt;.box&#123;  border: 3px solid #ccc;  width: 400px;  padding: 10px;  margin: 20px;&#125;h2 &#123;  margin-top: 10px;&#125;&lt;/style&gt;</code></pre><p><code>Son2.vue</code></p><pre><code class="html">&lt;template&gt;  &lt;div class=&quot;box&quot;&gt;    &lt;h2&gt;Son2 子组件&lt;/h2&gt;    从vuex中获取的值:&lt;label&gt;&lt;/label&gt;    &lt;br /&gt;    &lt;button&gt;值 - 1&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;Son2Com&#39;&#125;&lt;/script&gt;&lt;style lang=&quot;css&quot; scoped&gt;.box &#123;  border: 3px solid #ccc;  width: 400px;  padding: 10px;  margin: 20px;&#125;h2 &#123;  margin-top: 10px;&#125;&lt;/style&gt;</code></pre><h2 id="三、vuex-的使用-创建仓库"><a href="#三、vuex-的使用-创建仓库" class="headerlink" title="三、vuex 的使用 - 创建仓库"></a>三、vuex 的使用 - 创建仓库</h2><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke/blog/source/_posts/assets/1683212784179.png" alt="68321278417"></p><h3 id="1-安装-vuex"><a href="#1-安装-vuex" class="headerlink" title="1.安装 vuex"></a>1.安装 vuex</h3><p>安装vuex与vue-router类似，vuex是一个独立存在的插件，如果脚手架初始化没有选 vuex，就需要额外安装。</p><pre><code class="bash">yarn add vuex@3 或者 npm i vuex@3</code></pre><h3 id="2-新建-store-index-js-专门存放-vuex"><a href="#2-新建-store-index-js-专门存放-vuex" class="headerlink" title="2.新建 store/index.js 专门存放 vuex"></a>2.新建 <code>store/index.js</code> 专门存放 vuex</h3><p>​为了维护项目目录的整洁，在src目录下新建一个store目录其下放置一个index.js文件。 (和 <code>router/index.js</code> 类似)</p><p>​<img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke/blog/source/_posts/assets/1683212805824.png" alt="68321280582"></p><h3 id="3-创建仓库-store-index-js"><a href="#3-创建仓库-store-index-js" class="headerlink" title="3.创建仓库 store/index.js"></a>3.创建仓库 <code>store/index.js</code></h3><pre><code class="jsx">// 导入 vueimport Vue from &#39;vue&#39;// 导入 vueximport Vuex from &#39;vuex&#39;// vuex也是vue的插件, 需要use一下, 进行插件的安装初始化Vue.use(Vuex)// 创建仓库 storeconst store = new Vuex.Store()// 导出仓库export default store</code></pre><h3 id="4-在-main-js-中导入挂载到-Vue-实例上"><a href="#4-在-main-js-中导入挂载到-Vue-实例上" class="headerlink" title="4 在 main.js 中导入挂载到 Vue 实例上"></a>4 在 main.js 中导入挂载到 Vue 实例上</h3><pre><code class="js">import Vue from &#39;vue&#39;import App from &#39;./App.vue&#39;import store from &#39;./store&#39;Vue.config.productionTip = falsenew Vue(&#123;  render: h =&gt; h(App),  store&#125;).$mount(&#39;#app&#39;)</code></pre><p>此刻起, 就成功创建了一个 <strong>空仓库!!</strong></p><h3 id="5-测试打印Vuex"><a href="#5-测试打印Vuex" class="headerlink" title="5.测试打印Vuex"></a>5.测试打印Vuex</h3><p>App.vue</p><pre><code class="js">created()&#123;  console.log(this.$store)&#125;</code></pre><h2 id="四、核心概念-state-状态"><a href="#四、核心概念-state-状态" class="headerlink" title="四、核心概念 - state 状态"></a>四、核心概念 - state 状态</h2><h3 id="1-目标"><a href="#1-目标" class="headerlink" title="1.目标"></a>1.目标</h3><p>明确如何给仓库 提供 数据，如何 使用 仓库的数据</p><h3 id="2-提供数据"><a href="#2-提供数据" class="headerlink" title="2.提供数据"></a>2.提供数据</h3><p>State提供唯一的公共数据源，所有共享的数据都要统一放到Store中的State中存储。</p><p>打开项目中的store.js文件，在state对象中可以添加我们要共享的数据。</p><pre><code class="jsx">// 创建仓库 storeconst store = new Vuex.Store(&#123;  // state 状态, 即数据, 类似于vue组件中的data,  // 区别：  // 1.data 是组件自己的数据,   // 2.state 中的数据整个vue项目的组件都能访问到  state: &#123;    count: 101  &#125;&#125;)</code></pre><h3 id="3-访问Vuex中的数据"><a href="#3-访问Vuex中的数据" class="headerlink" title="3.访问Vuex中的数据"></a>3.访问Vuex中的数据</h3><p>问题: 如何在组件中获取count?</p><ol><li>通过$store直接访问  —&gt;  </li><li>通过辅助函数mapState 映射计算属性  —&gt;  </li></ol><h3 id="4-通过-store访问的语法"><a href="#4-通过-store访问的语法" class="headerlink" title="4.通过$store访问的语法"></a>4.通过$store访问的语法</h3><pre><code class="js">获取 store： 1.Vue模板中获取 this.$store 2.js文件中获取 import 导入 store模板中：     &#123;&#123; $store.state.xxx &#125;&#125;组件逻辑中：  this.$store.state.xxxJS模块中：   store.state.xxx</code></pre><h3 id="5-代码实现"><a href="#5-代码实现" class="headerlink" title="5.代码实现"></a>5.代码实现</h3><h4 id="5-1模板中使用"><a href="#5-1模板中使用" class="headerlink" title="5.1模板中使用"></a>5.1模板中使用</h4><p>组件中可以使用  <strong>$store</strong> 获取到vuex中的store对象实例，可通过<strong>state</strong>属性属性获取<strong>count</strong>， 如下</p><pre><code class="vue">&lt;h1&gt;state的数据 - &#123;&#123; $store.state.count &#125;&#125;&lt;/h1&gt;</code></pre><h4 id="5-2组件逻辑中使用"><a href="#5-2组件逻辑中使用" class="headerlink" title="5.2组件逻辑中使用"></a>5.2组件逻辑中使用</h4><p>将state属性定义在计算属性中 <a href="https://vuex.vuejs.org/zh/guide/state.html">https://vuex.vuejs.org/zh/guide/state.html</a></p><pre><code class="js">&lt;h1&gt;state的数据 - &#123;&#123; count &#125;&#125;&lt;/h1&gt;// 把state中数据，定义在组件内的计算属性中  computed: &#123;    count () &#123;      return this.$store.state.count    &#125;  &#125;</code></pre><h4 id="5-3-js文件中使用"><a href="#5-3-js文件中使用" class="headerlink" title="5.3 js文件中使用"></a>5.3 js文件中使用</h4><pre><code class="vue">//main.jsimport store from &quot;@/store&quot;console.log(store.state.count)</code></pre><p>每次都像这样一个个的提供计算属性, 太麻烦了,我们有没有简单的语法帮我们获取state中的值呢？</p><h2 id="五、通过辅助函数-mapState获取-state中的数据"><a href="#五、通过辅助函数-mapState获取-state中的数据" class="headerlink" title="五、通过辅助函数  - mapState获取 state中的数据"></a>五、通过辅助函数  - mapState获取 state中的数据</h2><blockquote><p>mapState是辅助函数，帮助我们把store中的数据映射到 组件的计算属性中, 它属于一种方便的用法</p></blockquote><p>用法 ：</p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke/blog/source/_posts/assets/1683214719574.png" alt="68321471957"> </p><h3 id="1-第一步：导入mapState-mapState是vuex中的一个函数"><a href="#1-第一步：导入mapState-mapState是vuex中的一个函数" class="headerlink" title="1.第一步：导入mapState (mapState是vuex中的一个函数)"></a>1.第一步：导入mapState (mapState是vuex中的一个函数)</h3><pre><code class="js">import &#123; mapState &#125; from &#39;vuex&#39;</code></pre><h3 id="2-第二步：采用数组形式引入state属性"><a href="#2-第二步：采用数组形式引入state属性" class="headerlink" title="2.第二步：采用数组形式引入state属性"></a>2.第二步：采用数组形式引入state属性</h3><pre><code class="js">mapState([&#39;count&#39;]) </code></pre><blockquote><p>上面代码的最终得到的是 <strong>类似于</strong></p></blockquote><pre><code class="js">count () &#123;    return this.$store.state.count&#125;</code></pre><h3 id="3-第三步：利用展开运算符将导出的状态映射给计算属性"><a href="#3-第三步：利用展开运算符将导出的状态映射给计算属性" class="headerlink" title="3.第三步：利用展开运算符将导出的状态映射给计算属性"></a>3.第三步：利用<strong>展开运算符</strong>将导出的状态映射给计算属性</h3><pre><code class="js">  computed: &#123;    ...mapState([&#39;count&#39;])  &#125;</code></pre><pre><code class="vue"> &lt;div&gt; state的数据：&#123;&#123; count &#125;&#125;&lt;/div&gt;</code></pre><h2 id="六、开启严格模式及Vuex的单项数据流"><a href="#六、开启严格模式及Vuex的单项数据流" class="headerlink" title="六、开启严格模式及Vuex的单项数据流"></a>六、开启严格模式及Vuex的单项数据流</h2><h3 id="1-目标-1"><a href="#1-目标-1" class="headerlink" title="1.目标"></a>1.目标</h3><p>明确 vuex 同样遵循单向数据流，组件中不能直接修改仓库的数据</p><h3 id="2-直接在组件中修改Vuex中state的值"><a href="#2-直接在组件中修改Vuex中state的值" class="headerlink" title="2.直接在组件中修改Vuex中state的值"></a>2.直接在组件中修改Vuex中state的值</h3><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke/blog/source/_posts/assets/1683215892288.png" alt="68321589228"></p><p>Son1.vue</p><pre><code class="vue">button @click=&quot;handleAdd&quot;&gt;值 + 1&lt;/button&gt;methods:&#123;     handleAdd (n) &#123;      // 错误代码(vue默认不会监测，监测需要成本)       this.$store.state.count++      // console.log(this.$store.state.count)     &#125;,&#125;</code></pre><h3 id="3-开启严格模式"><a href="#3-开启严格模式" class="headerlink" title="3.开启严格模式"></a>3.开启严格模式</h3><p>通过 <code>strict: true</code> 可以开启严格模式,开启严格模式后，直接修改state中的值会报错</p><blockquote><p><strong>state数据的修改只能通过mutations，并且mutations必须是同步的</strong></p></blockquote><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke/blog/source/_posts/assets/1683215821033.png" alt="68321471957"></p><h2 id="七、核心概念-mutations"><a href="#七、核心概念-mutations" class="headerlink" title="七、核心概念-mutations"></a>七、核心概念-mutations</h2><h3 id="1-定义mutations"><a href="#1-定义mutations" class="headerlink" title="1.定义mutations"></a>1.定义mutations</h3><pre><code class="js">const store  = new Vuex.Store(&#123;  state: &#123;    count: 0  &#125;,  // 定义mutations  mutations: &#123;       &#125;&#125;)</code></pre><h3 id="2-格式说明"><a href="#2-格式说明" class="headerlink" title="2.格式说明"></a>2.格式说明</h3><p>mutations是一个对象，对象中存放修改state的方法</p><pre><code class="js">mutations: &#123;    // 方法里参数 第一个参数是当前store的state属性    // payload 载荷 运输参数 调用mutaiions的时候 可以传递参数 传递载荷    addCount (state) &#123;      state.count += 1    &#125;  &#125;,</code></pre><h3 id="3-组件中提交-mutations"><a href="#3-组件中提交-mutations" class="headerlink" title="3.组件中提交 mutations"></a>3.组件中提交 mutations</h3><pre><code class="jsx">this.$store.commit(&#39;addCount&#39;)</code></pre><h3 id="4-练习"><a href="#4-练习" class="headerlink" title="4.练习"></a>4.练习</h3><p>1.在mutations中定义个点击按钮进行 +5 的方法</p><p>2.在mutations中定义个点击按钮进行 改变title 的方法</p><p>3.在组件中调用mutations修改state中的值</p><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h3><p>通过mutations修改state的步骤</p><p>1.定义 mutations 对象，对象中存放修改 state 的方法</p><p>2.组件中提交调用 mutations(通过$store.commit(‘mutations的方法名’))</p><h2 id="八、带参数的-mutations"><a href="#八、带参数的-mutations" class="headerlink" title="八、带参数的 mutations"></a>八、带参数的 mutations</h2><h3 id="1-目标："><a href="#1-目标：" class="headerlink" title="1.目标："></a>1.目标：</h3><p>掌握 mutations 传参语法</p><h3 id="2-语法"><a href="#2-语法" class="headerlink" title="2.语法"></a>2.语法</h3><p>看下面这个案例，每次点击不同的按钮，加的值都不同，每次都要定义不同的mutations处理吗？</p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke/blog/source/_posts/assets/1683217004239.png" alt="68321700423"></p><p>提交 mutation 是可以传递参数的  <code>this.$store.commit(&#39;xxx&#39;,  参数)</code></p><h4 id="2-1-提供mutation函数（带参数）"><a href="#2-1-提供mutation函数（带参数）" class="headerlink" title="2.1 提供mutation函数（带参数）"></a>2.1 提供mutation函数（带参数）</h4><pre><code class="js">mutations: &#123;  ...  addCount (state, count) &#123;    state.count = count  &#125;&#125;,</code></pre><h4 id="2-2-提交mutation"><a href="#2-2-提交mutation" class="headerlink" title="2.2 提交mutation"></a>2.2 提交mutation</h4><pre><code class="jsx">handle ( ) &#123;  this.$store.commit(&#39;addCount&#39;, 10)&#125;</code></pre><p><strong>小tips: 提交的参数只能是一个, 如果有多个参数要传, 可以传递一个对象</strong></p><pre><code class="jsx">this.$store.commit(&#39;addCount&#39;, &#123;  count: 10&#125;)</code></pre><h2 id="九、练习-mutations的减法功能"><a href="#九、练习-mutations的减法功能" class="headerlink" title="九、练习-mutations的减法功能"></a>九、练习-mutations的减法功能</h2><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke/blog/source/_posts/assets/1683217248752.png" alt="68321724875"></p><h3 id="1-步骤"><a href="#1-步骤" class="headerlink" title="1.步骤"></a>1.步骤</h3><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke/blog/source/_posts/assets/1683217268256.png" alt="68321726825"></p><h3 id="2-代码实现-4"><a href="#2-代码实现-4" class="headerlink" title="2.代码实现"></a>2.代码实现</h3><p>Son2.vue</p><pre><code class="vue">    &lt;button @click=&quot;subCount(1)&quot;&gt;值 - 1&lt;/button&gt;    &lt;button @click=&quot;subCount(5)&quot;&gt;值 - 5&lt;/button&gt;    &lt;button @click=&quot;subCount(10)&quot;&gt;值 - 10&lt;/button&gt;    export default &#123;        methods:&#123;             subCount (n) &#123;                 this.$store.commit(&#39;addCount&#39;, n)        &#125;,        &#125;    &#125;</code></pre><p>store&#x2F;index.js</p><pre><code class="js">mutations:&#123;    subCount (state, n) &#123;      state.count -= n    &#125;,&#125;</code></pre><h2 id="十、练习-Vuex中的值和组件中的input双向绑定"><a href="#十、练习-Vuex中的值和组件中的input双向绑定" class="headerlink" title="十、练习-Vuex中的值和组件中的input双向绑定"></a>十、练习-Vuex中的值和组件中的input双向绑定</h2><h3 id="1-目标-2"><a href="#1-目标-2" class="headerlink" title="1.目标"></a>1.目标</h3><p>实时输入，实时更新，巩固 mutations 传参语法</p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke/blog/source/_posts/assets/1683217697064.png" alt="68321769706"></p><h3 id="2-实现步骤"><a href="#2-实现步骤" class="headerlink" title="2.实现步骤"></a>2.实现步骤</h3><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke/blog/source/_posts/assets/1683217717788.png" alt="68321771778"></p><h3 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3.代码实现"></a>3.代码实现</h3><p>App.vue</p><pre><code class="vue">&lt;input :value=&quot;count&quot; @input=&quot;handleInput&quot; type=&quot;text&quot;&gt;export default &#123;  methods: &#123;    handleInput (e) &#123;      // 1. 实时获取输入框的值      const num = +e.target.value      // 2. 提交mutation，调用mutation函数      this.$store.commit(&#39;changeCount&#39;, num)    &#125;  &#125;&#125;</code></pre><p>store&#x2F;index.js</p><pre><code class="js">mutations: &#123;    changeCount (state, newCount) &#123;      state.count = newCount   &#125;&#125;,</code></pre><h2 id="十一、辅助函数-mapMutations"><a href="#十一、辅助函数-mapMutations" class="headerlink" title="十一、辅助函数- mapMutations"></a>十一、辅助函数- mapMutations</h2><blockquote><p>mapMutations和mapState很像，它把位于mutations中的方法提取了出来，我们可以将它导入</p></blockquote><pre><code class="js">import  &#123; mapMutations &#125; from &#39;vuex&#39;methods: &#123;    ...mapMutations([&#39;addCount&#39;])&#125;</code></pre><blockquote><p>上面代码的含义是将mutations的方法导入了methods中，等价于</p></blockquote><pre><code class="js">methods: &#123;      // commit(方法名, 载荷参数)      addCount () &#123;          this.$store.commit(&#39;addCount&#39;)      &#125; &#125;</code></pre><p>此时，就可以直接通过this.addCount调用了</p><pre><code class="jsx">&lt;button @click=&quot;addCount&quot;&gt;值+1&lt;/button&gt;</code></pre><p>但是请注意： Vuex中mutations中要求不能写异步代码，如果有异步的ajax请求，应该放置在actions中</p><h2 id="十二、核心概念-actions"><a href="#十二、核心概念-actions" class="headerlink" title="十二、核心概念 - actions"></a>十二、核心概念 - actions</h2><blockquote><p>state是存放数据的，mutations是同步更新数据 (便于监测数据的变化, 更新视图等, 方便于调试工具查看变化)，</p><p>actions则负责进行异步操作</p></blockquote><p><strong>说明：mutations必须是同步的</strong></p><p><strong>需求: 一秒钟之后, 要给一个数 去修改state</strong></p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke/blog/source/_posts/assets/1683218603674.png" alt="68321860367"></p><h3 id="1-定义actions"><a href="#1-定义actions" class="headerlink" title="1.定义actions"></a><strong>1.定义actions</strong></h3><pre><code class="js">mutations: &#123;  changeCount (state, newCount) &#123;    state.count = newCount  &#125;&#125;actions: &#123;  setAsyncCount (context, num) &#123;    // 一秒后, 给一个数, 去修改 num    setTimeout(() =&gt; &#123;      context.commit(&#39;changeCount&#39;, num)    &#125;, 1000)  &#125;&#125;,</code></pre><h3 id="2-组件中通过dispatch调用"><a href="#2-组件中通过dispatch调用" class="headerlink" title="2.组件中通过dispatch调用"></a><strong>2.组件中通过dispatch调用</strong></h3><pre><code class="js">setAsyncCount () &#123;  this.$store.dispatch(&#39;setAsyncCount&#39;, 666)&#125;</code></pre><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke/blog/source/_posts/assets/1683441987572.png" alt="68344198757"></p><h2 id="十三、辅助函数-mapActions"><a href="#十三、辅助函数-mapActions" class="headerlink" title="十三、辅助函数 -mapActions"></a>十三、辅助函数 -mapActions</h2><p>1.目标：掌握辅助函数 mapActions，映射方法</p><blockquote><p>mapActions 是把位于 actions中的方法提取了出来，映射到组件methods中</p></blockquote><p>Son2.vue</p><pre><code class="js">import &#123; mapActions &#125; from &#39;vuex&#39;methods: &#123;   ...mapActions([&#39;changeCountAction&#39;])&#125;//mapActions映射的代码 本质上是以下代码的写法//methods: &#123;//  changeCountAction (n) &#123;//    this.$store.dispatch(&#39;changeCountAction&#39;, n)//  &#125;,//&#125;</code></pre><p>直接通过 this.方法 就可以调用</p><pre><code class="vue">&lt;button @click=&quot;changeCountAction(200)&quot;&gt;+异步&lt;/button&gt;</code></pre><h2 id="十四、核心概念-getters"><a href="#十四、核心概念-getters" class="headerlink" title="十四、核心概念 - getters"></a>十四、核心概念 - getters</h2><blockquote><p>除了state之外，有时我们还需要从state中<strong>筛选出符合条件的一些数据</strong>，这些数据是依赖state的，此时会用到getters</p></blockquote><p>例如，state中定义了list，为1-10的数组，</p><pre><code class="js">state: &#123;    list: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]&#125;</code></pre><p>组件中，需要显示所有大于5的数据，正常的方式，是需要list在组件中进行再一步的处理，但是getters可以帮助我们实现它</p><h3 id="1-定义getters"><a href="#1-定义getters" class="headerlink" title="1.定义getters"></a>1.定义getters</h3><pre><code class="js">  getters: &#123;    // getters函数的第一个参数是 state    // 必须要有返回值     filterList:  state =&gt;  state.list.filter(item =&gt; item &gt; 5)  &#125;</code></pre><h3 id="2-使用getters"><a href="#2-使用getters" class="headerlink" title="2.使用getters"></a>2.使用getters</h3><h4 id="2-1原始方式-store"><a href="#2-1原始方式-store" class="headerlink" title="2.1原始方式-$store"></a>2.1原始方式-$store</h4><pre><code class="vue">&lt;div&gt;&#123;&#123; $store.getters.filterList &#125;&#125;&lt;/div&gt;</code></pre><h4 id="2-2辅助函数-mapGetters"><a href="#2-2辅助函数-mapGetters" class="headerlink" title="2.2辅助函数 - mapGetters"></a>2.2辅助函数 - mapGetters</h4><pre><code class="js">computed: &#123;    ...mapGetters([&#39;filterList&#39;])&#125;</code></pre><pre><code class="vue"> &lt;div&gt;&#123;&#123; filterList &#125;&#125;&lt;/div&gt;</code></pre><h2 id="十五、使用小结"><a href="#十五、使用小结" class="headerlink" title="十五、使用小结"></a>十五、使用小结</h2><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke/blog/source/_posts/assets/1683442133911.png" alt="68344213391"></p><h2 id="十六、核心概念-module"><a href="#十六、核心概念-module" class="headerlink" title="十六、核心概念 - module"></a>十六、核心概念 - module</h2><h3 id="1-目标-3"><a href="#1-目标-3" class="headerlink" title="1.目标"></a>1.目标</h3><p>掌握核心概念 module 模块的创建</p><h3 id="2-问题"><a href="#2-问题" class="headerlink" title="2.问题"></a>2.问题</h3><p>由于使用<strong>单一状态树</strong>，应用的所有状态<strong>会集中到一个比较大的对象</strong>。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。</p><p>这句话的意思是，如果把所有的状态都放在state中，当项目变得越来越大的时候，Vuex会变得越来越难以维护</p><p>由此，又有了Vuex的模块化</p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke/blog/source/_posts/assets/1683425758358.png" alt="68342575835"></p><h3 id="3-模块定义-准备-state"><a href="#3-模块定义-准备-state" class="headerlink" title="3.模块定义 - 准备 state"></a><strong>3.模块定义</strong> - 准备 state</h3><p>定义两个模块   <strong>user</strong> 和  <strong>setting</strong></p><p>user中管理用户的信息状态  userInfo  <code>modules/user.js</code></p><pre><code class="jsx">const state = &#123;  userInfo: &#123;    name: &#39;zs&#39;,    age: 18  &#125;&#125;const mutations = &#123;&#125;const actions = &#123;&#125;const getters = &#123;&#125;export default &#123;  state,  mutations,  actions,  getters&#125;</code></pre><p>setting中管理项目应用的  主题色 theme，描述 desc， <code>modules/setting.js</code></p><pre><code class="jsx">const state = &#123;  theme: &#39;dark&#39;  desc: &#39;描述真呀真不错&#39;&#125;const mutations = &#123;&#125;const actions = &#123;&#125;const getters = &#123;&#125;export default &#123;  state,  mutations,  actions,  getters&#125;</code></pre><p>在<code>store/index.js</code>文件中的modules配置项中，注册这两个模块</p><pre><code class="js">import user from &#39;./modules/user&#39;import setting from &#39;./modules/setting&#39;const store = new Vuex.Store(&#123;    modules:&#123;        user,        setting    &#125;&#125;)</code></pre><p>使用模块中的数据,  可以直接通过模块名访问 <code>$store.state.模块名.xxx</code>  &#x3D;&gt;  <code>$store.state.setting.desc</code></p><p>也可以通过 mapState 映射</p><h2 id="十七、获取模块内的state数据"><a href="#十七、获取模块内的state数据" class="headerlink" title="十七、获取模块内的state数据"></a>十七、获取模块内的state数据</h2><h3 id="1-目标：-1"><a href="#1-目标：-1" class="headerlink" title="1.目标："></a>1.目标：</h3><p>掌握模块中 state 的访问语法</p><p>尽管已经分模块了，但其实子模块的状态，还是会挂到根级别的 state 中，属性名就是模块名</p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke/blog/source/_posts/assets/1683427841660.png" alt="68342784166"></p><h3 id="2-使用模块中的数据"><a href="#2-使用模块中的数据" class="headerlink" title="2.使用模块中的数据"></a>2.使用模块中的数据</h3><ol><li>直接通过模块名访问 $store.state.模块名.xxx</li><li>通过 mapState 映射：<ol><li>默认根级别的映射  mapState([ ‘xxx’ ])     </li><li>子模块的映射 ：mapState(‘模块名’, [‘xxx’])  -  需要开启命名空间 <strong>namespaced:true</strong></li></ol></li></ol><p><code>modules/user.js</code></p><pre><code class="jsx">const state = &#123;  userInfo: &#123;    name: &#39;zs&#39;,    age: 18  &#125;,  myMsg: &#39;我的数据&#39;&#125;const mutations = &#123;  updateMsg (state, msg) &#123;    state.myMsg = msg  &#125;&#125;const actions = &#123;&#125;const getters = &#123;&#125;export default &#123;  namespaced: true,  state,  mutations,  actions,  getters&#125;</code></pre><h3 id="3-代码示例"><a href="#3-代码示例" class="headerlink" title="3.代码示例"></a>3.代码示例</h3><p>$store直接访问</p><pre><code class="js">$store.state.user.userInfo.name</code></pre><p>mapState辅助函数访问</p><pre><code class="js">...mapState(&#39;user&#39;, [&#39;userInfo&#39;]),...mapState(&#39;setting&#39;, [&#39;theme&#39;, &#39;desc&#39;]),</code></pre><h2 id="十八、获取模块内的getters数据"><a href="#十八、获取模块内的getters数据" class="headerlink" title="十八、获取模块内的getters数据"></a>十八、获取模块内的getters数据</h2><h3 id="1-目标：-2"><a href="#1-目标：-2" class="headerlink" title="1.目标："></a>1.目标：</h3><p>掌握模块中 getters 的访问语</p><h3 id="2-语法："><a href="#2-语法：" class="headerlink" title="2.语法："></a>2.语法：</h3><p>使用模块中 getters 中的数据： </p><ol><li>直接通过模块名访问<code> $store.getters[&#39;模块名/xxx &#39;]</code></li><li>通过 mapGetters 映射      <ol><li>默认根级别的映射  <code>mapGetters([ &#39;xxx&#39; ]) </code></li><li>子模块的映射  <code>mapGetters(&#39;模块名&#39;, [&#39;xxx&#39;])</code> -  需要开启命名空间</li></ol></li></ol><h3 id="3-代码演示"><a href="#3-代码演示" class="headerlink" title="3.代码演示"></a>3.代码演示</h3><p><code>modules/user.js</code></p><pre><code class="js">const getters = &#123;  // 分模块后，state指代子模块的state  UpperCaseName (state) &#123;    return state.userInfo.name.toUpperCase()  &#125;&#125;</code></pre><p>Son1.vue 直接访问getters</p><pre><code class="html">&lt;!-- 测试访问模块中的getters - 原生 --&gt;&lt;div&gt;&#123;&#123; $store.getters['user/UpperCaseName'] &#125;&#125;&lt;/div&gt;</code></pre><p>Son2.vue 通过命名空间访问</p><pre><code class="js">computed:&#123;  ...mapGetters(&#39;user&#39;, [&#39;UpperCaseName&#39;])&#125;</code></pre><h2 id="十九、获取模块内的mutations方法"><a href="#十九、获取模块内的mutations方法" class="headerlink" title="十九、获取模块内的mutations方法"></a>十九、获取模块内的mutations方法</h2><h3 id="1-目标：-3"><a href="#1-目标：-3" class="headerlink" title="1.目标："></a>1.目标：</h3><p>掌握模块中 mutation 的调用语法</p><h3 id="2-注意："><a href="#2-注意：" class="headerlink" title="2.注意："></a>2.注意：</h3><p>默认模块中的 mutation 和 actions 会被挂载到全局，<strong>需要开启命名空间</strong>，才会挂载到子模块。</p><h3 id="3-调用方式："><a href="#3-调用方式：" class="headerlink" title="3.调用方式："></a>3.调用方式：</h3><ol><li>直接通过 store 调用   $store.commit(‘模块名&#x2F;xxx ‘,  额外参数)</li><li>通过 mapMutations 映射    <ol><li>默认根级别的映射  mapMutations([ ‘xxx’ ])     </li><li>子模块的映射 mapMutations(‘模块名’, [‘xxx’])  -  需要开启命名空间</li></ol></li></ol><h3 id="4-代码实现"><a href="#4-代码实现" class="headerlink" title="4.代码实现"></a>4.代码实现</h3><p><code>modules/user.js</code></p><pre><code class="js">const mutations = &#123;  setUser (state, newUserInfo) &#123;    state.userInfo = newUserInfo  &#125;&#125;</code></pre><p><code>modules/setting.js</code></p><pre><code class="js">const mutations = &#123;  setTheme (state, newTheme) &#123;    state.theme = newTheme  &#125;&#125;</code></pre><p>Son1.vue</p><pre><code class="vue">&lt;button @click=&quot;updateUser&quot;&gt;更新个人信息&lt;/button&gt; &lt;button @click=&quot;updateTheme&quot;&gt;更新主题色&lt;/button&gt;export default &#123;  methods: &#123;    updateUser () &#123;      // $store.commit(&#39;模块名/mutation名&#39;, 额外传参)      this.$store.commit(&#39;user/setUser&#39;, &#123;        name: &#39;xiaowang&#39;,        age: 25      &#125;)    &#125;,     updateTheme () &#123;      this.$store.commit(&#39;setting/setTheme&#39;, &#39;pink&#39;)    &#125;  &#125;&#125;</code></pre><p>Son2.vue</p><pre><code class="vue">&lt;button @click=&quot;setUser(&#123; name: &#39;xiaoli&#39;, age: 80 &#125;)&quot;&gt;更新个人信息&lt;/button&gt;&lt;button @click=&quot;setTheme(&#39;skyblue&#39;)&quot;&gt;更新主题&lt;/button&gt;methods:&#123;// 分模块的映射...mapMutations(&#39;setting&#39;, [&#39;setTheme&#39;]),...mapMutations(&#39;user&#39;, [&#39;setUser&#39;]),&#125;</code></pre><h2 id="二十、获取模块内的actions方法"><a href="#二十、获取模块内的actions方法" class="headerlink" title="二十、获取模块内的actions方法"></a>二十、获取模块内的actions方法</h2><h3 id="1-目标：-4"><a href="#1-目标：-4" class="headerlink" title="1.目标："></a>1.目标：</h3><p>掌握模块中 action 的调用语法 (同理 - 直接类比 mutation 即可)</p><h3 id="2-注意：-1"><a href="#2-注意：-1" class="headerlink" title="2.注意："></a>2.注意：</h3><p>默认模块中的 mutation 和 actions 会被挂载到全局，<strong>需要开启命名空间</strong>，才会挂载到子模块。</p><h3 id="3-调用语法："><a href="#3-调用语法：" class="headerlink" title="3.调用语法："></a>3.调用语法：</h3><ol><li>直接通过 store 调用   $store.dispatch(‘模块名&#x2F;xxx ‘,  额外参数)</li><li>通过 mapActions 映射     <ol><li>默认根级别的映射  mapActions([ ‘xxx’ ])     </li><li>子模块的映射 mapActions(‘模块名’, [‘xxx’])  -  需要开启命名空间</li></ol></li></ol><h3 id="4-代码实现-1"><a href="#4-代码实现-1" class="headerlink" title="4.代码实现"></a>4.代码实现</h3><p>需求：</p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke/blog/source/_posts/assets/1683431615694.png" alt="68343161569"></p><p><code>modules/user.js</code></p><pre><code class="js">const actions = &#123;  setUserSecond (context, newUserInfo) &#123;    // 将异步在action中进行封装    setTimeout(() =&gt; &#123;      // 调用mutation   context上下文，默认提交的就是自己模块的action和mutation      context.commit(&#39;setUser&#39;, newUserInfo)    &#125;, 1000)  &#125;&#125;</code></pre><p>Son1.vue  直接通过store调用</p><pre><code class="vue">&lt;button @click=&quot;updateUser2&quot;&gt;一秒后更新信息&lt;/button&gt;methods:&#123;    updateUser2 () &#123;      // 调用action dispatch      this.$store.dispatch(&#39;user/setUserSecond&#39;, &#123;        name: &#39;xiaohong&#39;,        age: 28      &#125;)    &#125;,&#125;</code></pre><p>Son2.vue mapActions映射</p><pre><code class="js">&lt;button @click=&quot;setUserSecond(&#123; name: &#39;xiaoli&#39;, age: 80 &#125;)&quot;&gt;一秒后更新信息&lt;/button&gt;methods:&#123;  ...mapActions(&#39;user&#39;, [&#39;setUserSecond&#39;])&#125;</code></pre><h2 id="二十一、Vuex模块化的使用小结"><a href="#二十一、Vuex模块化的使用小结" class="headerlink" title="二十一、Vuex模块化的使用小结"></a>二十一、Vuex模块化的使用小结</h2><h3 id="1-直接使用"><a href="#1-直接使用" class="headerlink" title="1.直接使用"></a>1.直接使用</h3><ol><li>state –&gt; $store.state.<strong>模块名</strong>.数据项名</li><li>getters –&gt; $store.getters[‘<strong>模块名</strong>&#x2F;属性名’]</li><li>mutations –&gt; $store.commit(‘<strong>模块名</strong>&#x2F;方法名’, 其他参数)</li><li>actions –&gt; $store.dispatch(‘<strong>模块名</strong>&#x2F;方法名’, 其他参数)</li></ol><h3 id="2-借助辅助方法使用"><a href="#2-借助辅助方法使用" class="headerlink" title="2.借助辅助方法使用"></a>2.借助辅助方法使用</h3><p>1.import { mapXxxx, mapXxx } from ‘vuex’</p><p>computed、methods: {</p><p>​     &#x2F;&#x2F; <strong>…mapState、…mapGetters放computed中；</strong></p><p>​    &#x2F;&#x2F;  <strong>…mapMutations、…mapActions放methods中；</strong></p><p>​    …mapXxxx(<strong>‘模块名’</strong>, [‘数据项|方法’]),</p><p>​    …mapXxxx(<strong>‘模块名’</strong>, { 新的名字: 原来的名字 }),</p><p>}</p><p>2.组件中直接使用 属性 <code>&#123;&#123; age &#125;&#125;</code> 或 方法 <code>@click=&quot;updateAge(2)&quot;</code></p><h2 id="二十二、综合案例-创建项目"><a href="#二十二、综合案例-创建项目" class="headerlink" title="二十二、综合案例 - 创建项目"></a>二十二、综合案例 - 创建项目</h2><ol><li><p>脚手架新建项目 (注意：<strong>勾选vuex</strong>)      </p><p>版本说明：</p><p>vue2   vue-router3   vuex3               </p><p>vue3  vue-router4  vuex4&#x2F;pinia</p></li></ol><pre><code>vue create vue-cart-demo</code></pre><ol start="2"><li>将原本src内容清空，替换成教学资料的《vuex-cart-准备代码》</li></ol><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke/blog/source/_posts/assets/1683432959356.png" alt="68343295935"></p><p>需求：</p><ol><li>发请求动态渲染购物车，数据存vuex （存cart模块， 将来还会有user模块，article模块…）</li><li>数字框可以修改数据</li><li>动态计算总价和总数量</li></ol><h2 id="二十三、综合案例-构建vuex-cart模块"><a href="#二十三、综合案例-构建vuex-cart模块" class="headerlink" title="二十三、综合案例-构建vuex-cart模块"></a>二十三、综合案例-构建vuex-cart模块</h2><ol><li>新建 <code>store/modules/cart.js</code></li></ol><pre><code class="jsx">export default &#123;  namespaced: true,  state () &#123;    return &#123;      list: []    &#125;  &#125;,&#125;</code></pre><ol start="2"><li>挂载到 vuex 仓库上 <code>store/cart.js</code></li></ol><pre><code class="jsx">import Vuex from &#39;vuex&#39;import Vue from &#39;vue&#39;import cart from &#39;./modules/cart&#39;Vue.use(Vuex)const store = new Vuex.Store(&#123;  modules: &#123;    cart  &#125;&#125;)export default store</code></pre><h2 id="二十四、综合案例-准备后端接口服务环境-了解"><a href="#二十四、综合案例-准备后端接口服务环境-了解" class="headerlink" title="二十四、综合案例-准备后端接口服务环境(了解)"></a>二十四、综合案例-准备后端接口服务环境(了解)</h2><ol><li>安装全局工具 json-server （全局工具仅需要安装一次）</li></ol><pre><code>yarn global add json-server 或 npm i json-server  -g</code></pre><ol start="2"><li>代码根目录新建一个 db 目录</li><li>将资料 index.json 移入 db 目录</li><li>进入 db 目录，执行命令，启动后端接口服务 (使用–watch 参数 可以实时监听 json 文件的修改)</li></ol><pre><code>json-server  --watch  index.json</code></pre><h2 id="二十五、综合案例-请求动态渲染数据"><a href="#二十五、综合案例-请求动态渲染数据" class="headerlink" title="二十五、综合案例-请求动态渲染数据"></a>二十五、综合案例-请求动态渲染数据</h2><h3 id="1-目标-4"><a href="#1-目标-4" class="headerlink" title="1.目标"></a>1.目标</h3><p>请求获取数据存入 vuex, 映射渲染</p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke/blog/source/_posts/assets/1683436471929.png" alt="6834364719 2"></p><ol><li>安装 axios</li></ol><pre><code class="jsx">yarn add axios</code></pre><ol start="2"><li>准备actions 和 mutations</li></ol><pre><code class="jsx">import axios from &#39;axios&#39;export default &#123;  namespaced: true,  state () &#123;    return &#123;      list: []    &#125;  &#125;,  mutations: &#123;    updateList (state, payload) &#123;      state.list = payload    &#125;  &#125;,  actions: &#123;    async getList (ctx) &#123;      const res = await axios.get(&#39;http://localhost:3000/cart&#39;)      ctx.commit(&#39;updateList&#39;, res.data)    &#125;  &#125;&#125;</code></pre><ol start="3"><li><code>App.vue</code>页面中调用 action,  获取数据</li></ol><pre><code class="jsx">import &#123; mapState &#125; from &#39;vuex&#39;export default &#123;  name: &#39;App&#39;,  components: &#123;    CartHeader,    CartFooter,    CartItem  &#125;,  created () &#123;    this.$store.dispatch(&#39;cart/getList&#39;)  &#125;,  computed: &#123;    ...mapState(&#39;cart&#39;, [&#39;list&#39;])  &#125;&#125;</code></pre><ol start="4"><li>动态渲染</li></ol><pre><code class="jsx">&lt;!-- 商品 Item 项组件 --&gt;&lt;cart-item v-for=&quot;item in list&quot; :key=&quot;item.id&quot; :item=&quot;item&quot;&gt;&lt;/cart-item&gt;</code></pre><p><code>cart-item.vue</code></p><pre><code class="jsx">&lt;template&gt;  &lt;div class=&quot;goods-container&quot;&gt;    &lt;!-- 左侧图片区域 --&gt;    &lt;div class=&quot;left&quot;&gt;      &lt;img :src=&quot;item.thumb&quot; class=&quot;avatar&quot; alt=&quot;&quot;&gt;    &lt;/div&gt;    &lt;!-- 右侧商品区域 --&gt;    &lt;div class=&quot;right&quot;&gt;      &lt;!-- 标题 --&gt;      &lt;div class=&quot;title&quot;&gt;&#123;&#123;item.name&#125;&#125;&lt;/div&gt;      &lt;div class=&quot;info&quot;&gt;        &lt;!-- 单价 --&gt;        &lt;span class=&quot;price&quot;&gt;￥&#123;&#123;item.price&#125;&#125;&lt;/span&gt;        &lt;div class=&quot;btns&quot;&gt;          &lt;!-- 按钮区域 --&gt;          &lt;button class=&quot;btn btn-light&quot;&gt;-&lt;/button&gt;          &lt;span class=&quot;count&quot;&gt;&#123;&#123;item.count&#125;&#125;&lt;/span&gt;          &lt;button class=&quot;btn btn-light&quot;&gt;+&lt;/button&gt;        &lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;CartItem&#39;,  props: &#123;    item: Object  &#125;,  methods: &#123;  &#125;&#125;&lt;/script&gt;</code></pre><h2 id="二十六、综合案例-修改数量"><a href="#二十六、综合案例-修改数量" class="headerlink" title="二十六、综合案例-修改数量"></a>二十六、综合案例-修改数量</h2><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke/blog/source/_posts/assets/1683437346997.png" alt="68343734699"></p><ol><li>注册点击事件</li></ol><pre><code class="jsx">&lt;!-- 按钮区域 --&gt;&lt;button class=&quot;btn btn-light&quot; @click=&quot;onBtnClick(-1)&quot;&gt;-&lt;/button&gt;&lt;span class=&quot;count&quot;&gt;&#123;&#123;item.count&#125;&#125;&lt;/span&gt;&lt;button class=&quot;btn btn-light&quot; @click=&quot;onBtnClick(1)&quot;&gt;+&lt;/button&gt;</code></pre><ol start="2"><li>页面中dispatch action</li></ol><pre><code class="jsx">onBtnClick (step) &#123;  const newCount = this.item.count + step  if (newCount &lt; 1) return  // 发送修改数量请求  this.$store.dispatch(&#39;cart/updateCount&#39;, &#123;    id: this.item.id,    count: newCount  &#125;)&#125;</code></pre><ol start="3"><li>提供action函数</li></ol><pre><code class="jsx">async updateCount (ctx, payload) &#123;  await axios.patch(&#39;http://localhost:3000/cart/&#39; + payload.id, &#123;    count: payload.count  &#125;)  ctx.commit(&#39;updateCount&#39;, payload)&#125;</code></pre><ol start="4"><li>提供mutation处理函数</li></ol><pre><code class="jsx">mutations: &#123;  ...,  updateCount (state, payload) &#123;    const goods = state.list.find((item) =&gt; item.id === payload.id)    goods.count = payload.count  &#125;&#125;,</code></pre><h2 id="二十七、综合案例-底部总价展示"><a href="#二十七、综合案例-底部总价展示" class="headerlink" title="二十七、综合案例-底部总价展示"></a>二十七、综合案例-底部总价展示</h2><ol><li>提供getters</li></ol><pre><code class="jsx">getters: &#123;  total(state) &#123;    return state.list.reduce((p, c) =&gt; p + c.count, 0);  &#125;,  totalPrice (state) &#123;    return state.list.reduce((p, c) =&gt; p + c.count * c.price, 0);  &#125;,&#125;,</code></pre><ol start="2"><li>动态渲染</li></ol><pre><code class="jsx">&lt;template&gt;  &lt;div class=&quot;footer-container&quot;&gt;    &lt;!-- 中间的合计 --&gt;    &lt;div&gt;      &lt;span&gt;共 &#123;&#123;total&#125;&#125; 件商品，合计：&lt;/span&gt;      &lt;span class=&quot;price&quot;&gt;￥&#123;&#123;totalPrice&#125;&#125;&lt;/span&gt;    &lt;/div&gt;    &lt;!-- 右侧结算按钮 --&gt;    &lt;button class=&quot;btn btn-success btn-settle&quot;&gt;结算&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; mapGetters &#125; from &#39;vuex&#39;export default &#123;  name: &#39;CartFooter&#39;,  computed: &#123;    ...mapGetters(&#39;cart&#39;, [&#39;total&#39;, &#39;totalPrice&#39;])  &#125;&#125;&lt;/script&gt;</code></pre><h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><p>商城系统</p><p><img src="/2023/07/17/VUE%E5%AD%A6%E4%B9%A0/personboke\blog\source_posts\VUE学习\image-20230726225416358.png" alt="image-20230726225416358"></p></slot>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo基本操作</title>
      <link href="/2023/07/15/hexo%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>/2023/07/15/hexo%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo的常用指令合集"><a href="#Hexo的常用指令合集" class="headerlink" title="Hexo的常用指令合集"></a>Hexo的常用指令合集</h1><p>xo有许多主题，其实最火爆的是NexT、Matery等，复制关键词到GitHub或者baidu都能搜到。权衡利弊最终我还是选择了大多数人使用的next。我这边先用的buttfly后期有时间再进行优化</p><h2 id="关于部署命令"><a href="#关于部署命令" class="headerlink" title="关于部署命令"></a>关于部署命令</h2><h4 id="（1）hexo-g或hexo-generate"><a href="#（1）hexo-g或hexo-generate" class="headerlink" title="（1）hexo g或hexo generate"></a>（1）<code>hexo g</code>或<code>hexo generate</code></h4><p>该命令执行后在hexo站点根目录下生成public文件夹</p><p><img src="/2023/07/15/hexo%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230715194722355.png" alt="image-20230715194722355"></p><h4 id="（2）hexo-clean"><a href="#（2）hexo-clean" class="headerlink" title="（2）hexo clean"></a>（2）<code>hexo clean</code></h4><p>把（1）中的<code>public</code>文件夹删除</p><h4 id="（3）hexo-s或hexo-server"><a href="#（3）hexo-s或hexo-server" class="headerlink" title="（3）hexo s或hexo server"></a>（3）<code>hexo s</code>或<code>hexo server</code></h4><p>启动服务，默认地址为<a href="http://localhost:4000/%EF%BC%8C4000%E7%AB%AF%E5%8F%A3">http://localhost:4000/，4000端口</a></p><p><img src="/2023/07/15/hexo%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/Users\李开恩\AppData\Roaming\Typora\typora-user-images\image-20230715194810602.png" alt="image-20230715194810602"></p><h4 id="4）hexo-d或hexo-deploy"><a href="#4）hexo-d或hexo-deploy" class="headerlink" title="4）hexo d或hexo deploy"></a>4）<code>hexo d</code>或<code>hexo deploy</code></h4><p>部署站点，在本地生成<code>.deploy_git</code>文件夹，并将编译后的文件上传至 GitHub。</p><h4 id="5）hexo-new"><a href="#5）hexo-new" class="headerlink" title="5）hexo new"></a>5）hexo new</h4><p>例如： hexo new photo “my-first-blog”<br>上述指令执行时，Hexo 会尝试在 scaffolds 中寻找photo.md布局，若找到，则根据该布局新建文章；若未找到或指令中未指定该参数，则使用post.md新建文章。新建文章的名称在_config.yml中配置。</p><h4 id="（6）删除文章"><a href="#（6）删除文章" class="headerlink" title="（6）删除文章"></a>（6）删除文章</h4><p>只需在本地把<code>source/_posts</code>文件夹下的文章源文件删除后，执行以下命令重新部署即可。</p><pre><code class="hexo">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s // 一定要先 clean，防止灵异事件发生</code></pre><h4 id="7）重新打包发布到本地"><a href="#7）重新打包发布到本地" class="headerlink" title="7）重新打包发布到本地"></a>7）重新打包发布到本地</h4><pre><code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</code></pre><h4 id="8）重新打包发布到GItHub"><a href="#8）重新打包发布到GItHub" class="headerlink" title="8）重新打包发布到GItHub"></a>8）重新打包发布到GItHub</h4><pre><code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code></pre><h1 id="Hexo写文章基本操作"><a href="#Hexo写文章基本操作" class="headerlink" title="Hexo写文章基本操作"></a>Hexo写文章基本操作</h1><h2 id="步骤1"><a href="#步骤1" class="headerlink" title="步骤1"></a>步骤1</h2><p>打开hexo的根目录，也就是里面有_config.yml, source, themes等等的那个，对于我个人我把他叫做myblog</p><h2 id="步骤2"><a href="#步骤2" class="headerlink" title="步骤2"></a>步骤2</h2><p>在该目录下打开git bash，执行该代码，可在浏览器打开<code>http://localhost:4000/</code>进行实时查看自己的网站。（注意：此时外网还不能访问本地的修改，只有提交之后才能访问。）</p><pre><code>hexo server</code></pre><h2 id="步骤3（此时还是在根目录下执行以下操作）"><a href="#步骤3（此时还是在根目录下执行以下操作）" class="headerlink" title="步骤3（此时还是在根目录下执行以下操作）"></a>步骤3（此时还是在根目录下执行以下操作）</h2><h3 id="新建发布文章（post-page）"><a href="#新建发布文章（post-page）" class="headerlink" title="新建发布文章（post page）"></a>新建发布文章（post page）</h3><p>执行以下命令后会自动在<code>\myblog\source\_posts</code>下新建一个<code>a.md</code>并且标题是“a”，此时刷新<code>http://localhost:4000/</code>可以看到本地已经更新出标题为a的这篇文章。</p><pre><code>hexo new a</code></pre><h3 id="新建草稿（draft-page）"><a href="#新建草稿（draft-page）" class="headerlink" title="新建草稿（draft page）"></a>新建草稿（draft page）</h3><p>执行以下命令后会自动在<code>\myblog\source\_drafts</code>下新建一个<code>b.md</code>并且标题是“b”，此时刷新<code>http://localhost:4000/</code>本地并没有更新出这篇文章。</p><pre><code>hexo new draft b</code></pre><h3 id="发布草稿"><a href="#发布草稿" class="headerlink" title="发布草稿"></a>发布草稿</h3><p>草稿可以通过命令变成发布文章，仍然是需要在根目录执行以下命令</p><pre><code>hexo publish b</code></pre><p>这个时候你会发现_drafts里的b.md不见了，跑到了_posts里面,也就说明你的草稿发布成功了。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第02章 MySQL的数据目录</title>
      <link href="/2023/07/15/%E7%AC%AC02%E7%AB%A0%20MySQL%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95/"/>
      <url>/2023/07/15/%E7%AC%AC02%E7%AB%A0%20MySQL%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h3 id="第02章-MySQL的数据目录"><a href="#第02章-MySQL的数据目录" class="headerlink" title="第02章 MySQL的数据目录"></a>第02章 MySQL的数据目录</h3><h4 id="1-MySQL8的主要目录结构"><a href="#1-MySQL8的主要目录结构" class="headerlink" title="1. MySQL8的主要目录结构"></a><strong>1. MySQL8的主要目录结构</strong></h4><pre><code class="shell">find / -name mysql</code></pre><h5 id="1-1-数据库文件的存放路径"><a href="#1-1-数据库文件的存放路径" class="headerlink" title="1.1 数据库文件的存放路径"></a><strong>1.1</strong> <strong>数据库文件的存放路径</strong></h5><pre><code class="mysql">show variables like &#39;datadir&#39;; # /var/lib/mysql/</code></pre><h5 id="1-2-相关命令目录"><a href="#1-2-相关命令目录" class="headerlink" title="1.2 相关命令目录"></a><strong>1.2</strong> <strong>相关命令目录</strong></h5><p><strong>相关命令目录：&#x2F;usr&#x2F;bin 和&#x2F;usr&#x2F;sbin。</strong></p><h5 id="1-3-配置文件目录"><a href="#1-3-配置文件目录" class="headerlink" title="1.3 配置文件目录"></a><strong>1.3</strong> <strong>配置文件目录</strong></h5><p><strong>配置文件目录：&#x2F;usr&#x2F;share&#x2F;mysql-8.0（命令及配置文件），&#x2F;etc&#x2F;mysql（如my.cnf）</strong></p><h4 id="2-数据库和文件系统的关系"><a href="#2-数据库和文件系统的关系" class="headerlink" title="2. 数据库和文件系统的关系"></a><strong>2.</strong> <strong>数据库和文件系统的关系</strong></h4><h5 id="2-1-表在文件系统中的表示"><a href="#2-1-表在文件系统中的表示" class="headerlink" title="2.1 表在文件系统中的表示"></a><strong>2.1</strong> <strong>表在文件系统中的表示</strong></h5><h6 id="2-3-1-InnoDB存储引擎模式"><a href="#2-3-1-InnoDB存储引擎模式" class="headerlink" title="2.3.1 InnoDB存储引擎模式"></a><strong>2.3.1 InnoDB存储引擎模式</strong></h6><p><strong>1.</strong> <strong>表结构</strong></p><p>为了保存表结构，<code>InnoDB</code>在<code>数据目录</code>下对应的数据库子目录下创建了一个专门用于<code>描述表结构的文件</code></p><pre><code>表名.frm</code></pre><p><strong>2.</strong> <strong>表中数据和索引</strong></p><p><strong>① 系统表空间（system tablespace）</strong></p><p>默认情况下，InnoDB会在数据目录下创建一个名为<code>ibdata1</code>、大小为<code>12M</code>的<code>自拓展</code>文件，这个文件就是对应的<code>系统表空间</code>在文件系统上的表示。</p><p><strong>② 独立表空间(file-per-table tablespace)</strong> </p><p>在MySQL5.6.6以及之后的版本中，InnoDB并不会默认的把各个表的数据存储到系统表空间中，而是为<code>每一个表建立一个独立表空间</code>，也就是说我们创建了多少个表，就有多少个独立表空间。使用<code>独立表空间</code>来存储表数据的话，会在该表所属数据库对应的子目录下创建一个表示该独立表空间的文件，文件名和表名相同。</p><pre><code>表名.ibd</code></pre><blockquote><p>MySQL8.0中不再单独提供<code>表名.frm</code>，而是合并在<code>表名.ibd</code>文件中。</p></blockquote><p><strong>③ 系统表空间与独立表空间的设置</strong></p><p>我们可以自己指定使用<code>系统表空间</code>还是<code>独立表空间</code>来存储数据，这个功能由启动参数<code>innodb_file_per_table</code>控制</p><pre><code class="ini">[server] innodb_file_per_table=0 # 0：代表使用系统表空间； 1：代表使用独立表空间</code></pre><p><strong>④ 其他类型的表空间</strong></p><p>随着MySQL的发展，除了上述两种老牌表空间之外，现在还新提出了一些不同类型的表空间，比如通用表空间（general tablespace）、临时表空间（temporary tablespace）等。</p><h6 id="2-3-2-MyISAM存储引擎模式"><a href="#2-3-2-MyISAM存储引擎模式" class="headerlink" title="2.3.2 MyISAM存储引擎模式"></a><strong>2.3.2 MyISAM存储引擎模式</strong></h6><p><strong>1.</strong> <strong>表结构</strong></p><p>在存储表结构方面， MyISAM 和 InnoDB 一样，也是在<code>数据目录</code>下对应的数据库子目录下创建了一个专门用于描述表结构的文件</p><pre><code>表名.frm</code></pre><p><strong>2.</strong> <strong>表中数据和索引</strong></p><p>在MyISAM中的索引全部都是<code>二级索引</code>，该存储引擎的<code>数据和索引是分开存放</code>的。所以在文件系统中也是使用不同的文件来存储数据文件和索引文件，同时表数据都存放在对应的数据库子目录下。</p><pre><code>test.frm 存储表结构 #MySQL8.0 改为了 b.xxx.sditest.MYD 存储数据 (MYData) test.MYI 存储索引 (MYIndex</code></pre><h3 id><a href="#" class="headerlink" title></a></h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第03章 用户与权限管理</title>
      <link href="/2023/07/15/%E7%AC%AC03%E7%AB%A0%20%E7%94%A8%E6%88%B7%E4%B8%8E%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"/>
      <url>/2023/07/15/%E7%AC%AC03%E7%AB%A0%20%E7%94%A8%E6%88%B7%E4%B8%8E%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="第03章-用户与权限管理"><a href="#第03章-用户与权限管理" class="headerlink" title="第03章 用户与权限管理"></a>第03章 用户与权限管理</h3><h4 id="1-用户管理"><a href="#1-用户管理" class="headerlink" title="1. 用户管理"></a><strong>1.</strong> <strong>用户管理</strong></h4><h5 id="1-1-登录MySQL服务器"><a href="#1-1-登录MySQL服务器" class="headerlink" title="1.1 登录MySQL服务器"></a><strong>1.1</strong> <strong>登录MySQL服务器</strong></h5><p>启动MySQL服务后，可以通过mysql命令来登录MySQL服务器，命令如下：</p><pre><code class="mysql">mysql –h hostname|hostIP –P port –u username –p DatabaseName –e &quot;SQL语句&quot;</code></pre><ul><li><code>-h参数</code>后面接主机名或者主机IP，hostname为主机，hostIP为主机IP。 </li><li><code>-P参数</code>后面接MySQL服务的端口，通过该参数连接到指定的端口。MySQL服务的默认端口是3306，不使用该参数时自动连接到3306端口，port为连接的端口号。</li><li><code>-u参数</code>后面接用户名，username为用户名。</li><li><code>-p参数</code>会提示输入密码。</li><li><code>DatabaseName参数</code>指明登录到哪一个数据库中。如果没有该参数，就会直接登录到MySQL数据库中，然后可以使用USE命令来选择数据库。</li><li><code>-e参数</code>后面可以直接加SQL语句。登录MySQL服务器以后即可执行这个SQL语句，然后退出MySQL服务器。</li></ul><pre><code class="mysql">mysql -uroot -p -hlocalhost -P3306 mysql -e &quot;select host,user from user&quot;</code></pre><h5 id="1-2-创建用户"><a href="#1-2-创建用户" class="headerlink" title="1.2 创建用户"></a><strong>1.2</strong> <strong>创建用户</strong></h5><pre><code class="mysql">CREATE USER 用户名 [IDENTIFIED BY &#39;密码&#39;][,用户名 [IDENTIFIED BY &#39;密码&#39;]];</code></pre><p>举例：</p><pre><code class="mysql">CREATE USER zhang3 IDENTIFIED BY &#39;123123&#39;; # 默认host是 %CREATE USER &#39;kangshifu&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;123456&#39;;</code></pre><h5 id="1-3-修改用户"><a href="#1-3-修改用户" class="headerlink" title="1.3 修改用户"></a><strong>1.3</strong> <strong>修改用户</strong></h5><pre><code class="mysql">UPDATE mysql.user SET USER=&#39;li4&#39; WHERE USER=&#39;wang5&#39;; FLUSH PRIVILEGES;</code></pre><h5 id="1-4-删除用户"><a href="#1-4-删除用户" class="headerlink" title="1.4 删除用户"></a><strong>1.4</strong> <strong>删除用户</strong></h5><p><strong>方式1：使用DROP方式删除（推荐）</strong></p><pre><code class="mysql">DROP USER user[,user]…;</code></pre><p>举例：</p><pre><code class="mysql">DROP USER li4 ; # 默认删除host为%的用户DROP USER &#39;kangshifu&#39;@&#39;localhost&#39;;</code></pre><p><strong>方式2：使用DELETE方式删除（不推荐，有残留信息）</strong></p><pre><code class="mysql">DELETE FROM mysql.user WHERE Host=’hostname’ AND User=’username’;FLUSH PRIVILEGES;</code></pre><h5 id="1-5-设置当前用户密码"><a href="#1-5-设置当前用户密码" class="headerlink" title="1.5 设置当前用户密码"></a><strong>1.5</strong> <strong>设置当前用户密码</strong></h5><p><strong>1.</strong> <strong>使用ALTER USER命令来修改当前用户密码</strong></p><pre><code class="mysql">ALTER USER USER() IDENTIFIED BY &#39;new_password&#39;;</code></pre><p><strong>2.</strong> <strong>使用SET语句来修改当前用户密码</strong></p><pre><code class="mysql">SET PASSWORD=&#39;new_password&#39;;</code></pre><h5 id="1-6-修改其它用户密码"><a href="#1-6-修改其它用户密码" class="headerlink" title="1.6 修改其它用户密码"></a><strong>1.6</strong> <strong>修改其它用户密码</strong></h5><p><strong>1.</strong> <strong>使用ALTER语句来修改普通用户的密码</strong></p><pre><code class="mysql">ALTER USER user [IDENTIFIED BY &#39;新密码&#39;] [,user[IDENTIFIED BY &#39;新密码&#39;]]…;</code></pre><p><strong>2.</strong> <strong>使用SET命令来修改普通用户的密码</strong></p><pre><code class="mysql">SET PASSWORD FOR &#39;username&#39;@&#39;hostname&#39;=&#39;new_password&#39;;</code></pre><h4 id="2-权限管理"><a href="#2-权限管理" class="headerlink" title="2. 权限管理"></a><strong>2.</strong> <strong>权限管理</strong></h4><h5 id="2-1-权限列表"><a href="#2-1-权限列表" class="headerlink" title="2.1 权限列表"></a><strong>2.1</strong> <strong>权限列表</strong></h5><pre><code class="mysql">show privileges;</code></pre><ul><li><code>CREATE和DROP权限</code>，可以创建新的数据库和表，或删除（移掉）已有的数据库和表。如果将MySQL数据库中的DROP权限授予某用户，用户就可以删除MySQL访问权限保存的数据库。</li><li><code>SELECT、INSERT、UPDATE和DELETE权限</code>允许在一个数据库现有的表上实施操作。</li><li><code>SELECT权限</code>只有在它们真正从一个表中检索行时才被用到。</li><li><code>INDEX权限</code>允许创建或删除索引，INDEX适用于已有的表。如果具有某个表的CREATE权限，就可以在CREATE TABLE语句中包括索引定义。</li><li><code>ALTER权限</code>可以使用ALTER TABLE来更改表的结构和重新命名表。</li><li><code>CREATE ROUTINE权限</code>用来创建保存的程序（函数和程序），<code>ALTER ROUTINE权限</code>用来更改和删除保存的程序，<code>EXECUTE权限</code>用来执行保存的程序。</li><li><code>GRANT权限</code>允许授权给其他用户，可用于数据库、表和保存的程序。</li><li><code>FILE权限</code>使用户可以使用LOAD DATA INFILE和SELECT … INTO OUTFILE语句读或写服务器上的文件，任何被授予FILE权限的用户都能读或写MySQL服务器上的任何文件（说明用户可以读任何数据库目录下的文件，因为服务器可以访问这些文件）。</li></ul><h5 id="2-2-授予权限的原则"><a href="#2-2-授予权限的原则" class="headerlink" title="2.2 授予权限的原则"></a><strong>2.2</strong> <strong>授予权限的原则</strong></h5><p>权限控制主要是出于安全因素，因此需要遵循以下几个<code>经验原则</code>：</p><p>1、只授予能<code>满足需要的最小权限</code>，防止用户干坏事。比如用户只是需要查询，那就只给select权限就可以了，不要给用户赋予update、insert或者delete权限。</p><p>2、创建用户的时候<code>限制用户的登录主机</code>，一般是限制成指定IP或者内网IP段。</p><p>3、为每个用户<code>设置满足密码复杂度的密码</code>。 </p><p>4、<code>定期清理不需要的用户</code>，回收权限或者删除用户。</p><h5 id="2-3-授予权限"><a href="#2-3-授予权限" class="headerlink" title="2.3 授予权限"></a><strong>2.3</strong> <strong>授予权限</strong></h5><pre><code class="mysql">GRANT 权限1,权限2,…权限n ON 数据库名称.表名称 TO 用户名@用户地址 [IDENTIFIED BY ‘密码口令’];</code></pre><ul><li>该权限如果发现没有该用户，则会直接新建一个用户。</li><li>给li4用户用本地命令行方式，授予atguigudb这个库下的所有表的插删改查的权限。</li></ul><pre><code class="mysql">GRANT SELECT,INSERT,DELETE,UPDATE ON atguigudb.* TO li4@localhost;</code></pre><ul><li>授予通过网络方式登录的joe用户 ，对所有库所有表的全部权限，密码设为123。注意这里唯独不包括grant的权限</li></ul><pre><code class="mysql">GRANT ALL PRIVILEGES ON *.* TO joe@&#39;%&#39; IDENTIFIED BY &#39;123&#39;;</code></pre><h5 id="2-4-查看权限"><a href="#2-4-查看权限" class="headerlink" title="2.4 查看权限"></a><strong>2.4</strong> <strong>查看权限</strong></h5><ul><li>查看当前用户权限</li></ul><pre><code class="mysql">SHOW GRANTS; # 或 SHOW GRANTS FOR CURRENT_USER; # 或 SHOW GRANTS FOR CURRENT_USER();</code></pre><ul><li>查看某用户的全局权限</li></ul><pre><code class="mysql">SHOW GRANTS FOR &#39;user&#39;@&#39;主机地址&#39;;</code></pre><h5 id="2-5-收回权限"><a href="#2-5-收回权限" class="headerlink" title="2.5 收回权限"></a><strong>2.5</strong> <strong>收回权限</strong></h5><p><strong>注意：在将用户账户从user表删除之前，应该收回相应用户的所有权限。</strong></p><ul><li>收回权限命令</li></ul><pre><code class="mysql">REVOKE 权限1,权限2,…权限n ON 数据库名称.表名称 FROM 用户名@用户地址;</code></pre><ul><li>举例</li></ul><pre><code class="mysql">#收回全库全表的所有权限 REVOKE ALL PRIVILEGES ON *.* FROM joe@&#39;%&#39;; #收回mysql库下的所有表的插删改查权限 REVOKE SELECT,INSERT,UPDATE,DELETE ON mysql.* FROM joe@localhost;</code></pre><ul><li>注意：<code>须用户重新登录后才能生效</code></li></ul><h4 id="3-角色管理"><a href="#3-角色管理" class="headerlink" title="3. 角色管理"></a><strong>3.</strong> <strong>角色管理</strong></h4><h5 id="3-1-创建角色"><a href="#3-1-创建角色" class="headerlink" title="3.1 创建角色"></a><strong>3.1</strong> <strong>创建角色</strong></h5><pre><code class="mysql">CREATE ROLE &#39;role_name&#39;[@&#39;host_name&#39;] [,&#39;role_name&#39;[@&#39;host_name&#39;]]...</code></pre><p>角色名称的命名规则和用户名类似。如果<code>host_name省略，默认为%</code>，<code>role_name不可省略</code>，不可为空。</p><h5 id="3-2-给角色赋予权限"><a href="#3-2-给角色赋予权限" class="headerlink" title="3.2 给角色赋予权限"></a><strong>3.2</strong> <strong>给角色赋予权限</strong></h5><pre><code class="mysql">GRANT privileges ON table_name TO &#39;role_name&#39;[@&#39;host_name&#39;];</code></pre><p>上述语句中privileges代表权限的名称，多个权限以逗号隔开。可使用SHOW语句查询权限名称</p><pre><code class="mysql">SHOW PRIVILEGES\G</code></pre><h5 id="3-3-查看角色的权限"><a href="#3-3-查看角色的权限" class="headerlink" title="3.3 查看角色的权限"></a><strong>3.3</strong> <strong>查看角色的权限</strong></h5><pre><code class="mysql">SHOW GRANTS FOR &#39;role_name&#39;;</code></pre><p>只要你创建了一个角色，系统就会自动给你一个“<code>USAGE</code>”权限，意思是<code>连接登录数据库的权限</code>。</p><h5 id="3-4-回收角色的权限"><a href="#3-4-回收角色的权限" class="headerlink" title="3.4 回收角色的权限"></a><strong>3.4</strong> <strong>回收角色的权限</strong></h5><pre><code class="mysql">REVOKE privileges ON tablename FROM &#39;rolename&#39;;</code></pre><h5 id="3-5-删除角色"><a href="#3-5-删除角色" class="headerlink" title="3.5 删除角色"></a><strong>3.5</strong> <strong>删除角色</strong></h5><pre><code class="mysql">DROP ROLE role [,role2]...</code></pre><p>注意，<code>如果你删除了角色，那么用户也就失去了通过这个角色所获得的所有权限</code>。</p><h5 id="3-6-给用户赋予角色"><a href="#3-6-给用户赋予角色" class="headerlink" title="3.6 给用户赋予角色"></a><strong>3.6</strong> <strong>给用户赋予角色</strong></h5><p>角色创建并授权后，要赋给用户并处于<code>激活状态</code>才能发挥作用。</p><pre><code class="mysql">GRANT role [,role2,...] TO user [,user2,...];</code></pre><p>查询当前已激活的角色</p><pre><code class="mysql">SELECT CURRENT_ROLE();</code></pre><h5 id="3-7-激活角色"><a href="#3-7-激活角色" class="headerlink" title="3.7 激活角色"></a><strong>3.7</strong> <strong>激活角色</strong></h5><p><strong>方式1：使用set default role 命令激活角色</strong></p><pre><code class="mysql">SET DEFAULT ROLE ALL TO &#39;kangshifu&#39;@&#39;localhost&#39;;</code></pre><p><strong>方式2：将activate_all_roles_on_login设置为ON</strong></p><pre><code class="mysql">SET GLOBAL activate_all_roles_on_login=ON;</code></pre><p>这条 SQL 语句的意思是，对<code>所有角色永久激活</code>。</p><h5 id="3-8-撤销用户的角色"><a href="#3-8-撤销用户的角色" class="headerlink" title="3.8 撤销用户的角色"></a><strong>3.8</strong> <strong>撤销用户的角色</strong></h5><pre><code class="mysql">REVOKE role FROM user;</code></pre><h5 id="3-9-设置强制角色-mandatory-role"><a href="#3-9-设置强制角色-mandatory-role" class="headerlink" title="3.9 设置强制角色(mandatory role)"></a><strong>3.9</strong> <strong>设置强制角色(mandatory role)</strong></h5><p>方式1：服务启动前设置</p><pre><code class="ini">[mysqld] mandatory_roles=&#39;role1,role2@localhost,r3@%.atguigu.com&#39;</code></pre><p>方式2：运行时设置</p><pre><code class="mysql">SET PERSIST mandatory_roles = &#39;role1,role2@localhost,r3@%.example.com&#39;; #系统重启后仍然有效SET GLOBAL mandatory_roles = &#39;role1,role2@localhost,r3@%.example.com&#39;; #系统重启后失效</code></pre><h3 id><a href="#" class="headerlink" title></a></h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第04章 逻辑架构</title>
      <link href="/2023/07/15/%E7%AC%AC04%E7%AB%A0%20%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/"/>
      <url>/2023/07/15/%E7%AC%AC04%E7%AB%A0%20%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h3 id="第04章-逻辑架构"><a href="#第04章-逻辑架构" class="headerlink" title="第04章 逻辑架构"></a>第04章 逻辑架构</h3><h4 id="1-逻辑架构剖析"><a href="#1-逻辑架构剖析" class="headerlink" title="1. 逻辑架构剖析"></a><strong>1.</strong> <strong>逻辑架构剖析</strong></h4><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203291130782.png" alt="MySQL服务器端的逻辑架构说明"></p><h5 id="1-1-第1层：连接层"><a href="#1-1-第1层：连接层" class="headerlink" title="1.1 第1层：连接层"></a><strong>1.1</strong> <strong>第1层：连接层</strong></h5><p>系统（客户端）访问<code>MySQL</code>服务器前，做的第一件事就是建立<code>TCP</code>连接。</p><p>经过三次握手建立连接成功后，<code>MySQL</code>服务器对<code>TCP</code>传输过来的账号密码做身份认证、权限获取。</p><ul><li><strong>用户名或密码不对，会收到一个Access denied for user错误，客户端程序结束执行</strong></li><li><strong>用户名密码认证通过，会从权限表查出账号拥有的权限与连接关联，之后的权限判断逻辑，都将依赖于此时读到的权限</strong></li></ul><p><code>TCP</code>连接收到请求后，必须要分配给一个线程专门与这个客户端的交互。所以还会有个线程池，去走后面的流程。每一个连接从线程池中获取线程，省去了创建和销毁线程的开销。</p><h5 id="1-2-第2层：服务层"><a href="#1-2-第2层：服务层" class="headerlink" title="1.2 第2层：服务层"></a><strong>1.2</strong> <strong>第2层：服务层</strong></h5><ul><li><p><strong>SQL Interface: SQL接口</strong></p><ul><li>接收用户的SQL命令，并且返回用户需要查询的结果。比如SELECT … FROM就是调用SQL Interface </li><li>MySQL支持DML（数据操作语言）、DDL（数据定义语言）、存储过程、视图、触发器、自定义函数等多种SQL语言接口</li></ul></li><li><p><strong>Parser:</strong> <strong>解析器</strong></p><ul><li>在解析器中对 SQL 语句进行语法分析、语义分析。将SQL语句分解成数据结构，并将这个结构传递到后续步骤，以后SQL语句的传递和处理就是基于这个结构的。如果在分解构成中遇到错误，那么就说明这个SQL语句是不合理的。</li><li>在SQL命令传递到解析器的时候会被解析器验证和解析，并为其创建<code>语法树</code>，并根据数据字典丰富查询语法树，会<code>验证该客户端是否具有执行该查询的权限</code>。创建好语法树后，MySQL还会对SQL查询进行语法上的优化，进行查询重写。</li></ul></li><li><p><strong>Optimizer:</strong> <strong>查询优化器</strong></p><ul><li>SQL语句在语法解析之后、查询之前会使用查询优化器确定 SQL 语句的执行路径，生成一个<code>执行计划</code>。</li><li>这个执行计划表明应该<code>使用哪些索引</code>进行查询（全表检索还是使用索引检索），表之间的连接顺序如何，最后会按照执行计划中的步骤调用存储引擎提供的方法来真正的执行查询，并将查询结果返回给用户。</li><li>它使用“<code>选取-投影-连接</code>”策略进行查询。例如：</li></ul><pre><code class="mysql">SELECT id,name FROM student WHERE gender = &#39;女&#39;;</code></pre><p>这个SELECT查询先根据WHERE语句进行<code>选取</code>，而不是将表全部查询出来以后再进行gender过滤。 这个SELECT查询先根据id和name进行属性<code>投影</code>，而不是将属性全部取出以后再进行过滤，将这两个查询条件<code>连接</code>起来生成最终查询结果。</p></li><li><p><strong>Caches &amp; Buffers： 查询缓存组件</strong></p><ul><li>MySQL内部维持着一些Cache和Buffer，比如Query Cache用来缓存一条SELECT语句的执行结果，如果能够在其中找到对应的查询结果，那么就不必再进行查询解析、优化和执行的整个过程了，直接将结果反馈给客户端。</li><li>这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等 。</li><li>这个查询缓存可以在<code>不同客户端之间共享</code>。 </li><li>从MySQL 5.7.20开始，不推荐使用查询缓存，并在<code>MySQL 8.0中删除</code>。</li></ul></li></ul><h5 id="1-3-第3层：引擎层"><a href="#1-3-第3层：引擎层" class="headerlink" title="1.3 第3层：引擎层"></a><strong>1.3</strong> <strong>第3层：引擎层</strong></h5><p>插件式存储引擎层（ Storage Engines），<strong>真正的负责了MySQL中数据的存储和提取，对物理服务器级别维护的底层数据执行操作</strong>，服务层通过API与存储引擎进行通信。</p><h5 id="1-4-小结"><a href="#1-4-小结" class="headerlink" title="1.4 小结"></a><strong>1.4</strong> <strong>小结</strong></h5><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203291131321.png" alt="image-20220329113126234"></p><p>简化为三层结构：</p><ol><li><p>连接层：客户端和服务器端建立连接，客户端发送 SQL 至服务器端；</p></li><li><p>SQL 层（服务层）：对 SQL 语句进行查询处理；与数据库文件的存储方式无关；</p></li><li><p>存储引擎层：与数据库文件打交道，负责数据的存储和读取。</p></li></ol><h4 id="2-SQL执行流程"><a href="#2-SQL执行流程" class="headerlink" title="2. SQL执行流程"></a><strong>2. SQL执行流程</strong></h4><h5 id="2-1-MySQL-中的-SQL执行流程"><a href="#2-1-MySQL-中的-SQL执行流程" class="headerlink" title="2.1 MySQL 中的 SQL执行流程"></a><strong>2.1 MySQL</strong> <strong>中的</strong> <strong>SQL执行流程</strong></h5><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203291133116.png" alt="image-20220329113337008"></p><p><strong>MySQL的查询流程：</strong></p><p><strong>1.</strong> <strong>查询缓存</strong>：Server 如果在查询缓存中发现了这条 SQL 语句，就会直接将结果返回给客户端；如果没有，就进入到解析器阶段。需要说明的是，因为查询缓存往往效率不高，所以在 MySQL8.0 之后就抛弃了这个功能。</p><p>查询缓存是提前把查询结果缓存起来，这样下次不需要执行就可以直接拿到结果。需要说明的是，在MySQL 中的查询缓存，不是缓存查询计划，而是查询对应的结果。这就意味着查询匹配的<code>鲁棒性大大降低</code>，只有<code>相同的查询操作才会命中查询缓存</code>。两个查询请求在任何字符上的不同（例如：空格、注释、大小写），都会导致缓存不会命中。因此 MySQL 的 查询缓存命中率不高 。</p><p>同时，如果查询请求中包含某些系统函数、用户自定义变量和函数、一些系统表，如 mysql、 information_schema、 performance_schema 数据库中的表，那这个请求就不会被缓存。</p><p>此外，既然是缓存，那就有它<code>缓存失效的时候</code>。MySQL的缓存系统会监测涉及到的每张表，只要该表的结构或者数据被修改，如对该表使用了<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>、<code>TRUNCATE TABLE</code>、<code>ALTER TABLE</code>、<code>DROP TABLE</code>或<code>DROP DATABASE</code>语句，那使用该表的所有高速缓存查询都将变为无效并从高速缓存中删除！对于<code>更新压力大的数据库</code>来说，查询缓存的命中率会非常低。</p><p><strong>2.</strong> <strong>解析器</strong>：在解析器中对 SQL 语句进行语法分析、语义分析。</p><p>分析器先做“<code>词法分析</code>”。你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是什么，代表什么。 MySQL 从你输入的”select”这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名 T”，把字符串“ID”识别成“列 ID”。</p><p>接着，要做“<code>语法分析</code>”。根据词法分析的结果，语法分析器（比如：Bison）会根据语法规则，判断你输入的这个 SQL 语句是否<code>满足 MySQL 语法</code>。如果SQL语句正确，则会生成一个语法树。</p><p><strong>3.</strong> <strong>优化器</strong>：在优化器中会确定 SQL 语句的执行路径，比如是根据<code>全表检索</code>，还是根据<code>索引检索</code>等。在查询优化器中，可以分为<code>逻辑查询</code>优化阶段和<code>物理查询</code>优化阶段。</p><p><strong>4.</strong> <strong>执行器</strong>：在执行之前需要判断该用户是否<code>具备权限</code>。如果没有，就会返回权限错误。如果具备权限，就执行 SQL查询并返回结果。在 MySQL8.0 以下的版本，如果设置了查询缓存，这时会将查询结果进行缓存。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203291145074.png" alt="image-20220329114541991"></p><p>SQL 语句在 MySQL 中的流程是： SQL语句→查询缓存→解析器→优化器→执行器 。</p><h4 id="3-数据库缓冲池-buffer-pool"><a href="#3-数据库缓冲池-buffer-pool" class="headerlink" title="3. 数据库缓冲池(buffer pool)"></a><strong>3.</strong> <strong>数据库缓冲池(buffer pool)</strong></h4><p><code>InnoDB</code>存储引擎是以页为单位来管理存储空间的，我们进行的增删改查操作其实本质上都是在访问页面（包括读页面、写页面、创建新页面等操作）。而磁盘 I&#x2F;O 需要消耗的时间很多，而在内存中进行操作，效率则会高很多，为了能让数据表或者索引中的数据随时被我们所用，DBMS 会申请<code>占用内存来作为数据缓冲池</code>，在真正访问页面之前，需要把在磁盘上的页缓存到内存中的<code>Buffer Pool</code>之后才可以访问。</p><p>这样做的好处是可以让磁盘活动最小化，从而<code>减少与磁盘直接进行 I/O 的时间</code>。要知道，这种策略对提升 SQL 语句的查询性能来说至关重要。如果索引的数据在缓冲池里，那么访问的成本就会降低很多。</p><h5 id="3-1-缓冲池-vs-查询缓存"><a href="#3-1-缓冲池-vs-查询缓存" class="headerlink" title="3.1 缓冲池 vs 查询缓存"></a><strong>3.1</strong> <strong>缓冲池</strong> <strong>vs</strong> <strong>查询缓存</strong></h5><p><strong>1.</strong> <strong>缓冲池（Buffer Pool）</strong></p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203291155004.png" alt="image-20220329115517901"></p><p>从图中，你能看到 InnoDB 缓冲池包括了数据页、索引页、插入缓冲、锁信息、自适应 Hash 和数据字典信息等。</p><p><strong>缓存原则：</strong></p><p>“<code>位置 * 频次</code>”这个原则，可以帮我们对 I&#x2F;O 访问效率进行优化。</p><p>首先，位置决定效率，提供缓冲池就是为了在内存中可以直接访问数据。</p><p>其次，频次决定优先级顺序。因为缓冲池的大小是有限的，比如磁盘有 200G，但是内存只有 16G，缓冲池大小只有 1G，就无法将所有数据都加载到缓冲池里，这时就涉及到优先级顺序，会<code>优先对使用频次高的热数据进行加载</code>。</p><p><strong>2.</strong> <strong>查询缓存</strong></p><p>查询缓存是提前把<code>查询结果缓存</code>起来，这样下次不需要执行就可以直接拿到结果。需要说明的是，在MySQL 中的查询缓存，不是缓存查询计划，而是查询对应的结果。因为命中条件苛刻，而且只要数据表发生变化，查询缓存就会失效，因此命中率低。</p><h5 id="3-2-缓冲池如何读取数据"><a href="#3-2-缓冲池如何读取数据" class="headerlink" title="3.2 缓冲池如何读取数据"></a><strong>3.2</strong> <strong>缓冲池如何读取数据</strong></h5><p>缓冲池管理器会尽量将经常使用的数据保存起来，在数据库进行页面读操作的时候，首先会判断该页面是否在缓冲池中，如果存在就直接读取，如果不存在，就会通过内存或磁盘将页面存放到缓冲池中再进行读取。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203291159111.png" alt="image-20220329115958009"></p><h5 id="3-3-查看-x2F-设置缓冲池的大小"><a href="#3-3-查看-x2F-设置缓冲池的大小" class="headerlink" title="3.3 查看&#x2F;设置缓冲池的大小"></a><strong>3.3</strong> <strong>查看&#x2F;设置缓冲池的大小</strong></h5><p>查看缓冲池的大小</p><pre><code class="mysql">show variables like &#39;innodb_buffer_pool_size&#39;;</code></pre><p>设置缓冲池的大小</p><pre><code class="mysql">set global innodb_buffer_pool_size = 268435456;</code></pre><p>或者</p><pre><code class="ini">[server] innodb_buffer_pool_size = 268435456</code></pre><h5 id="3-4-多个Buffer-Pool实例"><a href="#3-4-多个Buffer-Pool实例" class="headerlink" title="3.4 多个Buffer Pool实例"></a><strong>3.4</strong> <strong>多个Buffer Pool实例</strong></h5><pre><code class="ini">[server] innodb_buffer_pool_instances = 2</code></pre><p>何查看缓冲池的个数</p><pre><code class="mysql">show variables like &#39;innodb_buffer_pool_instances&#39;;</code></pre><p>每个<code>Buffer Pool</code>实例实际占内存空间</p><pre><code>innodb_buffer_pool_size/innodb_buffer_pool_instances</code></pre><h3 id><a href="#" class="headerlink" title></a></h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第05章 存储引擎</title>
      <link href="/2023/07/15/%E7%AC%AC05%E7%AB%A0%20%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
      <url>/2023/07/15/%E7%AC%AC05%E7%AB%A0%20%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<h3 id="第05章-存储引擎"><a href="#第05章-存储引擎" class="headerlink" title="第05章 存储引擎"></a>第05章 存储引擎</h3><h4 id="1-查看存储引擎"><a href="#1-查看存储引擎" class="headerlink" title="1. 查看存储引擎"></a><strong>1.</strong> <strong>查看存储引擎</strong></h4><pre><code class="mysql">show engines;# 或show engines\G</code></pre><h4 id="2-设置系统默认的存储引擎"><a href="#2-设置系统默认的存储引擎" class="headerlink" title="2. 设置系统默认的存储引擎"></a><strong>2.</strong> <strong>设置系统默认的存储引擎</strong></h4><ul><li>查看默认的存储引擎：</li></ul><pre><code class="mysql">show variables like &#39;%storage_engine%&#39;; #或SELECT @@default_storage_engine;</code></pre><ul><li>修改默认的存储引擎</li></ul><p>如果在创建表的语句中没有显式指定表的存储引擎的话，那就会默认使用<code>InnoDB</code>作为表的存储引擎。</p><pre><code class="mysql">SET DEFAULT_STORAGE_ENGINE=MyISAM;</code></pre><p>或者修改<code>my.cnf</code>文件：</p><pre><code class="ini">default-storage-engine=MyISAM </code></pre><pre><code class="shell"># 重启服务 systemctl restart mysqld.service</code></pre><h4 id="3-设置表的存储引擎"><a href="#3-设置表的存储引擎" class="headerlink" title="3. 设置表的存储引擎"></a><strong>3.</strong> <strong>设置表的存储引擎</strong></h4><p>存储引擎是负责对表中的数据进行提取和写入工作的，我们可以为<code>不同的表设置不同的存储引擎</code>，也就是说不同的表可以有不同的物理存储结构，不同的提取和写入方式。</p><h5 id="3-1-创建表时指定存储引擎"><a href="#3-1-创建表时指定存储引擎" class="headerlink" title="3.1 创建表时指定存储引擎"></a><strong>3.1</strong> <strong>创建表时指定存储引擎</strong></h5><pre><code class="mysql">CREATE TABLE 表名(    建表语句; ) ENGINE = 存储引擎名称;</code></pre><h5 id="3-2-修改表的存储引擎"><a href="#3-2-修改表的存储引擎" class="headerlink" title="3.2 修改表的存储引擎"></a><strong>3.2</strong> <strong>修改表的存储引擎</strong></h5><pre><code class="mysql">ALTER TABLE 表名 ENGINE = 存储引擎名称;</code></pre><h4 id="4-引擎介绍"><a href="#4-引擎介绍" class="headerlink" title="4. 引擎介绍"></a><strong>4.</strong> <strong>引擎介绍</strong></h4><h5 id="4-1-InnoDB-引擎：具备外键支持功能的事务存储引擎"><a href="#4-1-InnoDB-引擎：具备外键支持功能的事务存储引擎" class="headerlink" title="4.1 InnoDB 引擎：具备外键支持功能的事务存储引擎"></a><strong>4.1 InnoDB</strong> <strong>引擎：具备外键支持功能的事务存储引擎</strong></h5><ul><li>MySQL从3.23.34a开始就包含InnoDB存储引擎。<code>大于等于5.5之后，默认采用InnoDB引擎</code>。 </li><li>InnoDB是MySQL的<code>默认事务型引擎</code>，它被设计用来处理大量的短期(short-lived)事务。可以确保事务的完整提交(Commit)和回滚(Rollback)。</li><li>除了增加和查询外，还需要更新、删除操作，那么，应优先选择InnoDB存储引擎。</li><li><strong>除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑InnoDB引擎。</strong></li><li>数据文件结构：<ul><li>表名.frm 存储表结构（MySQL8.0时，合并在表名.ibd中）</li><li>表名.ibd 存储数据和索引</li></ul></li><li>InnoDB是<code>为处理巨大数据量的最大性能设计</code>。<ul><li>在以前的版本中，字典数据以元数据文件、非事务表等来存储。现在这些元数据文件被删除了。比如：<code>.frm</code>，<code>.par</code>，<code>.trn</code>，<code>.isl</code>，<code>.db.opt</code>等都在MySQL8.0中不存在了。</li></ul></li><li>对比MyISAM的存储引擎，<code>InnoDB写的处理效率差一些</code>，并且会占用更多的磁盘空间以保存数据和索引。</li><li>MyISAM只缓存索引，不缓存真实数据；InnoDB不仅缓存索引还要缓存真实数据，<code>对内存要求较高</code>，而且内存大小对性能有决定性的影响。</li></ul><h5 id="4-2-MyISAM-引擎：主要的非事务处理存储引擎"><a href="#4-2-MyISAM-引擎：主要的非事务处理存储引擎" class="headerlink" title="4.2 MyISAM 引擎：主要的非事务处理存储引擎"></a><strong>4.2 MyISAM</strong> <strong>引擎：主要的非事务处理存储引擎</strong></h5><ul><li>MyISAM提供了大量的特性，包括全文索引、压缩、空间函数(GIS)等，但MyISAM<code>不支持事务、行级锁、外键</code>，有一个毫无疑问的缺陷就是<code>崩溃后无法安全恢复</code>。 </li><li><code>5.5之前默认的存储引擎</code></li><li>优势是访问的<code>速度快</code>，对事务完整性没有要求或者以SELECT、INSERT为主的应用</li><li>针对数据统计有额外的常数存储。故而 count(*) 的查询效率很高</li><li>数据文件结构：<ul><li>表名.frm 存储表结构</li><li>表名.MYD 存储数据 (MYData)</li><li>表名.MYI 存储索引 (MYIndex)</li></ul></li><li>应用场景：只读应用或者以读为主的业务</li></ul><h5 id="4-3-Archive-引擎：用于数据存档"><a href="#4-3-Archive-引擎：用于数据存档" class="headerlink" title="4.3 Archive 引擎：用于数据存档"></a><strong>4.3 Archive</strong> <strong>引擎：用于数据存档</strong></h5><h5 id="4-4-Blackhole-引擎：丢弃写操作，读操作会返回空内容"><a href="#4-4-Blackhole-引擎：丢弃写操作，读操作会返回空内容" class="headerlink" title="4.4 Blackhole 引擎：丢弃写操作，读操作会返回空内容"></a><strong>4.4 Blackhole</strong> <strong>引擎：丢弃写操作，读操作会返回空内容</strong></h5><h5 id="4-5-CSV-引擎：存储数据时，以逗号分隔各个数据项"><a href="#4-5-CSV-引擎：存储数据时，以逗号分隔各个数据项" class="headerlink" title="4.5 CSV 引擎：存储数据时，以逗号分隔各个数据项"></a><strong>4.5 CSV</strong> <strong>引擎：存储数据时，以逗号分隔各个数据项</strong></h5><h5 id="4-6-Memory-引擎：置于内存的表"><a href="#4-6-Memory-引擎：置于内存的表" class="headerlink" title="4.6 Memory 引擎：置于内存的表"></a><strong>4.6 Memory</strong> <strong>引擎：置于内存的表</strong></h5><h5 id="4-7-Federated-引擎：访问远程表"><a href="#4-7-Federated-引擎：访问远程表" class="headerlink" title="4.7 Federated 引擎：访问远程表"></a><strong>4.7 Federated</strong> <strong>引擎：访问远程表</strong></h5><h5 id="4-8-Merge引擎：管理多个MyISAM表构成的表集合"><a href="#4-8-Merge引擎：管理多个MyISAM表构成的表集合" class="headerlink" title="4.8 Merge引擎：管理多个MyISAM表构成的表集合"></a><strong>4.8 Merge引擎：管理多个MyISAM表构成的表集合</strong></h5><h5 id="4-9-NDB引擎：MySQL集群专用存储引擎"><a href="#4-9-NDB引擎：MySQL集群专用存储引擎" class="headerlink" title="4.9 NDB引擎：MySQL集群专用存储引擎"></a><strong>4.9 NDB引擎：MySQL集群专用存储引擎</strong></h5><h4 id="5-MyISAM和InnoDB"><a href="#5-MyISAM和InnoDB" class="headerlink" title="5. MyISAM和InnoDB"></a><strong>5. MyISAM和InnoDB</strong></h4><table><thead><tr><th>对比项</th><th><strong>MyISAM</strong></th><th><strong>InnoDB</strong></th></tr></thead><tbody><tr><td>外键</td><td>不支持</td><td>支持</td></tr><tr><td>事务</td><td>不支持</td><td>支持</td></tr><tr><td>行表锁</td><td>表锁，即使操作一条记录也会锁住整个表，不适合高并发的操作</td><td>行锁，操作时只锁某一行，不对其它行有影响，适合高并发的操作</td></tr><tr><td>缓存</td><td>只缓存索引，不缓存真实数据</td><td>不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响</td></tr><tr><td>自带系统表使用</td><td>Y</td><td>N</td></tr><tr><td>关注点</td><td>性能：节省资源、消耗少、简单业务</td><td>事务：并发写、事务、更大资源</td></tr><tr><td>默认安装</td><td>Y</td><td>Y</td></tr><tr><td>默认使用</td><td>N</td><td>Y</td></tr></tbody></table><h3 id><a href="#" class="headerlink" title></a></h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第08章 索引的创建与设计原则</title>
      <link href="/2023/07/15/%E7%AC%AC08%E7%AB%A0%20%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
      <url>/2023/07/15/%E7%AC%AC08%E7%AB%A0%20%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h3 id="第08章-索引的创建与设计原则"><a href="#第08章-索引的创建与设计原则" class="headerlink" title="第08章 索引的创建与设计原则"></a>第08章 索引的创建与设计原则</h3><h4 id="1-索引的声明与使用"><a href="#1-索引的声明与使用" class="headerlink" title="1. 索引的声明与使用"></a><strong>1.</strong> <strong>索引的声明与使用</strong></h4><h5 id="1-1-索引的分类"><a href="#1-1-索引的分类" class="headerlink" title="1.1 索引的分类"></a><strong>1.1</strong> <strong>索引的分类</strong></h5><ul><li>从<code>功能逻辑</code>上说，索引主要有 4 种，分别是普通索引、唯一索引、主键索引、全文索引。</li><li>按照<code>物理实现方式</code>，索引可以分为 2 种：聚簇索引和非聚簇索引。</li><li>按照<code>作用字段个数</code>进行划分，分成单列索引和联合索引。</li></ul><h5 id="1-2-创建索引"><a href="#1-2-创建索引" class="headerlink" title="1.2 创建索引"></a><strong>1.2</strong> <strong>创建索引</strong></h5><pre><code class="mysql">CREATE TABLE table_name [col_name data_type] [UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY] [index_name] (col_name [length]) [ASC | DESC]</code></pre><ul><li><code>UNIQUE</code>、<code>FULLTEXT</code>和<code>SPATIAL</code>为可选参数，分别表示唯一索引、全文索引和空间索引；</li><li><code>INDEX</code>与<code>KEY</code>为同义词，两者的作用相同，用来指定创建索引；</li><li><code>index_name</code>指定索引的名称，为可选参数，如果不指定，那么MySQL默认col_name为索引名；</li><li><code>col_name</code>为需要创建索引的字段列，该列必须从数据表中定义的多个列中选择；</li><li><code>length</code>为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度；</li><li><code>ASC</code>或<code>DESC</code>指定升序或者降序的索引值存储。</li></ul><p><strong>1.</strong> <strong>创建普通索引</strong></p><pre><code class="mysql">CREATE TABLE book(     book_id INT ,     book_name VARCHAR(100),     authors VARCHAR(100),     info VARCHAR(100) ,     comment VARCHAR(100),     year_publication YEAR,     INDEX(year_publication) );</code></pre><p><strong>2.</strong> <strong>创建唯一索引</strong></p><pre><code class="mysql">CREATE TABLE test1(     id INT NOT NULL,     name varchar(30) NOT NULL,     UNIQUE INDEX uk_idx_id(id) );</code></pre><p><strong>3.</strong> <strong>主键索引</strong></p><pre><code class="mysql">CREATE TABLE student (     id INT(10) UNSIGNED AUTO_INCREMENT,     student_no VARCHAR(200),    student_name VARCHAR(200),     PRIMARY KEY(id) );</code></pre><pre><code class="mysql"># 删除主键索引ALTER TABLE student drop PRIMARY KEY ;</code></pre><p><strong>4.</strong> <strong>创建单列索引</strong></p><pre><code class="mysql">CREATE TABLE test2(     id INT NOT NULL,     name CHAR(50) NULL,     INDEX single_idx_name(name(20)) );</code></pre><p><strong>5.</strong> <strong>创建组合索引</strong></p><pre><code class="mysql">CREATE TABLE test3(     id INT(11) NOT NULL,     name CHAR(30) NOT NULL,     age INT(11) NOT NULL,     info VARCHAR(255),     INDEX multi_idx(id,name,age) );</code></pre><p><strong>6.</strong> <strong>创建全文索引</strong></p><pre><code class="mysql">CREATE TABLE `papers` (     id` int(10) unsigned NOT NULL AUTO_INCREMENT,     `title` varchar(200) DEFAULT NULL,     `content` text, PRIMARY KEY (`id`),     FULLTEXT KEY `title` (`title`,`content`) ) ENGINE=MyISAM DEFAULT CHARSET=utf8;</code></pre><pre><code class="mysql">SELECT * FROM papers WHERE MATCH(title,content) AGAINST (‘查询字符串’);</code></pre><p><strong>7.</strong> <strong>创建空间索引</strong></p><pre><code class="mysql">CREATE TABLE test5(     geo GEOMETRY NOT NULL,     SPATIAL INDEX spa_idx_geo(geo) ) ENGINE=MyISAM;</code></pre><p><strong>2.</strong> <strong>在已经存在的表上创建索引</strong></p><p><strong>1.</strong> <strong>使用ALTER TABLE语句创建索引</strong></p><pre><code class="mysql">ALTER TABLE table_name ADD [UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY] [index_name] (col_name[length],...) [ASC | DESC]</code></pre><p><strong>2.</strong> <strong>使用CREATE INDEX创建索引</strong></p><pre><code class="mysql">CREATE [UNIQUE | FULLTEXT | SPATIAL] INDEX index_name ON table_name (col_name[length],...) [ASC | DESC]</code></pre><h5 id="1-3-删除索引"><a href="#1-3-删除索引" class="headerlink" title="1.3 删除索引"></a><strong>1.3</strong> <strong>删除索引</strong></h5><p><strong>1.</strong> <strong>使用ALTER TABLE删除索引</strong></p><pre><code class="mysql">ALTER TABLE table_name DROP INDEX index_name;</code></pre><p><strong>2.</strong> <strong>使用DROP INDEX语句删除索引</strong></p><pre><code class="mysql">DROP INDEX index_name ON table_name;</code></pre><h4 id="2-MySQL8-0索引新特性"><a href="#2-MySQL8-0索引新特性" class="headerlink" title="2. MySQL8.0索引新特性"></a><strong>2. MySQL8.0索引新特性</strong></h4><h5 id="2-1-支持降序索引"><a href="#2-1-支持降序索引" class="headerlink" title="2.1 支持降序索引"></a><strong>2.1</strong> <strong>支持降序索引</strong></h5><pre><code class="mysql">CREATE TABLE ts1(a int,b int,index idx_a_b(a,b desc));</code></pre><h5 id="2-2-隐藏索引"><a href="#2-2-隐藏索引" class="headerlink" title="2.2 隐藏索引"></a><strong>2.2</strong> <strong>隐藏索引</strong></h5><p>从MySQL 8.x开始支持<code>隐藏索引（invisible indexes）</code>，只需要将待删除的索引设置为隐藏索引，使查询优化器不再使用这个索引（即使使用force index（强制使用索引），优化器也不会使用该索引），确认将索引设置为隐藏索引后系统不受任何响应，就可以彻底删除索引。<code>这种通过先将索引设置为隐藏索引，再删除索引的方式就是软删除</code>。</p><p><strong>1.</strong> <strong>创建表时直接创建</strong> </p><pre><code class="mysql">CREATE TABLE tablename(     propname1 type1[CONSTRAINT1],     propname2 type2[CONSTRAINT2],     ……    propnamen typen,     INDEX [indexname](propname1 [(length)]) INVISIBLE );</code></pre><p><strong>2.</strong> <strong>在已经存在的表上创建</strong></p><pre><code class="mysql">CREATE INDEX indexname ON tablename(propname[(length)]) INVISIBLE;</code></pre><p><strong>3.</strong> <strong>通过ALTER TABLE语句创建</strong></p><pre><code class="mysql">ALTER TABLE tablename ADD INDEX indexname (propname [(length)]) INVISIBLE;</code></pre><p><strong>4.</strong> <strong>切换索引可见状态</strong></p><pre><code class="mysql">ALTER TABLE tablename ALTER INDEX index_name INVISIBLE; #切换成隐藏索引 ALTER TABLE tablename ALTER INDEX index_name VISIBLE; #切换成非隐藏索引</code></pre><h4 id="3-索引的设计原则"><a href="#3-索引的设计原则" class="headerlink" title="3. 索引的设计原则"></a><strong>3.</strong> <strong>索引的设计原则</strong></h4><h5 id="3-1-哪些情况适合创建索引"><a href="#3-1-哪些情况适合创建索引" class="headerlink" title="3.1 哪些情况适合创建索引"></a><strong>3.1</strong> <strong>哪些情况适合创建索引</strong></h5><p><strong>1.</strong> <strong>字段的数值有唯一性的限制</strong></p><p>索引本身可以起到约束的作用，比如唯一索引、主键索引都可以起到唯一性约束的，因此在我们的数据表中，如果<code>某个字段是唯一的</code>，就可以直接<code>创建唯一性索引</code>，或者<code>主键索引</code>。这样可以更快速地通过该索引来确定某条记录。</p><blockquote><p>业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。（来源：Alibaba）</p><p>说明：不要以为唯一索引影响了insert速度，这个速度损耗可以忽略，但提高查找速度是明显的。</p></blockquote><p><strong>2.</strong> <strong>频繁作为</strong> <strong>WHERE</strong> <strong>查询条件的字段</strong></p><p>某个字段在SELECT语句的 WHERE 条件中经常被使用到，那么就需要给这个字段创建索引了。尤其是在数据量大的情况下，创建普通索引就可以大幅提升数据查询的效率。</p><p><strong>3.</strong> <strong>经常</strong> <strong>GROUP BY</strong> <strong>和</strong> <strong>ORDER BY</strong> <strong>的列</strong></p><p>索引就是让数据按照某种顺序进行存储或检索，因此当我们使用 GROUP BY 对数据进行分组查询，或者使用 ORDER BY 对数据进行排序的时候，就需要<code>对分组或者排序的字段进行索引</code>。如果待排序的列有多个，那么可以在这些列上建立<code>组合索引</code>。</p><p><strong>4. UPDATE、DELETE</strong> <strong>的</strong> <strong>WHERE</strong> <strong>条件列</strong></p><p>对数据按照某个条件进行查询后再进行 UPDATE 或 DELETE 的操作，如果对 WHERE 字段创建了索引，就能大幅提升效率。原理是因为我们需要先根据 WHERE 条件列检索出来这条记录，然后再对它进行更新或删除。<strong>如果进行更新的时候，更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护。</strong></p><p><strong>5.DISTINCT</strong> <strong>字段需要创建索引</strong></p><p>有时候我们需要对某个字段进行去重，使用 DISTINCT，那么对这个字段创建索引，也会提升查询效率。</p><p><strong>6.</strong> <strong>多表</strong> <strong>JOIN</strong> <strong>连接操作时，创建索引注意事项</strong></p><p>首先，<code>连接表的数量尽量不要超过 3 张</code>，因为每增加一张表就相当于增加了一次嵌套的循环，数量级增长会非常快，严重影响查询的效率。</p><p>其次，<code>对 WHERE 条件创建索引</code>，因为 WHERE 才是对数据条件的过滤。如果在数据量非常大的情况下，没有 WHERE 条件过滤是非常可怕的。</p><p>最后，<code>对用于连接的字段创建索引</code>，并且该字段在多张表中的<code>类型必须一致</code>。</p><p><strong>7.</strong> <strong>使用列的类型小的创建索引</strong> </p><p>我们这里所说的<code>类型大小</code>指的就是该类型表示的数据范围的大小。</p><ul><li>数据类型越小，在查询时进行的比较操作越快</li><li>数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以<code>放下更多的记录</code>，从而减少磁盘<code>I/O</code>带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。</li></ul><p>这个建议对于表的<code>主键来说更加适用</code>，因为不仅是聚簇索引中会存储主键值，其他所有的二级索引的节点处都会存储一份记录的主键值，如果主键使用更小的数据类型，也就意味着节省更多的存储空间和更高效的I&#x2F;O。</p><p><strong>8.</strong> <strong>使用字符串前缀创建索引</strong></p><p>区分度计算公式：</p><pre><code class="mysql">count(distinct left(列名, 索引长度))/count(*)</code></pre><p><strong>拓展：Alibaba《Java开发手册》</strong></p><p>【<code>强制</code>】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度。</p><p>说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会<code>高达 90% 以上</code>。</p><p><strong>9.</strong> <strong>区分度高(散列性高)的列适合作为索引</strong></p><p><code>列的基数</code>指的是某一列中不重复数据的个数，比方说某个列包含值<code>2,5,8,2,5,8,2,5,8</code>，虽然有<code>9</code>条记录，但该列的基数却是<code>3</code>。也就是说，<strong>在记录行数一定的情况下，列的基数越大，该列中的值越分散；列的基数越小，该列中的值越集中。</strong>这个列的基数指标非常重要，直接影响我们是否能有效的利用索引。最好为列的基数大的列建立索引，为基数太小的列建立索引效果可能不好。</p><p>可以使用公式<code>select count(distinct a)/count(*) from t1</code>计算区分度，越接近1越好，一般超过<code>33%</code>就算是比较高效的索引了。</p><p>拓展：联合索引把区分度高（散列性高）的列放在前面。</p><p><strong>10.</strong> <strong>使用最频繁的列放到联合索引的左侧</strong></p><p><strong>11.</strong> <strong>在多个字段都要创建索引的情况下，联合索引优于单值索引</strong></p><h5 id="3-2-限制索引的数目"><a href="#3-2-限制索引的数目" class="headerlink" title="3.2 限制索引的数目"></a><strong>3.2</strong> <strong>限制索引的数目</strong></h5><p>在实际工作中，我们也需要注意平衡，索引的数目不是越多越好。我们需要限制每张表上的索引数量，建议单张表索引数量<code>不超过6个</code>。原因：</p><ul><li>每个索引都需要占用<code>磁盘空间</code>，索引越多，需要的磁盘空间就越大。</li><li>索引会影响<code>INSERT、DELETE、UPDATE等语句的性能</code>，因为表中的数据更改的同时，索引也会进行调整和更新，会造成负担。</li><li>优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的<code>索引来进行评估</code>，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，会增加MySQL优化器生成执行计划时间，降低查询性能。</li></ul><h5 id="3-3-哪些情况不适合创建索引"><a href="#3-3-哪些情况不适合创建索引" class="headerlink" title="3.3 哪些情况不适合创建索引"></a><strong>3.3</strong> <strong>哪些情况不适合创建索引</strong></h5><p><strong>1.</strong> <strong>在where中使用不到的字段，不要设置索引</strong></p><p><strong>2.</strong> <strong>数据量小的表最好不要使用索引</strong></p><p><strong>3.</strong> <strong>有大量重复数据的列上不要建立索引</strong></p><p><strong>4.</strong> <strong>避免对经常更新的表创建过多的索引</strong> </p><p><strong>5.</strong> <strong>不建议用无序的值作为索引</strong></p><p>例如身份证、UUID(在索引比较时需要转为ASCII，并且插入时可能造成页分裂)、MD5、HASH、无序长字符串等。</p><p><strong>6.</strong> <strong>删除不再使用或者很少使用的索引</strong></p><p><strong>7.</strong> <strong>不要定义冗余或重复的索引</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第09章 性能分析工具的使用</title>
      <link href="/2023/07/15/%E7%AC%AC09%E7%AB%A0%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/07/15/%E7%AC%AC09%E7%AB%A0%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="第09章-性能分析工具的使用"><a href="#第09章-性能分析工具的使用" class="headerlink" title="第09章 性能分析工具的使用"></a>第09章 性能分析工具的使用</h3><h4 id="1-统计SQL的查询成本：last-query-cost"><a href="#1-统计SQL的查询成本：last-query-cost" class="headerlink" title="1. 统计SQL的查询成本：last_query_cost"></a><strong>1.</strong> <strong>统计SQL的查询成本：last_query_cost</strong></h4><pre><code class="mysql">SHOW STATUS LIKE &#39;last_query_cost&#39;;</code></pre><p>使用场景：它对于比较开销是非常有用的，特别是我们有好几种查询方式可选的时候。</p><blockquote><p>SQL 查询是一个动态的过程，从页加载的角度来看，我们可以得到以下两点结论：</p><ol><li><code>位置决定效率</code>。如果页就在数据库<code>缓冲池</code>中，那么效率是最高的，否则还需要从<code>内存</code>或者<code>磁盘</code>中进行读取，当然针对单个页的读取来说，如果页存在于内存中，会比在磁盘中读取效率高很多。</li><li><code>批量决定效率</code>。如果我们从磁盘中对单一页进行随机读，那么效率是很低的（差不多10ms），而采用顺序读取的方式，批量对页进行读取，平均一页的读取效率就会提升很多，甚至要快于单个页面在内存中的随机读取。</li></ol><p>所以说，遇到I&#x2F;O并不用担心，方法找对了，效率还是很高的。我们首先要考虑数据存放的位置，如果是经常使用的数据就要尽量放到<code>缓冲池</code>中，其次我们可以充分利用磁盘的吞吐能力，一次性批量读取数据，这样单个页的读取效率也就得到了提升。</p></blockquote><h4 id="2-定位执行慢的SQL：慢查询日志"><a href="#2-定位执行慢的SQL：慢查询日志" class="headerlink" title="2. 定位执行慢的SQL：慢查询日志"></a><strong>2.</strong> <strong>定位执行慢的SQL：慢查询日志</strong></h4><p>MySQL的慢查询日志，用来记录在MySQL中<code>响应时间超过阈值</code>的语句，具体指运行时间超过<code>long_query_time</code>的值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为<code>10</code>，意思是运行10秒以上（不含10秒）的语句，认为是超出了我们的最大忍耐时间值。</p><p>默认情况下，MySQL数据库<code>没有开启慢查询日志</code>，需要我们手动来设置这个参数。<code>如果不是调优需要的话，一般不建议启动该参数</code>，因为开启慢查询日志会或多或少带来一定的性能影响。</p><h5 id="2-1-开启慢查询日志参数"><a href="#2-1-开启慢查询日志参数" class="headerlink" title="2.1 开启慢查询日志参数"></a><strong>2.1</strong> <strong>开启慢查询日志参数</strong></h5><p><strong>1.</strong> <strong>开启slow_query_log</strong></p><pre><code class="mysql">set global slow_query_log=&#39;ON&#39;;</code></pre><p>查看下慢查询日志是否开启，以及慢查询日志文件的位置：</p><pre><code class="mysql">show variables like `%slow_query_log%`;</code></pre><p><strong>2.</strong> <strong>修改long_query_time阈值</strong></p><pre><code class="mysql">show variables like &#39;%long_query_time%&#39;;</code></pre><pre><code class="mysql">#测试发现：设置global的方式对当前session的long_query_time失效。对新连接的客户端有效。所以可以一并 执行下述语句 mysql &gt; set global long_query_time = 1; mysql&gt; show global variables like &#39;%long_query_time%&#39;; mysql&gt; set long_query_time=1; mysql&gt; show variables like &#39;%long_query_time%&#39;;</code></pre><h5 id="2-2-查看慢查询数目"><a href="#2-2-查看慢查询数目" class="headerlink" title="2.2 查看慢查询数目"></a><strong>2.2</strong> <strong>查看慢查询数目</strong></h5><pre><code class="mysql">SHOW GLOBAL STATUS LIKE &#39;%Slow_queries%&#39;;</code></pre><h5 id="2-3-慢查询日志分析工具：mysqldumpslow"><a href="#2-3-慢查询日志分析工具：mysqldumpslow" class="headerlink" title="2.3 慢查询日志分析工具：mysqldumpslow"></a><strong>2.3</strong> <strong>慢查询日志分析工具：mysqldumpslow</strong></h5><pre><code class="shell">#得到返回记录集最多的10个SQL mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log #得到访问次数最多的10个SQL mysqldumpslow -s c -t 10 /var/lib/mysql/atguigu-slow.log#得到按照时间排序的前10条里面含有左连接的查询语句 mysqldumpslow -s t -t 10 -g &quot;left join&quot; /var/lib/mysql/atguigu-slow.log #另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现爆屏情况 mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log | more</code></pre><h5 id="2-4-关闭慢查询日志"><a href="#2-4-关闭慢查询日志" class="headerlink" title="2.4 关闭慢查询日志"></a><strong>2.4</strong> <strong>关闭慢查询日志</strong></h5><p><strong>方式1：永久性方式</strong></p><pre><code class="ini">[mysqld] slow_query_log=OFF#或[mysqld] #slow_query_log =OFF</code></pre><p><strong>方式2：临时性方式</strong></p><pre><code class="mysql">SET GLOBAL slow_query_log=off;</code></pre><h4 id="3-查看-SQL-执行成本：SHOW-PROFILE"><a href="#3-查看-SQL-执行成本：SHOW-PROFILE" class="headerlink" title="3. 查看 SQL 执行成本：SHOW PROFILE"></a><strong>3.</strong> <strong>查看</strong> <strong>SQL</strong> <strong>执行成本：SHOW PROFILE</strong></h4><pre><code class="mysql">show variables like &#39;profiling&#39;;#开启set profiling = &#39;ON&#39;;#查看show profiles;show profile cpu,block io for query 2;</code></pre><h4 id="4-分析查询语句：EXPLAIN"><a href="#4-分析查询语句：EXPLAIN" class="headerlink" title="4. 分析查询语句：EXPLAIN"></a><strong>4.</strong> <strong>分析查询语句：EXPLAIN</strong></h4><h5 id="4-1-基本语法"><a href="#4-1-基本语法" class="headerlink" title="4.1 基本语法"></a><strong>4.1</strong> <strong>基本语法</strong></h5><pre><code class="mysql">EXPLAIN SELECT select_options #或者DESCRIBE SELECT select_options</code></pre><p>EXPLAIN 语句输出的各个列的作用如下：</p><table><thead><tr><th>列名</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td>在一个大的查询语句中每个SELECT关键字都对应一个<code>唯一的id</code></td></tr><tr><td>select_type</td><td>SELECT关键字对应的那个查询的类型</td></tr><tr><td>table</td><td>表名</td></tr><tr><td>partitions</td><td>匹配的分区信息</td></tr><tr><td>type</td><td>针对单表的访问方法</td></tr><tr><td>possible_keys</td><td>可能用到的索引</td></tr><tr><td>key</td><td>实际上使用的索引</td></tr><tr><td>key_len</td><td>实际使用到的索引长度</td></tr><tr><td>ref</td><td>当使用索引列等值查询时，与索引列进行等值匹配的对象信息</td></tr><tr><td>rows</td><td>预估的需要读取的记录条数</td></tr><tr><td>filtered</td><td>某个表经过搜索条件过滤后剩余记录条数的百分比</td></tr><tr><td>Extra</td><td>一些额外的信息</td></tr></tbody></table><h5 id="4-2-EXPLAIN各列作用"><a href="#4-2-EXPLAIN各列作用" class="headerlink" title="4.2 EXPLAIN各列作用"></a><strong>4.2 EXPLAIN各列作用</strong></h5><p><strong>1. table</strong></p><p>不论我们的查询语句有多复杂，包含了多少个表 ，到最后也是需要对每个表进行<code>单表访问</code>的，所以MySQL规定<strong>EXPLAIN语句输出的每条记录都对应着某个单表的访问方法</strong>，该条记录的table列代表着该表的表名（有时不是真实的表名字，可能是简称）。</p><p><strong>2. id</strong></p><ul><li><strong>id如果相同，可以认为是一组，从上往下顺序执行</strong></li><li><strong>在所有组中，id值越大，优先级越高，越先执行</strong></li><li><strong>关注点：id号每个号码，表示一趟独立的查询,一个sql的查询趟数越少越好</strong></li></ul><p><strong>3. select_type</strong></p><p><strong>4. partitions</strong></p><p><strong>5. type（重点）</strong></p><p><strong>结果值从最好到最坏依次是：</strong> <strong>system &gt; const &gt; eq_ref &gt; ref</strong> <strong>&gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt;</strong> <strong>range &gt; index &gt; ALL</strong> </p><p><strong>SQL性能优化的目标：至少要达到 range级别，要求是ref级别，最好是consts级别。（阿里巴巴开发手册要求）</strong></p><p><strong>6. possible_keys和key</strong></p><p><strong>7. key_len（重点）</strong></p><p><strong>key_len的长度计算公式：</strong></p><pre><code>varchar(10)变长字段且允许NULL = 10 * ( character set： utf8=3,gbk=2,latin1=1)+1(NULL)+2(变长字段) varchar(10)变长字段且不允许NULL = 10 * ( character set：utf8=3,gbk=2,latin1=1)+2(变长字段)char(10)固定字段且允许NULL = 10 * ( character set：utf8=3,gbk=2,latin1=1)+1(NULL) char(10)固定字段且不允许NULL = 10 * ( character set：utf8=3,gbk=2,latin1=1)</code></pre><p><strong>8. ref</strong> </p><p><strong>9. rows（重点）</strong></p><p>预估的需要读取的记录条数</p><p><strong>10. filtered</strong></p><p><strong>11. Extra</strong></p><h4 id="5-EXPLAIN的进一步使用"><a href="#5-EXPLAIN的进一步使用" class="headerlink" title="5. EXPLAIN的进一步使用"></a><strong>5. EXPLAIN的进一步使用</strong></h4><h5 id="5-1-EXPLAIN四种输出格式"><a href="#5-1-EXPLAIN四种输出格式" class="headerlink" title="5.1 EXPLAIN四种输出格式"></a><strong>5.1 EXPLAIN四种输出格式</strong></h5><p>这里谈谈EXPLAIN的输出格式。EXPLAIN可以输出四种格式：<code>传统格式</code>，<code>JSON格式</code>，<code>TREE格式</code>以及<code>可视化输出</code>。用户可以根据需要选择适用于自己的格式。</p><p><strong>1.</strong> <strong>传统格式</strong></p><p><strong>2. JSON格式</strong> </p><p>JSON格式：在EXPLAIN单词和真正的查询语句中间加上<code>FORMAT=JSON</code>。用于查看执行成本<code>cost_info</code></p><p><strong>3. TREE格式</strong></p><p>TREE格式是8.0.16版本之后引入的新格式，主要根据查询的<code>各个部分之间的关系</code>和<code>各部分的执行顺序</code>来描述如何查询。</p><p><strong>4.</strong> <strong>可视化输出</strong></p><p>可视化输出，可以通过MySQL Workbench可视化查看MySQL的执行计划。</p><h5 id="5-2-SHOW-WARNINGS的使用"><a href="#5-2-SHOW-WARNINGS的使用" class="headerlink" title="5.2 SHOW WARNINGS的使用"></a><strong>5.2 SHOW WARNINGS的使用</strong></h5><pre><code class="mysql">mysql&gt; EXPLAIN SELECT s1.key1, s2.key1 FROM s1 LEFT JOIN s2 ON s1.key1 = s2.key1 WHERE s2.common_field IS NOT NULL;# 查看优化后的执行语句mysql&gt; SHOW WARNINGS\G</code></pre><h4 id="6-分析优化器执行计划：trace"><a href="#6-分析优化器执行计划：trace" class="headerlink" title="6. 分析优化器执行计划：trace"></a><strong>6.</strong> <strong>分析优化器执行计划：trace</strong></h4><pre><code class="mysql"># 开启SET optimizer_trace=&quot;enabled=on&quot;,end_markers_in_json=on; # 设置大小set optimizer_trace_max_mem_size=1000000;# 使用select * from student where id &lt; 10;select * from information_schema.optimizer_trace\G</code></pre><h4 id="7-MySQL监控分析视图-sys-schema"><a href="#7-MySQL监控分析视图-sys-schema" class="headerlink" title="7. MySQL监控分析视图-sys schema"></a><strong>7. MySQL监控分析视图-sys schema</strong></h4><p><strong>7.1 Sys schema视图使用场景</strong></p><p><strong>索引情况</strong></p><pre><code class="mysql">#1. 查询冗余索引 select * from sys.schema_redundant_indexes; #2. 查询未使用过的索引 select * from sys.schema_unused_indexes; #3. 查询索引的使用情况 select index_name,rows_selected,rows_inserted,rows_updated,rows_deleted from sys.schema_index_statistics where table_schema=&#39;dbname&#39; ;</code></pre><p><strong>表相关</strong></p><pre><code class="mysql"># 1. 查询表的访问量 select table_schema,table_name,sum(io_read_requests+io_write_requests) as io from sys.schema_table_statistics group by table_schema,table_name order by io desc; # 2. 查询占用bufferpool较多的表 select object_schema,object_name,allocated,datafrom sys.innodb_buffer_stats_by_table order by allocated limit 10; # 3. 查看表的全表扫描情况 select * from sys.statements_with_full_table_scans where db=&#39;dbname&#39;;</code></pre><p><strong>语句相关</strong></p><pre><code class="mysql">#1. 监控SQL执行的频率 select db,exec_count,query from sys.statement_analysis order by exec_count desc; #2. 监控使用了排序的SQL select db,exec_count,first_seen,last_seen,queryfrom sys.statements_with_sorting limit 1; #3. 监控使用了临时表或者磁盘临时表的SQL select db,exec_count,tmp_tables,tmp_disk_tables,queryfrom sys.statement_analysis where tmp_tables&gt;0 or tmp_disk_tables &gt;0 order by (tmp_tables+tmp_disk_tables) desc;</code></pre><p><strong>IO相关</strong></p><pre><code class="mysql">#1. 查看消耗磁盘IO的文件 select file,avg_read,avg_write,avg_read+avg_write as avg_iofrom sys.io_global_by_file_by_bytes order by avg_read limit 10;</code></pre><p><strong>Innodb</strong> <strong>相关</strong></p><pre><code class="mysql">#1. 行锁阻塞情况 select * from sys.innodb_lock_waits;</code></pre><h3 id><a href="#" class="headerlink" title></a></h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第10章 索引优化与查询优化</title>
      <link href="/2023/07/15/%E7%AC%AC10%E7%AB%A0%20%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E4%B8%8E%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/"/>
      <url>/2023/07/15/%E7%AC%AC10%E7%AB%A0%20%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E4%B8%8E%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h3 id="第10章-索引优化与查询优化"><a href="#第10章-索引优化与查询优化" class="headerlink" title="第10章 索引优化与查询优化"></a>第10章 索引优化与查询优化</h3><h4 id="1-索引失效案例"><a href="#1-索引失效案例" class="headerlink" title="1. 索引失效案例"></a><strong>1.</strong> <strong>索引失效案例</strong></h4><p>MySQL中<code>提高性能</code>的一个最有效的方式是对数据表<code>设计合理的索引</code>。索引提供了访问高效数据的方法，并且加快查询的速度，因此索引对查询的速度有着至关重要的影响。</p><ul><li>使用索引可以<code>快速地定位</code>表中的某条记录，从而提高数据库查询的速度，提高数据库的性能。</li><li>如果查询时没有使用索引，查询语句就会<code>扫描表中的所有记录</code>。在数据量大的情况下，这样查询的速度会很慢。</li></ul><p>大多数情况下都（默认）采用<code>B+树</code>来构建索引。只是空间列类型的索引使用<code>R-树</code>，并且MEMORY表还支持<code>hash索引</code>。</p><p>其实，用不用索引，最终都是优化器说了算。优化器是基于什么的优化器？基于<code>cost开销(CostBaseOptimizer)</code>，它不是基于<code>规则(Rule-BasedOptimizer)</code>，也不是基于<code>语义</code>。怎么样开销小就怎么来。另外，<strong>SQL语句是否使用索引，跟数据库版本、数据量、数据选择度都有关系。</strong></p><h5 id="1-1-全值匹配我最爱"><a href="#1-1-全值匹配我最爱" class="headerlink" title="1.1 全值匹配我最爱"></a><strong>1.1</strong> <strong>全值匹配我最爱</strong></h5><h5 id="1-2-最佳左前缀法则"><a href="#1-2-最佳左前缀法则" class="headerlink" title="1.2 最佳左前缀法则"></a><strong>1.2</strong> <strong>最佳左前缀法则</strong></h5><p>在MySQL建立联合索引时会遵守最佳左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。</p><p>结论：MySQL可以为多个字段创建索引，一个索引可以包括16个字段。对于多列索引，<strong>过滤条件要使用索引必须按照索引建立时的顺序，依次满足，一旦跳过某个字段，索引后面的字段都无法被使用。</strong>如果查询条件中没有使用这些字段中第1个字段时，多列（或联合）索引不会被使用。</p><h5 id="1-3-主键插入顺序"><a href="#1-3-主键插入顺序" class="headerlink" title="1.3 主键插入顺序"></a><strong>1.3</strong> <strong>主键插入顺序</strong></h5><p>对于一个使用<code>InnoDB</code>存储引擎的表来说，在我们没有显示的创建索引时，表中的数据实际上都是存储在<code>聚簇索引</code>的叶子节点的。而记录又存储在数据页中的，数据页和记录又是按照记录<code>主键值从小到大</code>的顺序进行排序，所以如果我们<code>插入</code>的记录的<code>主键值是依次增大</code>的话，那我们每插满一个数据页就换到下一个数据页继续插，而如果我们插入的<code>主键值忽小忽大</code>的话，则可能会造成<code>页面分裂</code>和<code>记录移位</code>。</p><h5 id="1-4-计算、函数、类型转换-自动或手动-导致索引失效"><a href="#1-4-计算、函数、类型转换-自动或手动-导致索引失效" class="headerlink" title="1.4 计算、函数、类型转换(自动或手动)导致索引失效"></a><strong>1.4</strong> <strong>计算、函数、类型转换(自动或手动)导致索引失效</strong></h5><h5 id="1-5-类型转换导致索引失效"><a href="#1-5-类型转换导致索引失效" class="headerlink" title="1.5 类型转换导致索引失效"></a><strong>1.5</strong> <strong>类型转换导致索引失效</strong></h5><h5 id="1-6-范围条件右边的列索引失效"><a href="#1-6-范围条件右边的列索引失效" class="headerlink" title="1.6 范围条件右边的列索引失效"></a><strong>1.6</strong> <strong>范围条件右边的列索引失效</strong></h5><blockquote><p>应用开发中范围查询，例如：金额查询，日期查询往往都是范围查询。应将查询条件放置where语句最后。（创建的联合索引中，务必把范围涉及到的字段写在最后）</p></blockquote><h5 id="1-7-不等于-x3D-或者-lt-gt-索引失效"><a href="#1-7-不等于-x3D-或者-lt-gt-索引失效" class="headerlink" title="1.7 不等于(!&#x3D; 或者&lt;&gt;)索引失效"></a><strong>1.7</strong> <strong>不等于(!&#x3D; 或者&lt;&gt;)索引失效</strong></h5><h5 id="1-8-is-null可以使用索引，is-not-null无法使用索引"><a href="#1-8-is-null可以使用索引，is-not-null无法使用索引" class="headerlink" title="1.8 is null可以使用索引，is not null无法使用索引"></a><strong>1.8 is null可以使用索引，is not null无法使用索引</strong></h5><blockquote><p>结论：最好在设计数据表的时候就将<code>字段设置为 NOT NULL 约束</code>，比如你可以将INT类型的字段，默认值设置为0。将字符类型的默认值设置为空字符串(‘’)</p><p>拓展：同理，在查询中使用<code>not like</code>也无法使用索引，导致全表扫描</p></blockquote><h5 id="1-9-like以通配符-开头索引失效"><a href="#1-9-like以通配符-开头索引失效" class="headerlink" title="1.9 like以通配符%开头索引失效"></a><strong>1.9 like以通配符%开头索引失效</strong></h5><blockquote><p>拓展：Alibaba《Java开发手册》</p><p>【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。</p></blockquote><h5 id="1-10-OR-前后存在非索引的列，索引失效"><a href="#1-10-OR-前后存在非索引的列，索引失效" class="headerlink" title="1.10 OR 前后存在非索引的列，索引失效"></a><strong>1.10 OR</strong> <strong>前后存在非索引的列，索引失效</strong></h5><p>在WHERE子句中，如果在OR前的条件列进行了索引，而在OR后的条件列没有进行索引，那么索引会失效。也就是说，<strong>OR前后的两个条件中的列都是索引时，查询中才使用索引。</strong></p><h5 id="1-11-数据库和表的字符集统一使用utf8mb4"><a href="#1-11-数据库和表的字符集统一使用utf8mb4" class="headerlink" title="1.11 数据库和表的字符集统一使用utf8mb4"></a><strong>1.11</strong> <strong>数据库和表的字符集统一使用utf8mb4</strong></h5><p>统一使用utf8mb4( 5.5.3版本以上支持)兼容性更好，统一字符集可以避免由于字符集转换产生的乱码。不同的<code>字符集</code>进行比较前需要进行<code>转换</code>会造成索引失效。</p><h4 id="2-关联查询优化"><a href="#2-关联查询优化" class="headerlink" title="2. 关联查询优化"></a><strong>2.</strong> <strong>关联查询优化</strong></h4><blockquote><p>结论1：对于内连接来说，查询优化器可以决定谁来作为驱动表，谁作为被驱动表出现</p><p>结论2：对于内连接来讲，如果表的连接条件中只能有一个字段有索引，则有索引的字段所在的表会被作为被驱动表</p><p>结论3：对于内连接来说，在两个表的连接条件都存在索引的情况下，会选择小表作为驱动表。<code>小表驱动大表</code></p></blockquote><h5 id="2-1-Index-Nested-Loop-Join（索引嵌套循环连接）"><a href="#2-1-Index-Nested-Loop-Join（索引嵌套循环连接）" class="headerlink" title="2.1 Index Nested-Loop Join（索引嵌套循环连接）"></a>2.1 Index Nested-Loop Join（索引嵌套循环连接）</h5><p>Index Nested-Loop Join其优化的思路主要是为了<code>减少内层表数据的匹配次数</code>，所以要求被驱动表上必须<code>有索引</code>才行。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204011826671.png" alt="image-20220401182649509"></p><h5 id="2-2-Block-Nested-Loop-Join（块嵌套循环连接）"><a href="#2-2-Block-Nested-Loop-Join（块嵌套循环连接）" class="headerlink" title="2.2 Block Nested-Loop Join（块嵌套循环连接）"></a>2.2 Block Nested-Loop Join（块嵌套循环连接）</h5><p>如果存在索引，那么会使用index的方式进行join，如果join的列没有索引，被驱动表要扫描的次数太多了。每次访问被驱动表，其表中的记录都会被加载到内存中，然后再从驱动表中取一条与其匹配，匹配结束后清除内存，然后再从驱动表中加载一条记录，然后把被驱动表的记录再加载到内存匹配，这样周而复始，大大增加了IO的次数。为了减少被驱动表的IO次数，就出现了Block Nested-Loop Join的方式。</p><p>不再是逐条获取驱动表的数据，而是一块一块的获取，引入了<code>join buffer缓冲区</code>，将驱动表join相关的部分数据列（大小受join buffer的限制）缓存到join buffer中，然后全表扫描被驱动表，被驱动表的每一条记录一次性和join buffer中的所有驱动表记录进行匹配（内存中操作），将简单嵌套循环中的多次比较合并成一次，降低了被驱动表的访问频率。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204011833000.png" alt="image-20220401183344880"></p><h5 id="2-3-Hash-Join"><a href="#2-3-Hash-Join" class="headerlink" title="2.3 Hash Join"></a>2.3 Hash Join</h5><p><strong>从MySQL的8.0.20版本开始将废弃BNLJ，因为从MySQL8.0.18版本开始就加入了hash join默认都会使用hash join</strong></p><ul><li>Nested Loop：对于被连接的数据子集较小的情况下，Nested Loop是个较好的选择。</li><li>Hash Join是做<code>大数据集连接</code>时的常用方式，优化器使用两个表中较小（相对较小）的表利用Join Key在内存中建立<code>散列值</code>，然后扫描较大的表并探测散列值，找出与Hash表匹配的行。<ul><li>这种方式适用于较小的表完全可以放入内存中的情况，这样总成本就是访问两个表的成本之和。</li><li>在表很大的情况下并不能完全放入内存，这时优化器会将它分割成<code>若干不同的分区</code>，不能放入内存的部分就把该分区写入磁盘的临时段，此时要求有较大的临时段从而尽量提高I&#x2F;O的性能。</li><li>它能够很好的工作于没有索引的大表和并行查询的环境中，并提供最好的性能。Hash Join只能应用于等值连接，这是由Hash的特点决定的。</li></ul></li></ul><h4 id="3-子查询优化"><a href="#3-子查询优化" class="headerlink" title="3. 子查询优化"></a><strong>3.</strong> <strong>子查询优化</strong></h4><p><strong>子查询是</strong> <strong>MySQL</strong> <strong>的一项重要的功能，可以帮助我们通过一个</strong> <strong>SQL</strong> <strong>语句实现比较复杂的查询。但是，子查询的执行效率不高。</strong>原因：</p><p>① 执行子查询时，MySQL需要为内层查询语句的查询结果<code>建立一个临时表</code>，然后外层查询语句从临时表中查询记录。查询完毕后，再<code>撤销这些临时表</code>。这样会消耗过多的CPU和IO资源，产生大量的慢查询。</p><p>② 子查询的结果集存储的临时表，不论是内存临时表还是磁盘临时表都<code>不会存在索引</code>，所以查询性能会受到一定的影响。</p><p>③ 对于返回结果集比较大的子查询，其对查询性能的影响也就越大。</p><p><strong>在MySQL中，可以使用连接（JOIN）查询来替代子查询。</strong>连接查询<code>不需要建立临时表</code>，其<code>速度比子查询要快</code>，如果查询中使用索引的话，性能就会更好。</p><blockquote><p>结论：尽量不要使用NOT IN 或者 NOT EXISTS，用LEFT JOIN xxx ON xx WHERE xx IS NULL替代</p></blockquote><h4 id="4-排序优化"><a href="#4-排序优化" class="headerlink" title="4. 排序优化"></a><strong>4.</strong> <strong>排序优化</strong></h4><ol><li><p>SQL 中，可以在 WHERE 子句和 ORDER BY 子句中使用索引，目的是在 WHERE 子句中 <code>避免全表扫描</code>，在 ORDER BY 子句<code>避免使用 FileSort 排序</code>。当然，某些情况下全表扫描，或者 FileSort 排序不一定比索引慢。但总的来说，我们还是要避免，以提高查询效率。</p></li><li><p>尽量使用 Index 完成 ORDER BY 排序。如果 WHERE 和 ORDER BY 后面是相同的列就使用单索引列；如果不同就使用联合索引。</p></li><li><p>无法使用 Index 时，需要对 FileSort 方式进行调优。</p></li></ol><h4 id="5-GROUP-BY优化"><a href="#5-GROUP-BY优化" class="headerlink" title="5. GROUP BY优化"></a><strong>5. GROUP BY优化</strong></h4><ul><li>group by 使用索引的原则几乎跟order by一致 ，group by 即使没有过滤条件用到索引，也可以直接使用索引。</li><li>group by 先排序再分组，遵照索引建的最佳左前缀法则</li><li>当无法使用索引列，可以增大<code>max_length_for_sort_data</code>和<code>sort_buffer_size</code>参数的设置</li><li>where效率高于having，能写在where限定的条件就不要写在having中了</li><li>减少使用order by，和业务沟通能不排序就不排序，或将排序放到程序端去做。Order by、group by、distinct这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。</li><li>包含了order by、group by、distinct这些查询的语句，where条件过滤出来的结果集请保持在1000行以内，否则SQL会很慢。</li></ul><h4 id="6-优化分页查询"><a href="#6-优化分页查询" class="headerlink" title="6. 优化分页查询"></a><strong>6.</strong> <strong>优化分页查询</strong></h4><p><strong>优化思路一</strong></p><p>在索引上完成排序分页操作，最后根据主键关联回原表查询所需要的其他列内容。</p><pre><code class="mysql">EXPLAIN SELECT * FROM student t,(SELECT id FROM student ORDER BY id LIMIT 2000000,10) aWHERE t.id = a.id;</code></pre><p><strong>优化思路二</strong></p><p>该方案适用于主键自增的表，可以把Limit 查询转换成某个位置的查询。</p><pre><code class="mysql">EXPLAIN SELECT * FROM student WHERE id &gt; 2000000 LIMIT 10;</code></pre><h4 id="7-优先考虑覆盖索引"><a href="#7-优先考虑覆盖索引" class="headerlink" title="7. 优先考虑覆盖索引"></a><strong>7.</strong> <strong>优先考虑覆盖索引</strong></h4><h5 id="7-1-什么是覆盖索引？"><a href="#7-1-什么是覆盖索引？" class="headerlink" title="7.1 什么是覆盖索引？"></a><strong>7.1</strong> <strong>什么是覆盖索引？</strong></h5><p><strong>理解方式一</strong>：索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。毕竟索引叶子节点存储了它们索引的数据；当能通过读取索引就可以得到想要的数据，那就不需要读取行了。<strong>一个索引包含了满足查询结果的数据就叫做覆盖索引。</strong></p><p><strong>理解方式二</strong>：非聚簇复合索引的一种形式，它包括在查询里的SELECT、JOIN和WHERE子句用到的所有列（即建索引的字段正好是覆盖查询条件中所涉及的字段）。</p><p>简单说就是，<code>索引列+主键</code>包含<code>SELECT 到 FROM之间查询的列</code>。</p><h5 id="7-2-覆盖索引的利弊"><a href="#7-2-覆盖索引的利弊" class="headerlink" title="7.2 覆盖索引的利弊"></a><strong>7.2</strong> <strong>覆盖索引的利弊</strong></h5><p><strong>好处：</strong></p><p><strong>1.</strong> <strong>避免Innodb表进行索引的二次查询（回表）</strong></p><p><strong>2.</strong> <strong>可以把随机IO变成顺序IO加快查询效率</strong></p><p><strong>弊端：</strong></p><p><code>索引字段的维护</code>总是有代价的。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑了。这是业务DBA，或者称为业务数据架构师的工作。</p><h4 id="8-索引条件下推"><a href="#8-索引条件下推" class="headerlink" title="8. 索引条件下推"></a><strong>8.</strong> <strong>索引条件下推</strong></h4><h5 id="8-1-使用前后的扫描过程"><a href="#8-1-使用前后的扫描过程" class="headerlink" title="8.1 使用前后的扫描过程"></a><strong>8.1</strong> <strong>使用前后的扫描过程</strong></h5><p><strong>在不使用ICP索引扫描的过程：</strong></p><p>storage层：只将满足index key条件的索引记录对应的整行记录取出，返回给server层 </p><p>server 层：对返回的数据，使用后面的where条件过滤，直至返回最后一行。</p><p><strong>使用ICP扫描的过程：</strong></p><p>storage层：首先将index key条件满足的索引记录区间确定，然后在索引上使用index filter进行过滤。将满足的index filter条件的索引记录才去回表取出整行记录返回server层。不满足index filter条件的索引记录丢弃，不回表、也不会返回server层。</p><p>server 层：对返回的数据，使用table filter条件做最后的过滤。</p><h4 id="9-其它查询优化策略"><a href="#9-其它查询优化策略" class="headerlink" title="9. 其它查询优化策略"></a><strong>9.</strong> <strong>其它查询优化策略</strong></h4><h5 id="9-1-EXISTS-和-IN-的区分"><a href="#9-1-EXISTS-和-IN-的区分" class="headerlink" title="9.1 EXISTS 和 IN 的区分"></a><strong>9.1 EXISTS</strong> <strong>和</strong> <strong>IN</strong> <strong>的区分</strong></h5><p>索引是个前提，其实选择与否还会要看表的大小。你可以将选择的标准理解为<code>小表驱动大表</code>。</p><h5 id="9-2-COUNT-与COUNT-具体字段-效率"><a href="#9-2-COUNT-与COUNT-具体字段-效率" class="headerlink" title="9.2 COUNT(*)与COUNT(具体字段)效率"></a><strong>9.2 COUNT(*)与COUNT(具体字段)效率</strong></h5><p><strong>环节1：</strong><code>COUNT(*)</code>和<code>COUNT(1)</code>都是对所有结果进行<code>COUNT</code>，<code>COUNT(*)</code>和<code>COUNT(1)</code>本质上并没有区别（二者执行时间可能略有差别，不过你还是可以把它俩的执行效率看成是相等的）。如果有WHERE子句，则是对所有符合筛选条件的数据行进行统计；如果没有WHERE子句，则是对数据表的数据行数进行统计。</p><p><strong>环节2：</strong>如果是MyISAM存储引擎，统计数据表的行数只需要<code>O(1)</code>的复杂度，这是因为每张MyISAM的数据表都有一个meta信息存储了<code>row_count</code>值，而一致性则是由表级锁来保证的。</p><p>如果是InnoDB存储引擎，因为InnoDB支持事务，采用行级锁和MVCC机制，所以无法像MyISAM一样，维护一个row_count变量，因此需要采用<code>扫描全表</code>，是<code>O(n)</code>的复杂度，进行循环+计数的方式来完成统计。</p><p><strong>环节3：</strong>在InnoDB引擎中，如果采用<code>COUNT(具体字段)</code>来统计数据行数，要尽量采用二级索引。因为主键采用的索引是聚簇索引，聚簇索引包含的信息多，明显会大于二级索引（非聚簇索引）。对于<code>COUNT(*)</code>和<code>COUNT(1)</code>来说，它们不需要查找具体的行，只是统计行数，系统会<code>自动</code>采用占用空间更小的二级索引来进行统计。</p><p>如果有多个二级索引，会使用key_len小的二级索引进行扫描。当没有二级索引的时候，才会采用主键索引来进行统计。</p><h5 id="9-3-关于SELECT"><a href="#9-3-关于SELECT" class="headerlink" title="9.3 关于SELECT(*)"></a><strong>9.3</strong> <strong>关于SELECT(*)</strong></h5><p>在表查询中，建议明确字段，不要使用 * 作为查询的字段列表，推荐使用SELECT &lt;字段列表&gt; 查询。原因：</p><p>① MySQL 在解析的过程中，会通过<code>查询数据字典</code>将”*”按序转换成所有列名，这会大大的耗费资源和时间。</p><p>② 无法使用<code>覆盖索引</code></p><h5 id="9-4-LIMIT-1-对优化的影响"><a href="#9-4-LIMIT-1-对优化的影响" class="headerlink" title="9.4 LIMIT 1 对优化的影响"></a><strong>9.4 LIMIT 1</strong> <strong>对优化的影响</strong></h5><p>针对的是会扫描全表的 SQL 语句，如果你可以确定结果集只有一条，那么加上<code>LIMIT 1</code>的时候，当找到一条结果的时候就不会继续扫描了，这样会加快查询速度。</p><p>如果数据表已经对字段建立了唯一索引，那么可以通过索引进行查询，不会全表扫描的话，就不需要加上<code>LIMIT 1</code>了。</p><h5 id="9-5-多使用COMMIT"><a href="#9-5-多使用COMMIT" class="headerlink" title="9.5 多使用COMMIT"></a><strong>9.5</strong> <strong>多使用COMMIT</strong></h5><p>只要有可能，在程序中尽量多使用 COMMIT，这样程序的性能得到提高，需求也会因为 COMMIT 所释放的资源而减少。</p><p>COMMIT 所释放的资源：</p><ul><li><p>回滚段上用于恢复数据的信息</p></li><li><p>被程序语句获得的锁</p></li><li><p>redo &#x2F; undo log buffer 中的空间</p></li><li><p>管理上述 3 种资源中的内部花费</p></li></ul><h3 id><a href="#" class="headerlink" title></a></h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第12章 数据库其它调优策略</title>
      <link href="/2023/07/15/%E7%AC%AC12%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B6%E5%AE%83%E8%B0%83%E4%BC%98%E7%AD%96%E7%95%A5/"/>
      <url>/2023/07/15/%E7%AC%AC12%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B6%E5%AE%83%E8%B0%83%E4%BC%98%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<h3 id="第12章-数据库其它调优策略"><a href="#第12章-数据库其它调优策略" class="headerlink" title="第12章 数据库其它调优策略"></a>第12章 数据库其它调优策略</h3><h4 id="1-数据库调优的措施"><a href="#1-数据库调优的措施" class="headerlink" title="1. 数据库调优的措施"></a><strong>1.</strong> <strong>数据库调优的措施</strong></h4><h5 id="1-1-调优的目标"><a href="#1-1-调优的目标" class="headerlink" title="1.1 调优的目标"></a><strong>1.1</strong> <strong>调优的目标</strong></h5><ul><li>尽可能<code>节省系统资源</code>，以便系统可以提供更大负荷的服务。（吞吐量更大）</li><li>合理的结构设计和参数调整，以提高用户操<code> 响应的速度</code>。（响应速度更快）</li><li>减少系统的瓶颈，提高MySQL数据库整体的性能。</li></ul><h5 id="1-2-如何定位调优问题"><a href="#1-2-如何定位调优问题" class="headerlink" title="1.2 如何定位调优问题"></a><strong>1.2</strong> <strong>如何定位调优问题</strong></h5><ul><li><strong>用户的反馈（主要）</strong></li><li><strong>日志分析（主要）</strong></li><li><strong>服务器资源使用监控</strong></li><li><strong>数据库内部状况监控</strong></li><li><strong>其它</strong></li></ul><h5 id="1-3-调优的维度和步骤"><a href="#1-3-调优的维度和步骤" class="headerlink" title="1.3 调优的维度和步骤"></a><strong>1.3</strong> <strong>调优的维度和步骤</strong></h5><p><strong>第1步：选择适合的</strong> <strong>DBMS</strong> </p><p><strong>第2步：优化表设计</strong> </p><p><strong>第3步：优化逻辑查询</strong></p><p><strong>第4步：优化物理查询</strong></p><p>物理查询优化是在确定了逻辑查询优化之后，采用物理优化技术（比如索引等），通过计算代价模型对各种可能的访问路径进行估算，从而找到执行方式中代价最小的作为执行计划。</p><p><strong>第5步：使用</strong> <strong>Redis</strong> <strong>或</strong> <strong>Memcached</strong> <strong>作为缓存</strong></p><p><strong>第6步：库级优化</strong> </p><p><strong>1、读写分离</strong></p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204031025279.png" alt="image-20220403102536170"></p><p><strong>2、数据分片</strong></p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204031026743.png" alt="image-20220403102618627"></p><h4 id="2-优化MySQL服务器"><a href="#2-优化MySQL服务器" class="headerlink" title="2. 优化MySQL服务器"></a><strong>2.</strong> <strong>优化MySQL服务器</strong></h4><h5 id="2-1-优化服务器硬件"><a href="#2-1-优化服务器硬件" class="headerlink" title="2.1 优化服务器硬件"></a><strong>2.1</strong> <strong>优化服务器硬件</strong></h5><p><strong>服务器的硬件性能直接决定着MySQL数据库的性能。</strong>硬件的性能瓶颈直接决定MySQL数据库的运行速度和效率。针对性能瓶颈提高硬件配置，可以提高MySQL数据库查询、更新的速度。 </p><p>（1）<code>配置较大的内存</code></p><p>（2）<code>配置高速磁盘系统</code></p><p>（3）<code>合理分布磁盘I/O</code></p><p>（4）<code>配置多处理器</code></p><h5 id="2-2-优化MySQL的参数"><a href="#2-2-优化MySQL的参数" class="headerlink" title="2.2 优化MySQL的参数"></a><strong>2.2</strong> <strong>优化MySQL的参数</strong></h5><ul><li><code>innodb_buffer_pool_size</code>：这个参数是Mysql数据库最重要的参数之一，表示InnoDB类型的<code>表和索引的最大缓存</code>。它不仅仅缓存<code>索引数据</code>，还会缓存<code>表的数据</code>。这个值越大，查询的速度就会越快。但是这个值太大会影响操作系统的性能。</li><li><code>key_buffer_size</code>：表示<code>索引缓冲区的大小</code>。索引缓冲区是所有的<code>线程共享</code>。增加索引缓冲区可以得到更好处理的索引（对所有读和多重写）。当然，这个值不是越大越好，它的大小取决于内存的大小。如果这个值太大，就会导致操作系统频繁换页，也会降低系统性能。对于内存在<code>4GB</code>左右的服务器该参数可设置为<code>256M</code>或<code>384M</code>。</li><li><code>table_cache</code>：表示<code>同时打开的表的个数</code>。这个值越大，能够同时打开的表的个数越多。物理内存越大，设置就越大。默认为2402，调到512-1024最佳。这个值不是越大越好，因为同时打开的表太多会影响操作系统的性能。</li><li><code>query_cache_size</code>：表示<code>查询缓冲区的大小</code>。可以通过在MySQL控制台观察，如果Qcache_lowmem_prunes的值非常大，则表明经常出现缓冲不够的情况，就要增加Query_cache_size的值；如果Qcache_hits的值非常大，则表明查询缓冲使用非常频繁，如果该值较小反而会影响效率，那么可以考虑不用查询缓存；Qcache_free_blocks，如果该值非常大，则表明缓冲区中碎片很多。MySQL8.0之后失效。该参数需要和query_cache_type配合使用。</li><li><code>query_cache_type</code>的值是0时，所有的查询都不使用查询缓存区。但是query_cache_type&#x3D;0并不会导致MySQL释放query_cache_size所配置的缓存区内存。<ul><li>当query_cache_type&#x3D;1时，所有的查询都将使用查询缓存区，除非在查询语句中指定<code>SQL_NO_CACHE</code>，如SELECT SQL_NO_CACHE * FROM tbl_name。 </li><li>当query_cache_type&#x3D;2时，只有在查询语句中使用<code>SQL_CACHE</code>关键字，查询才会使用查询缓存区。使用查询缓存区可以提高查询的速度，这种方式只适用于修改操作少且经常执行相同的查询操作的情况。</li></ul></li><li><code>sort_buffer_size</code>：表示每个<code>需要进行排序的线程分配的缓冲区的大小</code>。增加这个参数的值可以提高<code>ORDER BY</code>或<code>GROUP BY</code>操作的速度。默认数值是2 097 144字节（约2MB）。对于内存在4GB左右的服务器推荐设置为6-8M，如果有100个连接，那么实际分配的总共排序缓冲区大小为100 × 6 ＝ 600MB。 </li><li><code>join_buffer_size = 8M</code>：表示<code>联合查询操作所能使用的缓冲区大小</code>，和sort_buffer_size一样，该参数对应的分配内存也是每个连接独享。</li><li><code>read_buffer_size</code>：表示<code>每个线程连续扫描时为扫描的每个表分配的缓冲区的大小（字节）</code>。当线程从表中连续读取记录时需要用到这个缓冲区。SET SESSION read_buffer_size&#x3D;n可以临时设置该参数的值。默认为64K，可以设置为4M。 </li><li><code>innodb_flush_log_at_trx_commit</code>：表示<code>何时将缓冲区的数据写入日志文件</code>，并且将日志文件写入磁盘中。该参数对于innoDB引擎非常重要。该参数有3个值，分别为0、1和2。该参数的默认值为1。<ul><li>值为<code>0</code>时，表示<code>每秒1次</code>的频率将数据写入日志文件并将日志文件写入磁盘。每个事务的commit并不会触发前面的任何操作。该模式速度最快，但不太安全，mysqld进程的崩溃会导致上一秒钟所有事务数据的丢失。</li><li>值为<code>1</code>时，表示<code>每次提交事务时</code>将数据写入日志文件并将日志文件写入磁盘进行同步。该模式是最安全的，但也是最慢的一种方式。因为每次事务提交或事务外的指令都需要把日志写入（flush）硬盘。</li><li>值为<code>2</code>时，表示<code>每次提交事务时</code>将数据写入日志文件，<code>每隔1秒</code>将日志文件写入磁盘。该模式速度较快，也比0安全，只有在操作系统崩溃或者系统断电的情况下，上一秒钟所有事务数据才可能丢失。</li></ul></li><li><code>innodb_log_buffer_size</code>：这是 InnoDB 存储引擎的<code>事务日志所使用的缓冲区</code>。为了提高性能，也是先将信息写入 Innodb Log Buffer 中，当满足 innodb_flush_log_trx_commit 参数所设置的相应条件（或者日志缓冲区写满）之后，才会将日志写到文件（或者同步到磁盘）中。</li><li><code>max_connections</code>：表示 允许连接到MySQL数据库的最大数量 ，默认值是 151 。如果状态变量connection_errors_max_connections 不为零，并且一直增长，则说明不断有连接请求因数据库连接数已达到允许最大值而失败，这是可以考虑增大max_connections 的值。在Linux 平台下，性能好的服务器，支持 500-1000 个连接不是难事，需要根据服务器性能进行评估设定。这个连接数 不是越大 越好 ，因为这些连接会浪费内存的资源。过多的连接可能会导致MySQL服务器僵死。</li><li><code>back_log</code>：用于<code>控制MySQL监听TCP端口时设置的积压请求栈大小</code>。如果MySql的连接数达到max_connections时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即back_log，如果等待连接的数量超过back_log，将不被授予连接资源，将会报错。5.6.6 版本之前默认值为 50 ， 之后的版本默认为 50 + （max_connections &#x2F; 5）， 对于Linux系统推荐设置为小于512的整数，但最大不超过900。如果需要数据库在较短的时间内处理大量连接请求， 可以考虑适当增大back_log 的值。</li><li><code>thread_cache_size</code>：<code>线程池缓存线程数量的大小</code>，当客户端断开连接后将当前线程缓存起来，当在接到新的连接请求时快速响应无需创建新的线程 。这尤其对那些使用短连接的应用程序来说可以极大的提高创建连接的效率。那么为了提高性能可以增大该参数的值。默认为60，可以设置为120。</li><li><code>wait_timeout</code>：指定<code>一个请求的最大连接时间</code>，对于4GB左右内存的服务器可以设置为5-10。 </li><li><code>interactive_timeout</code>：表示服务器在关闭连接前等待行动的秒数。</li></ul><h4 id="3-优化数据库结构"><a href="#3-优化数据库结构" class="headerlink" title="3. 优化数据库结构"></a><strong>3.</strong> <strong>优化数据库结构</strong></h4><h5 id="3-1-拆分表：冷热数据分离"><a href="#3-1-拆分表：冷热数据分离" class="headerlink" title="3.1 拆分表：冷热数据分离"></a><strong>3.1</strong> <strong>拆分表：冷热数据分离</strong></h5><h5 id="3-2-增加中间表"><a href="#3-2-增加中间表" class="headerlink" title="3.2 增加中间表"></a><strong>3.2</strong> <strong>增加中间表</strong></h5><h5 id="3-3-增加冗余字段"><a href="#3-3-增加冗余字段" class="headerlink" title="3.3 增加冗余字段"></a><strong>3.3</strong> <strong>增加冗余字段</strong></h5><h5 id="3-4-优化数据类型"><a href="#3-4-优化数据类型" class="headerlink" title="3.4 优化数据类型"></a><strong>3.4</strong> <strong>优化数据类型</strong></h5><p><strong>情况1：对整数类型数据进行优化。</strong></p><p>遇到整数类型的字段可以用<code>INT 型</code>。这样做的理由是，INT 型数据有足够大的取值范围，不用担心数据超出取值范围的问题。刚开始做项目的时候，首先要保证系统的稳定性，这样设计字段类型是可以的。但在数据量很大的时候，数据类型的定义，在很大程度上会影响到系统整体的执行效率。</p><p>对于<code>非负型</code>的数据（如自增ID、整型IP）来说，要优先使用无符号整型<code>UNSIGNED</code>来存储。因为无符号相对于有符号，同样的字节数，存储的数值范围更大。如tinyint有符号为-128-127，无符号为0-255，多出一倍的存储空间。</p><p><strong>情况2：既可以使用文本类型也可以使用整数类型的字段，要选择使用整数类型</strong>。</p><p>跟文本类型数据相比，大整数往往占用<code>更少的存储空间</code>，因此，在存取和比对的时候，可以占用更少的内存空间。所以，在二者皆可用的情况下，尽量使用整数类型，这样可以提高查询的效率。如：将IP地址转换成整型数据。</p><p><strong>情况3：避免使用TEXT、BLOB数据类型</strong></p><p><strong>情况4：避免使用ENUM类型</strong></p><p><strong>情况5：使用TIMESTAMP存储时间</strong></p><p><strong>情况6：用DECIMAL代替FLOAT和DOUBLE存储精确浮点数</strong></p><p><strong>总之，遇到数据量大的项目时，一定要在充分了解业务需求的前提下，合理优化数据类型，这样才能充分发挥资源的效率，使系统达到最优</strong>。</p><h5 id="3-5-优化插入记录的速度"><a href="#3-5-优化插入记录的速度" class="headerlink" title="3.5 优化插入记录的速度"></a><strong>3.5</strong> <strong>优化插入记录的速度</strong></h5><p><strong>1. MyISAM引擎的表：</strong></p><p><strong>① 禁用索引</strong></p><p><strong>② 禁用唯一性检查</strong></p><p><strong>③ 使用批量插入</strong></p><p><strong>④ 使用LOAD DATA INFILE 批量导入</strong></p><p><strong>2. InnoDB引擎的表：</strong></p><p> <strong>① 禁用唯一性检查</strong></p><p><strong>② 禁用外键检查</strong></p><p><strong>③ 禁止自动提交</strong></p><h5 id="3-6-使用非空约束"><a href="#3-6-使用非空约束" class="headerlink" title="3.6 使用非空约束"></a><strong>3.6</strong> <strong>使用非空约束</strong></h5><p><strong>在设计字段的时候，如果业务允许，建议尽量使用非空约束</strong></p><h5 id="3-7-分析表、检查表与优化表"><a href="#3-7-分析表、检查表与优化表" class="headerlink" title="3.7 分析表、检查表与优化表"></a><strong>3.7</strong> <strong>分析表、检查表与优化表</strong></h5><p><strong>1.</strong> <strong>分析表</strong></p><pre><code class="mysql">ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name[,tbl_name]…</code></pre><p>默认的，MySQL服务会将 ANALYZE TABLE语句写到binlog中，以便在主从架构中，从服务能够同步数据。可以添加参数LOCAL 或者 NO_WRITE_TO_BINLOG取消将语句写到binlog中。</p><p>使用<code>ANALYZE TABLE</code>分析表的过程中，数据库系统会自动对表加一个<code>只读锁</code>。在分析期间，只能读取表中的记录，不能更新和插入记录。ANALYZE TABLE语句能够分析InnoDB和MyISAM类型的表，但是不能作用于视图。</p><p>ANALYZE TABLE分析后的统计结果会反应到<code>cardinality</code>的值，该值统计了表中某一键所在的列不重复的值的个数。<strong>该值越接近表中的总行数，则在表连接查询或者索引查询时，就越优先被优化器选择使用。</strong></p><p><strong>2.</strong> <strong>检查表</strong> </p><pre><code class="mysql">CHECK TABLE tbl_name [, tbl_name] ... [option] ... option = &#123;QUICK | FAST | MEDIUM | EXTENDED | CHANGED&#125;</code></pre><p>MySQL中可以使用<code>CHECK TABLE</code>语句来检查表。CHECK TABLE语句能够检查InnoDB和MyISAM类型的表是否存在错误。CHECK TABLE语句在执行过程中也会给表加上<code>只读锁</code>。</p><p><strong>3.</strong> <strong>优化表</strong></p><pre><code class="mysql">OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...</code></pre><p>MySQL中使用<code>OPTIMIZE TABLE</code>语句来优化表。但是，OPTILMIZE TABLE语句只能优化表中的<code>VARCHAR</code>、<code>BLOB</code>或<code>TEXT</code>类型的字段。一个表使用了这些字段的数据类型，若已经<code>删除</code>了表的一大部分数据，或者已经对含有可变长度行的表（含有VARCHAR、BLOB或TEXT列的表）进行了很多<code>更新</code>，则应使用OPTIMIZE TABLE来重新利用未使用的空间，并整理数据文件的<code>碎片</code>。 </p><p>OPTIMIZE TABLE 语句对InnoDB和MyISAM类型的表都有效。该语句在执行过程中也会给表加上<code>只读锁</code>。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第13章 事务基础知识</title>
      <link href="/2023/07/15/%E7%AC%AC13%E7%AB%A0%20%E4%BA%8B%E5%8A%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2023/07/15/%E7%AC%AC13%E7%AB%A0%20%E4%BA%8B%E5%8A%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h3 id="第13章-事务基础知识"><a href="#第13章-事务基础知识" class="headerlink" title="第13章 事务基础知识"></a>第13章 事务基础知识</h3><h4 id="1-数据库事务概述"><a href="#1-数据库事务概述" class="headerlink" title="1. 数据库事务概述"></a><strong>1.</strong> <strong>数据库事务概述</strong></h4><h5 id="1-1-基本概念"><a href="#1-1-基本概念" class="headerlink" title="1.1 基本概念"></a><strong>1.1</strong> <strong>基本概念</strong></h5><p><strong>事务：</strong>一组逻辑操作单元，使数据从一种状态变换到另一种状态。</p><p><strong>事务处理的原则：</strong>保证所有事务都作为<code>一个工作单元</code>来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都被提交(<code>commit</code>)，那么这些修改就<code>永久</code>地保存下来；要么数据库管理系统将<code>放弃</code>所作的所有<code>修改</code>，整个事务回滚(<code>rollback</code>)到最初状态。</p><h5 id="1-2-事务的ACID特性"><a href="#1-2-事务的ACID特性" class="headerlink" title="1.2 事务的ACID特性"></a><strong>1.2</strong> <strong>事务的ACID特性</strong></h5><ul><li><strong>原子性（atomicity）：</strong></li></ul><p>原子性是指事务是一个不可分割的工作单位，要么全部提交，要么全部失败回滚。</p><ul><li><strong>一致性（consistency）：</strong></li></ul><p>一致性是指事务执行前后，数据从一个<code>合法性状态</code>变换到另外一个<code>合法性状态</code>。这种状态是<code>语义上</code>的而不是语法上的，跟具体的业务有关。</p><ul><li><strong>隔离型（isolation）：</strong></li></ul><p>事务的隔离性是指一个事务的执行<code>不能被其他事务干扰</code>，即一个事务内部的操作及使用的数据对<code>并发</code>的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p><ul><li><strong>持久性（durability）：</strong></li></ul><p>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是<code>永久性的</code>，接下来的其他操作和数据库故障不应该对其有任何影响。</p><p>持久性是通过<code>事务日志</code>来保证的。日志包括了<code>重做日志</code>和<code>回滚日志</code>。当我们通过事务对数据进行修改的时候，首先会将数据库的变化信息记录到重做日志中，然后再对数据库中对应的行进行修改。这样做的好处是，即使数据库系统崩溃，数据库重启后也能找到没有更新到数据库系统中的重做日志，重新执行，从而使事务具有持久性。</p><h5 id="1-3-事务的状态"><a href="#1-3-事务的状态" class="headerlink" title="1.3 事务的状态"></a><strong>1.3</strong> <strong>事务的状态</strong></h5><ul><li><strong>活动的（active）</strong></li></ul><p>事务对应的数据库操作正在执行过程中时，我们就说该事务处在<code>活动的</code>状态。</p><ul><li><strong>部分提交的（partially committed）</strong></li></ul><p>当事务中的最后一个操作执行完成，但由于操作都在内存中执行，所造成的影响并<code>没有刷新到磁盘</code>时，我们就说该事务处在<code>部分提交的</code>状态。</p><ul><li><strong>失败的（failed）</strong></li></ul><p>当事务处在<code>活动的</code>或者<code>部分提交的</code>状态时，可能遇到了某些错误（数据库自身的错误、操作系统错误或者直接断电等）而无法继续执行，或者人为的停止当前事务的执行，我们就说该事务处在<code>失败的</code>状态。</p><ul><li><strong>中止的（aborted）</strong></li></ul><p>如果事务执行了一部分而变为<code>失败的</code>状态，那么就需要把已经修改的事务中的操作还原到事务执行前的状态。换句话说，就是要撤销失败事务对当前数据库造成的影响。我们把这个撤销的过程称之为<code>回滚</code>。当<code>回滚</code>操作执行完毕时，也就是数据库恢复到了执行事务之前的状态，我们就说该事务处在了<code>中止的</code>状态。</p><ul><li><strong>提交的（committed）</strong></li></ul><p>当一个处在<code>部分提交的</code>状态的事务将修改过的数据都<code>同步到磁盘</code>上之后，我们就可以说该事务处在了<code>提交的</code>状态。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204031104063.png" alt="image-20220403110448951"></p><h4 id="2-如何使用事务"><a href="#2-如何使用事务" class="headerlink" title="2. 如何使用事务"></a><strong>2.</strong> <strong>如何使用事务</strong></h4><h5 id="2-1-显式事务"><a href="#2-1-显式事务" class="headerlink" title="2.1 显式事务"></a><strong>2.1</strong> <strong>显式事务</strong></h5><p><strong>步骤1：</strong> <code>START TRANSACTION</code>或者<code>BEGIN</code>，作用是显式开启一个事务。</p><pre><code class="mysql">mysql&gt; BEGIN; #或者 mysql&gt; START TRANSACTION;</code></pre><p><code>START TRANSACTION</code>语句相较于<code>BEGIN</code>特别之处在于，后边能跟随几个<code>修饰符</code>： </p><p>①<code>READ ONLY</code>：标识当前事务是一个<code>只读事务</code>，也就是属于该事务的数据库操作只能读取数据，而不能修改数据。</p><p>②<code>READ WRITE</code>：标识当前事务是一个<code>读写事务</code>，也就是属于该事务的数据库操作既可以读取数据，也可以修改数据。</p><p>③<code>WITH CONSISTENT SNAPSHOT</code>：启动一致性读。</p><p><strong>步骤2：</strong>一系列事务中的操作（主要是DML，不含DDL）</p><p><strong>步骤3：</strong>提交事务 或 中止事务（即回滚事务）</p><pre><code class="mysql"># 提交事务。当提交事务后，对数据库的修改是永久性的。mysql&gt; COMMIT;</code></pre><pre><code class="mysql"># 回滚事务。即撤销正在进行的所有没有提交的修改 mysql&gt; ROLLBACK; # 将事务回滚到某个保存点。 mysql&gt; ROLLBACK TO [SAVEPOINT]</code></pre><p>其中关于SAVEPOINT相关操作有：</p><pre><code class="mysql"># 在事务中创建保存点，方便后续针对保存点进行回滚。一个事物中可以存在多个保存点。SAVEPOINT 保存点名称;</code></pre><pre><code class="mysql"># 删除某个保存点RELEASE SAVEPOINT 保存点名称;</code></pre><h5 id="2-2-隐式事务"><a href="#2-2-隐式事务" class="headerlink" title="2.2 隐式事务"></a><strong>2.2</strong> <strong>隐式事务</strong></h5><ul><li>显式的的使用<code>START TRANSACTION</code>或者<code>BEGIN</code>语句开启一个事务。这样在本次事务提交或者回滚前会暂时关闭掉自动提交的功能。</li><li>把系统变量<code>autocommit</code>的值设置为<code>OFF</code></li></ul><h5 id="2-3-隐式提交数据的情况"><a href="#2-3-隐式提交数据的情况" class="headerlink" title="2.3 隐式提交数据的情况"></a><strong>2.3</strong> <strong>隐式提交数据的情况</strong></h5><ul><li><p><strong>数据定义语言（Data definition language，缩写为：DDL）</strong></p></li><li><p><strong>隐式使用或修改mysql数据库中的表</strong></p></li><li><p><strong>事务控制或关于锁定的语句</strong></p><ul><li>当我们在一个事务还没提交或者回滚时就又使用<code>START TRANSACTION</code>或者<code>BEGIN</code>语句开启了另一个事务时，会<code>隐式的提交</code>上一个事务。</li><li>当前的<code>autocommit</code>系统变量的值为<code>OFF</code>，我们手动把它调为<code>ON</code>时，也会<code>隐式的提交</code>前边语句所属的事务。</li><li>使用<code>LOCK TABLES</code>、<code>UNLOCK TABLES</code>等关于锁定的语句也会<code>隐式的提交</code>前边语句所属的事务。</li></ul></li></ul><h4 id="3-事务隔离级别"><a href="#3-事务隔离级别" class="headerlink" title="3. 事务隔离级别"></a><strong>3.</strong> <strong>事务隔离级别</strong></h4><h5 id="3-1-数据并发问题"><a href="#3-1-数据并发问题" class="headerlink" title="3.1 数据并发问题"></a><strong>3.1</strong> <strong>数据并发问题</strong></h5><p><strong>1.</strong> <strong>脏写（</strong><code>Dirty Write</code><strong>）</strong></p><p>对于两个事务 Session A、Session B，如果事务Session A<code>修改了</code>另一个<code>未提交</code>事务Session B<code>修改过</code>的数据，那就意味着发生了<code>脏写</code></p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204031124086.png" alt="image-20220403112416944"></p><p><strong>2.</strong> <strong>脏读（</strong><code>Dirty Read</code><strong>）</strong></p><p>对于两个事务 Session A、Session B，Session A<code>读取</code>了已经被 Session B<code>更新</code>但还<code>没有被提交</code>的字段。之后若 Session B<code>回滚</code>，Session A<code>读取</code>的内容就是<code>临时且无效</code>的。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204031124136.png" alt="image-20220403112435995"></p><p><strong>3.</strong> <strong>不可重复读（</strong><code>Non-Repeatable Read</code><strong>）</strong></p><p>对于两个事务Session A、Session B，Session A<code>读取</code>了一个字段，然后 Session B<code>更新</code>了该字段。 之后Session A<code>再次读取</code>同一个字段，<code>值就不同</code>了。那就意味着发生了不可重复读。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204031124331.png" alt="image-20220403112458183"></p><p><strong>4.</strong> <strong>幻读（</strong><code>Phantom</code><strong>）</strong></p><p>对于两个事务Session A、Session B, Session A 从一个表中<code>读取</code>了一个字段, 然后 Session B 在该表中<code>插入</code>了一些新的行。 之后, 如果 Session A<code>再次读取</code>同一个表, 就会多出几行。那就意味着发生了幻读。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204031125847.png" alt="image-20220403112514712"></p><p><strong>注意1：</strong></p><p>有的同学会有疑问，那如果Session B中<code>剔除了</code>一些符合<code>studentno &gt; 0</code>的记录而不是插入新记录，那么Session A之后再根据<code>studentno &gt; 0</code>的条件读取的<code>记录变少了</code>，这种现象算不算<code>幻读</code>呢？这种现象<code>不属于幻读</code>，幻读强调的是一个事物按照某个<code>相同条件多次读取</code>记录时，后读取时读到了之前<code>没有读到的记录</code>。</p><p><strong>注意2：</strong></p><p>那对于先前已经读到的记录，之后又读取不到这种情况，算啥呢？这相当于对每一条记录都发生了<code>不可重复读</code>的现象。幻读只是重点强调了读取到之前读取没有获取到的记录。</p><h5 id="3-2-SQL中的四种隔离级别"><a href="#3-2-SQL中的四种隔离级别" class="headerlink" title="3.2 SQL中的四种隔离级别"></a><strong>3.2 SQL中的四种隔离级别</strong></h5><p><code>SQL标准</code>中设立了4个<code>隔离级别</code>：</p><ul><li><code>READ UNCOMMITTED</code>：读未提交，在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。不能避免脏读、不可重复读、幻读。</li><li><code>READ COMMITTED</code>：读已提交，它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。可以避免脏读，但不可重复读、幻读问题仍然存在。</li><li><code>REPEATABLE READ</code>：可重复读，事务A在读到一条数据之后，此时事务B对该数据进行了修改并提交，那么事务A再读该数据，读到的还是原来的内容。可以避免脏读、不可重复读，但幻读问题仍然存在。<code>这是MySQL的默认隔离级别</code>。</li><li><code>SERIALIZABLE</code>：可串行化，确保事务可以从一个表中读取相同的行。在这个事务持续期间，禁止其他事务对该表执行插入、更新和删除操作。所有的并发问题都可以避免，但性能十分低下。能避免脏读、不可重复读和幻读。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204031127542.png" alt="image-20220403112740425"></p><h5 id="3-3-如何设置事务的隔离级别"><a href="#3-3-如何设置事务的隔离级别" class="headerlink" title="3.3 如何设置事务的隔离级别"></a><strong>3.3</strong> <strong>如何设置事务的隔离级别</strong></h5><pre><code class="mysql">SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL 隔离级别; #其中，隔离级别格式： &gt; READ UNCOMMITTED &gt; READ COMMITTED &gt; REPEATABLE READ &gt; SERIALIZABLE</code></pre><p>或者：</p><pre><code class="mysql">SET [GLOBAL|SESSION] TRANSACTION_ISOLATION = &#39;隔离级别&#39; #其中，隔离级别格式： &gt; READ-UNCOMMITTED &gt; READ-COMMITTED &gt; REPEATABLE-READ &gt; SERIALIZABLE</code></pre><h3 id><a href="#" class="headerlink" title></a></h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第16章 多版本并发控制</title>
      <link href="/2023/07/15/%E7%AC%AC16%E7%AB%A0%20%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"/>
      <url>/2023/07/15/%E7%AC%AC16%E7%AB%A0%20%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="第16章-多版本并发控制"><a href="#第16章-多版本并发控制" class="headerlink" title="第16章 多版本并发控制"></a>第16章 多版本并发控制</h3><h4 id="1-什么是MVCC"><a href="#1-什么是MVCC" class="headerlink" title="1. 什么是MVCC"></a><strong>1.</strong> <strong>什么是MVCC</strong></h4><p>MVCC （Multiversion Concurrency Control），多版本并发控制。顾名思义，MVCC 是通过数据行的多个版本管理来实现数据库的<code>并发控制</code>。这项技术使得在InnoDB的事务隔离级别下执行<code>一致性读</code>操作有了保证。换言之，就是为了查询一些正在被另一个事务更新的行，并且可以看到它们被更新之前的值，这样在做查询的时候就不用等待另一个事务释放锁。</p><h4 id="2-快照读与当前读"><a href="#2-快照读与当前读" class="headerlink" title="2. 快照读与当前读"></a><strong>2.</strong> <strong>快照读与当前读</strong></h4><p>MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理<code>读-写冲突</code>，做到即使有读写冲突时，也能做到<code>不加锁</code>，<code>非阻塞并发读</code>，而这个读指的就是<code>快照读</code>, 而非<code>当前读</code>。当前读实际上是一种加锁的操作，是悲观锁的实现。而MVCC本质是采用乐观锁思想的一种方式。</p><h5 id="2-1-快照读"><a href="#2-1-快照读" class="headerlink" title="2.1 快照读"></a><strong>2.1</strong> <strong>快照读</strong></h5><p>快照读又叫一致性读，读取的是快照数据。<strong>不加锁的简单的</strong> <strong>SELECT</strong> <strong>都属于快照读</strong>，即不加锁的非阻塞读。</p><p>之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于MVCC，它在很多情况下，避免了加锁操作，降低了开销。</p><p>既然是基于多版本，那么快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本。</p><p>快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读。</p><h5 id="2-2-当前读"><a href="#2-2-当前读" class="headerlink" title="2.2 当前读"></a><strong>2.2</strong> <strong>当前读</strong></h5><p>当前读读取的是记录的最新版本（最新数据，而不是历史版本的数据），读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。加锁的 SELECT，或者对数据进行增删改都会进行当前读。</p><h4 id="3-复习"><a href="#3-复习" class="headerlink" title="3. 复习"></a><strong>3.</strong> <strong>复习</strong></h4><h5 id="3-1-再谈隔离级别"><a href="#3-1-再谈隔离级别" class="headerlink" title="3.1 再谈隔离级别"></a><strong>3.1</strong> <strong>再谈隔离级别</strong></h5><p>我们知道事务有 4 个隔离级别，可能存在三种并发问题：</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051536648.png" alt="image-20220405153617536"></p><p>另图：</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051536125.png" alt="image-20220405153632021"></p><h5 id="3-2-隐藏字段、Undo-Log版本链"><a href="#3-2-隐藏字段、Undo-Log版本链" class="headerlink" title="3.2 隐藏字段、Undo Log版本链"></a><strong>3.2</strong> <strong>隐藏字段、Undo Log版本链</strong></h5><p>回顾一下undo日志的版本链，对于使用<code>InnoDB</code>存储引擎的表来说，它的聚簇索引记录中都包含两个必要的隐藏列。</p><ul><li><code>trx_id</code>：每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的<code>事务id</code>赋值给trx_id 隐藏列。</li><li><code>roll_pointer</code>：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到 undo日志 中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</li></ul><h4 id="4-MVCC实现原理之ReadView"><a href="#4-MVCC实现原理之ReadView" class="headerlink" title="4. MVCC实现原理之ReadView"></a><strong>4. MVCC实现原理之ReadView</strong></h4><p>MVCC 的实现依赖于：<strong>隐藏字段、Undo Log、Read View</strong>。</p><h5 id="4-1-什么是ReadView"><a href="#4-1-什么是ReadView" class="headerlink" title="4.1 什么是ReadView"></a><strong>4.1</strong> <strong>什么是ReadView</strong></h5><p>ReadView就是事务在使用MVCC机制进行快照读操作时产生的读视图。当事务启动时，会生成数据库系统当前的一个快照，InnoDB为每个事务构造了一个数组，用来记录并维护系统当前<code>活跃事务</code>的ID（“活跃”指的就是，启动了但还没提交）。</p><h5 id="4-2-设计思路"><a href="#4-2-设计思路" class="headerlink" title="4.2 设计思路"></a><strong>4.2</strong> <strong>设计思路</strong></h5><p>使用<code>READ UNCOMMITTED</code>隔离级别的事务，由于可以读到未提交事务修改过的记录，所以直接读取记录的最新版本就好了。</p><p>使用<code>SERIALIZABLE</code>隔离级别的事务，InnoDB规定使用加锁的方式来访问记录。</p><p>使用<code>READ COMMITTED</code>和<code>REPEATABLE READ</code>隔离级别的事务，都必须保证读到<code>已经提交了的</code>事务修改过的记录。假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的，核心问题就是需要判断一下版本链中的哪个版本是当前事务可见的，这是ReadView要解决的主要问题。</p><p>这个ReadView中主要包含4个比较重要的内容，分别如下：</p><ol><li><code>creator_trx_id</code>，创建这个 Read View 的事务 ID。</li></ol><blockquote><p>说明：只有在对表中的记录做改动时（执行INSERT、DELETE、UPDATE这些语句时）才会为事务分配事务id，否则在一个只读事务中的事务id值都默认为0。 </p></blockquote><ol start="2"><li><p><code>trx_ids</code>，表示在生成ReadView时当前系统中活跃的读写事务的<code>事务id列表</code>。 </p></li><li><p><code>up_limit_id</code>，活跃的事务中最小的事务 ID。 </p></li><li><p><code>low_limit_id</code>，表示生成ReadView时系统中应该分配给下一个事务的<code>id</code>值。low_limit_id 是系统最大的事务id值，这里要注意是系统中的事务id，需要区别于正在活跃的事务ID。</p></li></ol><blockquote><p>注意：low_limit_id并不是trx_ids中的最大值，事务id是递增分配的。比如，现在有id为1， 2，3这三个事务，之后id为3的事务提交了。那么一个新的读事务在生成ReadView时，trx_ids就包括1和2，up_limit_id的值就是1，low_limit_id的值就是4。</p></blockquote><h5 id="4-3-ReadView的规则"><a href="#4-3-ReadView的规则" class="headerlink" title="4.3 ReadView的规则"></a><strong>4.3 ReadView的规则</strong></h5><p>有了这个ReadView，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见。</p><ul><li>如果被访问版本的trx_id属性值与ReadView中的<code>creator_trx_id</code>值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。</li><li>如果被访问版本的trx_id属性值小于ReadView中的<code>up_limit_id</code>值，表明生成该版本的事务在当前事务生成ReadView前已经提交，所以该版本可以被当前事务访问。</li><li>如果被访问版本的trx_id属性值大于或等于ReadView中的<code>low_limit_id</code>值，表明生成该版本的事务在当前事务生成ReadView后才开启，所以该版本不可以被当前事务访问。</li><li>如果被访问版本的trx_id属性值在ReadView的<code>up_limit_id</code>和<code>low_limit_id</code>之间，那就需要判断一下trx_id属性值是不是在 trx_ids 列表中。<ul><li>如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问。</li><li>如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。</li></ul></li></ul><h5 id="4-4-MVCC整体操作流程"><a href="#4-4-MVCC整体操作流程" class="headerlink" title="4.4 MVCC整体操作流程"></a><strong>4.4 MVCC整体操作流程</strong></h5><p>了解了这些概念之后，我们来看下当查询一条记录的时候，系统如何通过MVCC找到它：</p><ol><li><p>首先获取事务自己的版本号，也就是事务 ID； </p></li><li><p>获取 ReadView； </p></li><li><p>查询得到的数据，然后与 ReadView 中的事务版本号进行比较；</p></li><li><p>如果不符合 ReadView 规则，就需要从 Undo Log 中获取历史快照；</p></li><li><p>最后返回符合规则的数据。</p></li></ol><p>在隔离级别为读已提交（Read Committed）时，一个事务中的每一次 SELECT 查询都会重新获取一次Read View。</p><p>如表所示：</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051549618.png" alt="image-20220405154948505"></p><blockquote><p>注意，此时同样的查询语句都会重新获取一次 Read View，这时如果 Read View 不同，就可能产生不可重复读或者幻读的情况。</p></blockquote><p>当隔离级别为可重复读的时候，就避免了不可重复读，这是因为一个事务只在第一次 SELECT 的时候会获取一次 Read View，而后面所有的 SELECT 都会复用这个 Read View，如下表所示：</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051550072.png" alt="image-20220405155041964"></p><h4 id="5-举例说明"><a href="#5-举例说明" class="headerlink" title="5. 举例说明"></a><strong>5.</strong> <strong>举例说明</strong></h4><h5 id="5-1-READ-COMMITTED隔离级别下"><a href="#5-1-READ-COMMITTED隔离级别下" class="headerlink" title="5.1 READ COMMITTED隔离级别下"></a><strong>5.1 READ COMMITTED隔离级别下</strong></h5><p><strong>READ COMMITTED</strong> <strong>：每次读取数据前都生成一个ReadView</strong>。</p><h5 id="5-2-REPEATABLE-READ隔离级别下"><a href="#5-2-REPEATABLE-READ隔离级别下" class="headerlink" title="5.2 REPEATABLE READ隔离级别下"></a><strong>5.2 REPEATABLE READ隔离级别下</strong></h5><p>使用<code>REPEATABLE READ</code>隔离级别的事务来说，只会在第一次执行查询语句时生成一个 ReadView ，之后的查询就不会重复生成了。</p><h5 id="5-3-如何解决幻读"><a href="#5-3-如何解决幻读" class="headerlink" title="5.3 如何解决幻读"></a><strong>5.3</strong> <strong>如何解决幻读</strong></h5><p>假设现在表 student 中只有一条数据，数据内容中，主键 id&#x3D;1，隐藏的 trx_id&#x3D;10，它的 undo log 如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051556631.png" alt="image-20220405155640520"></p><p>假设现在有事务 A 和事务 B 并发执行，<code>事务 A</code>的事务 id 为<code>20</code>，<code>事务 B</code>的事务 id 为<code>30</code>。</p><p>步骤1：事务 A 开始第一次查询数据，查询的 SQL 语句如下。</p><pre><code class="mysql">select * from student where id &gt;= 1;</code></pre><p>在开始查询之前，MySQL 会为事务 A 产生一个 ReadView，此时 ReadView 的内容如下：<code>trx_ids= [20,30]</code>，<code>up_limit_id=20</code>，<code>low_limit_id=31</code>，<code>creator_trx_id=20</code>。</p><p>由于此时表 student 中只有一条数据，且符合 where id&gt;&#x3D;1 条件，因此会查询出来。然后根据 ReadView机制，发现该行数据的trx_id&#x3D;10，小于事务 A 的 ReadView 里 up_limit_id，这表示这条数据是事务 A 开启之前，其他事务就已经提交了的数据，因此事务 A 可以读取到。</p><p>结论：事务 A 的第一次查询，能读取到一条数据，id&#x3D;1。</p><p>步骤2：接着事务 B(trx_id&#x3D;30)，往表 student 中新插入两条数据，并提交事务。</p><pre><code class="mysql">insert into student(id,name) values(2,&#39;李四&#39;); insert into student(id,name) values(3,&#39;王五&#39;);</code></pre><p>此时表student 中就有三条数据了，对应的 undo 如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051559345.png" alt="image-20220405155909223"></p><p>步骤3：接着事务 A 开启第二次查询，根据可重复读隔离级别的规则，此时事务 A 并不会再重新生成ReadView。此时表 student 中的 3 条数据都满足 where id&gt;&#x3D;1 的条件，因此会先查出来。然后根据ReadView 机制，判断每条数据是不是都可以被事务 A 看到。</p><p>1）首先 id&#x3D;1 的这条数据，前面已经说过了，可以被事务 A 看到。</p><p>2）然后是 id&#x3D;2 的数据，它的 trx_id&#x3D;30，此时事务 A 发现，这个值处于 up_limit_id 和 low_limit_id 之间，因此还需要再判断 30 是否处于 trx_ids 数组内。由于事务 A 的 trx_ids&#x3D;[20,30]，因此在数组内，这表示 id&#x3D;2 的这条数据是与事务 A 在同一时刻启动的其他事务提交的，所以这条数据不能让事务 A 看到。</p><p>3）同理，id&#x3D;3 的这条数据，trx_id 也为 30，因此也不能被事务 A 看见。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051559867.png" alt="image-20220405155941753"></p><p>结论：最终事务 A 的第二次查询，只能查询出 id&#x3D;1 的这条数据。这和事务 A 的第一次查询的结果是一样的，因此没有出现幻读现象，所以说在 MySQL 的可重复读隔离级别下，不存在幻读问题。</p><h4 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a><strong>6.</strong> <strong>总结</strong></h4><p>这里介绍了<code>MVCC</code>在<code>READ COMMITTD</code>、<code>REPEATABLE READ</code>这两种隔离级别的事务在执行快照读操作时访问记录的版本链的过程。这样使不同事务的<code>读-写</code>、<code>写-读</code>操作并发执行，从而提升系统性能。</p><p>核心点在于 ReadView 的原理，<code>READ COMMITTD</code>、<code>REPEATABLE READ</code>这两个隔离级别的一个很大不同就是生成ReadView的时机不同：</p><ul><li><code>READ COMMITTD</code>在每一次进行普通SELECT操作前都会生成一个ReadView </li><li><code>REPEATABLE READ</code>只在第一次进行普通SELECT操作前生成一个ReadView，之后的查询操作都重复使用这个ReadView就好了。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第14章 MySql事务日志</title>
      <link href="/2023/07/15/%E7%AC%AC14%E7%AB%A0%20MySQL%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97/"/>
      <url>/2023/07/15/%E7%AC%AC14%E7%AB%A0%20MySQL%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h3 id="第14章-MySQL事务日志"><a href="#第14章-MySQL事务日志" class="headerlink" title="第14章 MySQL事务日志"></a>第14章 MySQL事务日志</h3><p>事务有4种特性：原子性、一致性、隔离性和持久性。那么事务的四种特性到底是基于什么机制实现呢？</p><ul><li>事务的隔离性由<code>锁机制</code>实现。</li><li>而事务的原子性、一致性和持久性由事务的 redo 日志和undo 日志来保证。<ul><li>REDO LOG 称为<code>重做日志</code>，提供再写入操作，恢复提交事务修改的页操作，用来保证事务的持久性。</li><li>UNDO LOG 称为<code>回滚日志</code>，回滚行记录到某个特定版本，用来保证事务的原子性、一致性。</li></ul></li></ul><h4 id="1-redo日志"><a href="#1-redo日志" class="headerlink" title="1. redo日志"></a><strong>1. redo日志</strong></h4><h5 id="1-1-为什么需要REDO日志"><a href="#1-1-为什么需要REDO日志" class="headerlink" title="1.1 为什么需要REDO日志"></a><strong>1.1</strong> <strong>为什么需要REDO日志</strong></h5><p>一方面，缓冲池可以帮助我们消除CPU和磁盘之间的鸿沟，checkpoint机制可以保证数据的最终落盘，然而由于checkpoint<code>并不是每次变更的时候就触发</code>的，而是master线程隔一段时间去处理的。所以最坏的情况就是事务提交后，刚写完缓冲池，数据库宕机了，那么这段数据就是丢失的，无法恢复。</p><p>另一方面，事务包含<code>持久性</code>的特性，就是说对于一个已经提交的事务，在事务提交后即使系统发生了崩溃，这个事务对数据库中所做的更改也不能丢失。</p><p>那么如何保证这个持久性呢？<code>一个简单的做法</code>：在事务提交完成之前把该事务所修改的所有页面都刷新到磁盘，但是这个简单粗暴的做法有些问题</p><p><code>另一个解决的思路</code>：我们只是想让已经提交了的事务对数据库中数据所做的修改永久生效，即使后来系统崩溃，在重启后也能把这种修改恢复出来。所以我们其实没有必要在每次事务提交时就把该事务在内存中修改过的全部页面刷新到磁盘，只需要把<code>修改</code>了哪些东西<code>记录一下</code>就好。比如，某个事务将系统表空间中<code>第10号</code>页面中偏移量为<code>100</code>处的那个字节的值<code>1</code>改成<code>2</code>。我们只需要记录一下：将第0号表空间的10号页面的偏移量为100处的值更新为 2 。</p><h5 id="1-2-REDO日志的好处、特点"><a href="#1-2-REDO日志的好处、特点" class="headerlink" title="1.2 REDO日志的好处、特点"></a><strong>1.2 REDO日志的好处、特点</strong></h5><p><strong>1.</strong> <strong>好处</strong></p><ul><li><strong>redo日志降低了刷盘频率</strong></li><li><strong>redo日志占用的空间非常小</strong></li></ul><p><strong>2.</strong> <strong>特点</strong></p><ul><li><strong>redo日志是顺序写入磁盘的</strong></li><li><strong>事务执行过程中，redo log不断记录</strong></li></ul><h5 id="1-3-redo的组成"><a href="#1-3-redo的组成" class="headerlink" title="1.3 redo的组成"></a><strong>1.3 redo的组成</strong></h5><p>Redo log可以简单分为以下两个部分：</p><ul><li><code>重做日志的缓冲 (redo log buffer) </code>，保存在内存中，是易失的。</li></ul><p><strong>参数设置：innodb_log_buffer_size：</strong></p><p>redo log buffer 大小，默认<code>16M</code>，最大值是4096M，最小值为1M。 </p><ul><li><code>重做日志文件 (redo log file)</code>，保存在硬盘中，是持久的。</li></ul><h5 id="1-4-redo的整体流程"><a href="#1-4-redo的整体流程" class="headerlink" title="1.4 redo的整体流程"></a><strong>1.4 redo的整体流程</strong></h5><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204031147714.png" alt="image-20220403114709581"></p><p>第1步：先将原始数据从磁盘中读入内存中来，修改数据的内存拷贝 </p><p>第2步：生成一条重做日志并写入redo log buffer，记录的是数据被修改后的值 </p><p>第3步：当事务commit时，将redo log buffer中的内容刷新到 redo log file，对 redo log file采用追加写的方式 </p><p>第4步：定期将内存中修改的数据刷新到磁盘中</p><blockquote><p>Write-Ahead Log(预先日志持久化)：在持久化一个数据页之前，先将内存中相应的日志页持久化。</p></blockquote><h5 id="1-5-redo-log的刷盘策略"><a href="#1-5-redo-log的刷盘策略" class="headerlink" title="1.5 redo log的刷盘策略"></a><strong>1.5 redo log的刷盘策略</strong></h5><p>redo log buffer刷盘到redo log file的过程并不是真正的刷到磁盘中去，只是刷入到<code>文件系统缓存</code>（page cache）中去（这是现代操作系统为了提高文件写入效率做的一个优化），真正的写入会交给系统自己来决定（比如page cache足够大了）。那么对于InnoDB来说就存在一个问题，如果交给系统来同步，同样如果系统宕机，那么数据也丢失了（虽然整个系统宕机的概率还是比较小的）。</p><p>针对这种情况，InnoDB给出<code>innodb_flush_log_at_trx_commit</code>参数，该参数控制 commit提交事务时，如何将 redo log buffer 中的日志刷新到 redo log file 中。它支持三种策略：</p><ul><li><code>设置为0</code>：表示每次事务提交时不进行刷盘操作。（系统默认master thread每隔1s进行一次重做日志的同步）</li><li><code>设置为1</code>：表示每次事务提交时都将进行同步，刷盘操作（<code>默认值</code>） </li><li><code>设置为2</code>：表示每次事务提交时都只把 redo log buffer 内容写入 page cache，不进行同步。由os自己决定什么时候同步到磁盘文件。</li></ul><h5 id="1-6-不同刷盘策略演示"><a href="#1-6-不同刷盘策略演示" class="headerlink" title="1.6 不同刷盘策略演示"></a><strong>1.6</strong> <strong>不同刷盘策略演示</strong></h5><p><strong>1.</strong> <strong>流程图</strong></p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204031152952.png" alt="image-20220403115232833"></p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204031152607.png" alt="image-20220403115249492"></p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204031153931.png" alt="image-20220403115300809"></p><h5 id="1-7-写入redo-log-buffer过程"><a href="#1-7-写入redo-log-buffer过程" class="headerlink" title="1.7 写入redo log buffer过程"></a><strong>1.7</strong> <strong>写入redo log buffer过程</strong></h5><p><strong>1.</strong> <strong>补充概念：Mini-Transaction</strong></p><p>一个事务可以包含若干条语句，每一条语句其实是由若干个<code>mtr</code>组成，每一个<code>mtr</code>又可以包含若干条redo日志</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204040912119.png" alt="image-20220404091224993"></p><p><strong>2. redo</strong> <strong>日志写入log buffer</strong></p><p>不同的事务可能是<code>并发</code>执行的，所以<code>事务T1</code>、<code>事务T2</code>之间的<code>mtr</code>可能是<code>交替执行</code>的。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204040915708.png" alt="image-20220404091511602"></p><h5 id="1-8-redo-log-file"><a href="#1-8-redo-log-file" class="headerlink" title="1.8 redo log file"></a><strong>1.8 redo log file</strong></h5><p><strong>1.</strong> <strong>相关参数设置</strong> </p><ul><li><p><code>innodb_log_group_home_dir</code>：指定 redo log 文件组所在的路径，默认值为<code>./</code>，表示在数据库的数据目录下。MySQL的默认数据目录（<code>var/lib/mysql</code>）下默认有两个名为<code>ib_logfile0</code>和<code>ib_logfile1</code>的文件，log buffer中的日志默认情况下就是刷新到这两个磁盘文件中。此redo日志文件位置还可以修改。</p></li><li><p><code>innodb_log_files_in_group</code>：指明redo log file的个数，命名方式如：ib_logfile0，ib_logfile1… ib_logfilen。默认2个，最大100个。</p></li><li><p><code>innodb_flush_log_at_trx_commit</code>：控制 redo log 刷新到磁盘的策略，默认为<code>1</code>。 </p></li><li><p><code>innodb_log_file_size</code>：单个 redo log 文件设置大小，默认值为 48M 。最大值为512G，注意最大值指的是整个 redo log 系列文件之和，即（innodb_log_files_in_group * innodb_log_file_size ）不能大于最大值512G。</p></li></ul><p><strong>2.</strong> <strong>日志文件组</strong></p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204040920532.png" alt="image-20220404092038421"></p><p><strong>3. checkpoint</strong></p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204040921715.png" alt="image-20220404092106617"></p><p>如果 write pos 追上 checkpoint ，表示<strong>日志文件组</strong>满了，这时候不能再写入新的 redo log记录，MySQL 得停下来，清空一些记录，把 checkpoint 推进一下。</p><h4 id="2-Undo日志"><a href="#2-Undo日志" class="headerlink" title="2. Undo日志"></a><strong>2. Undo日志</strong></h4><p>redo log是事务持久性的保证，undo log是事务原子性的保证。在事务中<code>更新数据</code>的<code>前置操作</code>其实是要先写入一个 undo log 。</p><h5 id="2-1-如何理解Undo日志"><a href="#2-1-如何理解Undo日志" class="headerlink" title="2.1 如何理解Undo日志"></a><strong>2.1</strong> <strong>如何理解Undo日志</strong></h5><p>事务需要保证<code>原子性</code>，也就是事务中的操作要么全部完成，要么什么也不做。但有时候事务执行到一半会出现一些情况，比如：</p><ul><li>情况一：事务执行过程中可能遇到各种错误，比如<code>服务器本身的错误</code>，<code>操作系统错误</code>，甚至是突然<code>断电</code>导致的错误。</li><li>情况二：程序员可以在事务执行过程中手动输入<code>ROLLBACK</code>语句结束当前事务的执行。</li></ul><p>以上情况出现，我们需要把数据改回原先的样子，这个过程称之为<code>回滚</code>，这样就可以造成一个假象：这个事务看起来什么都没做，所以符合<code>原子性</code>要求。</p><h5 id="2-2-Undo日志的作用"><a href="#2-2-Undo日志的作用" class="headerlink" title="2.2 Undo日志的作用"></a><strong>2.2 Undo日志的作用</strong></h5><ul><li><strong>作用1：回滚数据</strong></li><li><strong>作用2：MVCC（详情看第16章）</strong></li></ul><h5 id="2-3-undo的存储结构"><a href="#2-3-undo的存储结构" class="headerlink" title="2.3 undo的存储结构"></a><strong>2.3 undo的存储结构</strong></h5><p><strong>1.</strong> <strong>回滚段与undo页</strong></p><p>InnoDB对undo log的管理采用段的方式，也就是<code>回滚段（rollback segment）</code>。每个回滚段记录了<code>1024</code>个<code>undo log segment</code>，而在每个undo log segment段中进行<code>undo页</code>的申请。</p><p><strong>2.</strong> <strong>回滚段与事务</strong> </p><ol><li><p>每个事务只会使用一个回滚段，一个回滚段在同一时刻可能会服务于多个事务。</p></li><li><p>当一个事务开始的时候，会制定一个回滚段，在事务进行的过程中，当数据被修改时，原始的数据会被复制到回滚段。</p></li><li><p>在回滚段中，事务会不断填充盘区，直到事务结束或所有的空间被用完。如果当前的盘区不够用，事务会在段中请求扩展下一个盘区，如果所有已分配的盘区都被用完，事务会覆盖最初的盘区或者在回滚段允许的情况下扩展新的盘区来使用。</p></li><li><p>回滚段存在于undo表空间中，在数据库中可以存在多个undo表空间，但同一时刻只能使用一个undo表空间。</p></li><li><p>当事务提交时，InnoDB存储引擎会做以下两件事情：</p><ul><li>将undo log放入列表中，以供之后的purge操作</li><li>判断undo log所在的页是否可以重用，若可以分配给下个事务使用</li></ul></li></ol><p><strong>3.</strong> <strong>回滚段中的数据分类</strong></p><ol><li><p>未提交的回滚数据(uncommitted undo information) </p></li><li><p>已经提交但未过期的回滚数据(committed undo information) </p></li><li><p>事务已经提交并过期的数据(expired undo information)</p></li></ol><h5 id="2-4-undo的类型"><a href="#2-4-undo的类型" class="headerlink" title="2.4 undo的类型"></a><strong>2.4 undo的类型</strong></h5><p>在InnoDB存储引擎中，undo log分为：</p><ul><li>insert undo log </li><li>update undo log</li></ul><h5 id="2-5-undo-log的生命周期"><a href="#2-5-undo-log的生命周期" class="headerlink" title="2.5 undo log的生命周期"></a><strong>2.5 undo log的生命周期</strong></h5><p><strong>1.</strong> <strong>简要生成过程</strong></p><p><strong>只有Buffer Pool的流程：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204040937761.png" alt="image-20220404093706650"></p><p><strong>有了Redo Log和Undo Log之后：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204040938657.png" alt="image-20220404093832512"></p><p><strong>2.</strong> <strong>详细生成过程</strong></p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204040939231.png" alt="image-20220404093950136"></p><p><strong>当我们执行INSERT时：</strong></p><pre><code class="mysql">begin; INSERT INTO user (name) VALUES (&quot;tom&quot;);</code></pre><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204040940543.png" alt="image-20220404094033441"></p><p><strong>当我们执行UPDATE时：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204040941624.png" alt="image-20220404094105525"></p><pre><code class="mysql">UPDATE user SET id=2 WHERE id=1;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204040941449.png" alt="image-20220404094142337"></p><p><strong>3. undo log是如何回滚的</strong></p><p>以上面的例子来说，假设执行rollback，那么对应的流程应该是这样：</p><ol><li><p>通过undo no&#x3D;3的日志把id&#x3D;2的数据删除</p></li><li><p>通过undo no&#x3D;2的日志把id&#x3D;1的数据的deletemark还原成0 </p></li><li><p>通过undo no&#x3D;1的日志把id&#x3D;1的数据的name还原成Tom </p></li><li><p>通过undo no&#x3D;0的日志把id&#x3D;1的数据删除</p></li></ol><p><strong>4. undo log的删除</strong></p><ul><li>针对于insert undo log</li></ul><p>因为insert操作的记录，只对事务本身可见，对其他事务不可见。故该undo log可以在事务提交后直接删除，不需要进行purge操作。</p><ul><li>针对于update undo log</li></ul><p>该undo log可能需要提供MVCC机制，因此不能在事务提交时就进行删除。提交时放入undo log链表，等待purge线程进行最后的删除。</p><h5 id="2-6-小结"><a href="#2-6-小结" class="headerlink" title="2.6 小结"></a><strong>2.6</strong> <strong>小结</strong></h5><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204040944948.png" alt="image-20220404094436830"></p><p>undo log是逻辑日志，对事务回滚时，只是将数据库逻辑地恢复到原来的样子。</p><p>redo log是物理日志，记录的是数据页的物理变化，undo log不是redo log的逆过程。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第17章 其它数据库日志</title>
      <link href="/2023/07/15/%E7%AC%AC17%E7%AB%A0%20%E5%85%B6%E5%AE%83%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%A5%E5%BF%97/"/>
      <url>/2023/07/15/%E7%AC%AC17%E7%AB%A0%20%E5%85%B6%E5%AE%83%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h3 id="第17章-其它数据库日志"><a href="#第17章-其它数据库日志" class="headerlink" title="第17章 其它数据库日志"></a>第17章 其它数据库日志</h3><h4 id="1-MySQL支持的日志"><a href="#1-MySQL支持的日志" class="headerlink" title="1. MySQL支持的日志"></a><strong>1. MySQL支持的日志</strong></h4><h5 id="1-1-日志类型"><a href="#1-1-日志类型" class="headerlink" title="1.1 日志类型"></a><strong>1.1</strong> <strong>日志类型</strong></h5><p>MySQL有不同类型的日志文件，用来存储不同类型的日志，分为<code>二进制日志</code>、<code>错误日志</code>、<code>通用查询日志</code>和<code>慢查询日志</code>，这也是常用的4种。MySQL 8又新增两种支持的日志：<code>中继日志</code>和<code>数据定义语句日志</code>。使用这些日志文件，可以查看MySQL内部发生的事情。</p><ul><li><p><strong>慢查询日志：</strong>记录所有执行时间超过long_query_time的所有查询，方便我们对查询进行优化。</p></li><li><p><strong>通用查询日志：</strong>记录所有连接的起始时间和终止时间，以及连接发送给数据库服务器的所有指令，对我们复原操作的实际场景、发现问题，甚至是对数据库操作的审计都有很大的帮助。</p></li><li><p><strong>错误日志：</strong>记录MySQL服务的启动、运行或停止MySQL服务时出现的问题，方便我们了解服务器的状态，从而对服务器进行维护。</p></li><li><p><strong>二进制日志：</strong>记录所有更改数据的语句，可以用于主从服务器之间的数据同步，以及服务器遇到故障时数据的无损失恢复。</p></li><li><p><strong>中继日志：</strong>用于主从服务器架构中，从服务器用来存放主服务器二进制日志内容的一个中间文件。从服务器通过读取中继日志的内容，来同步主服务器上的操作。</p></li><li><p><strong>数据定义语句日志：</strong>记录数据定义语句执行的元数据操作。</p></li></ul><p>除二进制日志外，其他日志都是<code>文本文件</code>。默认情况下，所有日志创建于<code>MySQL数据目录</code>中。</p><h5 id="1-2-日志的弊端"><a href="#1-2-日志的弊端" class="headerlink" title="1.2 日志的弊端"></a><strong>1.2</strong> <strong>日志的弊端</strong></h5><ul><li><p>日志功能会<code>降低MySQL数据库的性能</code>。</p></li><li><p>日志会<code>占用大量的磁盘空间</code>。</p></li></ul><h4 id="2-通用查询日志-general-query-log"><a href="#2-通用查询日志-general-query-log" class="headerlink" title="2. 通用查询日志(general query log)"></a><strong>2.</strong> <strong>通用查询日志(general query log)</strong></h4><p>通用查询日志用来<code>记录用户的所有操作</code>，包括启动和关闭MySQL服务、所有用户的连接开始时间和截止时间、发给 MySQL 数据库服务器的所有 SQL 指令等。当我们的数据发生异常时，<strong>查看通用查询日志，还原操作时的具体场景</strong>，可以帮助我们准确定位问题。</p><h5 id="2-1-查看当前状态"><a href="#2-1-查看当前状态" class="headerlink" title="2.1 查看当前状态"></a><strong>2.1</strong> <strong>查看当前状态</strong></h5><pre><code class="mysql">mysql&gt; SHOW VARIABLES LIKE &#39;%general%&#39;;</code></pre><h5 id="2-2-启动日志"><a href="#2-2-启动日志" class="headerlink" title="2.2 启动日志"></a><strong>2.2</strong> <strong>启动日志</strong></h5><p><strong>方式1：永久性方式</strong></p><pre><code class="ini">[mysqld] general_log=ON general_log_file=[path[filename]] #日志文件所在目录路径，filename为日志文件名</code></pre><p><strong>方式2：临时性方式</strong></p><pre><code class="mysql">SET GLOBAL general_log=on; # 开启通用查询日志SET GLOBAL general_log_file=’path/filename’; # 设置日志文件保存位置SET GLOBAL general_log=off; # 关闭通用查询日志SHOW VARIABLES LIKE &#39;general_log%&#39;; # 查看设置后情况</code></pre><h5 id="2-3-停止日志"><a href="#2-3-停止日志" class="headerlink" title="2.3 停止日志"></a><strong>2.3</strong> <strong>停止日志</strong></h5><p><strong>方式1：永久性方式</strong></p><pre><code class="ini">[mysqld] general_log=OFF</code></pre><p><strong>方式2：临时性方式</strong></p><pre><code class="mysql">SET GLOBAL general_log=off;SHOW VARIABLES LIKE &#39;general_log%&#39;;</code></pre><h4 id="3-错误日志-error-log"><a href="#3-错误日志-error-log" class="headerlink" title="3.错误日志(error log)"></a><strong>3.错误日志(error log)</strong></h4><h5 id="3-1-启动日志"><a href="#3-1-启动日志" class="headerlink" title="3.1 启动日志"></a><strong>3.1</strong> <strong>启动日志</strong></h5><p>在MySQL数据库中，错误日志功能是<code>默认开启</code>的。而且，错误日志<code>无法被禁止</code>。</p><pre><code class="ini">[mysqld] log-error=[path/[filename]] #path为日志文件所在的目录路径，filename为日志文件名</code></pre><h5 id="3-2-查看日志"><a href="#3-2-查看日志" class="headerlink" title="3.2 查看日志"></a><strong>3.2</strong> <strong>查看日志</strong></h5><pre><code class="mysql">mysql&gt; SHOW VARIABLES LIKE &#39;log_err%&#39;;</code></pre><h5 id="3-3-删除-刷新日志"><a href="#3-3-删除-刷新日志" class="headerlink" title="3.3 删除\刷新日志"></a><strong>3.3</strong> <strong>删除\刷新日志</strong></h5><pre><code class="shell">install -omysql -gmysql -m0644 /dev/null /var/log/mysqld.logmysqladmin -uroot -p flush-logs</code></pre><h4 id="4-二进制日志-bin-log"><a href="#4-二进制日志-bin-log" class="headerlink" title="4. 二进制日志(bin log)"></a><strong>4.</strong> <strong>二进制日志(bin log)</strong></h4><h5 id="4-1-查看默认情况"><a href="#4-1-查看默认情况" class="headerlink" title="4.1 查看默认情况"></a><strong>4.1</strong> <strong>查看默认情况</strong></h5><pre><code class="mysql">mysql&gt; show variables like &#39;%log_bin%&#39;;</code></pre><h5 id="4-2-日志参数设置"><a href="#4-2-日志参数设置" class="headerlink" title="4.2 日志参数设置"></a><strong>4.2</strong> <strong>日志参数设置</strong></h5><p><strong>方式1：永久性方式</strong></p><pre><code class="ini">[mysqld] #启用二进制日志 log-bin=atguigu-bin binlog_expire_logs_seconds=600 max_binlog_size=100M</code></pre><p><strong>设置带文件夹的bin-log日志存放目录</strong></p><pre><code class="ini">[mysqld] log-bin=&quot;/var/lib/mysql/binlog/atguigu-bin&quot;</code></pre><p>注意：新建的文件夹需要使用mysql用户，使用下面的命令即可。</p><pre><code class="shell">chown -R -v mysql:mysql binlog</code></pre><p><strong>方式2：临时性方式</strong></p><pre><code class="mysql"># global 级别 mysql&gt; set global sql_log_bin=0; ERROR 1228 (HY000): Variable &#39;sql_log_bin&#39; is a SESSION variable and can`t be used with SET GLOBAL # session级别 mysql&gt; SET sql_log_bin=0; Query OK, 0 rows affected (0.01 秒)</code></pre><h5 id="4-3-查看日志"><a href="#4-3-查看日志" class="headerlink" title="4.3 查看日志"></a><strong>4.3</strong> <strong>查看日志</strong></h5><pre><code class="mysql">mysqlbinlog -v &quot;/var/lib/mysql/binlog/atguigu-bin.000002&quot;# 不显示binlog格式的语句mysqlbinlog -v --base64-output=DECODE-ROWS &quot;/var/lib/mysql/binlog/atguigu-bin.000002&quot;</code></pre><pre><code class="mysql"># 可查看参数帮助 mysqlbinlog --no-defaults --help # 查看最后100行 mysqlbinlog --no-defaults --base64-output=decode-rows -vv atguigu-bin.000002 |tail -100 # 根据position查找 mysqlbinlog --no-defaults --base64-output=decode-rows -vv atguigu-bin.000002 |grep -A20 &#39;4939002&#39;</code></pre><p>上面这种办法读取出binlog日志的全文内容比较多，不容易分辨查看到pos点信息，下面介绍一种更为方便的查询命令：</p><pre><code class="mysql">mysql&gt; show binlog events [IN &#39;log_name&#39;] [FROM pos] [LIMIT [offset,] row_count];</code></pre><ul><li><code>IN &#39;log_name&#39;</code>：指定要查询的binlog文件名（不指定就是第一个binlog文件）　</li><li><code>FROM pos</code>：指定从哪个pos起始点开始查起（不指定就是从整个文件首个pos点开始算）</li><li><code>LIMIT [offset]</code>：偏移量(不指定就是0) </li><li><code>row_count</code>:查询总条数（不指定就是所有行）</li></ul><pre><code class="mysql">mysql&gt; show binlog events in &#39;atguigu-bin.000002&#39;;</code></pre><h5 id="4-4-使用日志恢复数据"><a href="#4-4-使用日志恢复数据" class="headerlink" title="4.4 使用日志恢复数据"></a><strong>4.4</strong> <strong>使用日志恢复数据</strong></h5><p>mysqlbinlog恢复数据的语法如下：</p><pre><code class="shell">mysqlbinlog [option] filename|mysql –uuser -ppass;</code></pre><ul><li><code>filename</code>：是日志文件名。</li><li><code>option</code>：可选项，比较重要的两对option参数是–start-date、–stop-date 和 –start-position、– stop-position。 <ul><li><code>--start-date 和 --stop-date</code>：可以指定恢复数据库的起始时间点和结束时间点。</li><li><code>--start-position和--stop-position</code>：可以指定恢复数据的开始位置和结束位置。</li></ul></li></ul><blockquote><p>注意：使用mysqlbinlog命令进行恢复操作时，必须是编号小的先恢复，例如atguigu-bin.000001必须在atguigu-bin.000002之前恢复。</p></blockquote><h5 id="4-5-删除二进制日志"><a href="#4-5-删除二进制日志" class="headerlink" title="4.5 删除二进制日志"></a><strong>4.5</strong> <strong>删除二进制日志</strong></h5><p><strong>1. PURGE MASTER LOGS：删除指定日志文件</strong></p><pre><code class="mysql">PURGE &#123;MASTER | BINARY&#125; LOGS TO ‘指定日志文件名’ PURGE &#123;MASTER | BINARY&#125; LOGS BEFORE ‘指定日期’</code></pre><h4 id="5-再谈二进制日志-binlog"><a href="#5-再谈二进制日志-binlog" class="headerlink" title="5. 再谈二进制日志(binlog)"></a><strong>5.</strong> <strong>再谈二进制日志(binlog)</strong></h4><h5 id="5-1-写入机制"><a href="#5-1-写入机制" class="headerlink" title="5.1 写入机制"></a><strong>5.1</strong> <strong>写入机制</strong></h5><p>binlog的写入时机也非常简单，事务执行过程中，先把日志写到<code>binlog cache</code>，事务提交的时候，再把binlog cache写到binlog文件中。因为一个事务的binlog不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为binlog cache。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051630535.png" alt="image-20220405163025361"></p><p>write和fsync的时机，可以由参数<code>sync_binlog</code>控制，默认是 <code>0</code>。为0的时候，表示每次提交事务都只write，由系统自行判断什么时候执行fsync。虽然性能得到提升，但是机器宕机，page cache里面的binglog 会丢失。如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051631346.png" alt="image-20220405163125180"></p><p>为了安全起见，可以设置为<code>1</code>，表示每次提交事务都会执行fsync，就如同<strong>redo log</strong> <strong>刷盘流程</strong>一样。最后还有一种折中方式，可以设置为N(N&gt;1)，表示每次提交事务都write，但累积N个事务后才fsync。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051632526.png" alt="image-20220405163205364"></p><p>在出现IO瓶颈的场景里，将sync_binlog设置成一个比较大的值，可以提升性能。同样的，如果机器宕机，会丢失最近N个事务的binlog日志。</p><h5 id="5-2-binlog与redolog对比"><a href="#5-2-binlog与redolog对比" class="headerlink" title="5.2 binlog与redolog对比"></a><strong>5.2 binlog与redolog对比</strong></h5><ul><li>redo log 它是<code>物理日志</code>，记录内容是“在某个数据页上做了什么修改”，属于 InnoDB 存储引擎层产生的。</li><li>而 binlog 是<code>逻辑日志</code>，记录内容是语句的原始逻辑，类似于“给 ID&#x3D;2 这一行的 c 字段加 1”，属于MySQL Server 层。</li><li>虽然它们都属于持久化的保证，但是侧重点不同。<ul><li>redo log 让InnoDB存储引擎拥有了崩溃恢复能力。</li><li>binlog保证了MySQL集群架构的数据一致性</li></ul></li></ul><h5 id="5-3-两阶段提交"><a href="#5-3-两阶段提交" class="headerlink" title="5.3 两阶段提交"></a><strong>5.3</strong> <strong>两阶段提交</strong></h5><p>在执行更新语句过程，会记录redo log与binlog两块日志，以基本的事务为单位，redo log在事务执行过程中可以不断写入，而binlog只有在提交事务时才写入，所以redo log与binlog的<code>写入时机</code>不一样。</p><p>为了解决两份日志之间的逻辑一致问题，InnoDB存储引擎使用<strong>两阶段提交</strong>方案。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051637390.png" alt="image-20220405163716222"></p><p>使用<strong>两阶段提交</strong>后，写入binlog时发生异常也不会有影响</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051639192.png" alt="image-20220405163902977"></p><p>另一个场景，redo log设置commit阶段发生异常，那会不会回滚事务呢？</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051639403.png" alt="image-20220405163927129"></p><p>并不会回滚事务，它会执行上图框住的逻辑，虽然redo log是处于prepare阶段，但是能通过事务id找到对应的binlog日志，所以MySQL认为是完整的，就会提交事务恢复数据。</p><h4 id="6-中继日志-relay-log"><a href="#6-中继日志-relay-log" class="headerlink" title="6. 中继日志(relay log)"></a><strong>6.</strong> <strong>中继日志(relay log)</strong></h4><h5 id="6-1-介绍"><a href="#6-1-介绍" class="headerlink" title="6.1 介绍"></a><strong>6.1</strong> <strong>介绍</strong></h5><p><strong>中继日志只在主从服务器架构的从服务器上存在</strong>。从服务器为了与主服务器保持一致，要从主服务器读取二进制日志的内容，并且把读取到的信息写入<code>本地的日志文件</code>中，这个从服务器本地的日志文件就叫<code>中继日志</code>。然后，从服务器读取中继日志，并根据中继日志的内容对从服务器的数据进行更新，完成主从服务器的<code>数据同步</code>。</p><h5 id="6-2-恢复的典型错误"><a href="#6-2-恢复的典型错误" class="headerlink" title="6.2 恢复的典型错误"></a><strong>6.2</strong> <strong>恢复的典型错误</strong></h5><p>如果从服务器宕机，有的时候为了系统恢复，要重装操作系统，这样就可能会导致你的<code>服务器名称</code>与之前<code>不同</code>。而中继日志里是<code>包含从服务器名</code>的。在这种情况下，就可能导致你恢复从服务器的时候，无法从宕机前的中继日志里读取数据，以为是日志文件损坏了，其实是名称不对了。</p><p>解决的方法也很简单，把从服务器的名称改回之前的名称。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第19章 数据库备份与恢复</title>
      <link href="/2023/07/15/%E7%AC%AC18%E7%AB%A0%20%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
      <url>/2023/07/15/%E7%AC%AC18%E7%AB%A0%20%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="第18章-主从复制"><a href="#第18章-主从复制" class="headerlink" title="第18章 主从复制"></a>第18章 主从复制</h3><h4 id="1-主从复制概述"><a href="#1-主从复制概述" class="headerlink" title="1. 主从复制概述"></a><strong>1.</strong> <strong>主从复制概述</strong></h4><h5 id="1-1-如何提升数据库并发能力"><a href="#1-1-如何提升数据库并发能力" class="headerlink" title="1.1 如何提升数据库并发能力"></a><strong>1.1</strong> <strong>如何提升数据库并发能力</strong></h5><p>一般应用对数据库而言都是“<code>读多写少</code>”，也就说对数据库读取数据的压力比较大，有一个思路就是采用数据库集群的方案，做<code>主从架构</code>、进行<code>读写分离</code>，这样同样可以提升数据库的并发处理能力。但并不是所有的应用都需要对数据库进行主从架构的设置，毕竟设置架构本身是有成本的。</p><p>如果我们的目的在于提升数据库高并发访问的效率，那么首先考虑的是如何<code>优化SQL和索引</code>，这种方式简单有效；其次才是采用<code>缓存的策略</code>，比如使用 Redis将热点数据保存在内存数据库中，提升读取的效率；最后才是对数据库采用<code>主从架构</code>，进行读写分离。</p><h5 id="1-2-主从复制的作用"><a href="#1-2-主从复制的作用" class="headerlink" title="1.2 主从复制的作用"></a><strong>1.2</strong> <strong>主从复制的作用</strong></h5><p><strong>第1个作用：读写分离。</strong></p><p><strong>第2个作用就是数据备份。</strong></p><p><strong>第3个作用是具有高可用性。</strong></p><h4 id="2-主从复制的原理"><a href="#2-主从复制的原理" class="headerlink" title="2. 主从复制的原理"></a><strong>2.</strong> <strong>主从复制的原理</strong></h4><h5 id="2-1-原理剖析"><a href="#2-1-原理剖析" class="headerlink" title="2.1 原理剖析"></a><strong>2.1</strong> <strong>原理剖析</strong></h5><p><strong>三个线程</strong></p><p>实际上主从同步的原理就是基于 binlog 进行数据同步的。在主从复制过程中，会基于<code>3 个线程</code>来操作，一个主库线程，两个从库线程。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051646097.png" alt="image-20220405164559961"></p><p><code>二进制日志转储线程</code>（Binlog dump thread）是一个主库线程。当从库线程连接的时候， 主库可以将二进制日志发送给从库，当主库读取事件（Event）的时候，会在 Binlog 上<code>加锁</code>，读取完成之后，再将锁释放掉。</p><p><code>从库 I/O 线程</code>会连接到主库，向主库发送请求更新 Binlog。这时从库的 I&#x2F;O 线程就可以读取到主库的二进制日志转储线程发送的 Binlog 更新部分，并且拷贝到本地的中继日志 （Relay log）。</p><p><code>从库 SQL 线程</code>会读取从库中的中继日志，并且执行日志中的事件，将从库中的数据与主库保持同步。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051647759.png" alt="image-20220405164718627"></p><p><strong>复制三步骤</strong></p><p>步骤1：<code>Master</code>将写操作记录到二进制日志（<code>binlog</code>）。</p><p>步骤2：<code>Slave</code>将<code>Master</code>的binary log events拷贝到它的中继日志（<code>relay log</code>）；</p><p>步骤3：<code>Slave</code>重做中继日志中的事件，将改变应用到自己的数据库中。 MySQL复制是异步的且串行化的，而且重启后从<code>接入点</code>开始复制。</p><p><strong>复制的问题</strong></p><p>复制的最大问题：<code>延时</code></p><h5 id="2-2-复制的基本原则"><a href="#2-2-复制的基本原则" class="headerlink" title="2.2 复制的基本原则"></a><strong>2.2</strong> <strong>复制的基本原则</strong></h5><ul><li><p>每个<code>Slave</code>只有一个<code>Master</code></p></li><li><p>每个<code>Slave</code>只能有一个唯一的服务器ID</p></li><li><p>每个<code>Master</code>可以有多个<code>Slave</code></p></li></ul><h4 id="3-同步数据一致性问题"><a href="#3-同步数据一致性问题" class="headerlink" title="3. 同步数据一致性问题"></a><strong>3.</strong> <strong>同步数据一致性问题</strong></h4><p><strong>主从同步的要求：</strong></p><ul><li><p>读库和写库的数据一致(最终一致)；</p></li><li><p>写数据必须写到写库；</p></li><li><p>读数据必须到读库(不一定)；</p></li></ul><h5 id="3-1-理解主从延迟问题"><a href="#3-1-理解主从延迟问题" class="headerlink" title="3.1 理解主从延迟问题"></a><strong>3.1</strong> <strong>理解主从延迟问题</strong></h5><p>进行主从同步的内容是二进制日志，它是一个文件，在进行<code>网络传输</code>的过程中就一定会<code>存在主从延迟</code>（比如 500ms），这样就可能造成用户在从库上读取的数据不是最新的数据，也就是主从同步中的<code>数据不一致性</code>问题。</p><h5 id="3-2-主从延迟问题原因"><a href="#3-2-主从延迟问题原因" class="headerlink" title="3.2 主从延迟问题原因"></a><strong>3.2</strong> <strong>主从延迟问题原因</strong></h5><p>在网络正常的时候，日志从主库传给从库所需的时间是很短的，即T2-T1的值是非常小的。即，网络正常情况下，主备延迟的主要来源是备库接收完binlog和执行完这个事务之间的时间差。</p><p><strong>主备延迟最直接的表现是，从库消费中继日志（relay log）的速度，比主库生产binlog的速度要慢。</strong>造成原因：</p><p>1、从库的机器性能比主库要差</p><p>2、从库的压力大</p><p>3、大事务的执行</p><h5 id="3-3-如何减少主从延迟"><a href="#3-3-如何减少主从延迟" class="headerlink" title="3.3 如何减少主从延迟"></a><strong>3.3</strong> <strong>如何减少主从延迟</strong></h5><p>若想要减少主从延迟的时间，可以采取下面的办法：</p><ol><li><p>降低多线程大事务并发的概率，优化业务逻辑</p></li><li><p>优化SQL，避免慢SQL，<code>减少批量操作</code>，建议写脚本以update-sleep这样的形式完成。</p></li><li><p><code>提高从库机器的配置</code>，减少主库写binlog和从库读binlog的效率差。</p></li><li><p>尽量采用<code>短的链路</code>，也就是主库和从库服务器的距离尽量要短，提升端口带宽，减少binlog传输的网络延时。</p></li><li><p>实时性要求的业务读强制走主库，从库只做灾备，备份。</p></li></ol><h5 id="3-4-如何解决一致性问题"><a href="#3-4-如何解决一致性问题" class="headerlink" title="3.4 如何解决一致性问题"></a><strong>3.4</strong> <strong>如何解决一致性问题</strong></h5><p>读写分离情况下，解决主从同步中数据不一致的问题， 就是解决主从之间 数据复制方式 的问题，如果按照数据一致性 从弱到强 来进行划分，有以下 3 种复制方式。</p><p><strong>方法</strong> <strong>1：异步复制</strong></p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051654133.png" alt="image-20220405165455998"></p><p><strong>方法</strong> <strong>2：半同步复制</strong></p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051655175.png" alt="image-20220405165513025"></p><p><strong>方法</strong> <strong>3：组复制</strong></p><p>首先我们将多个节点共同组成一个复制组，在<code>执行读写（RW）事务</code>的时候，需要通过一致性协议层（Consensus 层）的同意，也就是读写事务想要进行提交，必须要经过组里“大多数人”（对应 Node 节点）的同意，大多数指的是同意的节点数量需要大于 （N&#x2F;2+1），这样才可以进行提交，而不是原发起方一个说了算。而针对<code>只读（RO）事务</code>则不需要经过组内同意，直接 COMMIT 即可。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051656560.png" alt="image-20220405165650425"></p><h3 id><a href="#" class="headerlink" title></a></h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第19章 数据库备份与恢复</title>
      <link href="/2023/07/15/%E7%AC%AC19%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/"/>
      <url>/2023/07/15/%E7%AC%AC19%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/</url>
      
        <content type="html"><![CDATA[<h3 id="第19章-数据库备份与恢复"><a href="#第19章-数据库备份与恢复" class="headerlink" title="第19章 数据库备份与恢复"></a>第19章 数据库备份与恢复</h3><h4 id="1-物理备份与逻辑备份"><a href="#1-物理备份与逻辑备份" class="headerlink" title="1. 物理备份与逻辑备份"></a><strong>1.</strong> <strong>物理备份与逻辑备份</strong></h4><p><strong>物理备份</strong>：备份数据文件，转储数据库物理文件到某一目录。物理备份恢复速度比较快，但占用空间比较大，MySQL中可以用<code>xtrabackup</code>工具来进行物理备份。</p><p><strong>逻辑备份</strong>：对数据库对象利用工具进行导出工作，汇总入备份文件内。逻辑备份恢复速度慢，但占用空间小，更灵活。MySQL 中常用的逻辑备份工具为<code>mysqldump</code>。逻辑备份就是<code>备份sql语句</code>，在恢复的时候执行备份的sql语句实现数据库数据的重现。</p><h4 id="2-mysqldump实现逻辑备份"><a href="#2-mysqldump实现逻辑备份" class="headerlink" title="2. mysqldump实现逻辑备份"></a><strong>2. mysqldump实现逻辑备份</strong></h4><h5 id="2-1-备份一个数据库"><a href="#2-1-备份一个数据库" class="headerlink" title="2.1 备份一个数据库"></a><strong>2.1</strong> <strong>备份一个数据库</strong></h5><pre><code class="shell">mysqldump –u 用户名称 –h 主机名称 –p密码 待备份的数据库名称[tbname, [tbname...]]&gt; 备份文件名 称.sql</code></pre><pre><code class="shell">mysqldump -uroot -p atguigu&gt;atguigu.sql #备份文件存储在当前目录下mysqldump -uroot -p atguigudb1 &gt; /var/lib/mysql/atguigu.sql</code></pre><h5 id="2-2-备份全部数据库"><a href="#2-2-备份全部数据库" class="headerlink" title="2.2 备份全部数据库"></a><strong>2.2</strong> <strong>备份全部数据库</strong></h5><pre><code class="shell">mysqldump -uroot -pxxxxxx --all-databases &gt; all_database.sql mysqldump -uroot -pxxxxxx -A &gt; all_database.sql</code></pre><h5 id="2-3-备份部分数据库"><a href="#2-3-备份部分数据库" class="headerlink" title="2.3 备份部分数据库"></a><strong>2.3</strong> <strong>备份部分数据库</strong></h5><pre><code class="shell">mysqldump –u user –h host –p --databases [数据库的名称1 [数据库的名称2...]] &gt; 备份文件名 称.sql</code></pre><pre><code class="shell">mysqldump -uroot -p --databases atguigu atguigu12 &gt;two_database.sqlmysqldump -uroot -p -B atguigu atguigu12 &gt; two_database.sql</code></pre><h5 id="2-4-备份部分表"><a href="#2-4-备份部分表" class="headerlink" title="2.4 备份部分表"></a><strong>2.4</strong> <strong>备份部分表</strong></h5><pre><code class="shell">mysqldump –u user –h host –p 数据库的名称 [表名1 [表名2...]] &gt; 备份文件名称.sql</code></pre><pre><code class="shell">mysqldump -uroot -p atguigu book&gt; book.sql#备份多张表 mysqldump -uroot -p atguigu book account &gt; 2_tables_bak.sql</code></pre><h5 id="2-5-备份单表的部分数据"><a href="#2-5-备份单表的部分数据" class="headerlink" title="2.5 备份单表的部分数据"></a><strong>2.5</strong> <strong>备份单表的部分数据</strong></h5><pre><code class="shell">mysqldump -uroot -p atguigu student --where=&quot;id &lt; 10 &quot; &gt; student_part_id10_low_bak.sql</code></pre><h5 id="2-6-排除某些表的备份"><a href="#2-6-排除某些表的备份" class="headerlink" title="2.6 排除某些表的备份"></a><strong>2.6</strong> <strong>排除某些表的备份</strong></h5><pre><code class="shell">mysqldump -uroot -p atguigu --ignore-table=atguigu.student &gt; no_stu_bak.sql</code></pre><h5 id="2-7-只备份结构或只备份数据"><a href="#2-7-只备份结构或只备份数据" class="headerlink" title="2.7 只备份结构或只备份数据"></a><strong>2.7</strong> <strong>只备份结构或只备份数据</strong></h5><ul><li>只备份结构</li></ul><pre><code class="shell">mysqldump -uroot -p atguigu --no-data &gt; atguigu_no_data_bak.sql</code></pre><ul><li>只备份数据</li></ul><pre><code class="shell">mysqldump -uroot -p atguigu --no-create-info &gt; atguigu_no_create_info_bak.sql</code></pre><h5 id="2-8-备份中包含存储过程、函数、事件"><a href="#2-8-备份中包含存储过程、函数、事件" class="headerlink" title="2.8 备份中包含存储过程、函数、事件"></a><strong>2.8</strong> <strong>备份中包含存储过程、函数、事件</strong></h5><pre><code class="shell">mysqldump -uroot -p -R -E --databases atguigu &gt; fun_atguigu_bak.sql</code></pre><h4 id="3-mysql命令恢复数据"><a href="#3-mysql命令恢复数据" class="headerlink" title="3. mysql命令恢复数据"></a><strong>3. mysql命令恢复数据</strong></h4><pre><code class="shell">mysql –u root –p [dbname] &lt; backup.sql</code></pre><h5 id="3-1-单库备份中恢复单库"><a href="#3-1-单库备份中恢复单库" class="headerlink" title="3.1 单库备份中恢复单库"></a><strong>3.1</strong> <strong>单库备份中恢复单库</strong></h5><pre><code class="shell">#备份文件中包含了创建数据库的语句mysql -uroot -p &lt; atguigu.sql#备份文件中不包含了创建数据库的语句mysql -uroot -p atguigu4&lt; atguigu.sql</code></pre><h5 id="3-2-全量备份恢复"><a href="#3-2-全量备份恢复" class="headerlink" title="3.2 全量备份恢复"></a><strong>3.2</strong> <strong>全量备份恢复</strong></h5><pre><code class="shell">mysql –u root –p &lt; all.sql</code></pre><h5 id="3-3-从全量备份中恢复单库"><a href="#3-3-从全量备份中恢复单库" class="headerlink" title="3.3 从全量备份中恢复单库"></a><strong>3.3</strong> <strong>从全量备份中恢复单库</strong></h5><pre><code class="shell">sed -n &#39;/^-- Current Database: `atguigu`/,/^-- Current Database: `/p&#39; all_database.sql &gt; atguigu.sql #分离完成后我们再导入atguigu.sql即可恢复单个库</code></pre><h5 id="3-4-从单库备份中恢复单表"><a href="#3-4-从单库备份中恢复单表" class="headerlink" title="3.4 从单库备份中恢复单表"></a><strong>3.4</strong> <strong>从单库备份中恢复单表</strong></h5><pre><code class="shell">cat atguigu.sql | sed -e &#39;/./&#123;H;$!d;&#125;&#39; -e &#39;x;/CREATE TABLE `class`/!d;q&#39; &gt; class_structure.sql cat atguigu.sql | grep --ignore-case &#39;insert into `class`&#39; &gt; class_data.sql #用shell语法分离出创建表的语句及插入数据的语句后 再依次导出即可完成恢复 use atguigu; mysql&gt; source class_structure.sql; Query OK, 0 rows affected, 1 warning (0.00 sec) mysql&gt; source class_data.sql; Query OK, 1 row affected (0.01 sec)</code></pre><h4 id="4-表的导出与导入"><a href="#4-表的导出与导入" class="headerlink" title="4. 表的导出与导入"></a><strong>4.</strong> <strong>表的导出与导入</strong></h4><h5 id="4-1-表的导出"><a href="#4-1-表的导出" class="headerlink" title="4.1 表的导出"></a><strong>4.1</strong> <strong>表的导出</strong></h5><p><strong>1.</strong> <strong>使用SELECT…INTO OUTFILE导出文本文件</strong> </p><pre><code class="mysql">SHOW GLOBAL VARIABLES LIKE &#39;%secure%&#39;;SELECT * FROM account INTO OUTFILE &quot;/var/lib/mysql-files/account.txt&quot;;</code></pre><p><strong>2.</strong> <strong>使用mysqldump命令导出文本文件</strong></p><pre><code class="shell">mysqldump -uroot -p -T &quot;/var/lib/mysql-files/&quot; atguigu account# 或mysqldump -uroot -p -T &quot;/var/lib/mysql-files/&quot; atguigu account --fields-terminated- by=&#39;,&#39; --fields-optionally-enclosed-by=&#39;\&quot;&#39;</code></pre><p><strong>3.</strong> <strong>使用mysql命令导出文本文件</strong></p><pre><code class="shell">mysql -uroot -p --execute=&quot;SELECT * FROM account;&quot; atguigu&gt; &quot;/var/lib/mysql-files/account.txt&quot;</code></pre><h5 id="4-2-表的导入"><a href="#4-2-表的导入" class="headerlink" title="4.2 表的导入"></a><strong>4.2</strong> <strong>表的导入</strong></h5><p><strong>1.</strong> <strong>使用LOAD DATA INFILE方式导入文本文件</strong></p><pre><code class="mysql">LOAD DATA INFILE &#39;/var/lib/mysql-files/account_0.txt&#39; INTO TABLE atguigu.account;# 或LOAD DATA INFILE &#39;/var/lib/mysql-files/account_1.txt&#39; INTO TABLE atguigu.account FIELDS TERMINATED BY &#39;,&#39; ENCLOSED BY &#39;\&quot;&#39;;</code></pre><p><strong>2.</strong> <strong>使用mysqlimport方式导入文本文件</strong></p><pre><code class="shell">mysqlimport -uroot -p atguigu &#39;/var/lib/mysql-files/account.txt&#39; --fields-terminated- by=&#39;,&#39; --fields-optionally-enclosed-by=&#39;\&quot;&#39;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第06章 索引的数据结构</title>
      <link href="/2023/07/15/%E7%AC%AC06%E7%AB%A0%20%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2023/07/15/%E7%AC%AC06%E7%AB%A0%20%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h3 id="第06章-索引的数据结构"><a href="#第06章-索引的数据结构" class="headerlink" title="第06章 索引的数据结构"></a>第06章 索引的数据结构</h3><h4 id="1-索引及其优缺点"><a href="#1-索引及其优缺点" class="headerlink" title="1. 索引及其优缺点"></a><strong>1.</strong> <strong>索引及其优缺点</strong></h4><h5 id="1-1-索引概述"><a href="#1-1-索引概述" class="headerlink" title="1.1 索引概述"></a><strong>1.1</strong> <strong>索引概述</strong></h5><p>MySQL官方对索引的定义为：<strong>索引（Index）是帮助MySQL高效获取数据的数据结构</strong>。</p><p><strong>索引的本质：</strong>索引是数据结构。你可以简单理解为“排好序的快速查找数据结构”，满足特定查找算法。这些数据结构以某种方式指向数据， 这样就可以在这些数据结构的基础上实现<code>高级查找算法</code>。</p><h5 id="1-2-优点"><a href="#1-2-优点" class="headerlink" title="1.2 优点"></a><strong>1.2</strong> <strong>优点</strong></h5><p>（1）类似大学图书馆建书目索引，提高数据检索的效率，降低<code>数据库的IO成本</code>，这也是创建索引最主要的原因。</p><p>（2）通过创建唯一索引，可以保证数据库表中每一行<code>数据的唯一性</code>。</p><p>（3）在实现数据的参考完整性方面，可以<code>加速表和表之间的连接</code>。换句话说，对于有依赖关系的子表和父表联合查询时，可以提高查询速度。</p><p>（4）在使用分组和排序子句进行数据查询时，可以显著<code>减少查询中分组和排序的时间</code>，降低了CPU的消耗。</p><h5 id="1-3-缺点"><a href="#1-3-缺点" class="headerlink" title="1.3 缺点"></a><strong>1.3</strong> <strong>缺点</strong></h5><p>（1）创建索引和维护索引要<code>耗费时间</code>，并且随着数据量的增加，所耗费的时间也会增加。</p><p>（2）索引需要占<code>磁盘空间</code>，除了数据表占数据空间之外，每一个索引还要占一定的物理空间<code>存储在磁盘上</code>，如果有大量的索引，索引文件就可能比数据文件更快达到最大文件尺寸。</p><p>（3）虽然索引大大提高了查询速度，同时却会<code>降低更新表的速度</code>。当对表中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。</p><h4 id="2-InnoDB中索引的推演"><a href="#2-InnoDB中索引的推演" class="headerlink" title="2. InnoDB中索引的推演"></a><strong>2. InnoDB中索引的推演</strong></h4><h5 id="2-1-索引之前的查找"><a href="#2-1-索引之前的查找" class="headerlink" title="2.1 索引之前的查找"></a><strong>2.1</strong> <strong>索引之前的查找</strong></h5><pre><code class="mysql">SELECT [列名列表] FROM 表名 WHERE 列名 = xxx;</code></pre><p><strong>1.在一个页中的查找</strong></p><p>假设目前表中的记录比较少，所有的记录都可以被存放在一个页中，在查找记录的时候可以根据搜索条件的不同分为两种情况：</p><ul><li>以主键为搜索条件<ul><li>可以在页目录中使用<code>二分法</code>快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。</li></ul></li><li>以其他列作为搜索条件<ul><li>因为在数据页中并没有对非主键建立所谓的页目录，所以我们无法通过二分法快速定位相应的槽。这种情况下只能从最小记录开始依次遍历单链表中的每条记录，然后对比每条记录是不是符合搜索条件。很显然，这种查找的效率是非常低的。</li></ul></li></ul><p><strong>2.在很多页中查找</strong></p><p>大部分情况下我们表中存放的记录都是非常多的，需要好多的数据页来存储这些记录。在很多页中查找记录的话可以分为两个步骤：</p><ol><li>定位到记录所在的页。</li><li>从所在的页内查找相应的记录。</li></ol><p>在没有索引的情况下，不论是根据主键列或者其他列的值进行查找，由于我们并不能快速的定位到记录所在的页，所以只能<code>从第一个页</code>沿着<code>双向链表</code>一直往下找，在每一个页中根据我们上面的查找方式去查找指定的记录。因为要遍历所有的数据页，所以这种方式显然是<code>超级耗时</code>的。</p><h5 id="2-2-设计索引"><a href="#2-2-设计索引" class="headerlink" title="2.2 设计索引"></a><strong>2.2</strong> <strong>设计索引</strong></h5><pre><code class="mysql">mysql&gt; CREATE TABLE index_demo(    -&gt; c1 INT,    -&gt; c2 INT,    -&gt; c3 CHAR(1),    -&gt; PRIMARY KEY(c1)    -&gt; ) ROW_FORMAT = Compact;</code></pre><p>这个新建的<code>index_demo</code>表中有2个INT类型的列，1个CHAR(1)类型的列，而且我们规定了c1列为主键，这个表使用<code>Compact</code>行格式来实际存储记录的。这里我们简化了index_demo表的行格式示意图：</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203300956080.png" alt="image-20220330095642965"></p><ul><li><code>record_type</code>：记录头信息的一项属性，表示记录的类型，<code>0</code>表示普通记录、<code>1</code>表示目录项记录、<code>2</code>表示最小记录、<code>3</code>表示最大记录。</li><li><code>next_record</code>：记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量，我们用箭头来表明下一条记录是谁。</li><li><code>各个列的值</code>：这里只记录在<code>index_demo</code>表中的三个列，分别是<code>c1</code>、<code>c2</code>和<code>c3</code>。 </li><li><code>其他信息</code>：除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。</li></ul><p>将记录格式示意图的其他信息项暂时去掉并把它竖起来的效果就是这样：</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301000365.png" alt="image-20220330100053271"></p><p>把一些记录放到页里的示意图就是：</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301001377.png" alt="image-20220330100150297"></p><p><strong>1.</strong> <strong>一个简单的索引设计方案</strong></p><p>我们在根据某个搜索条件查找一些记录时为什么要遍历所有的数据页呢？因为各个页中的记录并没有规律，我们并不知道我们的搜索条件匹配哪些页中的记录，所以不得不依次遍历所有的数据页。所以如果我们<code>想快速的定位到需要查找的记录在哪些数据页</code>中该咋办？我们可以为快速定位记录所在的数据页而<code>建立一个目录</code>，建这个目录必须完成下边这些事：</p><ul><li><strong>下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。</strong></li><li><strong>给所有的页建立一个目录项。</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301004386.png" alt="image-20220330100409306"></p><p>以<code>页28</code>为例，它对应<code>目录项2</code>，这个目录项中包含着该页的页号<code>28</code>以及该页中用户记录的最小主键值<code>5</code>。我们只需要把几个目录项在物理存储器上连续存储（比如：数组），就可以实现根据主键值快速查找某条记录的功能了。比如：查找主键值为<code>20</code>的记录，具体查找过程分两步：</p><ol><li><p>先从目录项中根据<code>二分法</code>快速确定出主键值为<code>20</code>的记录在<code>目录项3</code>中（因为 12 &lt; 20 &lt; 209 ），它对应的页是<code>页9</code>。 </p></li><li><p>再根据前边说的在页中查找记录的方式去<code>页9</code>中定位具体的记录。</p></li></ol><p>至此，针对数据页做的简易目录就搞定了。这个目录有一个别名，称为<code>索引</code>。</p><p><strong>2. InnoDB中的索引方案</strong> </p><p><strong>① 迭代1次：目录项纪录的页</strong></p><p>我们把前边使用到的目录项放到数据页中的样子就是这样：</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301028743.png" alt="image-20220330102834658"></p><p>从图中可以看出来，我们新分配了一个编号为30的页来专门存储目录项记录。这里再次强调<code>目录项记录</code>和普通的<code>用户记录</code>的<strong>不同点</strong>：</p><ul><li><code>目录项记录</code>的<code>record_type</code>值是1，而<code>普通用户记录</code>的<code>record_type</code>值是0。</li><li>目录项记录只有<code>主键值和页的编号</code>两个列，而普通的用户记录的列是用户自己定义的，可能包含<code>很多列</code>，另外还有InnoDB自己添加的隐藏列。</li><li>了解：记录头信息里还有一个叫<code>min_rec_mask</code>的属性，只有在存储<code>目录项记录</code>的页中的主键值最小的<code>目录项记录</code>的<code>min_rec_mask</code>值为<code>1</code>，其他别的记录的<code>min_rec_mask</code>值都是<code>0</code>。</li></ul><p><strong>相同点：</strong>两者用的是一样的数据页，都会为主键值生成<code>Page Directory</code>（页目录），从而在按照主键值进行查找时可以使用<code>二分法</code>来加快查询速度。</p><p>现在以查找主键为<code>20</code>的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边两步：</p><ol><li><p>先到存储<code>目录项记录</code>的页，也就是页30中通过<code>二分法</code>快速定位到对应目录项，因为 12 &lt; 20 &lt; 209 ，所以定位到对应的记录所在的页就是页9。 </p></li><li><p>再到存储用户记录的页9中根据<code>二分法</code>快速定位到主键值为<code>20</code>的用户记录。</p></li></ol><p><strong>② 迭代2次：多个目录项纪录的页</strong></p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301034997.png" alt="image-20220330103442914"></p><p>从图中可以看出，我们插入了一条主键值为320的用户记录之后需要两个新的数据页：</p><ul><li>为存储该用户记录而新生成了<code>页31</code>。</li><li>因为原先存储目录项记录的<code>页30的容量已满</code>（我们前边假设只能存储4条目录项记录），所以不得不需要一个新的<code>页32</code>来存放<code>页31</code>对应的目录项。</li></ul><p>现在因为存储目录项记录的页不止一个，所以如果我们想根据主键值查找一条用户记录大致需要3个步骤，以查找主键值为<code>20</code>的记录为例：</p><ol><li><p>确定<code>目录项记录页</code>我们现在的存储目录项记录的页有两个，即<code>页30</code>和<code>页32</code>，又因为页30表示的目录项的主键值的范围是 [1, 320) ，页32表示的目录项的主键值不小于 320 ，所以主键值为<code>20</code>的记录对应的目录项记录在<code>页30</code>中。</p></li><li><p>通过目录项记录页<code>确定用户记录真实所在的页</code>。在一个存储<code>目录项记录</code>的页中通过主键值定位一条目录项记录的方式说过了。</p></li><li><p>在真实存储用户记录的页中定位到具体的记录。</p></li></ol><p><strong>③ 迭代3次：目录项记录页的目录页</strong></p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301038376.png" alt="image-20220330103847284"></p><p>如图，我们生成了一个存储更高级目录项的<code>页33</code>，这个页中的两条记录分别代表页30和页32，如果用户记录的主键值在<code>[1, 320)</code>之间，则到页30中查找更详细的目录项记录，如果主键值<code>不小于320</code>的话，就到页32中查找更详细的目录项记录。</p><p>我们可以用下边这个图来描述它：</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301040190.png" alt="image-20220330104012108"></p><p>这个数据结构，它的名称是<code>B+树</code>。 </p><p><strong>④</strong> <strong>B+Tree</strong></p><p>一个B+树的节点其实可以分成好多层，规定最下边的那层，也就是存放我们用户记录的那层为第<code>0</code>层，之后依次往上加。之前我们做了一个非常极端的假设：存放用户记录的页<code>最多存放3条记录</code>，存放目录项记录的页<code>最多存放4条记录</code>。其实真实环境中一个页存放的记录数量是非常大的，假设所有存放用户记录的叶子节点代表的数据页可以存放<code>100条用户记录</code>，所有存放目录项记录的内节点代表的数据页可以存放<code>1000条目录项记录</code>，那么：</p><ul><li>如果B+树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放<code>100</code>条记录。</li><li>如果B+树有2层，最多能存放<code>1000×100=10,0000</code>条记录。</li><li>如果B+树有3层，最多能存放<code>1000×1000×100=1,0000,0000</code>条记录。</li><li>如果B+树有4层，最多能存放<code>1000×1000×1000×100=1000,0000,0000</code>条记录。相当多的记录！！！</li></ul><p>你的表里能存放<code>100000000000</code>条记录吗？所以一般情况下，我们<code>用到的B+树都不会超过4层</code>，那我们通过主键值去查找某条记录最多只需要做4个页面内的查找（查找3个目录项页和一个用户记录页），又因为在每个页面内有所谓的<code>Page Directory</code>（页目录），所以在页面内也可以通过<code>二分法</code>实现快速定位记录。</p><h5 id="2-3-常见索引概念"><a href="#2-3-常见索引概念" class="headerlink" title="2.3 常见索引概念"></a><strong>2.3</strong> <strong>常见索引概念</strong></h5><p><strong>1.</strong> <strong>聚簇索引</strong></p><p><strong>特点：</strong></p><ol><li><p>使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：</p><ul><li><p><code>页内</code>的记录是按照主键的大小顺序排成一个<code>单向链表</code>。</p></li><li><p>各个存放<code>用户记录的页</code>也是根据页中用户记录的主键大小顺序排成一个<code>双向链表</code>。</p></li><li><p>存放<code>目录项记录的页</code>分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个<code>双向链表</code>。</p></li></ul></li><li><p>B+树的<code>叶子节点</code>存储的是完整的用户记录。</p><p>所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。</p></li></ol><p><strong>优点：</strong></p><ul><li><code>数据访问更快</code>，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快</li><li>聚簇索引对于主键的<code>排序查找</code>和<code>范围查找</code>速度非常快</li><li>按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多个数据块中提取数据，所以<code>节省了大量的io操作</code>。</li></ul><p><strong>缺点：</strong></p><ul><li><code>插入速度严重依赖于插入顺序</code>，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个<strong>自增ID列为主键</strong></li><li><code>更新主键的代价很高</code>，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义<strong>主键为不可更新</strong></li><li><code>二级索引访问需要两次索引查找</code>，第一次找到主键值，第二次根据主键值找到行数据</li></ul><p><strong>2.</strong> <strong>二级索引（辅助索引、非聚簇索引）</strong></p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301050055.png" alt="image-20220330105018965"></p><p><strong>概念：回表</strong> 我们根据这个以c2列大小排序的B+树只能确定我们要查找记录的主键值，所以如果我们想根据c2列的值查找到完整的用户记录的话，仍然需要到<code>聚簇索引</code>中再查一遍，这个过程称为<code>回表</code>。也就是根据c2列的值查询一条完整的用户记录需要使用到<code>2</code>棵B+树！</p><p><strong>3.</strong> <strong>联合索引</strong></p><p>我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让B+树按照<code>c2和c3列</code>的大小进行排序，这个包含两层含义：</p><ul><li><p>先把各个记录和页按照c2列进行排序。</p></li><li><p>在记录的c2列相同的情况下，采用c3列进行排序</p></li></ul><p>注意一点，以c2和c3列的大小为排序规则建立的B+树称为<code>联合索引</code>，本质上也是一个二级索引。它的意思与分别为c2和c3列分别建立索引的表述是不同的，不同点如下：</p><ul><li><p>建立<code>联合索引</code>只会建立如上图一样的1棵B+树。</p></li><li><p>为c2和c3列分别建立索引会分别以c2和c3列的大小为排序规则建立2棵B+树。</p></li></ul><h5 id="2-4-InnoDB的B-树索引的注意事项"><a href="#2-4-InnoDB的B-树索引的注意事项" class="headerlink" title="2.4 InnoDB的B+树索引的注意事项"></a><strong>2.4 InnoDB的B+树索引的注意事项</strong></h5><p><strong>1.</strong> <strong>根页面位置万年不动</strong> </p><p>我们前边介绍B+索引的时候，为了大家理解上的方便，先把存储用户记录的叶子节点都画出来，然后接着画存储目录项记录的内节点，实际上B+树的形成过程是这样的：</p><ul><li>每当为某个表创建一个B+树索引（聚簇索引不是人为创建的，默认就有）的时候，都会为这个索引创建一个<code>根节点</code>页面。最开始表中没有数据的时候，每个B+树索引对应的<code>根节点</code>中既没有用户记录，也没有目录项记录。</li><li>随后向表中插入用户记录时，先把用户记录存储到这个<code>根节点</code>中。</li><li>当根节点中的可用<code>空间用完时</code>继续插入记录，此时会将根节点中的所有记录复制到一个新分配的页，比如<code>页a</code>中，然后对这个新页进行<code>页分裂</code>的操作，得到另一个新页，比如<code>页b</code>。这时新插入的记录根据键值（也就是聚簇索引中的主键值，二级索引中对应的索引列的值）的大小就会被分配到<code>页a</code>或者<code>页b</code>中，而<code>根节点</code>便升级为存储目录项记录的页。</li></ul><p>这个过程特别注意的是：一个B+树索引的根节点自诞生之日起，便不会再移动。这样只要我们对某个表建立一个索引，那么它的根节点的页号便会被记录到某个地方，然后凡是<code>InnoDB</code>存储引擎需要用到这个索引的时候，都会从那个固定的地方取出根节点的页号，从而来访问这个索引。</p><p><strong>2.</strong> <strong>内节点中目录项记录的唯一性</strong> </p><p>我们知道B+树索引的内节点中目录项记录的内容是<code>索引列+页号</code>的搭配，但是这个搭配对于二级索引来说有点不严谨。还拿<code>index_demo</code>表为例，假设这个表中的数据是这样的：</p><table><thead><tr><th>c1</th><th>c2</th><th>c3</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>‘u’</td></tr><tr><td>3</td><td>1</td><td>‘d’</td></tr><tr><td>5</td><td>1</td><td>‘y’</td></tr><tr><td>7</td><td>1</td><td>‘a’</td></tr></tbody></table><p>如果二级索引中目录项的内容只是<code>索引号+页号</code>的搭配的话，那么为<code>c2</code>列建立索引后的B+树应该长这样：</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301110222.png" alt="image-20220330111029120"></p><p>如果我们想要新插入一行记录，其中<code>c1</code>、<code>c2</code>、<code>c3</code>的值分别是：<code>9</code>、<code>1</code>、<code>c</code>，那么在修改这个为c2列建立的二级索引对应的B+树时便碰到了个大问题：由于<code>页3</code>中存储的目录项记录是由<code>c2列+页号</code>的值构成的，<code>页3</code>中的两条目录项记录对应的c2列的值都是<code>1</code>，那么我们这条新插入的记录到底应该放在<code>页4</code>中，还是应该放在<code>页5</code>中啊？答案是：对不起，懵了。</p><p>为了让新插入记录能找到自己在哪个页里，我们需要<strong>保证在B+树的同一层内节点的目录项记录除页号这个字段以外是唯一的。</strong>所以对于二级索引的内节点的目录项记录的内容实际上是由三个部分构成的：</p><ul><li>索引列的值</li><li>主键值</li><li>页号</li></ul><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301120304.png" alt="image-20220330112018199"></p><p>这样我们再插入记录<code>(9, 1, &#39;c&#39;)</code>时，由于<code>页3</code>中存储的目录项记录是由<code>c2列+主键+页号</code>的值构成的，可以先把新记录的<code>c2</code>列的值和<code>页3</code>中各目录项记录的<code>c2</code>列的值作比较，如果<code>c2</code>列的值相同的话，可以接着比较主键值，因为B+树同一层中不同目录项记录的<code>c2列+主键</code>的值肯定是不一样的，所以最后肯定能定位唯一的一条目录项记录，在本例中最后确定新记录应该被插入到<code>页5</code>中。</p><p><strong>3.</strong> <strong>一个页面最少可以存储2条记录</strong></p><p>一个B+树只需要很少的层级就可以轻松存储数亿条记录，查询速度相当不错！这是因为B+树本质上就是一个大的多层级目录，每经过一个目录时都会过滤掉许多无效的子目录，直到最后访问的存储真实数据的目录。那如果一个大的目录中只存放一个子目录是个啥效果呢？那就是目录层级非常非常非常多，而且最后的那个存放真实数据的目录中存放一条记录。费了半天劲只能存放一条真实的用户记录？所以<code>InnoDB的一个数据页至少可以存放两条记录</code></p><h4 id="3-MyISAM中的索引方案"><a href="#3-MyISAM中的索引方案" class="headerlink" title="3. MyISAM中的索引方案"></a><strong>3. MyISAM中的索引方案</strong></h4><p><strong>B树索引适用存储引擎如表所示：</strong></p><table><thead><tr><th>索引&#x2F;存储引擎</th><th>MyISAM</th><th>InnoDB</th><th>Memory</th></tr></thead><tbody><tr><td>B-Tree索引</td><td>支持</td><td>支持</td><td>支持</td></tr></tbody></table><p>即使多个存储引擎支持同一种类型的索引，但是他们的实现原理也是不同的。Innodb和MyISAM默认的索引是Btree索引；而Memory默认的索引是Hash索引。</p><p>MyISAM引擎使用<code>B+Tree</code>作为索引结构，叶子节点的data域存放的是<code>数据记录的地址</code>。</p><h5 id="3-1-MyISAM索引的原理"><a href="#3-1-MyISAM索引的原理" class="headerlink" title="3.1 MyISAM索引的原理"></a><strong>3.1 MyISAM索引的原理</strong></h5><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301133907.png" alt="image-20220330113307813"></p><h5 id="3-2-MyISAM-与-InnoDB对比"><a href="#3-2-MyISAM-与-InnoDB对比" class="headerlink" title="3.2 MyISAM 与 InnoDB对比"></a><strong>3.2 MyISAM</strong> <strong>与</strong> <strong>InnoDB对比</strong></h5><p><strong>MyISAM的索引方式都是“非聚簇”的，与InnoDB包含1个聚簇索引是不同的。</strong></p><p><strong>小结两种引擎中索引的区别：</strong></p><p>① 在InnoDB存储引擎中，我们只需要根据主键值对<code>聚簇索引</code>进行一次查找就能找到对应的记录，而在<code>MyISAM</code>中却需要进行一次<code>回表</code>操作，意味着MyISAM中建立的索引相当于全部都是<code>二级索引</code>。 </p><p>② InnoDB的数据文件本身就是索引文件，而MyISAM索引文件和数据文件是<code>分离的</code>，索引文件仅保存数据记录的地址。</p><p>③ InnoDB的非聚簇索引data域存储相应记录<code>主键的值</code>，而MyISAM索引记录的是<code>地址</code>。换句话说，InnoDB的所有非聚簇索引都引用主键作为data域。</p><p>④ MyISAM的回表操作是十分<code>快速</code>的，因为是拿着地址偏移量直接到文件中取数据的，反观InnoDB是通过获取主键之后再去聚簇索引里找记录，虽然说也不慢，但还是比不上直接用地址去访问。</p><p>⑤ InnoDB要求表<code>必须有主键</code>（<code>MyISAM可以没有</code>）。如果没有显式指定，则MySQL系统会自动选择一个可以非空且唯一标识数据记录的列作为主键。如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整型。</p><h4 id="4-索引的代价"><a href="#4-索引的代价" class="headerlink" title="4. 索引的代价"></a><strong>4.</strong> <strong>索引的代价</strong></h4><p>索引是个好东西，可不能乱建，它在空间和时间上都会有消耗：</p><ul><li><strong>空间上的代价</strong></li></ul><p>每建立一个索引都要为它建立一棵B+树，每一棵B+树的每一个节点都是一个数据页，一个页默认会占用<code>16KB</code>的存储空间，一棵很大的B+树由许多数据页组成，那就是很大的一片存储空间。</p><ul><li><strong>时间上的代价</strong></li></ul><p>每次对表中的数据进行<code>增、删、改</code>操作时，都需要去修改各个B+树索引。而且我们讲过，B+树每层节点都是按照索引列的值<code>从小到大的顺序排序</code>而组成了<code>双向链表</code>。不论是叶子节点中的记录，还是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些<code>记录移位</code>，<code>页面分裂</code>、<code>页面回收</code>等操作来维护好节点和记录的排序。如果我们建了许多索引，每个索引对应的B+树都要进行相关的维护操作，会给性能拖后腿。</p><h4 id="5-MySQL数据结构选择的合理性"><a href="#5-MySQL数据结构选择的合理性" class="headerlink" title="5. MySQL数据结构选择的合理性"></a><strong>5. MySQL数据结构选择的合理性</strong></h4><h5 id="5-1-二叉搜索树"><a href="#5-1-二叉搜索树" class="headerlink" title="5.1 二叉搜索树"></a><strong>5.1</strong> <strong>二叉搜索树</strong></h5><p>如果我们利用二叉树作为索引结构，那么磁盘的IO次数和索引树的高度是相关的。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301636830.png" alt="image-20220330163602743"></p><p>为了提高查询效率，就需要<code>减少磁盘IO数</code>。为了减少磁盘IO的次数，就需要尽量<code>降低树的高度</code>，需要把原来“瘦高”的树结构变的“矮胖”，树的每层的分叉越多越好。</p><h5 id="5-2-AVL树"><a href="#5-2-AVL树" class="headerlink" title="5.2 AVL树"></a><strong>5.2 AVL树</strong></h5><p>如果我们利用二叉树作为索引结构，那么磁盘的IO次数和索引树的高度是相关的。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301635653.png" alt="image-20220330163506536"></p><p>针对同样的数据，如果我们把二叉树改成<code>M 叉树</code>（M&gt;2）呢？当 M&#x3D;3 时，同样的 31 个节点可以由下面的三叉树来进行存储：</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301637104.png" alt="image-20220330163709022"></p><h5 id="5-3-B-Tree"><a href="#5-3-B-Tree" class="headerlink" title="5.3 B-Tree"></a><strong>5.3 B-Tree</strong></h5><p>B 树的结构如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301638995.png" alt="image-20220330163803905"></p><p>一个 M 阶的 B 树（M&gt;2）有以下的特性：</p><ol><li><p>根节点的儿子数的范围是 [2,M]。 </p></li><li><p>每个中间节点包含 k-1 个关键字和 k 个孩子，孩子的数量 &#x3D; 关键字的数量 +1，k 的取值范围为[ceil(M&#x2F;2), M]。 </p></li><li><p>叶子节点包括 k-1 个关键字（叶子节点没有孩子），k 的取值范围为 [ceil(M&#x2F;2), M]。 </p></li><li><p>假设中间节点节点的关键字为：Key[1], Key[2], …, Key[k-1]，且关键字按照升序排序，即 Key[i] &lt;Key[i+1]。此时 k-1 个关键字相当于划分了 k 个范围，也就是对应着 k 个指针，即为：P[1], P[2], …,P[k]，其中 P[1] 指向关键字小于 Key[1] 的子树，P[i] 指向关键字属于 (Key[i-1], Key[i]) 的子树，P[k]指向关键字大于 Key[k-1] 的子树。</p></li><li><p>所有叶子节点位于同一层。</p></li></ol><p>上面那张图所表示的 B 树就是一棵 3 阶的 B 树。我们可以看下磁盘块 2，里面的关键字为（8，12），它有 3 个孩子 (3，5)，(9，10) 和 (13，15)，你能看到 (3，5) 小于 8，(9，10) 在 8 和 12 之间，而 (13，15)大于 12，刚好符合刚才我们给出的特征。</p><p>然后我们来看下如何用 B 树进行查找。假设我们想要<code>查找的关键字是 9</code>，那么步骤可以分为以下几步：</p><ol><li><p>我们与根节点的关键字 (17，35）进行比较，9 小于 17 那么得到指针 P1； </p></li><li><p>按照指针 P1 找到磁盘块 2，关键字为（8，12），因为 9 在 8 和 12 之间，所以我们得到指针 P2； </p></li><li><p>按照指针 P2 找到磁盘块 6，关键字为（9，10），然后我们找到了关键字 9。</p></li></ol><p>你能看出来在 B 树的搜索过程中，我们比较的次数并不少，但如果把数据读取出来然后在内存中进行比较，这个时间就是可以忽略不计的。而读取磁盘块本身需要进行 I&#x2F;O 操作，消耗的时间比在内存中进行比较所需要的时间要多，是数据查找用时的重要因素。<code>B 树相比于平衡二叉树来说磁盘 I/O 操作要少</code>，在数据查询中比平衡二叉树效率要高。所以<code>只要树的高度足够低，IO次数足够少，就可以提高查询性能</code>。</p><p><strong>再举例1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301644761.png" alt="image-20220330164411665"></p><h5 id="5-4-B-Tree"><a href="#5-4-B-Tree" class="headerlink" title="5.4 B+Tree"></a><strong>5.4 B+Tree</strong></h5><p><strong>B+</strong> <strong>树和</strong> <strong>B</strong> <strong>树的差异：</strong></p><ol><li><p>有 k 个孩子的节点就有 k 个关键字。也就是孩子数量 &#x3D; 关键字数，而 B 树中，孩子数量 &#x3D; 关键字数+1。</p></li><li><p>非叶子节点的关键字也会同时存在在子节点中，并且是在子节点中所有关键字的最大（或最小）。</p></li><li><p>非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子节点中。而 B 树中， <code>非叶子节点既保存索引，也保存数据记录</code>。 </p></li><li><p>所有关键字都在叶子节点出现，叶子节点构成一个有序链表，而且叶子节点本身按照关键字的大小从小到大顺序链接。</p></li></ol><blockquote><p>B 树和 B+ 树都可以作为索引的数据结构，在 MySQL 中采用的是 B+ 树。</p><p>但B树和B+树各有自己的应用场景，不能说B+树完全比B树好，反之亦然。</p></blockquote><p><strong>思考题：为了减少IO，索引树会一次性加载吗？</strong></p><blockquote><p>1、数据库索引是存储在磁盘上的，如果数据量很大，必然导致索引的大小也会很大，超过几个G。</p><p>2、当我们利用索引查询时候，是不可能将全部几个G的索引都加载进内存的，我们能做的只能是：逐一加载每一个磁盘页，因为磁盘页对应着索引树的节点。</p></blockquote><p><strong>思考题：B+树的存储能力如何？为何说一般查找行记录，最多只需1~3次磁盘IO</strong></p><blockquote><p>InnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT(占用4个字节)或BIGINT(占用8个字节)，指针类型也一般为4或8个字节，也就是说一个页（B+Tree中的一个节点）中大概存储16KB&#x2F;(8B+8B)&#x3D;1K个键值，因为是估算，为了方便计算，这里的K取值为10^3。也就是说一个深度为3的B+Tree索引可以维护10^3 * 10^3 * 10^3 &#x3D; 10亿条记录。（这里假定一个数据页也存储10^3条行记录数据了）</p><p>实际情况中每个节点可能不能填充满，因此在数据库中，<code>B+Tree的高度一般都在2~4层</code>。MySQL的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1~3次磁盘I&#x2F;O操作</p></blockquote><p><strong>思考题：为什么说B+树比B-树更适合实际应用中操作系统的文件索引和数据库索引？</strong></p><blockquote><p>1.B+树的磁盘读写代价更低</p><p>B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对于B树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。</p><p>2、B+树的查询效率更加稳定</p><p>由于非终结点并不是最终指向文件内容的节点，而只是叶子结点中关键字的索引。所有任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p></blockquote><p><strong>思考题：Hash索引与B+树索引的区别</strong></p><blockquote><p>1、Hash索引<code>不能进行范围查询</code>，而B+树可以。这是因为Hash索引指向的数据是无序的，而B+树的叶子节点是个有序的链表。</p><p>2、Hash索引<code>不支持联合索引的最左侧原则</code>（即联合索引的部分索引无法使用），而B+树可以。对于联合索引来说，Hash索引在计算Hash值的时候是将索引键合并后再一起计算Hash值，所以不会针对每个索引单独计算Hash值。因此如果用到联合索引的一个或者几个索引时，联合索引无法被利用。</p><p>3、Hash索引<code>不支持 ORDER BY 排序</code>，因为Hash索引指向的数据是无序的，因此无法起到排序优化的作用，而B+树索引数据是有序的，可以起到对该字段ORDER BY 排序优化的作用。同理，我们也无法用Hash索引进行<code>模糊查询</code>，而B+树使用LIKE进行模糊查询的时候，LIKE后面后模糊查询（比如%结尾）的话就可以起到优化作用。</p><p>4、<code>InnoDB不支持哈希索引</code></p></blockquote><h3 id><a href="#" class="headerlink" title></a></h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第07章 InnoDB数据存储结构</title>
      <link href="/2023/07/15/%E7%AC%AC07%E7%AB%A0%20InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/"/>
      <url>/2023/07/15/%E7%AC%AC07%E7%AB%A0%20InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h3 id="第07章-InnoDB数据存储结构"><a href="#第07章-InnoDB数据存储结构" class="headerlink" title="第07章 InnoDB数据存储结构"></a>第07章 InnoDB数据存储结构</h3><h4 id="1-数据库的存储结构：页"><a href="#1-数据库的存储结构：页" class="headerlink" title="1. 数据库的存储结构：页"></a>1. 数据库的存储结构：页</h4><p>索引结构给我们提供了高效的索引方式，不过索引信息以及数据记录都保存在文件上的，确切说是存储在页结构中。另一方面，索引是在存储引擎中实现的，MySQL服务器上的<code>存储引擎</code>负责对表中数据的读取和写入工作。不同存储引擎中<code>存放的格式</code>一般不同的，甚至有的存储引擎比如Memory都不用磁盘来存储数据。</p><p>由于<code>InnoDB</code>是MySQL的<code>默认存储引擎</code>，所以本章剖析InooDB存储引擎的数据存储结构。</p><h5 id="1-1-磁盘与内存交互基本单位：页"><a href="#1-1-磁盘与内存交互基本单位：页" class="headerlink" title="1.1 磁盘与内存交互基本单位：页"></a>1.1 磁盘与内存交互基本单位：页</h5><p>InnoDB将数据划分为若干个页，InnoDB中页的大小默认为<code>16KB</code>。</p><p>以<code>页</code>作为磁盘和内存之间交互的基本单位，也就是一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。也就是说，<strong>在数据库中，不论读一行，还是读多行，都是将这些行所在的页进行加载。也就是说，数据库管理存储空间的基本单位是页（Page），数据库I&#x2F;O操作的最小单位是页。</strong>一个页中可以存储多个行记录。</p><blockquote><p>记录是按照行来存储的，但是数据库的读取并不以行为单位，否则一次读取（也就是一次I&#x2F;O操作）只能处理一行数据，效率会非常低。</p></blockquote><h5 id="1-2-页结构概述"><a href="#1-2-页结构概述" class="headerlink" title="1.2 页结构概述"></a>1.2 页结构概述</h5><p>页a、页b、页c…页n这些页可以<code>不在物理结构上相连</code>，只要通过<code>双向链表</code>相关联即可。每个数据页中的记录会按照主键值从小到大的顺序组成一个<code>单向链表</code>，每个数据页都会为存储在它里边的记录生成一个<code>页目录</code>，在通过主键查找某条记录的时候可以在页目录中<code>使用二分法</code>快速定位到对应的槽，然后再遍历该槽对应的分组中的记录即可快速找到指定的记录。</p><h5 id="1-3-页的上层结构"><a href="#1-3-页的上层结构" class="headerlink" title="1.3 页的上层结构"></a>1.3 页的上层结构</h5><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301838071.png" alt="image-20220330183814954"></p><p>区（Extent）是比页大一级的存储结构，在InnoDB存储引擎中，一个区会分配<code>64个连续的页</code>。因为InnoDB中的页大小默认是16KB，所以一个区的大小是64*16KB&#x3D;<code>1MB</code>。</p><p>段（Segment）由一个或多个区组成，区在文件系统是一个连续分配的空间（在InnoDB中是连续的64个页），不过在段中不要求区与区之间是相邻的。<code>段是数据库中的分配单位，不同类型的数据库对象以不同的段形式存在。</code>当我们创建数据表、索引的时候，就会相应创建对应的段，比如创建一张表时会创建一个表段，创建一个索引时会创建一个索引段。</p><p>表空间（Tablespace）是一个逻辑容器，表空间存储的对象是段，在一个表空间中可以有一个或多个段，但是一个段只能属于一个表空间。数据库由一个或多个表空间组成，表空间从管理上可以划分为<code>系统表空间</code>、<code>用户表空间</code>、<code>撤销表空间</code>、<code>临时表空间</code>等。</p><h4 id="2-页的内部结构"><a href="#2-页的内部结构" class="headerlink" title="2. 页的内部结构"></a>2. 页的内部结构</h4><h5 id="2-1-第1部分：文件头部和文件尾部"><a href="#2-1-第1部分：文件头部和文件尾部" class="headerlink" title="2.1 第1部分：文件头部和文件尾部"></a>2.1 第1部分：文件头部和文件尾部</h5><h6 id="2-1-1-File-Header（文件头部）（38字节）"><a href="#2-1-1-File-Header（文件头部）（38字节）" class="headerlink" title="2.1.1 File Header（文件头部）（38字节）"></a>2.1.1 File Header（文件头部）（38字节）</h6><p><strong>作用</strong>：<br>描述各种页的通用信息。（比如页的编号、其上一页、下一页是谁等）</p><p><strong>大小</strong>：38字节</p><table><thead><tr><th>名称</th><th>占用空间大小</th><th>描述</th></tr></thead><tbody><tr><td><code>FIL_PAGE_SPACE_OR_CHKSUM</code></td><td><code>4</code>字节</td><td>页的校验和（checksum值）</td></tr><tr><td><code>FIL_PAGE_OFFSET</code></td><td><code>4</code>字节</td><td>页号</td></tr><tr><td><code>FIL_PAGE_PREV</code></td><td><code>4</code>字节</td><td>上一个页的页号</td></tr><tr><td><code>FIL_PAGE_NEXT</code></td><td><code>4</code>字节</td><td>下一个页的页号</td></tr><tr><td>FIL_PAGE_LSN</td><td><code>8</code>字节</td><td>页面被最后修改时对应的日志序列位置</td></tr><tr><td><code>FIL_PAGE_TYPE</code></td><td><code>2</code>字节</td><td>该页的类型</td></tr><tr><td>FIL_PAGE_FILE_FLUSH_LSN</td><td><code>8</code>字节</td><td>仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值</td></tr><tr><td><code>FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID</code></td><td><code>4</code>字节</td><td>页属于哪个表空间</td></tr></tbody></table><ul><li><code>FIL_PAGE_OFFSET（4字节）</code>：每一个页都有一个单独的页号，就跟你的身份证号码一样，InnoDB通过页号可以唯一定位一个页。</li><li><code>FIL_PAGE_TYPE（2字节）</code>：这个代表当前页的类型。</li></ul><table><thead><tr><th>类型名称</th><th>十六进制</th><th>描述</th></tr></thead><tbody><tr><td>FIL_PAGE_TYPE_ALLOCATED</td><td>0x0000</td><td>最新分配，还没有使用</td></tr><tr><td><code>FIL_PAGE_UNDO_LOG</code></td><td>0x0002</td><td>Undo日志页</td></tr><tr><td>FIL_PAGE_INODE</td><td>0x0003</td><td>段信息节点</td></tr><tr><td>FIL_PAGE_IBUF_FREE_LIST</td><td>0x0004</td><td>Insert Buffer空闲列表</td></tr><tr><td>FIL_PAGE_IBUF_BITMAP</td><td>0x0005</td><td>Insert Buffer位图</td></tr><tr><td><code>FIL_PAGE_TYPE_SYS</code></td><td>0x0006</td><td>系统页</td></tr><tr><td>FIL_PAGE_TYPE_TRX_SYS</td><td>0x0007</td><td>事务系统数据</td></tr><tr><td>FIL_PAGE_TYPE_FSP_HDR</td><td>0x0008</td><td>表空间头部信息</td></tr><tr><td>FIL_PAGE_TYPE_XDES</td><td>0x0009</td><td>扩展描述页</td></tr><tr><td>FIL_PAGE_TYPE_BLOB</td><td>0x000A</td><td>溢出页</td></tr><tr><td><code>FIL_PAGE_INDEX</code></td><td>0x45BF</td><td>索引页，也就是我们所说的<code>数据页</code></td></tr></tbody></table><ul><li><code>FIL_PAGE_PREV（4字节）和FIL_PAGE_NEXT（4字节）</code>：InnoDB都是以页为单位存放数据的，如果数据分散到多个不连续的页中存储的话需要把这些页关联起来，FIL_PAGE_PREV和FIL_PAGE_NEXT就分别代表本页的上一个和下一个页的页号。这样通过建立一个双向链表把许许多多的页就都串联起来了，保证这些页之间<strong>不需要是物理上的连续，而是逻辑上的连续。</strong></li><li><code>FIL_PAGE_SPACE_OR_CHKSUM（4字节）</code>：代表当前页面的校验和（checksum）。文件头部和文件尾部都有属性：FIL_PAGE_SPACE_OR_CHKSUM</li></ul><p><strong>作用：</strong></p><p>InnoDB存储引擎以页为单位把数据加载到内存中处理，如果该页中的数据在内存中被修改了，那么<code>在修改后的某个时间需要把数据同步到磁盘中。</code>但是在同步了一半的时候断电了，造成了该页传输的不完整。</p><p>为了检测一个页是否完整（也就是在同步的时候有没有发生只同步一半的尴尬情况），这时可以通过文件尾的校验和（checksum 值）与文件头的校验和做比对，如果两个值不相等则证明页的传输有问题，需要重新进行传输，否则认为页的传输已经完成。</p><ul><li><code>FIL_PAGE_LSN（8字节）</code>：页面被最后修改时对应的日志序列位置（英文名是：Log Sequence Number）</li></ul><h6 id="2-1-2-File-Trailer（文件尾部）（8字节）"><a href="#2-1-2-File-Trailer（文件尾部）（8字节）" class="headerlink" title="2.1.2 File Trailer（文件尾部）（8字节）"></a>2.1.2 File Trailer（文件尾部）（8字节）</h6><ul><li>前4个字节代表页的校验和：这个部分是和File Header中的校验和相对应的。</li><li>后4个字节代表页面被最后修改时对应的日志序列位置（LSN）：这个部分也是为了校验页的完整性的，如果首部和尾部的LSN值校验不成功的话，就说明同步过程出现了问题。</li></ul><h5 id="2-2-第2部分：空闲空间、用户记录和最小最大记录"><a href="#2-2-第2部分：空闲空间、用户记录和最小最大记录" class="headerlink" title="2.2 第2部分：空闲空间、用户记录和最小最大记录"></a>2.2 第2部分：空闲空间、用户记录和最小最大记录</h5><h6 id="2-2-1-Free-Space-空闲空间"><a href="#2-2-1-Free-Space-空闲空间" class="headerlink" title="2.2.1 Free Space (空闲空间)"></a>2.2.1 Free Space (空闲空间)</h6><p>我们自己存储的记录会按照指定的<code>行格式</code>存储到<code>User Records</code>部分。但是在一开始生成页的时候，其实并没有User Records这个部分，<code>每当我们插入一条记录，都会从Free Space部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到User Records部分</code>，当Free Space部分的空间全部被User Records部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去<code>申请新的页</code>了。</p><h6 id="2-2-2-User-Records-用户记录"><a href="#2-2-2-User-Records-用户记录" class="headerlink" title="2.2.2 User Records (用户记录)"></a>2.2.2 User Records (用户记录)</h6><p>User Records中的这些记录按照<code>指定的行格式</code>一条一条摆在User Records部分，相互之间形成<code>单链表</code>。</p><h6 id="2-2-3-Infimum-Supremum（最小最大记录）"><a href="#2-2-3-Infimum-Supremum（最小最大记录）" class="headerlink" title="2.2.3 Infimum + Supremum（最小最大记录）"></a>2.2.3 Infimum + Supremum（最小最大记录）</h6><p><strong>记录可以比较大小吗</strong>？<br>是的，记录可以比大小，对于一条完整的记录来说，比较记录的大小就是<code>比较主键</code>的大小。比方说我们插入的4行记录的主键值分别是：1、2、3、4，这也就意味着这4条记录是从小到大依次递增。</p><p>InnoDB规定的最小记录与最大记录这两条记录的构造十分简单，都是由5字节大小的记录头信息和8字节大小的一个固定的部分组成的。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301913664.png" alt="image-20220330191335574"></p><p>这两条记录<code>不是我们自己定义的记录</code>，所以它们并不存放在页的User Records部分，他们被单独放在一个称为Infimum + Supremum的部分</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301914167.png" alt="image-20220330191446070"></p><h5 id="2-3-第3部分：页目录和页面头部"><a href="#2-3-第3部分：页目录和页面头部" class="headerlink" title="2.3 第3部分：页目录和页面头部"></a>2.3 第3部分：页目录和页面头部</h5><h6 id="2-3-1-Page-Directory（页目录）"><a href="#2-3-1-Page-Directory（页目录）" class="headerlink" title="2.3.1 Page Directory（页目录）"></a>2.3.1 Page Directory（页目录）</h6><p><strong>为什么需要页目录</strong>？<br>在页中，记录是以<code>单向链表</code>的形式进行存储的。单向链表的特点就是插入、删除非常方便，但是<code>检索效率不高</code>，最差的情况下需要遍历链表上的所有节点才能完成检索。因此在页结构中专门设计了页目录这个模块，<code>专门给记录做一个目录</code>，通过<code>二分查找法</code>的方式进行检索，提升效率。</p><p><strong>页目录，二分法查找</strong></p><ol><li>将所有的记录<code>分成几个组</code>，这些记录包括最小记录和最大记录，但不包括标记为“已删除”的记录。</li><li>第 1 组，也就是最小记录所在的分组只有 1 个记录；<br>最后一组，就是最大记录所在的分组，会有 1-8 条记录；<br>其余的组记录数量在 4-8 条之间。<br>这样做的好处是，除了第 1 组（最小记录所在组）以外，其余组的记录数会<code>尽量平分</code>。</li><li>在每个组中最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段。</li><li><code>页目录用来存储每组最后一条记录的地址偏移量</code>，这些地址偏移量会按照<code>先后顺序存储</code>起来，每组的地址偏移量也被称之为<code>槽（slot）</code>，每个槽相当于指针指向了不同组的最后一个记录。</li></ol><p><strong>举例：</strong></p><p>现在的page_demo表中正常的记录共有6条，InnoDB会把它们分成两组，第一组中只有一个最小记录，第二组中是剩余的5条记录。如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301921631.png" alt="image-20220330192130497"></p><p>从这个图中我们需要注意这么几点：</p><ul><li>现在页目录部分中有两个槽，也就意味着我们的记录被分成了两个组，槽1中的值是112，代表最大记录的地址偏移量（就是从页面的0字节开始数，数112个字节）；槽0中的值是99，代表最小记录的地址偏移量。</li><li>注意最小和最大记录的头信息中的n_owned属性<ul><li>最小记录的n_owned值为1，这就代表着以最小记录结尾的这个分组中只有1条记录，也就是最小记录本身。</li><li>最大记录的n_owned值为5，这就代表着以最大记录结尾的这个分组中只有5条记录，包括最大记录本身还有我们自己插入的4条记录。</li></ul></li></ul><p>用箭头指向的方式替代数字，这样更易于我们理解，修改后如下</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301924874.png" alt="image-20220330192413776"></p><p><strong>为什么最小记录的n_owned值为1，而最大记录的n_owned值为5呢？</strong></p><p>InnoDB规定：对于最小记录所在的分组只能有1条记录，最大记录所在的分组拥有的记录条数只能在1<del>8条之间，剩下的分组中记录的条数范围只能在是 4</del>8 条之间。</p><p>分组是按照下边的步骤进行的：</p><ul><li>初始情况下一个数据页里只有最小记录和最大记录两条记录，它们分属于两个分组。</li><li>之后每插入一条记录，都会从页目录中找到主键值比本记录的主键值大并且差值最小的槽，然后把该槽对应的记录的n_owned值加1，表示本组内又添加了一条记录，直到该组中的记录数等于8个。</li><li>在一个组中的记录数等于8个后再插入一条记录时，会将组中的记录拆分成两个组，一个组中4条记录，另一个5条记录。这个过程会在页目录中新增一个槽来记录这个新增分组中最大的那条记录的偏移量。</li></ul><h6 id="2-3-2-Page-Header（页面头部）"><a href="#2-3-2-Page-Header（页面头部）" class="headerlink" title="2.3.2 Page Header（页面头部）"></a>2.3.2 Page Header（页面头部）</h6><p>为了能得到一个数据页中存储的记录的状态信息，比如本页中已经存储了多少条记录，第一条记录的地址是什么，页目录中存储了多少个槽等等，特意在页中定义了一个叫Page Header的部分，这个部分占用固定的56个字节，专门存储各种状态信息。</p><table><thead><tr><th>名称</th><th>占用空间大小</th><th>描述</th></tr></thead><tbody><tr><td>PAGE_N_DIR_SLOTS</td><td>2字节</td><td>在页目录中的槽数量</td></tr><tr><td>PAGE_HEAP_TOP</td><td>2字节</td><td>还未使用的空间最小地址，也就是说从该地址之后就是<code>Free Space</code></td></tr><tr><td>PAGE_N_HEAP</td><td>2字节</td><td>本页中的记录的数量（包括最小和最大记录以及标记为删除的记录）</td></tr><tr><td>PAGE_FREE</td><td>2字节</td><td>第一个已经标记为删除的记录的记录地址（各个已删除的记录通过<code>next_record</code>也会组成一个单链表，这个单链表中的记录可以被重新利用）</td></tr><tr><td>PAGE_GARBAGE</td><td>2字节</td><td>已删除记录占用的字节数</td></tr><tr><td>PAGE_LAST_INSERT</td><td>2字节</td><td>最后插入记录的位置</td></tr><tr><td>PAGE_DIRECTION</td><td>2字节</td><td>记录插入的方向</td></tr><tr><td>PAGE_N_DIRECTION</td><td>2字节</td><td>一个方向连续插入的记录数量</td></tr><tr><td>PAGE_N_RECS</td><td>2字节</td><td>该页中记录的数量（不包括最小和最大记录以及被标记为删除的记录）</td></tr><tr><td>PAGE_MAX_TRX_ID</td><td>8字节</td><td>修改当前页的最大事务ID，该值仅在二级索引中定义</td></tr><tr><td>PAGE_LEVEL</td><td>2字节</td><td>当前页在B+树中所处的层级</td></tr><tr><td>PAGE_INDEX_ID</td><td>8字节</td><td>索引ID，表示当前页属于哪个索引</td></tr><tr><td>PAGE_BTR_SEG_LEAF</td><td>10字节</td><td>B+树叶子段的头部信息，仅在B+树的Root页定义</td></tr><tr><td>PAGE_BTR_SEG_TOP</td><td>10字节</td><td>B+树非叶子段的头部信息，仅在B+树的Root页定义</td></tr></tbody></table><h4 id="3-InnoDB行格式（或记录格式）"><a href="#3-InnoDB行格式（或记录格式）" class="headerlink" title="3. InnoDB行格式（或记录格式）"></a>3. InnoDB行格式（或记录格式）</h4><h5 id="3-1-指定行格式的语法"><a href="#3-1-指定行格式的语法" class="headerlink" title="3.1 指定行格式的语法"></a>3.1 指定行格式的语法</h5><pre><code class="mysql">CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称</code></pre><pre><code class="mysql">ALTER TABLE 表名 ROW_FORMAT=行格式名称</code></pre><h5 id="3-2-COMPACT行格式"><a href="#3-2-COMPACT行格式" class="headerlink" title="3.2 COMPACT行格式"></a>3.2 COMPACT行格式</h5><p>在MySQL 5.1版本中，默认设置为Compact行格式。一条完整的记录其实可以被分为记录的额外信息和记录的真实数据两大部分。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301939611.png" alt="image-20220330193949517"></p><h6 id="3-2-1-变长字段长度列表"><a href="#3-2-1-变长字段长度列表" class="headerlink" title="3.2.1 变长字段长度列表"></a>3.2.1 变长字段长度列表</h6><p>MySQL支持一些变长的数据类型，比如VARCHAR(M)、VARBINARY(M)、TEXT类型，BLOB类型，这些数据类型修饰列称为<code>变长字段</code>，变长字段中存储多少字节的数据不是固定的，所以我们在存储真实数据的时候需要顺便把这些数据占用的字节数也存起来。<code>在Compact行格式中，把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长字段长度列表。</code></p><blockquote><p> 注意：这里面存储的变长长度和字段顺序是反过来的。比如两个varchar字段在表结构的顺序是a(10)，b(15)。那么在变长字段长度列表中存储的长度顺序就是15，10，是反过来的。</p></blockquote><h6 id="3-2-2-NULL值列表"><a href="#3-2-2-NULL值列表" class="headerlink" title="3.2.2 NULL值列表"></a>3.2.2 NULL值列表</h6><p>Compact行格式会把可以为NULL的列统一管理起来，存在一个标记为NULL值列表中。如果表中没有允许存储 NULL 的列，则 NULL值列表也不存在了。<br><strong>为什么定义NULL值列表？</strong><br>之所以要存储NULL是因为数据都是需要对齐的，如果<code>没有标注出来NULL值的位置</code>，就有可能在查询数据的时候<code>出现混乱</code>。如果使用<code>一个特定的符号</code>放到相应的数据位表示空置的话，虽然能达到效果，但是这样很浪费空间，所以直接就在行数据得头部开辟出一块空间专门用来记录该行数据哪些是非空数据，哪些是空数据，格式如下：</p><ol><li>二进制位的值为1时，代表该列的值为NULL。</li><li>二进制位的值为0时，代表该列的值不为NULL。</li></ol><blockquote><p>注意：同样顺序也是反过来存放的</p></blockquote><h6 id="3-2-3-记录头信息（5字节）"><a href="#3-2-3-记录头信息（5字节）" class="headerlink" title="3.2.3 记录头信息（5字节）"></a>3.2.3 记录头信息（5字节）</h6><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301945235.png" alt="image-20220330194534127"></p><table><thead><tr><th>名称</th><th>大小（单位：bit）</th><th>描述</th></tr></thead><tbody><tr><td><code>预留位1</code></td><td>1</td><td>没有使用</td></tr><tr><td><code>预留位2</code></td><td>1</td><td>没有使用</td></tr><tr><td><code>delete_mask</code></td><td>1</td><td>标记该记录是否被删除</td></tr><tr><td><code>mini_rec_mask</code></td><td>1</td><td>B+树的每层非叶子节点中的最小记录都会添加该标记</td></tr><tr><td><code>n_owned</code></td><td>4</td><td>表示当前记录拥有的记录数</td></tr><tr><td><code>heap_no</code></td><td>13</td><td>表示当前记录在记录堆的位置信息</td></tr><tr><td><code>record_type</code></td><td>3</td><td>表示当前记录的类型，<code>0</code>表示普通记录，<code>1</code>表示B+树非叶子节点记录，<code>2</code>表示最小记录，<code>3</code>表示最大记录</td></tr><tr><td><code>next_record</code></td><td>16</td><td>表示下一条记录的相对位置</td></tr></tbody></table><ul><li><code>delete_mask</code>：这个属性标记着当前记录是否被删除，占用1个二进制位。<ul><li>值为0：代表记录并没有被删除</li><li>值为1：代表记录被删除掉了</li></ul></li></ul><p><strong>被删除的记录为什么还在页中存储呢？</strong><br>你以为它删除了，可它还在真实的磁盘上。这些被删除的记录之所以不立即从磁盘上移除，是因为移除它们之后其他的记录在磁盘上需要<code>重新排列，导致性能消耗</code>。所以只是打一个删除标记而已，所有被删除掉的记录都会组成一个所谓的<code>垃圾链表</code>，在这个链表中的记录占用的空间称之为<code>可重用空间</code>，之后如果有新记录插入到表中的话，可能把这些被删除的记录占用的存储空间覆盖掉。</p><ul><li><code>min_rec_mask</code>：B+树的每层非叶子节点中的最小记录都会添加该标记，min_rec_mask值为1。我们自己插入的四条记录的min_rec_mask值都是0，意味着它们都不是B+树的非叶子节点中的最小记录。</li><li><code>record_type</code>：这个属性表示当前记录的类型，一共有4种类型的记录：<ul><li>0：表示普通记录</li><li>1：表示B+树非叶节点记录</li><li>2：表示最小记录</li><li>3：表示最大记录</li></ul></li><li><code>heap_no</code>：这个属性表示当前记录在本页中的位置。</li></ul><p><strong>怎么不见heap_no值为0和1的记录呢</strong>？<br>MySQL会自动给每个页里加了两个记录，由于这两个记录并不是我们自己插入的，所以有时候也称为<code>伪记录</code>或者<code>虚拟记录</code>。这两个伪记录一个代表<code>最小记录</code>，一个代表<code>最大记录</code>。最小记录和最大记录的heap_no值分别是0和1，也就是说它们的位置最靠前</p><ul><li><code>n_owned</code>：页目录中每个组中最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段</li><li><code>next_record</code>：记录头信息里该属性非常重要，它表示从当前记录的真实数据到下一条记录的真实数据的<code>地址偏移量</code>。</li></ul><h6 id="3-2-4-记录的真实数据"><a href="#3-2-4-记录的真实数据" class="headerlink" title="3.2.4 记录的真实数据"></a>3.2.4 记录的真实数据</h6><table><thead><tr><th>列名</th><th>是否必须</th><th>占用空间</th><th>描述</th></tr></thead><tbody><tr><td>row_id</td><td>否</td><td>6字节</td><td>行ID，唯一标识一条记录</td></tr><tr><td>transaction_id</td><td>是</td><td>6字节</td><td>事务ID</td></tr><tr><td>roll_pointer</td><td>是</td><td>7字节</td><td>回滚指针</td></tr></tbody></table><p>一个表没有手动定义主键，则会选取一个Unique键作为主键，如果连Unique键都没有定义的话，则会为表默认添加一个名为row_id的隐藏列作为主键。所以row_id是在没有自定义主键以及Unique键的情况下才会存在的。</p><h5 id="3-3-Dynamic和Compressed行格式"><a href="#3-3-Dynamic和Compressed行格式" class="headerlink" title="3.3 Dynamic和Compressed行格式"></a>3.3 Dynamic和Compressed行格式</h5><p>我们可以知道一个页的大小一般是16KB，也就是16384字节，而一个VARCHAR(M)类型的列就最多可以存储65533个字节，这样就可能出现一个页存放不了一条记录，这种现象称为<code>行溢出</code></p><p>在Compact和Reduntant行格式中，对于占用存储空间非常大的列，在记录的真实数据处只会存储该列的一部分数据，把剩余的数据分散存储在几个其他的页中进行<code>分页存储</code>，然后记录的真实数据处用20个字节存储指向这些页的地址（当然这20个字节中还包括这些分散在其他页面中的数据的占用的字节数），从而可以找到剩余数据所在的页。这称为<code>页的扩展</code>。</p><p>在MySQL 8.0中，默认行格式就是Dynamic，Dynamic、Compressed行格式和Compact行格式挺像，只不过在处理行溢出数据时有分歧</p><ul><li>Compressed和Dynamic两种记录格式对于存放在BLOB中的数据采用了完全的行溢出的方式。如图，在数据页中只存放20个字节的指针（溢出页的地址），实际的数据都存放在Off Page（溢出页）中。</li><li>Compact和Redundant两种格式会在记录的真实数据处存储一部分数据（存放768个前缀字节）。</li></ul><h4 id="4-区、段和碎片区"><a href="#4-区、段和碎片区" class="headerlink" title="4. 区、段和碎片区"></a>4. 区、段和碎片区</h4><h5 id="4-1-为什么要有区？"><a href="#4-1-为什么要有区？" class="headerlink" title="4.1 为什么要有区？"></a>4.1 为什么要有区？</h5><p><code>B+</code>树的每一层中的页都会形成一个双向链表，如果是以<code>页为单位</code>来分配存储空间的话，双向链表相邻的两个页之间的<code>物理位置可能离得非常远</code>。我们介绍B+树索引的使用场景的时候特别提到范围查询只需要定位到最左边的记录和最右边的记录，然后沿着双向链表一直扫描就可以了，而如果链表中相邻的两个页物理位置离得非常远，就是所谓的<code>随机I/O</code>。再一次强调，磁盘的速度和内存的速度差了好几个数量级，<code>随机I/O是非常慢</code>的，所以我们应该尽量让链表中相邻的页的物理位置也相邻，这样进行范围查询的时候才可以使用所谓的<code>顺序I/O</code>。</p><p>引入<code>区</code>的概念，一个区就是物理位置上连续的<code>64个页</code>。因为InnoDB中的页的大小默认是16KB，所以一个区的大小是64*16KB&#x3D;<code>1MB</code>。在表中<code>数据量大</code>的时候，为某个索引分配空间的时候就不再按照页的单位分配了，而是按照<code>区为单位分配</code>，甚至在表中的数据特别多的时候，可以一次性分配多个连续的区。虽然可能造成<code>一点点空间的浪费</code>（数据不足以填充满整个区），但是从性能角度看，可以消除很多的随机I&#x2F;O，<code>功大于过</code>！</p><h5 id="4-2-为什么要有段？"><a href="#4-2-为什么要有段？" class="headerlink" title="4.2 为什么要有段？"></a>4.2 为什么要有段？</h5><p>对于范围查询，其实是对B+树叶子节点中的记录进行顺序扫描，而如果不区分叶子节点和非叶子节点，统统把节点代表的页面放到申请到的区中的话，进行范围扫描的效果就大打折扣了。所以InnoDB对B+树的<code>叶子节点</code>和<code>非叶子节点</code>进行了区别对待，也就是说叶子节点有自己独有的区，非叶子节点也有自己独有的区。存放叶子节点的区的集合就算是一个<code>段（segment）</code>，存放非叶子节点的区的集合也算是一个段。也就是说一个索引会生成2个段，一个<code>叶子节点段</code>，一个<code>非叶子节点段</code>。</p><p>除了索引的叶子节点段和非叶子节点段之外，InnoDB中还有为存储一些特殊的数据而定义的段，比如回滚段。所以，常见的段有<code>数据段</code>、<code>索引段</code>、<code>回滚段</code>。数据段即为B+树的叶子节点，索引段即为B+树的非叶子节点。</p><p>在InnoDB存储引擎中，对段的管理都是由引擎自身所完成，DBA不能也没有必要对其进行控制。这从一定程度上简化了DBA对于段的管理。</p><p>段其实不对应表空间中的某一个连续的物理区域，而是一个逻辑上的概念，由若干个零散的页面以及一些完整的区组成。</p><h5 id="4-3-为什么要有碎片区？"><a href="#4-3-为什么要有碎片区？" class="headerlink" title="4.3 为什么要有碎片区？"></a>4.3 为什么要有碎片区？</h5><p>默认情况下，一个使用InnoDB存储引擎的表只有一个聚簇索引，一个索引会生成2个段，而段是以区为单位申请存储空间的，一个区默认占用1M（64*16KB&#x3D;1024KB）存储空间，所以<strong>默认情况下一个只存在几条记录的小表也需要2M的存储空间么？</strong>以后每次添加一个索引都要多申请2M的存储空间么？这对于存储记录比较少的表简直是天大的浪费。这个问题的症结在于到现在为止我们介绍的区都是非常<code>纯粹</code>的，也就是一个区被整个分配给某一个段，或者说区中的所有页面都是为了存储同一个段的数据而存在的，即使段的数据填不满区中所有的页面，那余下的页面也不能挪作他用。</p><p>为了考虑以完整的区为单位分配给某个段对于<code>数据量较小</code>的表太浪费存储空间的这种情况，InnoDB提出了一个<code>碎片（fragment）区</code>的概念。在一个碎片区中，并不是所有的页都是为了存储同一个段的数据而存在的，而是碎片区中的页可以用于不同的目的，比如有些页面用于段A，有些页面用于段B，有些页甚至哪个段都不属于。<code>碎片区直属于表空间</code>，并不属于任何一个段。</p><p>所以此后为某个段分配存储空间的策略是这样的：</p><ul><li>在刚开始向表中插入数据的时候，段是从某个碎片区以单个页面为单位来分配存储空间的。</li><li>当某个段已经占用了<code>32个碎片区</code>页面之后，就会申请以完整的区为单位来分配存储空间。</li></ul><p>所以现在段不能仅定义为是某些区的集合，更精确的应该是<code>某些零散的页面</code>已经<code>一些完整的区</code>的集合。</p><h5 id="4-4-区的分类"><a href="#4-4-区的分类" class="headerlink" title="4.4 区的分类"></a>4.4 区的分类</h5><p>区大体上可以分为4种类型：</p><ul><li><code>空闲的区(FREE)</code>：现在还没有用到这个区中的任何页面。</li><li><code>有剩余空间的碎片区(FREE_FRAG)</code>：表示碎片区中还有可用的页面。</li><li><code>没有剩余空间的碎片区(FULL_FRAG)</code>：表示碎片区中的所有页面都被使用，没有空闲页面。</li><li><code>附属于某个段的区(FSEG)</code>：每一索引都可以分为叶子节点段和非叶子节点段</li></ul><p>处于<code>FREE</code>、<code>FREE_FRAG</code>以及<code>FULL_FRAG</code>这三种状态的区都是独立的，直属于表空间。而处于<code>FSEG</code>状态的区是附属于某个段的。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第11章 数据库的设计规范</title>
      <link href="/2023/07/15/%E7%AC%AC11%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/"/>
      <url>/2023/07/15/%E7%AC%AC11%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h3 id="第11章-数据库的设计规范"><a href="#第11章-数据库的设计规范" class="headerlink" title="第11章 数据库的设计规范"></a>第11章 数据库的设计规范</h3><h4 id="1-范-式"><a href="#1-范-式" class="headerlink" title="1. 范 式"></a><strong>1.</strong> <strong>范 式</strong></h4><h5 id="1-1-范式简介"><a href="#1-1-范式简介" class="headerlink" title="1.1 范式简介"></a><strong>1.1</strong> <strong>范式简介</strong></h5><p><strong>在关系型数据库中，关于数据表设计的基本原则、规则就称为范式。</strong>可以理解为，一张数据表的设计结构需要满足的某种设计标准的<code>级别</code>。要想设计一个结构合理的关系型数据库，必须满足一定的范式。</p><h5 id="1-2-范式都包括哪些"><a href="#1-2-范式都包括哪些" class="headerlink" title="1.2 范式都包括哪些"></a><strong>1.2</strong> <strong>范式都包括哪些</strong></h5><p>目前关系型数据库有六种常见范式，按照范式级别，从低到高分别是：<strong>第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204030928295.png" alt="image-20220403092826169"></p><h5 id="1-3-键和相关属性的概念"><a href="#1-3-键和相关属性的概念" class="headerlink" title="1.3 键和相关属性的概念"></a><strong>1.3</strong> <strong>键和相关属性的概念</strong></h5><p>这里有两个表：</p><p><code>球员表(player)</code>：球员编号 | 姓名 | 身份证号 | 年龄 | 球队编号</p><p><code>球队表(team)</code>：球队编号 | 主教练 | 球队所在地</p><ul><li><code>超键</code>：对于球员表来说，超键就是包括球员编号或者身份证号的任意组合，比如（球员编号）（球员编号，姓名）（身份证号，年龄）等。</li><li><code>候选键</code>：就是最小的超键，对于球员表来说，候选键就是（球员编号）或者（身份证号）。</li><li><code>主键</code>：我们自己选定，也就是从候选键中选择一个，比如（球员编号）。</li><li><code>外键</code>：球员表中的球队编号。</li><li><code>主属性</code>、<code>非主属性</code>：在球员表中，主属性是（球员编号）（身份证号），其他的属性（姓名）（年龄）（球队编号）都是非主属性。</li></ul><h5 id="1-4-第一范式-1st-NF"><a href="#1-4-第一范式-1st-NF" class="headerlink" title="1.4 第一范式(1st NF)"></a><strong>1.4</strong> <strong>第一范式(1st NF)</strong></h5><p>第一范式主要是确保数据表中每个字段的值必须具有<code>原子性</code>，也就是说数据表中每个字段的值为<code>不可再次拆分</code>的最小数据单位。</p><h5 id="1-5-第二范式-2nd-NF"><a href="#1-5-第二范式-2nd-NF" class="headerlink" title="1.5 第二范式(2nd NF)"></a><strong>1.5</strong> <strong>第二范式(2nd NF)</strong></h5><p>第二范式要求，在满足第一范式的基础上，还要<strong>满足数据表里的每一条数据记录，都是可唯一标识的。而且所有非主键字段，都必须完全依赖主键，不能只依赖主键的一部分。</strong>如果知道主键的所有属性的值，就可以检索到任何元组（行）的任何属性的任何值。</p><h5 id="1-6-第三范式-3rd-NF"><a href="#1-6-第三范式-3rd-NF" class="headerlink" title="1.6 第三范式(3rd NF)"></a><strong>1.6</strong> <strong>第三范式(3rd NF)</strong></h5><p>第三范式是在第二范式的基础上，确保数据表中的每一个非主键字段都和主键字段直接相关，也就是说，<strong>要求数据表中的所有非主键字段不能依赖于其他非主键字段。</strong>（即，不能存在非主属性A依赖于非主属性B，非主属性B依赖于主键C的情况，即存在”A–&gt;B–&gt;C”的决定关系）通俗地讲，该规则的意思是所有<code>非主键属性</code>之间不能有依赖关系，必须<code>相互独立</code>。</p><h5 id="1-7-小结"><a href="#1-7-小结" class="headerlink" title="1.7 小结"></a>1.7 小结</h5><p>关于数据表的设计，有三个范式要遵循。</p><p>（1）第一范式（1NF），确保每列保持<code>原子性</code></p><p>数据库的每一列都是不可分割的原子数据项，不可再分的最小数据单元，而不能是集合、数组、记录等非原子数据项。</p><p>（2）第二范式（2NF），确保每列都和主键<code>完全依赖</code></p><p>尤其在复合主键的情况向下，非主键部分不应该依赖于部分主键。</p><p>（3）第三范式（3NF），确保每列都和主键<code>直接相关</code>，而不是间接相关</p><p><strong>范式的优点：</strong>数据的标准化有助于消除数据库中的<code>数据冗余</code>，第三范式（3NF）通常被认为在性能、拓展性和数据完整性方面达到了最好的平衡。</p><p><strong>范式的缺点：</strong>范式的使用，可能<code>降低查询的效率</code>。因为范式等级越高，设计出来的数据表就越多、越精细，数据的冗余度就越低，进行数据查询的时候就可能需要<code>关联多张表</code>，这不但代价昂贵，也可能使一些<code>索引策略无效</code>。</p><p>范式只是提出了设计的标准，实际上设计数据表时，未必一定要符合这些标准。开发中，我们会出现为了性能和读取效率违反范式化的原则，通过<code>增加少量的冗余</code>或重复的数据来提高数据库的<code>读性能</code>，减少关联查询，join表的次数，实现<code>空间换取时间</code>的目的。因此在实际的设计过程中要理论结合实际，灵活运用。</p><h4 id="2-反范式化"><a href="#2-反范式化" class="headerlink" title="2. 反范式化"></a><strong>2.</strong> <strong>反范式化</strong></h4><h5 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a><strong>2.1</strong> <strong>概述</strong></h5><p><strong>规范化</strong> <strong>vs</strong> <strong>性能</strong></p><ol><li><p>为满足某种商业目标 , 数据库性能比规范化数据库更重要</p></li><li><p>在数据规范化的同时 , 要综合考虑数据库的性能</p></li><li><p>通过在给定的表中添加额外的字段，以大量减少需要从中搜索信息所需的时间</p></li><li><p>通过在给定的表中插入计算列，以方便查询</p></li></ol><h5 id="2-2-反范式的新问题"><a href="#2-2-反范式的新问题" class="headerlink" title="2.2 反范式的新问题"></a><strong>2.2</strong> <strong>反范式的新问题</strong></h5><ul><li>存储<code>空间变大</code>了</li><li>一个表中字段做了修改，另一个表中冗余的字段也需要做同步修改，否则<code>数据不一致</code></li><li>若采用存储过程来支持数据的更新、删除等额外操作，如果更新频繁，会非常<code>消耗系统资源</code></li><li>在<code>数据量小</code>的情况下，反范式不能体现性能的优势，可能还会让数据库的设计更加<code>复杂</code></li></ul><h5 id="2-3-反范式的适用场景"><a href="#2-3-反范式的适用场景" class="headerlink" title="2.3 反范式的适用场景"></a><strong>2.3</strong> <strong>反范式的适用场景</strong></h5><p>当冗余信息有价值或者能<code>大幅度提高查询效率</code>的时候，我们才会采取反范式的优化。</p><p><strong>1.</strong> <strong>增加冗余字段的建议</strong> </p><p>1）这个冗余字段<code>不需要经常进行修改</code></p><p>2）这个冗余字段<code>查询的时候不可或缺</code></p><p><strong>2.</strong> <strong>历史快照、历史数据的需要</strong></p><p>在现实生活中，我们经常需要一些冗余信息，比如订单中的收货人信息，包括姓名、电话和地址等。每次发生的<code>订单收货信息</code>都属于<code>历史快照</code>，需要进行保存，但用户可以随时修改自己的信息，这时保存这些冗余信息是非常有必要的。</p><p>反范式优化也常用在<code>数据仓库</code>的设计中，因为数据仓库通常<code>存储历史数据</code>，对增删改的实时性要求不强，对历史数据的分析需求强。这时适当允许数据的冗余度，更方便进行数据分析。</p><h4 id="3-BCNF-巴斯范式"><a href="#3-BCNF-巴斯范式" class="headerlink" title="3. BCNF(巴斯范式)"></a><strong>3. BCNF(巴斯范式)</strong></h4><p>主属性（仓库名）对于候选键（管理员，物品名）是部分依赖的关系，这样就有可能导致异常情况。因此引入BCNF，<strong>它在</strong> <strong>3NF</strong> <strong>的基础上消除了主属性对候选键的部分依赖或者传递依赖关系</strong>。</p><p>如果在关系R中，U为主键，A属性是主键的一个属性，若存在A-&gt;Y，Y为主属性，则该关系不属于BCNF。</p><h4 id="4-ER模型"><a href="#4-ER模型" class="headerlink" title="4. ER模型"></a><strong>4. ER模型</strong></h4><p>ER模型也叫做<code>实体关系模型</code>，是用来描述现实生活中客观存在的事物、事物的属性，以及事物之间关系的一种数据模型。<strong>在开发基于数据库的信息系统的设计阶段，通常使用ER模型来描述信息需要和信息特性，帮助我们理清业务逻辑，从而设计出优秀的数据库。</strong></p><h5 id="4-1-ER-模型包括那些要素？"><a href="#4-1-ER-模型包括那些要素？" class="headerlink" title="4.1 ER 模型包括那些要素？"></a>4.1 ER 模型包括那些要素？</h5><p><strong>ER</strong> <strong>模型中有三个要素，分别是实体、属性和关系</strong>。 </p><p><code>实体</code>，可以看做是数据对象，往往对应于现实生活中的真实存在的个体。在 ER 模型中，用<code>矩形</code>来表示。实体分为两类，分别是<code>强实体</code>和<code>弱实体</code>。强实体是指不依赖于其他实体的实体；弱实体是指对另一个实体有很强的依赖关系的实体。</p><p><code>属性</code>，则是指实体的特性。比如超市的地址、联系电话、员工数等。在 ER 模型中用<code>椭圆形</code>来表示。</p><p><code>关系</code>，则是指实体之间的联系。比如超市把商品卖给顾客，就是一种超市与顾客之间的联系。在 ER 模型中用<code>菱形</code>来表示。</p><p>注意：实体和属性不容易区分。这里提供一个原则：我们要从系统整体的角度出发去看，<strong>可以独立存在的是实体，不可再分的是属性</strong>。也就是说，属性不能包含其他属性。</p><h5 id="4-2-关系的类型"><a href="#4-2-关系的类型" class="headerlink" title="4.2 关系的类型"></a><strong>4.2</strong> <strong>关系的类型</strong></h5><p>在 ER 模型的 3 个要素中，关系又可以分为 3 种类型，分别是 一对一、一对多、多对多。</p><p><code>一对一</code>：指实体之间的关系是一一对应的</p><p><code>一对多</code>：指一边的实体通过关系，可以对应多个另外一边的实体。相反，另外一边的实体通过这个关系，则只能对应唯一的一边的实体</p><p><code>多对多</code>：指关系两边的实体都可以通过关系对应多个对方的实体</p><h4 id="5-数据表的设计原则"><a href="#5-数据表的设计原则" class="headerlink" title="5. 数据表的设计原则"></a><strong>5.</strong> <strong>数据表的设计原则</strong></h4><p>数据表设计的一般原则：”三少一多” </p><p><strong>1.</strong> <strong>数据表的个数越少越好</strong> </p><p><strong>2.</strong> <strong>数据表中的字段个数越少越好</strong></p><p><strong>3.</strong> <strong>数据表中联合主键的字段个数越少越好</strong></p><p><strong>4.</strong> <strong>使用主键和外键越多越好</strong></p><blockquote><p>注意：这个原则并不是绝对的，有时候我们需要牺牲数据的冗余度来换取数据处理的效率。</p></blockquote><h4 id="6-数据库对象编写建议"><a href="#6-数据库对象编写建议" class="headerlink" title="6. 数据库对象编写建议"></a><strong>6.</strong> <strong>数据库对象编写建议</strong></h4><h5 id="6-1-关于库"><a href="#6-1-关于库" class="headerlink" title="6.1 关于库"></a><strong>6.1</strong> <strong>关于库</strong></h5><ol><li><p>【强制】库的名称必须控制在32个字符以内，只能使用英文字母、数字和下划线，建议以英文字母开头。</p></li><li><p>【强制】库名中英文<code>一律小写</code>，不同单词采用<code>下划线</code>分割。须见名知意。</p></li><li><p>【强制】库的名称格式：业务系统名称_子系统名。</p></li><li><p>【强制】库名禁止使用关键字（如type,order等）。</p></li><li><p>【强制】创建数据库时必须<code>显式指定字符集</code>，并且字符集只能是utf8或者utf8mb4。创建数据库SQL举例：CREATE DATABASE crm_fund <code>DEFAULT CHARACTER SET &#39;utf8&#39;</code>; </p></li><li><p>【建议】对于程序连接数据库账号，遵循<code>权限最小原则</code>。使用数据库账号只能在一个DB下使用，不准跨库。程序使用的账号<code>原则上不准有drop权限</code>。 </p></li><li><p>【建议】临时库以<code>tmp_</code>为前缀，并以日期为后缀；备份库以<code>bak_</code>为前缀，并以日期为后缀。</p></li></ol><h5 id="6-2-关于表、列"><a href="#6-2-关于表、列" class="headerlink" title="6.2 关于表、列"></a><strong>6.2</strong> <strong>关于表、列</strong></h5><ol><li><p>【强制】表和列的名称必须控制在32个字符以内，表名只能使用英文字母、数字和下划线，建议以<code>英文字母开头</code>。 </p></li><li><p>【强制】 <code>表名、列名一律小写</code>，不同单词采用下划线分割。须见名知意。</p></li><li><p>【强制】表名要求有模块名强相关，同一模块的表名尽量使用<code>统一前缀</code>。比如：crm_fund_item </p></li><li><p>【强制】创建表时必须<code>显式指定字符集</code>为utf8或utf8mb4。 </p></li><li><p>【强制】表名、列名禁止使用关键字（如type,order等）。</p></li><li><p>【强制】创建表时必须<code>显式指定表存储引擎</code>类型。如无特殊需求，一律为InnoDB。 </p></li><li><p>【强制】建表必须有comment。 </p></li><li><p>【强制】字段命名应尽可能使用表达实际含义的英文单词或<code>缩写</code>。如：公司 ID，不要使用 corporation_id, 而用corp_id 即可。</p></li><li><p>【强制】布尔值类型的字段命名为<code>is_描述</code>。如member表上表示是否为enabled的会员的字段命名为 is_enabled。 </p></li><li><p>【强制】禁止在数据库中存储图片、文件等大的二进制数据。通常文件很大，短时间内造成数据量快速增长，数据库进行数据库读取时，通常会进行大量的随机IO操作，文件很大时，IO操作很耗时。通常存储于文件服务器，数据库只存储文件地址信息。</p></li><li><p>【建议】建表时关于主键：<code>表必须有主键 </code>(1)强制要求主键为id，类型为int或bigint，且为auto_increment 建议使用unsigned无符号型。 (2)标识表里每一行主体的字段不要设为主键，建议设为其他字段如user_id，order_id等，并建立unique key索引。因为如果设为主键且主键值为随机插入，则会导致innodb内部页分裂和大量随机I&#x2F;O，性能下降。</p></li><li><p>【建议】核心表（如用户表）必须有行数据的<code>创建时间字段</code>（create_time）和<code>最后更新时间字段</code>（update_time），便于查问题。</p></li><li><p>【建议】表中所有字段尽量都是<code>NOT NULL</code>属性，业务可以根据需要定义<code>DEFAULT值</code>。 因为使用NULL值会存在每一行都会占用额外存储空间、数据迁移容易出错、聚合函数计算结果偏差等问题。</p></li><li><p>【建议】所有存储相同数据的<code>列名和列类型必须一致</code>（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）。</p></li><li><p>【建议】中间表（或临时表）用于保留中间结果集，名称以<code>tmp_</code>开头。备份表用于备份或抓取源表快照，名称以<code>bak_</code>开头。中间表和备份表定期清理。</p></li><li><p>【示范】一个较为规范的建表语句：</p></li></ol><pre><code class="mysql">CREATE TABLE user_info (     `id` int unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;自增主键&#39;,     `user_id` bigint(11) NOT NULL COMMENT &#39;用户id&#39;,     `username` varchar(45) NOT NULL COMMENT &#39;真实姓名&#39;,     `email` varchar(30) NOT NULL COMMENT &#39;用户邮箱&#39;,     `nickname` varchar(45) NOT NULL COMMENT &#39;昵称&#39;,     `birthday` date NOT NULL COMMENT &#39;生日&#39;,     `sex` tinyint(4) DEFAULT &#39;0&#39; COMMENT &#39;性别&#39;,     `short_introduce` varchar(150) DEFAULT NULL COMMENT &#39;一句话介绍自己，最多50个汉字&#39;,     `user_resume` varchar(300) NOT NULL COMMENT &#39;用户提交的简历存放地址&#39;,     `user_register_ip` int NOT NULL COMMENT &#39;用户注册时的源ip&#39;,     `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,     `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#39;修改时间&#39;,     `user_review_status` tinyint NOT NULL COMMENT &#39;用户资料审核状态，1为通过，2为审核中，3为未 通过，4为还未提交审核&#39;,    PRIMARY KEY (`id`),     UNIQUE KEY `uniq_user_id` (`user_id`),     KEY `idx_username`(`username`),     KEY `idx_create_time_status`(`create_time`,`user_review_status`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&#39;网站用户基本信息&#39;</code></pre><ol start="17"><li>【建议】创建表时，可以使用可视化工具。这样可以确保表、字段相关的约定都能设置上。实际上，我们通常很少自己写 DDL 语句，可以使用一些可视化工具来创建和操作数据库和数据表。可视化工具除了方便，还能直接帮我们将数据库的结构定义转化成 SQL 语言，方便数据库和数据表结构的导出和导入。</li></ol><h5 id="6-3-关于索引"><a href="#6-3-关于索引" class="headerlink" title="6.3 关于索引"></a><strong>6.3</strong> <strong>关于索引</strong></h5><ol><li><p>【强制】InnoDB表必须主键为id int&#x2F;bigint auto_increment，且主键值<code>禁止被更新</code>。 </p></li><li><p>【强制】InnoDB和MyISAM存储引擎表，索引类型必须为<code>BTREE</code>。 </p></li><li><p>【建议】主键的名称以<code>pk_</code>开头，唯一键以<code>uni_</code>或<code>uk_</code>开头，普通索引以<code>idx_</code>开头，一律使用小写格式，以字段的名称或缩写作为后缀。</p></li><li><p>【建议】多单词组成的columnname，取前几个单词首字母，加末单词组成column_name。如: sample 表 member_id 上的索引：idx_sample_mid。 </p></li><li><p>【建议】单个表上的索引个数<code>不能超过6个</code>。 </p></li><li><p>【建议】在建立索引时，多考虑建立<code>联合索引</code>，并把区分度最高的字段放在最前面。</p></li><li><p>【建议】在多表 JOIN 的SQL里，保证被驱动表的连接列上有索引，这样JOIN 执行效率最高。</p></li><li><p>【建议】建表或加索引时，保证表里互相不存在<code>冗余索引</code>。 比如：如果表里已经存在key(a,b)， 则key(a)为冗余索引，需要删除。</p></li></ol><h5 id="6-4-SQL编写"><a href="#6-4-SQL编写" class="headerlink" title="6.4 SQL编写"></a><strong>6.4 SQL编写</strong></h5><ol><li><p>【强制】程序端SELECT语句必须指定具体字段名称，禁止写成 *。 </p></li><li><p>【建议】程序端insert语句指定具体字段名称，不要写成INSERT INTO t1 VALUES(…)。 </p></li><li><p>【建议】除静态表或小表（100行以内），DML语句必须有WHERE条件，且使用索引查找。</p></li><li><p>【建议】INSERT INTO…VALUES(XX),(XX),(XX).. 这里XX的值不要超过5000个。 值过多虽然上线很快，但会引起主从同步延迟。</p></li><li><p>【建议】SELECT语句不要使用UNION，推荐使用UNION ALL，并且UNION子句个数限制在5个以内。</p></li><li><p>【建议】线上环境，多表 JOIN 不要超过5个表。</p></li><li><p>【建议】减少使用ORDER BY，和业务沟通能不排序就不排序，或将排序放到程序端去做。ORDER BY、GROUP BY、DISTINCT 这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。</p></li><li><p>【建议】包含了ORDER BY、GROUP BY、DISTINCT 这些查询的语句，WHERE 条件过滤出来的结果集请保持在1000行以内，否则SQL会很慢。</p></li><li><p>【建议】对单表的多次alter操作必须合并为一次。对于超过100W行的大表进行alter table，必须经过DBA审核，并在业务低峰期执行，多个alter需整合在一起。 因为alter table会产生<code>表锁</code>，期间阻塞对于该表的所有写入，对于业务可能会产生极大影响。</p></li><li><p>【建议】批量操作数据时，需要控制事务处理间隔时间，进行必要的sleep。 </p></li><li><p>【建议】事务里包含SQL不超过5个。因为过长的事务会导致锁数据较久，MySQL内部缓存、连接消耗过多等问题。</p></li><li><p>【建议】事务里更新语句尽量基于主键或UNIQUE KEY，如UPDATE… WHERE id&#x3D;XX;否则会产生间隙锁，内部扩大锁定范围，导致系统性能下降，产生死锁。</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第15章 Mysql锁</title>
      <link href="/2023/07/15/%E7%AC%AC15%E7%AB%A0%20%E9%94%81/"/>
      <url>/2023/07/15/%E7%AC%AC15%E7%AB%A0%20%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h3 id="第15章-锁"><a href="#第15章-锁" class="headerlink" title="第15章 锁"></a>第15章 锁</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a><strong>1.</strong> <strong>概述</strong></h4><p>在数据库中，除传统的计算资源（如CPU、RAM、I&#x2F;O等）的争用以外，数据也是一种供许多用户共享的资源。为保证数据的一致性，需要对<code>并发操作进行控制</code>，因此产生了<code>锁</code>。同时<code>锁机制</code>也为实现MySQL的各个隔离级别提供了保证。 锁冲突 也是影响数据库<code>并发访问性能</code>的一个重要因素。所以锁对数据库而言显得尤其重要，也更加复杂。</p><h4 id="2-MySQL并发事务访问相同记录"><a href="#2-MySQL并发事务访问相同记录" class="headerlink" title="2. MySQL并发事务访问相同记录"></a><strong>2. MySQL并发事务访问相同记录</strong></h4><h5 id="2-1-读-读情况"><a href="#2-1-读-读情况" class="headerlink" title="2.1 读-读情况"></a><strong>2.1</strong> <strong>读-读情况</strong></h5><p><code>读-读</code>情况，即并发事务相继<code>读取相同的记录</code>。读取操作本身不会对记录有任何影响，并不会引起什么问题，所以允许这种情况的发生。</p><h5 id="2-2-写-写情况"><a href="#2-2-写-写情况" class="headerlink" title="2.2 写-写情况"></a><strong>2.2</strong> <strong>写-写情况</strong></h5><p><code>写-写</code>情况，即并发事务相继对相同的记录做出改动。</p><p>在这种情况下会发生<code>脏写</code>的问题，任何一种隔离级别都不允许这种问题的发生。所以在多个未提交事务相继对一条记录做改动时，需要让它们<code>排队执行</code>，这个排队的过程其实是通过<code>锁</code>来实现的。</p><h5 id="2-3-读-写或写-读情况"><a href="#2-3-读-写或写-读情况" class="headerlink" title="2.3 读-写或写-读情况"></a><strong>2.3</strong> <strong>读-写或写-读情况</strong></h5><p><code>读-写</code>或<code>写-读</code>，即一个事务进行读取操作，另一个进行改动操作。这种情况下可能发生<code>脏读</code>、<code>不可重复读</code>、<code>幻读</code>的问题。</p><h5 id="2-4-并发问题的解决方案"><a href="#2-4-并发问题的解决方案" class="headerlink" title="2.4 并发问题的解决方案"></a><strong>2.4</strong> <strong>并发问题的解决方案</strong></h5><p>怎么解决<code>脏读</code>、<code>不可重复读</code>、<code>幻读</code>这些问题呢？其实有两种可选的解决方案：</p><ul><li>方案一：读操作利用多版本并发控制（<code>MVCC</code>，下章讲解），写操作进行<code>加锁</code>。</li></ul><p>所谓的<code>MVCC</code>，就是生成一个<code>ReadView</code>，通过ReadView找到符合条件的记录版本（历史版本由<code>undo日志</code>构建）。查询语句只能<code>读</code>到在生成ReadView之前<code>已提交事务所做的更改</code>，在生成ReadView之前未提交的事务或者之后才开启的事务所做的更改是看不到的。而<code>写操作</code>肯定针对的是<code>最新版本的记录</code>，读记录的历史版本和改动记录的最新版本本身并不冲突，也就是采用MVCC时，<code>读-写</code>操作并不冲突。</p><blockquote><p>普通的SELECT语句在READ COMMITTED和REPEATABLE READ隔离级别下会使用到MVCC读取记录。</p><ul><li>在<code>READ COMMITTED</code>隔离级别下，一个事务在执行过程中每次执行SELECT操作时都会生成一个ReadView，ReadView的存在本身就保证了<code>事务不可以读取到未提交的事务所做的更改</code>，也就是避免了脏读现象；</li><li>在<code>REPEATABLE READ</code>隔离级别下，一个事务在执行过程中只有<code>第一次执行SELECT操作 </code>才会生成一个ReadView，之后的SELECT操作都<code>复用</code>这ReadView，这样也就避免了不可重复读和幻读的问题。</li></ul></blockquote><ul><li><p>方案二：读、写操作都采用<code>加锁</code>的方式。</p></li><li><p>小结对比发现：</p><ul><li>采用<code>MVCC</code>方式的话，<code>读-写</code>操作彼此并不冲突，<code>性能更高</code>。</li><li>采用<code>加锁</code>方式的话，<code>读-写</code>操作彼此需要<code>排队执行</code>，影响性能。</li></ul></li></ul><p>一般情况下我们当然愿意采用<code>MVCC</code>来解决<code>读-写</code>操作并发执行的问题，但是业务在某些特殊情况下，要求必须采用<code>加锁</code>的方式执行。</p><h4 id="3-锁的不同角度分类"><a href="#3-锁的不同角度分类" class="headerlink" title="3. 锁的不同角度分类"></a><strong>3.</strong> <strong>锁的不同角度分类</strong></h4><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204050933339.png" alt="image-20220405093322184"></p><h5 id="3-1-从数据操作的类型划分：读锁、写锁"><a href="#3-1-从数据操作的类型划分：读锁、写锁" class="headerlink" title="3.1 从数据操作的类型划分：读锁、写锁"></a><strong>3.1</strong> <strong>从数据操作的类型划分：读锁、写锁</strong></h5><ul><li><code>读锁</code>：也称为<code>共享锁</code>、英文用<code>S</code>表示。针对同一份数据，多个事务的读操作可以同时进行而不会互相影响，相互不阻塞的。</li><li><code>写锁</code>：也称为<code>排他锁</code>、英文用<code>X</code>表示。当前写操作没有完成前，它会阻断其他写锁和读锁。这样就能确保在给定的时间里，只有一个事务能执行写入，并防止其他用户读取正在写入的同一资源。</li></ul><p><strong>需要注意的是对于</strong> <strong>InnoDB</strong> <strong>引擎来说，读锁和写锁可以加在表上，也可以加在行上。</strong></p><p><strong>1. 锁定读</strong></p><p>在采用<code>加锁</code>方式解决<code>脏读</code>、<code>不可重复读</code>、<code>幻读</code>这些问题时，读取一条记录时需要获取该记录的<code>S锁</code>，其实是不严谨的，有时候需要在读取记录时就获取记录的<code>X锁</code>，来禁止别的事务读写该记录，为此MySQL提出了两种比较特殊的<code>SELECT</code>语句格式：</p><ul><li>对读取的记录加<code>S锁</code>：</li></ul><pre><code class="mysql">SELECT ... LOCK IN SHARE MODE;# 或SELECT ... FOR SHARE; #(8.0新增语法)</code></pre><ul><li>对读取的记录加<code>X锁</code>：</li></ul><pre><code class="mysql">SELECT ... FOR UPDATE;</code></pre><p><strong>MySQL8.0新特性：</strong></p><p>在5.7及之前的版本，SELECT … FOR UPDATE，如果获取不到锁，会一直等待，直到<code>innodb_lock_wait_timeout</code>超时。在8.0版本中，SELECT … FOR UPDATE, SELECT … FOR SHARE 添加<code>NOWAIT</code>、<code>SKIP LOCKED</code>语法，跳过锁等待，或者跳过锁定。</p><ul><li>NOWAIT：如果查询的行已经加锁，会立即报错返回</li><li>SKIP LOCKED：如果查询的行已经加锁，只返回结果中不包含被锁定的行</li></ul><p><strong>2. 写操作</strong></p><ul><li><code>DELETE</code>：对一条记录做DELETE操作的过程其实是先在<code>B+</code>树中定位到这条记录的位置，然后获取这条记录的<code>X锁</code>，再执行<code>delete mark</code>操作。</li><li><code>UPDATE</code>：在对一条记录做UPDATE操作时分为三种情况：<ul><li>情况1：未修改该记录的键值，并且被更新的列占用的存储空间在修改前后未发生变化。则先在<code>B+</code>树中定位到这条记录的位置，然后再获取一下记录的<code>X锁</code>，最后在原纪录的位置进行修改操作。</li><li>情况2：未修改该记录的键值，并且至少有一个被更新的列占用的存储空间在修改前后发生变化。则先在<code>B+</code>树中定位到这条记录的位置，然后获取一下记录的<code>X锁</code>，将该记录彻底删除掉（就是把记录彻底移入垃圾链表），最后再插入一条新记录。新插入的记录由<code>INSERT</code>操作提供的<code>隐式锁</code>进行保护。</li><li>情况3：修改该记录的键值，则相当于在原纪录上做<code>DELECT</code>操作之后再来一次<code>INSERT</code>操作。</li></ul></li><li><code>INSERT</code>：一般情况下，新插入一条记录的操作并不加锁，通过一种称之为<code>隐式锁</code>的结构来保护这条新插入的记录在本事务提交前不被别的事务访问。</li></ul><h5 id="3-2-从数据操作的粒度划分：表级锁、页级锁、行锁"><a href="#3-2-从数据操作的粒度划分：表级锁、页级锁、行锁" class="headerlink" title="3.2 从数据操作的粒度划分：表级锁、页级锁、行锁"></a><strong>3.2</strong> <strong>从数据操作的粒度划分：表级锁、页级锁、行锁</strong></h5><p><strong>1.</strong> <strong>表锁（Table Lock）</strong> </p><p>该锁会锁定整张表，它是MySQL中最基本的锁策略，并<code>不依赖于存储引擎</code>，并且表锁是<code>开销最少</code>的策略。由于表级锁一次会将整个表锁定，所以可以很好的<code>避免死锁</code>的问题。当然，锁的粒度大所带来最大的负面影响就是出现锁资源争用的概率也会最高，导致<code>并发率大打折扣</code>。</p><p><strong>① 表级别的S锁、X锁</strong></p><p>在对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，InnoDB存储引擎是不会为这个表添加表级别的<code>S锁</code>或者<code>X锁</code>的。在对某个表执行一些诸如<code>ALTER TABLE</code>、<code>DROP TABLE</code>这类的<code>DDL</code>语句时，其他事务对这个表并发执行诸如SELECT、INSERT、DELETE、UPDATE的语句会发生阻塞。同理，某个事务中对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，在其他会话中对这个表执行<code>DDL</code>语句也会发生阻塞。这个过程其实是通过在<code>server层</code>使用一种称之为<code>元数据锁</code>（英文名：<code>Metadata Locks</code>，简称<code>MDL</code>）结构来实现的。</p><p>一般情况下，不会使用InnoDB存储引擎提供的表级别的<code>S锁</code>和<code>X锁</code>。只会在一些特殊情况下，比方说<code>崩溃恢复</code>过程中用到。比如，在系统变量<code>autocommit=0，innodb_table_locks = 1</code>时，<code>手动</code>获取InnoDB存储引擎提供的表t 的<code>S锁</code>或者<code>X锁</code>可以这么写：</p><ul><li><p><code>LOCK TABLES t READ</code>：InnoDB存储引擎会对表<code>t</code>加表级别的<code>S锁</code>。 </p></li><li><p><code>LOCK TABLES t WRITE</code>：InnoDB存储引擎会对表<code>t</code>加表级别的<code>X锁</code>。</p></li></ul><p>总结：MyISAM在执行查询语句（SELECT）前，会给涉及的所有表加读锁，在执行增删改操作前，会给涉及的表加写锁。<code>InnoDB</code>存储引擎是不会为这个表添加表级别的<code>读锁</code>或者<code>写锁</code>的。</p><p><strong>② 意向锁 （intention lock）</strong></p><p>InnoDB 支持<code>多粒度锁（multiple granularity locking）</code>，它允许<code>行级锁</code>与<code>表级锁</code>共存，而<strong>意向锁</strong>就是其中的一种<code>表锁</code>。</p><p>1、意向锁的存在是为了协调行锁和表锁的关系，支持多粒度（表锁与行锁）的锁并存。</p><p>2、意向锁是一种<code>不与行级锁冲突的表级锁</code>，这一点非常重要。</p><p>3、表明“某个事务正在某些行持有了锁或该事务准备去持有锁”</p><p>意向锁分为两种：</p><ul><li><strong>意向共享锁</strong>（intention shared lock, IS）：事务有意向对表中的某些行加<strong>共享锁</strong>（S锁）</li></ul><pre><code class="mysql">-- 事务要获取某些行的 S 锁，必须先获得表的 IS 锁。 SELECT column FROM table ... LOCK IN SHARE MODE;</code></pre><ul><li><strong>意向排他锁</strong>（intention exclusive lock, IX）：事务有意向对表中的某些行加<strong>排他锁</strong>（X锁）</li></ul><pre><code class="mysql">-- 事务要获取某些行的 X 锁，必须先获得表的 IX 锁。 SELECT column FROM table ... FOR UPDATE;</code></pre><p>即：意向锁是由存储引擎<code>自己维护的</code>，用户无法手动操作意向锁，在为数据行加共享 &#x2F; 排他锁之前，InooDB 会先获取该数据行<code>所在数据表的对应意向锁</code>。</p><p><strong>1. 意向锁要解决的问题</strong></p><p>现在有两个事务，分别是T1和T2，其中T2试图在该表级别上应用共享或排它锁，如果没有意向锁存在，那么T2就需要去检查各个页或行是否存在锁；如果存在意向锁，那么此时就会受到由T1控制的<code>表级别意向锁的阻塞</code>。T2在锁定该表前不必检查各个页或行锁，而只需检查表上的意向锁。简单来说就是给更大一级级别的空间示意里面是否已经上过锁。</p><p>在数据表的场景中，<strong>如果我们给某一行数据加上了排它锁，数据库会自动给更大一级的空间，比如数据页或数据表加上意向锁，告诉其他人这个数据页或数据表已经有人上过排它锁了</strong>，这样当其他人想要获取数据表排它锁的时候，只需要了解是否有人已经获取了这个数据表的意向排它锁即可。</p><ul><li>如果事务想要获取数据表中某些记录的共享锁，就需要在数据表上<code>添加意向共享锁</code></li><li>如果事务想要获取数据表中某些记录的排它锁，就需要在数据表上<code>添加意向排他锁</code></li></ul><p>这时，意向锁会告诉其他事务已经有人锁定了表中的某些记录。</p><p><strong>③ 自增锁（AUTO-INC锁）</strong></p><p><strong>1. “Simple inserts”</strong> <strong>（简单插入）</strong></p><p>可以<code>预先确定要插入的行数</code>（当语句被初始处理时）的语句。包括没有嵌套子查询的单行和多行<code>INSERT...VALUES()</code>和<code>REPLACE</code>语句。</p><p><strong>2. “Bulk inserts”</strong> <strong>（批量插入）</strong></p><p><code>事先不知道要插入的行数</code>（和所需自动递增值的数量）的语句。比如<code>INSERT ... SELECT</code>，<code>REPLACE ... SELECT</code>和<code>LOAD DATA</code>语句，但不包括纯INSERT。 InnoDB在每处理一行，为AUTO_INCREMENT列分配一个新值。</p><p><strong>3. “Mixed-mode inserts”</strong> <strong>（混合模式插入）</strong></p><p>这些是“Simple inserts”语句但是指定部分新行的自动递增值。例如<code>INSERT INTO teacher (id,name) VALUES (1,&#39;a&#39;), (NULL,&#39;b&#39;), (5,&#39;c&#39;), (NULL,&#39;d&#39;);</code>只是指定了部分id的值。另一种类型的“混合模式插入”是<code>INSERT ... ON DUPLICATE KEY UPDATE</code>。 </p><p>对于上面数据插入的案例，MySQL采用了<code>自增锁</code>的方式来实现，<strong>AUTO-INT锁是当向使用含有AUTO_INCREMENT列的表中插入数据时需要获取的一种特殊的表级锁</strong>，在执行插入语句时就在表级别加一个AUTO-INT锁，然后为每条待插入记录的AUTO_INCREMENT修饰的列分配递增的值，在该语句执行结束后，再把AUTO-INT锁释放掉。<strong>一个事务在持有AUTO-INC锁的过程中，其他事务的插入语句都要被阻塞</strong>，可以保证一个语句中分配的递增值是连续的。也正因为此，其并发性显然并不高，<strong>当我们向一个有AUTO_INCREMENT关键字的主键插入值的时候，每条语句都要对这个表锁进行竞争</strong>，这样的并发潜力其实是很低下的，所以innodb通过<code>innodb_autoinc_lock_mode</code>的不同取值来提供不同的锁定机制，来显著提高SQL语句的可伸缩性和性能。</p><p>innodb_autoinc_lock_mode有三种取值，分别对应与不同锁定模式：</p><p><code>（1）innodb_autoinc_lock_mode = 0(“传统”锁定模式)</code></p><p>在此锁定模式下，所有类型的insert语句都会获得一个特殊的表级AUTO-INC锁，用于插入具有AUTO_INCREMENT列的表。这种模式其实就如我们上面的例子，即每当执行insert的时候，都会得到一个表级锁(AUTO-INC锁)，使得语句中生成的auto_increment为顺序，且在binlog中重放的时候，可以保证master与slave中数据的auto_increment是相同的。因为是表级锁，当在同一时间多个事务中执行insert的时候，对于AUTO-INC锁的争夺会<code>限制并发</code>能力。</p><p><code>（2）innodb_autoinc_lock_mode = 1(“连续”锁定模式)</code></p><p>在 MySQL 8.0 之前，连续锁定模式是<code>默认</code>的。</p><p>在这个模式下，“bulk inserts”仍然使用AUTO-INC表级锁，并保持到语句结束。这适用于所有INSERT … SELECT，REPLACE … SELECT和LOAD DATA语句。同一时刻只有一个语句可以持有AUTO-INC锁。</p><p>对于“Simple inserts”（要插入的行数事先已知），则通过在<code>mutex（轻量锁）</code>的控制下获得所需数量的自动递增值来避免表级AUTO-INC锁， 它只在分配过程的持续时间内保持，而不是直到语句完成。不使用表级AUTO-INC锁，除非AUTO-INC锁由另一个事务保持。如果另一个事务保持AUTO-INC锁，则“Simple inserts”等待AUTO-INC锁，如同它是一个“bulk inserts”。 </p><p><code>（3）innodb_autoinc_lock_mode = 2(“交错”锁定模式)</code></p><p>从 MySQL 8.0 开始，交错锁模式是<code>默认</code>设置。</p><p>在这种锁定模式下，所有类INSERT语句都不会使用表级AUTO-INC锁，并且可以同时执行多个语句。这是最快和最可拓展的锁定模式，但是当使用基于语句的复制或恢复方案时，<strong>从二进制日志重播SQL语句时，这是不安全的。</strong></p><p>在此锁定模式下，自动递增值<code>保证</code>在所有并发执行的所有类型的insert语句中是<code>唯一</code>且<code>单调递增</code>的。但是，由于多个语句可以同时生成数字（即，跨语句交叉编号），<strong>为任何给定语句插入的行生成的值可能不是连续的。</strong></p><p><strong>④ 元数据锁（MDL锁）</strong></p><p>MySQL5.5引入了meta data lock，简称MDL锁，属于表锁范畴。MDL 的作用是，保证读写的正确性。比如，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个<code>表结构做变更</code>，增加了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。</p><p>因此，<strong>当对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。</strong></p><p><strong>2. InnoDB中的行锁</strong></p><p>行锁（Row Lock）也称为记录锁，顾名思义，就是锁住某一行（某条记录row）。需要注意的是，MySQL服务器层并没有实现行锁机制，<strong>行级锁只在存储引擎层实现。</strong></p><p><strong>优点：</strong>锁定力度小，发生<code>锁冲突概率低</code>，可以实现的<code>并发度高</code></p><p><strong>缺点：</strong>对于<code>锁的开销比较大</code>，加锁会比较慢，容易出现<code>死锁</code>情况</p><p>InnoDB与MyISAM的最大不同有两点：一是支持事务；二是采用了行级锁。</p><p><strong>① 记录锁（Record Locks）</strong></p><p>记录锁也就是仅仅把一条记录锁上，官方的类型名称为：<code>LOCK_REC_NOT_GAP</code>。</p><p>记录锁是有S锁和X锁之分的，称之为<code>S型记录锁</code>和<code>X型记录锁</code>。</p><ul><li>当一个事务获取了一条记录的S型记录锁后，其他事务也可以继续获取该记录的S型记录锁，但不可以继续获取X型记录锁；</li><li>当一个事务获取了一条记录的X型记录锁后，其他事务既不可以继续获取该记录的S型记录锁，也不可以继续获取X型记录锁。</li></ul><p><strong>② 间隙锁（Gap Locks）</strong></p><p><code>MySQL</code>在<code>REPEATABLE READ</code>隔离级别下是可以解决幻读问题的，解决方案有两种，可以使用<code>MVCC</code>方案解决，也可以采用<code>加锁</code>方案解决。但是在使用加锁方案解决时有个大问题，就是事务在第一次执行读取操作时，那些幻影记录尚不存在，我们无法给这些<code>幻影记录</code>加上<code>记录锁</code>。InnoDB提出了一种称之为<code>Gap Locks</code>的锁，官方的类型名称为：<code>LOCK_GAP</code>，我们可以简称为<code>gap锁</code>。</p><p><strong>gap锁的提出仅仅是为了防止插入幻影记录而提出的</strong>。虽然有<code>共享gap锁</code>和<code>独占gap锁</code>这样的说法，但是它们起到的作用是相同的。而且如果对一条记录加了gap锁（不论是共享gap锁还是独占gap锁），并不会限制其他事务对这条记录加记录锁或者继续加gap锁。</p><p><strong>③ 临键锁（Next-Key Locks）</strong></p><p>有时候我们既想<code>锁住某条记录</code>，又想<code>阻止</code>其他事务在该记录前边的<code>间隙插入新记录</code>，所以InnoDB就提出了一种称之为<code>Next-Key Locks</code>的锁，官方的类型名称为：<code>LOCK_ORDINARY</code>，我们也可以简称为<code>next-key锁</code>。Next-Key Locks是在存储引擎<code>innodb</code>、事务级别在<code>可重复读</code>的情况下使用的数据库锁，innodb默认的锁就是Next-Key locks。 </p><pre><code class="mysql">begin; select * from student where id &lt;=8 and id &gt; 3 for update;</code></pre><p><strong>④ 插入意向锁（Insert Intention Locks）</strong></p><p>我们说一个事务在<code>插入</code>一条记录时需要判断一下插入位置是不是被别的事务加了<code>gap锁</code>（<code>next-key锁</code>也包含<code>gap锁</code>），如果有的话，插入操作需要等待，直到拥有<code>gap锁</code>的那个事务提交。但是<strong>InnoDB规定事务在等待的时候也需要在内存中生成一个锁结构</strong>，表明有事务想在某个<code>间隙</code>中<code>插入</code>新记录，但是现在在等待。InnoDB就把这种类型的锁命名为<code>Insert Intention Locks</code>，官方的类型名称为：<code>LOCK_INSERT_INTENTION</code>，我们称为<code>插入意向锁</code>。插入意向锁是一种<code>Gap锁</code>，不是意向锁，在insert操作时产生。</p><p>插入意向锁是在插入一条记录行前，由<code>INSERT 操作产生的一种间隙锁</code>。</p><p>事实上<strong>插入意向锁并不会阻止别的事务继续获取该记录上任何类型的锁。</strong></p><p><strong>3.</strong> <strong>页锁</strong></p><p>页锁就是在<code>页的粒度</code>上进行锁定，锁定的数据资源比行锁要多，因为一个页中可以有多个行记录。当我们使用页锁的时候，会出现数据浪费的现象，但这样的浪费最多也就是一个页上的数据行。<strong>页锁的开销介于表锁和行锁之间，会出现死锁。锁定粒度介于表锁和行锁之间，并发度一般。</strong></p><p>每个层级的锁数量是有限制的，因为锁会占用内存空间，<code>锁空间的大小是有限的</code>。当某个层级的锁数量超过了这个层级的阈值时，就会进行<code>锁升级</code>。锁升级就是用更大粒度的锁替代多个更小粒度的锁，比如InnoDB 中行锁升级为表锁，这样做的好处是占用的锁空间降低了，但同时数据的并发度也下降了。</p><h5 id="3-3-从对待锁的态度划分-乐观锁、悲观锁"><a href="#3-3-从对待锁的态度划分-乐观锁、悲观锁" class="headerlink" title="3.3 从对待锁的态度划分:乐观锁、悲观锁"></a><strong>3.3</strong> <strong>从对待锁的态度划分:乐观锁、悲观锁</strong></h5><p>从对待锁的态度来看锁的话，可以将锁分成乐观锁和悲观锁，从名字中也可以看出这两种锁是两种看待<code>数据并发的思维方式</code>。需要注意的是，乐观锁和悲观锁并不是锁，而是锁的<code>设计思想</code>。</p><p><strong>1.</strong> <strong>悲观锁（Pessimistic Locking）</strong></p><p>悲观锁总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会<code>阻塞</code>直到它拿到锁（<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong>）。比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁，当其他线程想要访问数据时，都需要阻塞挂起。Java中<code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现。</p><p>注意：<strong>select … for update 语句执行过程中所有扫描的行都会被锁上，因此在MySQL中用悲观锁必须确定使用了索引，而不是全表扫描，否则将会把整个表锁住。</strong></p><p><strong>2.</strong> <strong>乐观锁（Optimistic Locking）</strong></p><p>乐观锁认为对同一数据的并发操作不会总发生，属于小概率事件，不用每次都对数据上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，也就是<strong>不采用数据库自身的锁机制，而是通过程序来实现</strong>。在程序上，我们可以采用<code>版本号机制</code>或者<code>CAS机制</code>实现。<strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量</strong>。在Java中<code>java.util.concurrent.atomic</code>包下的原子变量类就是使用了乐观锁的一种实现方式：CAS实现的。</p><p><strong>1.</strong> <strong>乐观锁的版本号机制</strong></p><p>在表中设计一个<code>版本字段 version</code>，第一次读的时候，会获取 version 字段的取值。然后对数据进行更新或删除操作时，会执行<code>UPDATE ... SET version=version+1 WHERE version=version</code>。此时如果已经有事务对这条数据进行了更改，修改就不会成功。</p><p><strong>2.</strong> <strong>乐观锁的时间戳机制</strong></p><p>时间戳和版本号机制一样，也是在更新提交的时候，将当前数据的时间戳和更新之前取得的时间戳进行比较，如果两者一致则更新成功，否则就是版本冲突。</p><p>你能看到乐观锁就是程序员自己控制数据并发操作的权限，基本是通过给数据行增加一个戳（版本号或者时间戳），从而证明当前拿到的数据是否最新。</p><p><strong>3.</strong> <strong>两种锁的适用场景</strong></p><p>从这两种锁的设计思想中，我们总结一下乐观锁和悲观锁的适用场景：</p><ol><li><p><code>乐观锁</code>适合<code>读操作多</code>的场景，相对来说写的操作比较少。它的优点在于<code>程序实现</code>，<code>不存在死锁</code>问题，不过适用场景也会相对乐观，因为它阻止不了除了程序以外的数据库操作。</p></li><li><p><code>悲观锁</code>适合<code>写操作多</code>的场景，因为写的操作具有<code>排它性</code>。采用悲观锁的方式，可以在数据库层面阻止其他事务对该数据的操作权限，防止<code>读 - 写</code>和<code>写 - 写</code>的冲突。</p></li></ol><h5 id="3-4-按加锁的方式划分：显式锁、隐式锁"><a href="#3-4-按加锁的方式划分：显式锁、隐式锁" class="headerlink" title="3.4 按加锁的方式划分：显式锁、隐式锁"></a><strong>3.4</strong> <strong>按加锁的方式划分：显式锁、隐式锁</strong></h5><p><strong>1.</strong> <strong>隐式锁</strong></p><ul><li><p><strong>情景一：</strong>对于聚簇索引记录来说，有一个<code>trx_id</code>隐藏列，该隐藏列记录着最后改动该记录的<code>事务id</code>。那么如果在当前事务中新插入一条聚簇索引记录后，该记录的<code>trx_id</code>隐藏列代表的的就是当前事务的<code>事务id</code>，如果其他事务此时想对该记录添加<code>S锁</code>或者<code>X锁</code>时，首先会看一下该记录的<code>trx_id</code>隐藏列代表的事务是否是当前的活跃事务，如果是的话，那么就帮助当前事务创建一个<code>X锁</code>（也就是为当前事务创建一个锁结构，<code>is_waiting</code>属性是<code>false</code>），然后自己进入等待状态（也就是为自己也创建一个锁结构，<code>is_waiting</code>属性是<code>true</code>）。</p></li><li><p><strong>情景二：</strong>对于二级索引记录来说，本身并没有<code>trx_id</code>隐藏列，但是在二级索引页面的<code>Page Header</code>部分有一个<code>PAGE_MAX_TRX_ID</code>属性，该属性代表对该页面做改动的最大的<code>事务id</code>，如果<code>PAGE_MAX_TRX_ID</code>属性值小于当前最小的活跃<code>事务id</code>，那么说明对该页面做修改的事务都已经提交了，否则就需要在页面中定位到对应的二级索引记录，然后回表找到它对应的聚簇索引记录，然后再重复<code>情景一</code>的做法。</p></li></ul><p>即：一个事务对新插入的记录可以不显示的加锁（生成一个锁结构），但是由于<code>事务id</code>的存在，相当于加了一个<code>隐式锁</code>。别的事务在对这条记录加<code>S锁</code>或者<code>X锁</code>时，由于<code>隐式锁</code>的存在，会先帮助当前事务生成一个锁结构，然后自己再生成一个锁结构后进入等待状态。隐式锁是一种<code>延迟加锁</code>的机制，从而来减少加锁的数量。</p><p><strong>2.</strong> <strong>显式锁</strong></p><p>通过特定的语句进行加锁，我们一般称之为显示加锁。</p><h5 id="3-5-其它锁之：全局锁"><a href="#3-5-其它锁之：全局锁" class="headerlink" title="3.5 其它锁之：全局锁"></a><strong>3.5</strong> <strong>其它锁之：全局锁</strong></h5><p>全局锁就是对<code>整个数据库实例</code>加锁。当你需要让整个库处于<code>只读状态</code>的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。全局锁的典型使用<code>场景</code>是：做<code>全库逻辑备份</code>。</p><p>全局锁的命令：</p><pre><code class="mysql">Flush tables with read lock</code></pre><h5 id="3-6-其它锁之：死锁"><a href="#3-6-其它锁之：死锁" class="headerlink" title="3.6 其它锁之：死锁"></a><strong>3.6</strong> <strong>其它锁之：死锁</strong></h5><p>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环。</p><p><strong>1. 如何处理死锁</strong></p><p><strong>方式1：</strong>等待，直到超时（innodb_lock_wait_timeout&#x3D;50s）</p><p>即当两个事务互相等待时，当一个事务等待时间超过设置的阈值时，就将其<code>回滚</code>，另外事务继续进行。</p><p><strong>方式2：</strong>使用死锁检测进行死锁处理</p><p>发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务（将持有最少行级排他锁的事务进行回滚），让其他事务得以继续执行。</p><h4 id="4-锁的内存结构"><a href="#4-锁的内存结构" class="headerlink" title="4. 锁的内存结构"></a><strong>4.</strong> <strong>锁的内存结构</strong></h4><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051514736.png" alt="image-20220405151409557"></p><p>结构解析：</p><p><code>1. 锁所在的事务信息</code>：</p><p>不论是<code>表锁</code>还是<code>行锁</code>，都是在事务执行过程中生成的，哪个事务生成了这个 锁结构 ，这里就记录这个事务的信息。</p><p>此<code>锁所在的事务信息</code>在内存结构中只是一个指针，通过指针可以找到内存中关于该事务的更多信息，比方说事务id等。</p><p><code>2. 索引信息</code>：</p><p>对于<code>行锁</code>来说，需要记录一下加锁的记录是属于哪个索引的。这里也是一个指针。</p><p><code>3. 表锁／行锁信息</code>： </p><p><code>表锁结构</code>和<code>行锁结构</code>在这个位置的内容是不同的：</p><ul><li>表锁：记载着是对哪个表加的锁，还有其他的一些信息。</li><li>行锁：记载了三个重要的信息：<ul><li>Space ID ：记录所在表空间。</li><li>Page Number ：记录所在页号。</li><li>n_bits ：对于行锁来说，一条记录就对应着一个比特位，一个页面中包含很多记录，用不同的比特位来区分到底是哪一条记录加了锁。为此在行锁结构的末尾放置了一堆比特位，这个n_bits 属性代表使用了多少比特位。</li></ul></li></ul><blockquote><p>n_bits的值一般都比页面中记录条数多一些。主要是为了之后在页面中插入了新记录后也不至于重新分配锁结构</p></blockquote><p><code>4. type_mode</code>：</p><p>这是一个32位的数，被分成了<code>lock_mode</code>、<code>lock_type</code>和<code>rec_lock_type</code>三个部分，如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051518659.png" alt="image-20220405151829547"></p><ul><li>锁的模式（<code>lock_mode</code>），占用低4位，可选的值如下：<ul><li><code>LOCK_IS</code>（十进制的<code>0</code>）：表示共享意向锁，也就是<code>IS锁</code>。 </li><li><code>LOCK_IX</code>（十进制的<code>1</code>）：表示独占意向锁，也就是<code>IX锁</code>。 </li><li><code>LOCK_S</code>（十进制的<code>2</code>）：表示共享锁，也就是<code>S锁</code>。 </li><li><code>LOCK_X</code>（十进制的<code>3</code>）：表示独占锁，也就是<code>X锁</code>。 </li><li><code>LOCK_AUTO_INC</code>（十进制的<code>4</code>）：表示<code>AUTO-INC锁</code>。</li></ul></li></ul><p>在InnoDB存储引擎中，LOCK_IS，LOCK_IX，LOCK_AUTO_INC都算是表级锁的模式，LOCK_S和 LOCK_X既可以算是表级锁的模式，也可以是行级锁的模式。</p><ul><li>锁的类型（<code>lock_type</code>），占用第5～8位，不过现阶段只有第5位和第6位被使用：<ul><li><code>LOCK_TABLE</code>（十进制的<code>16</code>），也就是当第5个比特位置为1时，表示表级锁。</li><li><code>LOCK_REC</code>（十进制的<code>32</code>），也就是当第6个比特位置为1时，表示行级锁。</li></ul></li><li>行锁的具体类型（<code>rec_lock_type</code>），使用其余的位来表示。只有在 <code>lock_type</code>的值为<code>LOCK_REC</code>时，也就是只有在该锁为行级锁时，才会被细分为更多的类型：<ul><li><code>LOCK_ORDINARY</code>（十进制的<code>0</code>）：表示<code>next-key锁</code>。 </li><li><code>LOCK_GAP</code>（十进制的<code>512</code>）：也就是当第10个比特位置为1时，表示<code>gap锁</code>。 </li><li><code>LOCK_REC_NOT_GAP</code>（十进制的<code>1024</code>）：也就是当第11个比特位置为1时，表示正经<code>记录锁</code>。</li><li><code>LOCK_INSERT_INTENTION</code>（十进制的<code>2048</code>）：也就是当第12个比特位置为1时，表示插入意向锁。其他的类型：还有一些不常用的类型我们就不多说了。</li></ul></li><li><code>is_waiting</code>属性呢？基于内存空间的节省，所以把 is_waiting 属性放到了 type_mode 这个32位的数字中：<ul><li><code>LOCK_WAIT</code>（十进制的<code>256</code>） ：当第9个比特位置为<code>1</code>时，表示<code>is_waiting</code>为<code>true</code>，也就是当前事务尚未获取到锁，处在等待状态；当这个比特位为<code>0</code>时，表示<code>is_waiting</code>为<code>false</code>，也就是当前事务获取锁成功。</li></ul></li></ul><p><code>5. 其他信息</code>：</p><p>为了更好的管理系统运行过程中生成的各种锁结构而设计了各种哈希表和链表。</p><p><code>6. 一堆比特位</code>：</p><p>如果是<code>行锁结构</code>的话，在该结构末尾还放置了一堆比特位，比特位的数量是由上边提到的<code>n_bits</code>属性表示的。InnoDB数据页中的每条记录在<code>记录头信息</code>中都包含一个 heap_no 属性，伪记录<code>Infimum</code>的<code>heap_no</code>值为<code>0</code>，<code>Supremum</code>的<code>heap_no</code>值为<code>1</code>，之后每插入一条记录，<code>heap_no</code>值就增1。<code>锁结构</code>最后的一堆比特位就对应着一个页面中的记录，一个比特位映射一个<code>heap_no</code>，即一个比特位映射到页内的一条记录。</p><h4 id="5-锁监控"><a href="#5-锁监控" class="headerlink" title="5. 锁监控"></a><strong>5.</strong> <strong>锁监控</strong></h4><pre><code class="mysql">mysql&gt; show status like &#39;innodb_row_lock%&#39;;</code></pre><ul><li>Innodb_row_lock_current_waits：当前正在等待锁定的数量；</li><li><code>Innodb_row_lock_time</code>：从系统启动到现在锁定总时间长度；（等待总时长）</li><li><code>Innodb_row_lock_time_avg</code>：每次等待所花平均时间；（等待平均时长）</li><li>Innodb_row_lock_time_max：从系统启动到现在等待最常的一次所花的时间；</li><li><code>Innodb_row_lock_waits</code>：系统启动后到现在总共等待的次数；（等待总次数）</li></ul><p><strong>其他监控方法：</strong></p><p>MySQL把事务和锁的信息记录在了<code>information_schema</code>库中，涉及到的三张表分别是<code>INNODB_TRX</code>、<code>INNODB_LOCKS</code>和<code>INNODB_LOCK_WAITS</code>。 </p><p><code>MySQL5.7及之前</code>，可以通过information_schema.INNODB_LOCKS查看事务的锁情况，但只能看到阻塞事务的锁；如果事务并未被阻塞，则在该表中看不到该事务的锁情况。</p><p>MySQL8.0删除了information_schema.INNODB_LOCKS，添加了<code>performance_schema.data_locks</code>，可以通过performance_schema.data_locks查看事务的锁情况，和MySQL5.7及之前不同，performance_schema.data_locks不但可以看到阻塞该事务的锁，还可以看到该事务所持有的锁。</p><p>同时，information_schema.INNODB_LOCK_WAITS也被<code>performance_schema.data_lock_waits</code>所代替。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/07/14/day06/"/>
      <url>/2023/07/14/day06/</url>
      
        <content type="html"><![CDATA[<h1 id="day06"><a href="#day06" class="headerlink" title="day06"></a>day06</h1><h2 id="一、声明式导航-导航链接"><a href="#一、声明式导航-导航链接" class="headerlink" title="一、声明式导航-导航链接"></a>一、声明式导航-导航链接</h2><h3 id="1-需求"><a href="#1-需求" class="headerlink" title="1.需求"></a>1.需求</h3><p>实现导航高亮效果</p><p><img src="/assets/1682492044744.png" alt="68249204474"></p><p>如果使用a标签进行跳转的话，需要给当前跳转的导航加样式，同时要移除上一个a标签的样式，太麻烦！！！</p><h3 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2.解决方案"></a>2.解决方案</h3><p>vue-router 提供了一个全局组件 router-link (取代 a 标签)</p><ul><li><strong>能跳转</strong>，配置 to 属性指定路径(<strong>必须</strong>) 。本质还是 a 标签 ，<strong>to 无需 #</strong></li><li><strong>能高亮</strong>，默认就会提供<strong>高亮类名</strong>，可以直接设置高亮样式</li></ul><p>语法： <router-link to="path的值">发现音乐</router-link></p><pre><code class="vue">  &lt;div&gt;    &lt;div class=&quot;footer_wrap&quot;&gt;      &lt;router-link to=&quot;/find&quot;&gt;发现音乐&lt;/router-link&gt;      &lt;router-link to=&quot;/my&quot;&gt;我的音乐&lt;/router-link&gt;      &lt;router-link to=&quot;/friend&quot;&gt;朋友&lt;/router-link&gt;    &lt;/div&gt;    &lt;div class=&quot;top&quot;&gt;      &lt;!-- 路由出口 → 匹配的组件所展示的位置 --&gt;      &lt;router-view&gt;&lt;/router-view&gt;    &lt;/div&gt;  &lt;/div&gt;</code></pre><h3 id="3-通过router-link自带的两个样式进行高亮"><a href="#3-通过router-link自带的两个样式进行高亮" class="headerlink" title="3.通过router-link自带的两个样式进行高亮"></a>3.通过router-link自带的两个样式进行高亮</h3><p>使用router-link跳转后，我们发现。当前点击的链接默认加了两个class的值 <code>router-link-exact-active</code>和<code>router-link-active</code></p><p>我们可以给任意一个class属性添加高亮样式即可实现功能</p><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h3><ul><li>router-link是什么？</li><li>router-link怎么用？</li><li>router-link的好处是什么？</li></ul><h2 id="二、声明式导航-两个类名"><a href="#二、声明式导航-两个类名" class="headerlink" title="二、声明式导航-两个类名"></a>二、声明式导航-两个类名</h2><p>当我们使用<router-link></router-link>跳转时，自动给当前导航加了<strong>两个类名</strong></p><p><img src="/assets/1682493121052.png" alt="68249312105"></p><h3 id="1-router-link-active"><a href="#1-router-link-active" class="headerlink" title="1.router-link-active"></a>1.router-link-active</h3><p><strong>模糊匹配（用的多）</strong></p><p>to&#x3D;”&#x2F;my”  可以匹配 &#x2F;my    &#x2F;my&#x2F;a    &#x2F;my&#x2F;b    ….  </p><p>只要是以&#x2F;my开头的路径 都可以和 to&#x3D;”&#x2F;my”匹配到</p><h3 id="2-router-link-exact-active"><a href="#2-router-link-exact-active" class="headerlink" title="2.router-link-exact-active"></a>2.router-link-exact-active</h3><p><strong>精确匹配</strong></p><p>to&#x3D;”&#x2F;my” 仅可以匹配  &#x2F;my</p><h3 id="3-在地址栏中输入二级路由查看类名的添加"><a href="#3-在地址栏中输入二级路由查看类名的添加" class="headerlink" title="3.在地址栏中输入二级路由查看类名的添加"></a>3.在地址栏中输入二级路由查看类名的添加</h3><h3 id="4-总结-1"><a href="#4-总结-1" class="headerlink" title="4.总结"></a>4.总结</h3><ul><li>router-link 会自动给当前导航添加两个类名，有什么区别呢？</li></ul><h2 id="三、声明式导航-自定义类名（了解）"><a href="#三、声明式导航-自定义类名（了解）" class="headerlink" title="三、声明式导航-自定义类名（了解）"></a>三、声明式导航-自定义类名（了解）</h2><h3 id="1-问题"><a href="#1-问题" class="headerlink" title="1.问题"></a>1.问题</h3><p>router-link的<strong>两个高亮类名 太长了</strong>，我们希望能定制怎么办</p><p><img src="/assets/1682493610911.png" alt="68249361091"></p><h3 id="2-解决方案-1"><a href="#2-解决方案-1" class="headerlink" title="2.解决方案"></a>2.解决方案</h3><p>我们可以在创建路由对象时，额外配置两个配置项即可。 <code>linkActiveClass</code>和<code>linkExactActiveClass</code></p><pre><code class="js">const router = new VueRouter(&#123;  routes: [...],  linkActiveClass: &quot;类名1&quot;,  linkExactActiveClass: &quot;类名2&quot;&#125;)</code></pre><p><img src="/assets/1682493729456.png" alt="68249372945"></p><h3 id="3-代码演示"><a href="#3-代码演示" class="headerlink" title="3.代码演示"></a>3.代码演示</h3><pre><code class="js">// 创建了一个路由对象const router = new VueRouter(&#123;  routes: [    ...  ],   linkActiveClass: &#39;active&#39;, // 配置模糊匹配的类名  linkExactActiveClass: &#39;exact-active&#39; // 配置精确匹配的类名&#125;)</code></pre><h3 id="4-总结-2"><a href="#4-总结-2" class="headerlink" title="4.总结"></a>4.总结</h3><p>如何自定义router-link的两个<strong>高亮类名</strong></p><h2 id="四、声明式导航-查询参数传参"><a href="#四、声明式导航-查询参数传参" class="headerlink" title="四、声明式导航-查询参数传参"></a>四、声明式导航-查询参数传参</h2><h3 id="1-目标"><a href="#1-目标" class="headerlink" title="1.目标"></a>1.目标</h3><p>在跳转路由时，进行传参</p><p><img src="/assets/1682494423923.png" alt="68249442392"></p><p>比如：现在我们在搜索页点击了热门搜索链接，跳转到详情页，<strong>需要把点击的内容带到详情页</strong>，改怎么办呢？</p><h3 id="2-跳转传参"><a href="#2-跳转传参" class="headerlink" title="2.跳转传参"></a>2.跳转传参</h3><p>我们可以通过两种方式，在跳转的时候把所需要的参数传到其他页面中</p><ul><li>查询参数传参</li><li>动态路由传参</li></ul><h3 id="3-查询参数传参"><a href="#3-查询参数传参" class="headerlink" title="3.查询参数传参"></a>3.查询参数传参</h3><ul><li><p>如何传参？</p><p><router-link to="/path?参数名=值"></router-link></p></li><li><p>如何接受参数</p><p>固定用法：$router.query.参数名</p></li></ul><h3 id="4-代码演示"><a href="#4-代码演示" class="headerlink" title="4.代码演示"></a>4.代码演示</h3><p>App.vue</p><pre><code class="vue">&lt;template&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;div class=&quot;link&quot;&gt;      &lt;router-link to=&quot;/home&quot;&gt;首页&lt;/router-link&gt;      &lt;router-link to=&quot;/search&quot;&gt;搜索页&lt;/router-link&gt;    &lt;/div&gt;    &lt;router-view&gt;&lt;/router-view&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;&#125;;&lt;/script&gt;&lt;style scoped&gt;.link &#123;  height: 50px;  line-height: 50px;  background-color: #495150;  display: flex;  margin: -8px -8px 0 -8px;  margin-bottom: 50px;&#125;.link a &#123;  display: block;  text-decoration: none;  background-color: #ad2a26;  width: 100px;  text-align: center;  margin-right: 5px;  color: #fff;  border-radius: 5px;&#125;&lt;/style&gt;</code></pre><p>Home.vue</p><pre><code class="vue">&lt;template&gt;  &lt;div class=&quot;home&quot;&gt;    &lt;div class=&quot;logo-box&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;search-box&quot;&gt;      &lt;input type=&quot;text&quot;&gt;      &lt;button&gt;搜索一下&lt;/button&gt;    &lt;/div&gt;    &lt;div class=&quot;hot-link&quot;&gt;      热门搜索：      &lt;router-link to=&quot;&quot;&gt;黑马程序员&lt;/router-link&gt;      &lt;router-link to=&quot;&quot;&gt;前端培训&lt;/router-link&gt;      &lt;router-link to=&quot;&quot;&gt;如何成为前端大牛&lt;/router-link&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;FindMusic&#39;&#125;&lt;/script&gt;&lt;style&gt;.logo-box &#123;  height: 150px;  background: url(&#39;@/assets/logo.jpeg&#39;) no-repeat center;&#125;.search-box &#123;  display: flex;  justify-content: center;&#125;.search-box input &#123;  width: 400px;  height: 30px;  line-height: 30px;  border: 2px solid #c4c7ce;  border-radius: 4px 0 0 4px;  outline: none;&#125;.search-box input:focus &#123;  border: 2px solid #ad2a26;&#125;.search-box button &#123;  width: 100px;  height: 36px;  border: none;  background-color: #ad2a26;  color: #fff;  position: relative;  left: -2px;  border-radius: 0 4px 4px 0;&#125;.hot-link &#123;  width: 508px;  height: 60px;  line-height: 60px;  margin: 0 auto;&#125;.hot-link a &#123;  margin: 0 5px;&#125;&lt;/style&gt;</code></pre><p>Search.vue</p><pre><code class="vue">&lt;template&gt;  &lt;div class=&quot;search&quot;&gt;    &lt;p&gt;搜索关键字: 黑马程序员&lt;/p&gt;    &lt;p&gt;搜索结果: &lt;/p&gt;    &lt;ul&gt;      &lt;li&gt;.............&lt;/li&gt;      &lt;li&gt;.............&lt;/li&gt;      &lt;li&gt;.............&lt;/li&gt;      &lt;li&gt;.............&lt;/li&gt;    &lt;/ul&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;MyFriend&#39;,  created () &#123;    // 在created中，获取路由参数  &#125;&#125;&lt;/script&gt;&lt;style&gt;.search &#123;  width: 400px;  height: 240px;  padding: 0 20px;  margin: 0 auto;  border: 2px solid #c4c7ce;  border-radius: 5px;&#125;&lt;/style&gt;</code></pre><p>router&#x2F;index.js</p><pre><code class="js">import Home from &#39;@/views/Home&#39;import Search from &#39;@/views/Search&#39;import Vue from &#39;vue&#39;import VueRouter from &#39;vue-router&#39;Vue.use(VueRouter) // VueRouter插件初始化// 创建了一个路由对象const router = new VueRouter(&#123;  routes: [    &#123; path: &#39;/home&#39;, component: Home &#125;,    &#123; path: &#39;/search&#39;, component: Search &#125;  ]&#125;)export default router</code></pre><p>main.js</p><pre><code>...import router from &#39;./router/index&#39;...new Vue(&#123;  render: h =&gt; h(App),  router&#125;).$mount(&#39;#app&#39;)</code></pre><h2 id="五、声明式导航-动态路由传参"><a href="#五、声明式导航-动态路由传参" class="headerlink" title="五、声明式导航-动态路由传参"></a>五、声明式导航-动态路由传参</h2><h3 id="1-动态路由传参方式"><a href="#1-动态路由传参方式" class="headerlink" title="1.动态路由传参方式"></a>1.动态路由传参方式</h3><ul><li><p>配置动态路由</p><blockquote><p>动态路由后面的参数可以随便起名，但要有语义</p></blockquote><pre><code class="js">const router = new VueRouter(&#123;  routes: [    ...,    &#123;       path: &#39;/search/:words&#39;,       component: Search     &#125;  ]&#125;)</code></pre></li><li><p>配置导航链接</p><p>to&#x3D;”&#x2F;path&#x2F;参数值”</p></li><li><p>对应页面组件<strong>接受参数</strong></p><p>$route.<strong>params</strong>.参数名</p><blockquote><p>params后面的参数名要和动态路由配置的参数保持一致</p></blockquote></li></ul><h3 id="2-查询参数传参-VS-动态路由传参"><a href="#2-查询参数传参-VS-动态路由传参" class="headerlink" title="2.查询参数传参 VS 动态路由传参"></a>2.查询参数传参 VS 动态路由传参</h3><ol><li><p>查询参数传参  (比较适合传<strong>多个参数</strong>) </p></li><li><p>跳转：to&#x3D;”&#x2F;path?参数名&#x3D;值&amp;参数名2&#x3D;值”</p></li><li><p>获取：$route.query.参数名</p></li><li><p>动态路由传参 (<strong>优雅简洁</strong>，传单个参数比较方便)</p><ol><li>配置动态路由：path: “&#x2F;path&#x2F;:参数名” </li><li>跳转：to&#x3D;”&#x2F;path&#x2F;参数值”</li><li>获取：$route.params.参数名</li></ol><p>注意：动态路由也可以传多个参数，但一般只传一个</p></li></ol><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h3><p>声明式导航跳转时, 有几种方式传值给路由页面？</p><ul><li>查询参数传参（多个参数）</li><li>动态路由传参（一个参数，优雅简洁）</li></ul><h2 id="六、动态路由参数的可选符-了解"><a href="#六、动态路由参数的可选符-了解" class="headerlink" title="六、动态路由参数的可选符(了解)"></a>六、动态路由参数的可选符(了解)</h2><h3 id="1-问题-1"><a href="#1-问题-1" class="headerlink" title="1.问题"></a>1.问题</h3><p>配了路由 path:”&#x2F;search&#x2F;:words”  为什么按下面步骤操作，会未匹配到组件，显示空白？</p><p><img src="/assets/1682497238305.png" alt="68249723830"></p><h3 id="2-原因"><a href="#2-原因" class="headerlink" title="2.原因"></a>2.原因</h3><p>&#x2F;search&#x2F;:words  表示，<strong>必须要传参数</strong>。如果不传参数，也希望匹配，可以加个可选符”？”</p><pre><code class="js">const router = new VueRouter(&#123;  routes: [     ...    &#123; path: &#39;/search/:words?&#39;, component: Search &#125;  ]&#125;)</code></pre><h2 id="七、Vue路由-重定向"><a href="#七、Vue路由-重定向" class="headerlink" title="七、Vue路由-重定向"></a>七、Vue路由-重定向</h2><h3 id="1-问题-2"><a href="#1-问题-2" class="headerlink" title="1.问题"></a>1.问题</h3><p>网页打开时， url 默认是 &#x2F; 路径，未匹配到组件时，会出现空白</p><p><img src="/assets/1682497872821.png" alt="68249787282"></p><h3 id="2-解决方案-2"><a href="#2-解决方案-2" class="headerlink" title="2.解决方案"></a>2.解决方案</h3><p><strong>重定向</strong> → 匹配 &#x2F; 后, 强制跳转 &#x2F;home 路径</p><h3 id="3-语法"><a href="#3-语法" class="headerlink" title="3.语法"></a>3.语法</h3><pre><code class="js">&#123; path: 匹配路径, redirect: 重定向到的路径 &#125;,比如：&#123; path:&#39;/&#39; ,redirect:&#39;/home&#39; &#125;</code></pre><h3 id="4-代码演示-1"><a href="#4-代码演示-1" class="headerlink" title="4.代码演示"></a>4.代码演示</h3><pre><code>const router = new VueRouter(&#123;  routes: [    &#123; path: &#39;/&#39;, redirect: &#39;/home&#39;&#125;,  ...  ]&#125;)</code></pre><h2 id="八、Vue路由-404"><a href="#八、Vue路由-404" class="headerlink" title="八、Vue路由-404"></a>八、Vue路由-404</h2><h3 id="1-作用"><a href="#1-作用" class="headerlink" title="1.作用"></a>1.作用</h3><p>当路径找不到匹配时，给个提示页面</p><h3 id="2-位置"><a href="#2-位置" class="headerlink" title="2.位置"></a>2.位置</h3><p>404的路由，虽然配置在任何一个位置都可以，但一般都<strong>配置在其他路由规则的最后面</strong></p><h3 id="3-语法-1"><a href="#3-语法-1" class="headerlink" title="3.语法"></a>3.语法</h3><p>path: “*”   (任意路径) – 前面不匹配就命中最后这个</p><pre><code class="js">import NotFind from &#39;@/views/NotFind&#39;const router = new VueRouter(&#123;  routes: [    ...    &#123; path: &#39;*&#39;, component: NotFind &#125; //最后一个  ]&#125;)</code></pre><h3 id="4-代码示例"><a href="#4-代码示例" class="headerlink" title="4.代码示例"></a>4.代码示例</h3><p>NotFound.vue</p><pre><code class="vue">&lt;template&gt;  &lt;div&gt;    &lt;h1&gt;404 Not Found&lt;/h1&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt;</code></pre><p>router&#x2F;index.js</p><pre><code class="js">...import NotFound from &#39;@/views/NotFound&#39;...// 创建了一个路由对象const router = new VueRouter(&#123;  routes: [     ...    &#123; path: &#39;*&#39;, component: NotFound &#125;  ]&#125;)export default router</code></pre><h2 id="九、Vue路由-模式设置"><a href="#九、Vue路由-模式设置" class="headerlink" title="九、Vue路由-模式设置"></a>九、Vue路由-模式设置</h2><h3 id="1-问题-3"><a href="#1-问题-3" class="headerlink" title="1.问题"></a>1.问题</h3><p>路由的路径看起来不自然, 有#，能否切成真正路径形式?</p><ul><li>hash路由(默认)        例如:  <a href="http://localhost:8080/#/home">http://localhost:8080/#/home</a></li><li>history路由(常用)     例如: <a href="http://localhost:8080/home">http://localhost:8080/home</a>   (以后上线需要服务器端支持，开发环境webpack给规避掉了history模式的问题)</li></ul><h3 id="2-语法"><a href="#2-语法" class="headerlink" title="2.语法"></a>2.语法</h3><pre><code class="js">const router = new VueRouter(&#123;    mode:&#39;histroy&#39;, //默认是hash    routes:[]&#125;)</code></pre><h2 id="十、编程式导航-两种路由跳转方式"><a href="#十、编程式导航-两种路由跳转方式" class="headerlink" title="十、编程式导航-两种路由跳转方式"></a>十、编程式导航-两种路由跳转方式</h2><h3 id="1-问题-4"><a href="#1-问题-4" class="headerlink" title="1.问题"></a>1.问题</h3><p>点击按钮跳转如何实现？</p><p><img src="/assets/1682500481059.png" alt="68250048105"></p><h3 id="2-方案"><a href="#2-方案" class="headerlink" title="2.方案"></a>2.方案</h3><p>编程式导航：用JS代码来进行跳转</p><h3 id="3-语法-2"><a href="#3-语法-2" class="headerlink" title="3.语法"></a>3.语法</h3><p>两种语法：</p><ul><li>path 路径跳转 （简易方便）</li><li>name 命名路由跳转 (适合 path 路径长的场景)</li></ul><h3 id="4-path路径跳转语法"><a href="#4-path路径跳转语法" class="headerlink" title="4.path路径跳转语法"></a>4.path路径跳转语法</h3><p>特点：简易方便</p><pre><code class="js">//简单写法this.$router.push(&#39;路由路径&#39;)//完整写法this.$router.push(&#123;  path: &#39;路由路径&#39;&#125;)</code></pre><h3 id="5-代码演示-path跳转方式"><a href="#5-代码演示-path跳转方式" class="headerlink" title="5.代码演示 path跳转方式"></a>5.代码演示 path跳转方式</h3><h3 id="6-name命名路由跳转"><a href="#6-name命名路由跳转" class="headerlink" title="6.name命名路由跳转"></a>6.name命名路由跳转</h3><p>特点：适合 path 路径长的场景</p><p>语法：</p><ul><li><p>路由规则，必须配置name配置项</p><pre><code class="js">&#123; name: &#39;路由名&#39;, path: &#39;/path/xxx&#39;, component: XXX &#125;,</code></pre></li><li><p>通过name来进行跳转</p><pre><code class="js">this.$router.push(&#123;  name: &#39;路由名&#39;&#125;)</code></pre></li></ul><h3 id="7-代码演示通过name命名路由跳转"><a href="#7-代码演示通过name命名路由跳转" class="headerlink" title="7.代码演示通过name命名路由跳转"></a>7.代码演示通过name命名路由跳转</h3><h3 id="8-总结"><a href="#8-总结" class="headerlink" title="8.总结"></a>8.总结</h3><p>编程式导航有几种跳转方式？</p><h2 id="十一、编程式导航-path路径跳转传参"><a href="#十一、编程式导航-path路径跳转传参" class="headerlink" title="十一、编程式导航-path路径跳转传参"></a>十一、编程式导航-path路径跳转传参</h2><h3 id="1-问题-5"><a href="#1-问题-5" class="headerlink" title="1.问题"></a>1.问题</h3><p>点击搜索按钮，跳转需要把文本框中输入的内容传到下一个页面如何实现？</p><p><img src="/assets/1682502720585.png" alt="68250272058"></p><h3 id="2-两种传参方式"><a href="#2-两种传参方式" class="headerlink" title="2.两种传参方式"></a>2.两种传参方式</h3><p>1.查询参数 </p><p>2.动态路由传参</p><h3 id="3-传参"><a href="#3-传参" class="headerlink" title="3.传参"></a>3.传参</h3><p>两种跳转方式，对于两种传参方式都支持：</p><p>① path 路径跳转传参</p><p>② name 命名路由跳转传参</p><h3 id="4-path路径跳转传参（query传参）"><a href="#4-path路径跳转传参（query传参）" class="headerlink" title="4.path路径跳转传参（query传参）"></a>4.path路径跳转传参（query传参）</h3><pre><code class="js">//简单写法this.$router.push(&#39;/路径?参数名1=参数值1&amp;参数2=参数值2&#39;)//完整写法this.$router.push(&#123;  path: &#39;/路径&#39;,  query: &#123;    参数名1: &#39;参数值1&#39;,    参数名2: &#39;参数值2&#39;  &#125;&#125;)</code></pre><p>接受参数的方式依然是：$route.query.参数名</p><h3 id="5-path路径跳转传参（动态路由传参）"><a href="#5-path路径跳转传参（动态路由传参）" class="headerlink" title="5.path路径跳转传参（动态路由传参）"></a>5.path路径跳转传参（动态路由传参）</h3><pre><code>//简单写法this.$router.push(&#39;/路径/参数值&#39;)//完整写法this.$router.push(&#123;  path: &#39;/路径/参数值&#39;&#125;)</code></pre><p>接受参数的方式依然是：$route.params.参数值</p><p><strong>注意：</strong>path不能配合params使用</p><h2 id="十二、编程式导航-name命名路由传参"><a href="#十二、编程式导航-name命名路由传参" class="headerlink" title="十二、编程式导航-name命名路由传参"></a>十二、编程式导航-name命名路由传参</h2><h3 id="1-name-命名路由跳转传参-query传参"><a href="#1-name-命名路由跳转传参-query传参" class="headerlink" title="1.name 命名路由跳转传参 (query传参)"></a>1.name 命名路由跳转传参 (query传参)</h3><pre><code class="js">this.$router.push(&#123;  name: &#39;路由名字&#39;,  query: &#123;    参数名1: &#39;参数值1&#39;,    参数名2: &#39;参数值2&#39;  &#125;&#125;)</code></pre><h3 id="2-name-命名路由跳转传参-动态路由传参"><a href="#2-name-命名路由跳转传参-动态路由传参" class="headerlink" title="2.name 命名路由跳转传参 (动态路由传参)"></a>2.name 命名路由跳转传参 (动态路由传参)</h3><pre><code class="js">this.$router.push(&#123;  name: &#39;路由名字&#39;,  params: &#123;    参数名: &#39;参数值&#39;,  &#125;&#125;)</code></pre><h3 id="3-总结-1"><a href="#3-总结-1" class="headerlink" title="3.总结"></a>3.总结</h3><p>编程式导航，如何跳转传参？</p><p>1.path路径跳转</p><ul><li><p>query传参</p><pre><code class="js">this.$router.push(&#39;/路径?参数名1=参数值1&amp;参数2=参数值2&#39;)this.$router.push(&#123;  path: &#39;/路径&#39;,  query: &#123;    参数名1: &#39;参数值1&#39;,    参数名2: &#39;参数值2&#39;  &#125;&#125;)</code></pre></li><li><p>动态路由传参</p><pre><code class="js">this.$router.push(&#39;/路径/参数值&#39;)this.$router.push(&#123;  path: &#39;/路径/参数值&#39;&#125;)</code></pre></li></ul><p>2.name命名路由跳转</p><ul><li><p>query传参</p><pre><code class="js">this.$router.push(&#123;  name: &#39;路由名字&#39;,  query: &#123;    参数名1: &#39;参数值1&#39;,    参数名2: &#39;参数值2&#39;  &#125;&#125;)</code></pre></li><li><p>动态路由传参 (需要配动态路由)</p><pre><code class="js">this.$router.push(&#123;  name: &#39;路由名字&#39;,  params: &#123;    参数名: &#39;参数值&#39;,  &#125;&#125;)</code></pre></li></ul><h2 id="十三、面经基础版-案例效果分析"><a href="#十三、面经基础版-案例效果分析" class="headerlink" title="十三、面经基础版-案例效果分析"></a>十三、面经基础版-案例效果分析</h2><h3 id="1-面经效果演示"><a href="#1-面经效果演示" class="headerlink" title="1.面经效果演示"></a>1.面经效果演示</h3><h3 id="2-功能分析"><a href="#2-功能分析" class="headerlink" title="2.功能分析"></a>2.功能分析</h3><ul><li>通过演示效果发现，主要的功能页面有两个，一个是<strong>列表页</strong>，一个是<strong>详情页</strong>，并且在列表页点击时可以跳转到详情页</li><li>底部导航可以来回切换，并且切换时，只有上面的主题内容在动态渲染</li></ul><p><img src="/assets/1682559784643.png" alt="68255978464"></p><h3 id="3-实现思路分析：配置路由-功能实现"><a href="#3-实现思路分析：配置路由-功能实现" class="headerlink" title="3.实现思路分析：配置路由+功能实现"></a>3.实现思路分析：配置路由+功能实现</h3><p>1.配置路由</p><ul><li>首页和面经详情页，两个一级路由</li><li>首页内嵌套4个可切换的页面（嵌套二级路由）</li></ul><p>2.实现功能</p><ul><li>首页请求渲染</li><li><strong>跳转传参</strong> 到 详情页，详情页动态渲染</li><li>组件缓存，性能优化</li></ul><p><img src="/assets/1682560255356.png" alt="68256025535"></p><h2 id="十四、面经基础版-一级路由配置"><a href="#十四、面经基础版-一级路由配置" class="headerlink" title="十四、面经基础版-一级路由配置"></a>十四、面经基础版-一级路由配置</h2><p>1.把文档中准备的素材拷贝到项目中</p><p>2.针对router&#x2F;index.js文件 进行一级路由配置</p><pre><code class="js">...import Layout from &#39;@/views/Layout.vue&#39;import ArticleDetail from &#39;@/views/ArticleDetail.vue&#39;...const router = new VueRouter(&#123;  routes: [    &#123;      path: &#39;/&#39;,      component: Layout    &#125;,    &#123;      path: &#39;/detail&#39;,      component: ArticleDetail    &#125;  ]&#125;)</code></pre><h2 id="十五、面经基础版-二级路由配置"><a href="#十五、面经基础版-二级路由配置" class="headerlink" title="十五、面经基础版-二级路由配置"></a>十五、面经基础版-二级路由配置</h2><p>二级路由也叫嵌套路由，当然也可以嵌套三级、四级…</p><h3 id="1-使用场景"><a href="#1-使用场景" class="headerlink" title="1.使用场景"></a>1.使用场景</h3><p>当在页面中点击链接跳转，只是部分内容切换时，我们可以使用嵌套路由</p><h3 id="2-语法-1"><a href="#2-语法-1" class="headerlink" title="2.语法"></a>2.语法</h3><ul><li>在一级路由下，配置children属性即可</li><li>配置二级路由的出口</li></ul><p> 1.在一级路由下，配置children属性</p><p> <strong>注意</strong>:一级的路由path 需要加 <code>/</code>   二级路由的path不需要加 <code>/</code></p><pre><code class="js">const router = new VueRouter(&#123;  routes: [    &#123;      path: &#39;/&#39;,      component: Layout,      children:[        //children中的配置项 跟一级路由中的配置项一模一样         &#123;path:&#39;xxxx&#39;,component:xxxx.vue&#125;,        &#123;path:&#39;xxxx&#39;,component:xxxx.vue&#125;,      ]    &#125;  ]&#125;)</code></pre><p>技巧：二级路由应该配置到哪个一级路由下呢？</p><p><strong>这些二级路由对应的组件渲染到哪个一级路由下，children就配置到哪个路由下边</strong></p><p>2.配置二级路由的出口 <router-view></router-view></p><p><strong>注意：</strong> 配置了嵌套路由，一定配置对应的路由出口，否则不会渲染出对应的组件</p><p>Layout.vue</p><pre><code class="vue">&lt;template&gt;  &lt;div class=&quot;h5-wrapper&quot;&gt;    &lt;div class=&quot;content&quot;&gt;      &lt;router-view&gt;&lt;/router-view&gt;    &lt;/div&gt;  ....  &lt;/div&gt;&lt;/template&gt;</code></pre><h3 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3.代码实现"></a>3.代码实现</h3><p>router&#x2F;index.js</p><pre><code class="js">...import Article from &#39;@/views/Article.vue&#39;import Collect from &#39;@/views/Collect.vue&#39;import Like from &#39;@/views/Like.vue&#39;import User from &#39;@/views/User.vue&#39;...const router = new VueRouter(&#123;  routes: [    &#123;      path: &#39;/&#39;,      component: Layout,      redirect: &#39;/article&#39;,      children:[        &#123;          path:&#39;/article&#39;,          component:Article        &#125;,        &#123;          path:&#39;/collect&#39;,          component:Collect        &#125;,        &#123;          path:&#39;/like&#39;,          component:Like        &#125;,        &#123;          path:&#39;/user&#39;,          component:User        &#125;      ]    &#125;,    ....  ]&#125;)</code></pre><p>Layout.vue</p><pre><code class="vue">&lt;template&gt;  &lt;div class=&quot;h5-wrapper&quot;&gt;    &lt;div class=&quot;content&quot;&gt;      &lt;!-- 内容部分 --&gt;      &lt;router-view&gt;&lt;/router-view&gt;    &lt;/div&gt;    &lt;nav class=&quot;tabbar&quot;&gt;      &lt;a href=&quot;#/article&quot;&gt;面经&lt;/a&gt;      &lt;a href=&quot;#/collect&quot;&gt;收藏&lt;/a&gt;      &lt;a href=&quot;#/like&quot;&gt;喜欢&lt;/a&gt;      &lt;a href=&quot;#/user&quot;&gt;我的&lt;/a&gt;    &lt;/nav&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><h2 id="十六、面经基础版-二级导航高亮"><a href="#十六、面经基础版-二级导航高亮" class="headerlink" title="十六、面经基础版-二级导航高亮"></a>十六、面经基础版-二级导航高亮</h2><h3 id="1-实现思路"><a href="#1-实现思路" class="headerlink" title="1.实现思路"></a>1.实现思路</h3><ul><li>将a标签替换成 <router-link></router-link>组件，配置to属性，不用加 #</li><li>结合高亮类名实现高亮效果 (推荐模糊匹配：router-link-active)</li></ul><h3 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2.代码实现"></a>2.代码实现</h3><p>Layout.vue</p><pre><code class="vue">....    &lt;nav class=&quot;tabbar&quot;&gt;      &lt;router-link to=&quot;/article&quot;&gt;面经&lt;/router-link&gt;      &lt;router-link to=&quot;/collect&quot;&gt;收藏&lt;/router-link&gt;      &lt;router-link to=&quot;/like&quot;&gt;喜欢&lt;/router-link&gt;      &lt;router-link to=&quot;/user&quot;&gt;我的&lt;/router-link&gt;    &lt;/nav&gt;&lt;style&gt;   a.router-link-active &#123;      color: orange;    &#125;&lt;/style&gt;</code></pre><h2 id="十七、面经基础版-首页请求渲染"><a href="#十七、面经基础版-首页请求渲染" class="headerlink" title="十七、面经基础版-首页请求渲染"></a>十七、面经基础版-首页请求渲染</h2><h3 id="1-步骤分析"><a href="#1-步骤分析" class="headerlink" title="1.步骤分析"></a>1.步骤分析</h3><p>1.安装axios </p><p>2.看接口文档，确认请求方式，请求地址，请求参数</p><p>3.created中发送请求，获取数据，存储到data中</p><p>4.页面动态渲染</p><h3 id="2-代码实现-1"><a href="#2-代码实现-1" class="headerlink" title="2.代码实现"></a>2.代码实现</h3><p>1.安装axios</p><p><code>yarn add axios </code>  <code>npm i axios</code></p><p>2.接口文档</p><pre><code class="vue">请求地址: https://mock.boxuegu.com/mock/3083/articles请求方式: get</code></pre><p>3.created中发送请求，获取数据，存储到data中</p><pre><code class="vue"> data() &#123;    return &#123;      articelList: [],    &#125;  &#125;,  async created() &#123;    const &#123;  data: &#123; result: &#123; rows &#125; &#125;&#125; = await axios.get(&#39;https://mock.boxuegu.com/mock/3083/articles&#39;)    this.articelList = rows  &#125;,</code></pre><p>4.页面动态渲染</p><pre><code class="vue">&lt;template&gt;  &lt;div class=&quot;article-page&quot;&gt;    &lt;div class=&quot;article-item&quot; v-for=&quot;item in articelList&quot; :key=&quot;item.id&quot;&gt;      &lt;div class=&quot;head&quot;&gt;        &lt;img :src=&quot;item.creatorAvatar&quot; alt=&quot;&quot; /&gt;        &lt;div class=&quot;con&quot;&gt;          &lt;p class=&quot;title&quot;&gt;&#123;&#123; item.stem &#125;&#125;&lt;/p&gt;          &lt;p class=&quot;other&quot;&gt;&#123;&#123; item.creatorName &#125;&#125; | &#123;&#123; item.createdAt &#125;&#125;&lt;/p&gt;        &lt;/div&gt;      &lt;/div&gt;      &lt;div class=&quot;body&quot;&gt;        &#123;&#123;item.content&#125;&#125;      &lt;/div&gt;      &lt;div class=&quot;foot&quot;&gt;点赞 &#123;&#123;item.likeCount&#125;&#125; | 浏览 &#123;&#123;item.views&#125;&#125;&lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><h2 id="十八、面经基础版-查询参数传参"><a href="#十八、面经基础版-查询参数传参" class="headerlink" title="十八、面经基础版-查询参数传参"></a>十八、面经基础版-查询参数传参</h2><h3 id="1-说明"><a href="#1-说明" class="headerlink" title="1.说明"></a>1.说明</h3><p>跳转详情页需要把当前点击的文章id传给详情页，获取数据</p><ul><li>查询参数传参  this.$router.push(‘&#x2F;detail?参数1&#x3D;参数值&amp;参数2&#x3D;参数值’) </li><li>动态路由传参  先改造路由 在传参  this.$router.push(‘&#x2F;detail&#x2F;参数值’)</li></ul><h3 id="2-查询参数传参实现"><a href="#2-查询参数传参实现" class="headerlink" title="2.查询参数传参实现"></a>2.查询参数传参实现</h3><p>Article.vue</p><pre><code class="vue">&lt;template&gt;  &lt;div class=&quot;article-page&quot;&gt;    &lt;div class=&quot;article-item&quot;       v-for=&quot;item in articelList&quot; :key=&quot;item.id&quot;       @click=&quot;$router.push(`/detail?id=$&#123;item.id&#125;`)&quot;&gt;     ...    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><p>ArticleDetail.vue</p><pre><code class="vue">  created()&#123;    console.log(this.$route.query.id)  &#125;</code></pre><h2 id="十九、面经基础版-动态路由传参"><a href="#十九、面经基础版-动态路由传参" class="headerlink" title="十九、面经基础版-动态路由传参"></a>十九、面经基础版-动态路由传参</h2><h3 id="1-实现步骤"><a href="#1-实现步骤" class="headerlink" title="1.实现步骤"></a>1.实现步骤</h3><ul><li>改造路由</li><li>动态传参</li><li>在详情页获取参数</li></ul><h3 id="2-代码实现-2"><a href="#2-代码实现-2" class="headerlink" title="2.代码实现"></a>2.代码实现</h3><p>改造路由</p><p>router&#x2F;index.js</p><pre><code class="js">...  &#123;      path: &#39;/detail/:id&#39;,      component: ArticleDetail  &#125;</code></pre><p>Article.vue</p><pre><code class="vue">&lt;div class=&quot;article-item&quot;      v-for=&quot;item in articelList&quot; :key=&quot;item.id&quot;      @click=&quot;$router.push(`/detail/$&#123;item.id&#125;`)&quot;&gt;       .... &lt;/div&gt;</code></pre><p>ArticleDetail.vue</p><pre><code class="vue">  created()&#123;    console.log(this.$route.params.id)  &#125;</code></pre><h3 id="3-额外优化功能点-点击回退跳转到上一页"><a href="#3-额外优化功能点-点击回退跳转到上一页" class="headerlink" title="3.额外优化功能点-点击回退跳转到上一页"></a>3.额外优化功能点-点击回退跳转到上一页</h3><p>ArticleDetail.vue</p><pre><code class="vue">&lt;template&gt;  &lt;div class=&quot;article-detail-page&quot;&gt;    &lt;nav class=&quot;nav&quot;&gt;&lt;span class=&quot;back&quot; @click=&quot;$router.back()&quot;&gt;&amp;lt;&lt;/span&gt; 面经详情&lt;/nav&gt;     ....  &lt;/div&gt;&lt;/template&gt;</code></pre><h2 id="二十、面经基础版-详情页渲染"><a href="#二十、面经基础版-详情页渲染" class="headerlink" title="二十、面经基础版-详情页渲染"></a>二十、面经基础版-详情页渲染</h2><h3 id="1-实现步骤分析"><a href="#1-实现步骤分析" class="headerlink" title="1.实现步骤分析"></a>1.实现步骤分析</h3><ul><li>导入axios</li><li>查看接口文档</li><li>在created中发送请求</li><li>页面动态渲染</li></ul><h3 id="2-代码实现-3"><a href="#2-代码实现-3" class="headerlink" title="2.代码实现"></a>2.代码实现</h3><p>接口文档</p><pre><code class="vue"> 请求地址: https://mock.boxuegu.com/mock/3083/articles/:id 请求方式: get</code></pre><p>在created中发送请求</p><pre><code class="vue"> data() &#123;    return &#123;      articleDetail:&#123;&#125;    &#125;  &#125;,  async created() &#123;    const id = this.$route.params.id    const &#123;data:&#123;result&#125;&#125; = await axios.get(      `https://mock.boxuegu.com/mock/3083/articles/$&#123;id&#125;`    )    this.articleDetail = result  &#125;,</code></pre><p>页面动态渲染</p><pre><code class="vue">&lt;template&gt;  &lt;div class=&quot;article-detail-page&quot;&gt;    &lt;nav class=&quot;nav&quot;&gt;      &lt;span class=&quot;back&quot; @click=&quot;$router.back()&quot;&gt;&amp;lt;&lt;/span&gt; 面经详情    &lt;/nav&gt;    &lt;header class=&quot;header&quot;&gt;      &lt;h1&gt;&#123;&#123;articleDetail.stem&#125;&#125;&lt;/h1&gt;      &lt;p&gt;&#123;&#123;articleDetail.createAt&#125;&#125; | &#123;&#123;articleDetail.views&#125;&#125; 浏览量 | &#123;&#123;articleDetail.likeCount&#125;&#125; 点赞数&lt;/p&gt;      &lt;p&gt;        &lt;img          :src=&quot;articleDetail.creatorAvatar&quot;          alt=&quot;&quot;        /&gt;        &lt;span&gt;&#123;&#123;articleDetail.creatorName&#125;&#125;&lt;/span&gt;      &lt;/p&gt;    &lt;/header&gt;    &lt;main class=&quot;body&quot;&gt;      &#123;&#123;articleDetail.content&#125;&#125;    &lt;/main&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><h2 id="二十一、面经基础版-缓存组件"><a href="#二十一、面经基础版-缓存组件" class="headerlink" title="二十一、面经基础版-缓存组件"></a>二十一、面经基础版-缓存组件</h2><h3 id="1-问题-6"><a href="#1-问题-6" class="headerlink" title="1.问题"></a>1.问题</h3><p>从面经列表 点到 详情页，又点返回，数据重新加载了 →  <strong>希望回到原来的位置</strong></p><p><img src="/assets/1682578630060.png" alt="68257863006"></p><h3 id="2-原因-1"><a href="#2-原因-1" class="headerlink" title="2.原因"></a>2.原因</h3><p>当路由被<strong>跳转</strong>后，原来所看到的组件就<strong>被销毁</strong>了（会执行组件内的beforeDestroy和destroyed生命周期钩子），<strong>重新返回</strong>后组件又被<strong>重新创建</strong>了（会执行组件内的beforeCreate,created,beforeMount,Mounted生命周期钩子），<strong>所以数据被加载了</strong></p><h3 id="3-解决方案"><a href="#3-解决方案" class="headerlink" title="3.解决方案"></a>3.解决方案</h3><p>利用keep-alive把原来的组件给缓存下来</p><h3 id="4-什么是keep-alive"><a href="#4-什么是keep-alive" class="headerlink" title="4.什么是keep-alive"></a>4.什么是keep-alive</h3><p>keep-alive 是 Vue 的内置组件，当它包裹动态组件时，<strong>会缓存不活动的组件实例，而不是销毁</strong>它们。</p><p>keep-alive 是一个抽象组件：它自身不会渲染成一个 DOM 元素，也不会出现在父组件中。</p><p><strong>优点：</strong></p><p>在组件切换过程中把切换出去的组件保留在内存中，防止重复渲染DOM，</p><p>减少加载时间及性能消耗，提高用户体验性。</p><p>App.vue</p><pre><code class="vue">&lt;template&gt;  &lt;div class=&quot;h5-wrapper&quot;&gt;    &lt;keep-alive&gt;      &lt;router-view&gt;&lt;/router-view&gt;    &lt;/keep-alive&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><p><strong>问题：</strong></p><p>缓存了所有被切换的组件</p><h3 id="5-keep-alive的三个属性"><a href="#5-keep-alive的三个属性" class="headerlink" title="5.keep-alive的三个属性"></a>5.keep-alive的三个属性</h3><p>① include  ： 组件名数组，只有匹配的组件<strong>会被缓存</strong></p><p>② exclude ： 组件名数组，任何匹配的组件都<strong>不会被缓存</strong></p><p>③ max       ： 最多可以<strong>缓存多少</strong>组件实例</p><p>App.vue</p><pre><code class="vue">&lt;template&gt;  &lt;div class=&quot;h5-wrapper&quot;&gt;    &lt;keep-alive :include=&quot;[&#39;LayoutPage&#39;]&quot;&gt;      &lt;router-view&gt;&lt;/router-view&gt;    &lt;/keep-alive&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><h3 id="6-额外的两个生命周期钩子"><a href="#6-额外的两个生命周期钩子" class="headerlink" title="6.额外的两个生命周期钩子"></a>6.额外的两个生命周期钩子</h3><p><strong>keep-alive的使用会触发两个生命周期函数</strong></p><p><strong>activated</strong> 当组件被激活（使用）的时候触发 →  进入这个页面的时候触发</p><p><strong>deactivated</strong> 当组件不被使用的时候触发      →  离开这个页面的时候触发</p><p>组件<strong>缓存后</strong>就<strong>不会执行</strong>组件的<strong>created, mounted, destroyed</strong> 等钩子了</p><p>所以其提供了<strong>actived 和deactived</strong>钩子，帮我们实现业务需求。</p><h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7.总结"></a>7.总结</h3><p>1.keep-alive是什么</p><p>2.keep-alive的优点</p><p>3.keep-alive的三个属性 (了解)</p><p>4.keep-alive的使用会触发两个生命周期函数(了解)</p><h2 id="二十二、VueCli-自定义创建项目"><a href="#二十二、VueCli-自定义创建项目" class="headerlink" title="二十二、VueCli 自定义创建项目"></a>二十二、VueCli 自定义创建项目</h2><p>1.安装脚手架 (已安装)</p><pre><code>npm i @vue/cli -g</code></pre><p>2.创建项目</p><pre><code>vue create hm-exp-mobile</code></pre><ul><li>选项</li></ul><pre><code class="js">Vue CLI v5.0.8? Please pick a preset:  Default ([Vue 3] babel, eslint)  Default ([Vue 2] babel, eslint)&gt; Manually select features     选自定义</code></pre><ul><li>手动选择功能</li></ul><p><img src="/assets/1682941856172.png" alt="68294185617"></p><ul><li>选择vue的版本</li></ul><pre><code class="jsx">  3.x&gt; 2.x</code></pre><ul><li>是否使用history模式</li></ul><p><img src="/assets/1682941888453.png" alt="image-20201025150602129"></p><ul><li>选择css预处理</li></ul><p><img src="/assets/1682941900018.png" alt="image-20220629175133593"></p><ul><li>选择eslint的风格 （eslint 代码规范的检验工具，检验代码是否符合规范）</li><li>比如：const age &#x3D; 18;   &#x3D;&gt;  报错！多加了分号！后面有工具，一保存，全部格式化成最规范的样子</li></ul><p><img src="/assets/1682941918562.png" alt="68294191856"></p><ul><li>选择校验的时机 （直接回车）</li></ul><p><img src="/assets/1682941935794.png" alt="68294193579"></p><ul><li>选择配置文件的生成方式 （直接回车）</li></ul><p><img src="/assets/1682941947985.png" alt="68294194798"></p><ul><li>是否保存预设，下次直接使用？  &#x3D;&gt;   不保存，输入 N</li></ul><p><img src="/assets/1682941961551.png" alt="68294196155"></p><ul><li>等待安装，项目初始化完成</li></ul><p><img src="/assets/1682941974763.png" alt="68294197476"></p><ul><li>启动项目</li></ul><pre><code>npm run serve</code></pre><p><img src="/2023/07/14/day06/personboke\blog\source_posts\day06\image-20230725223111863.png" alt="image-20230725223111863"></p><h2 id="二十三、ESlint代码规范及手动修复"><a href="#二十三、ESlint代码规范及手动修复" class="headerlink" title="二十三、ESlint代码规范及手动修复"></a>二十三、ESlint代码规范及手动修复</h2><p>代码规范：一套写代码的约定规则。例如：赋值符号的左右是否需要空格？一句结束是否是要加;？… </p><blockquote><p> 没有规矩不成方圆  </p></blockquote><p>ESLint:是一个代码检查工具，用来检查你的代码是否符合指定的规则(你和你的团队可以自行约定一套规则)。在创建项目时，我们使用的是 <a href="https://standardjs.com/readme-zhcn.html">JavaScript Standard Style</a> 代码风格的规则。</p><h4 id="1-JavaScript-Standard-Style-规范说明"><a href="#1-JavaScript-Standard-Style-规范说明" class="headerlink" title="1.JavaScript Standard Style 规范说明"></a>1.JavaScript Standard Style 规范说明</h4><p>建议把：<a href="https://standardjs.com/rules-zhcn.html">https://standardjs.com/rules-zhcn.html</a> 看一遍，然后在写的时候,  遇到错误就查询解决。</p><p>下面是这份规则中的一小部分：</p><ul><li><em>字符串使用单引号</em> – 需要转义的地方除外</li><li><em>无分号</em> – <a href="http://blog.izs.me/post/2353458699/an-open-letter-to-javascript-leaders-regarding">这</a><a href="http://inimino.org/~inimino/blog/javascript_semicolons">没什么不好。</a><a href="https://www.youtube.com/watch?v=gsfbh17Ax9I">不骗你！</a></li><li><em>关键字后加空格</em> <code>if (condition) &#123; ... &#125;</code></li><li><em>函数名后加空格</em> <code>function name (arg) &#123; ... &#125;</code></li><li>坚持使用全等 <code>===</code> 摒弃 <code>==</code> 一但在需要检查 <code>null || undefined</code> 时可以使用 <code>obj == null</code></li><li>……</li></ul><h4 id="2-代码规范错误"><a href="#2-代码规范错误" class="headerlink" title="2.代码规范错误"></a>2.代码规范错误</h4><p>如果你的代码不符合standard的要求，eslint会跳出来刀子嘴，豆腐心地提示你。</p><p>下面我们在main.js中随意做一些改动：添加一些空行，空格。</p><pre><code class="js">import Vue from &#39;vue&#39;import App from &#39;./App.vue&#39;import &#39;./styles/index.less&#39;import router from &#39;./router&#39;Vue.config.productionTip = falsenew Vue ( &#123;  render: h =&gt; h(App),  router&#125;).$mount(&#39;#app&#39;)</code></pre><p>按下保存代码之后：</p><p>你将会看在控制台中输出如下错误：</p><blockquote></blockquote><h4 id="3-手动修正"><a href="#3-手动修正" class="headerlink" title="3.手动修正"></a>3.手动修正</h4><p>根据错误提示来一项一项手动修正。</p><p>如果你不认识命令行中的语法报错是什么意思，你可以根据错误代码（func-call-spacing, space-in-parens,…..）去 ESLint 规则列表中查找其具体含义。</p><p>打开 <a href="https://zh-hans.eslint.org/docs/latest/rules/">ESLint 规则表</a>，使用页面搜索（Ctrl + F）这个代码，查找对该规则的一个释义。</p><p><img src="/assets/1682942792219.png" alt="68294279221"></p><h2 id="二十四、通过eslint插件来实现自动修正"><a href="#二十四、通过eslint插件来实现自动修正" class="headerlink" title="二十四、通过eslint插件来实现自动修正"></a>二十四、通过eslint插件来实现自动修正</h2><blockquote><ol><li>eslint会自动高亮错误显示</li><li>通过配置，eslint会自动帮助我们修复错误</li></ol></blockquote><ul><li>如何安装</li></ul><p><img src="/assets/1682942920986.png" alt="68294292098"></p><ul><li>如何配置</li></ul><pre><code class="js">// 当保存的时候，eslint自动帮我们修复错误&quot;editor.codeActionsOnSave&quot;: &#123;    &quot;source.fixAll&quot;: true&#125;,// 保存代码，不自动格式化&quot;editor.formatOnSave&quot;: false</code></pre><ul><li>注意：eslint的配置文件必须在根目录下，这个插件才能才能生效。打开项目必须以根目录打开，一次打开一个项目</li><li>注意：使用了eslint校验之后，把vscode带的那些格式化工具全禁用了 Beatify</li></ul><p>settings.json 参考</p><pre><code class="jsx">&#123;    &quot;window.zoomLevel&quot;: 2,    &quot;workbench.iconTheme&quot;: &quot;vscode-icons&quot;,    &quot;editor.tabSize&quot;: 2,    &quot;emmet.triggerExpansionOnTab&quot;: true,    // 当保存的时候，eslint自动帮我们修复错误    &quot;editor.codeActionsOnSave&quot;: &#123;        &quot;source.fixAll&quot;: true    &#125;,    // 保存代码，不自动格式化    &quot;editor.formatOnSave&quot;: false&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/05/07/day07/"/>
      <url>/2023/05/07/day07/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Vuex-概述"><a href="#一、Vuex-概述" class="headerlink" title="一、Vuex 概述"></a>一、<a href="https://vuex.vuejs.org/zh/">Vuex</a> 概述</h2><p>目标：明确<a href="https://vuex.vuejs.org/zh/">Vuex</a>是什么，应用场景以及优势</p><h3 id="1-是什么"><a href="#1-是什么" class="headerlink" title="1.是什么"></a>1.是什么</h3><p>Vuex 是一个 Vue 的 状态管理工具，状态就是数据。</p><p>大白话：Vuex 是一个插件，可以帮我们管理 Vue 通用的数据 (多组件共享的数据)。例如：购物车数据   个人信息数</p><h3 id="2-使用场景"><a href="#2-使用场景" class="headerlink" title="2.使用场景"></a>2.使用场景</h3><ul><li><p>某个状态 在 很多个组件 来使用 (个人信息)</p></li><li><p>多个组件 共同维护 一份数据 (购物车)</p></li></ul><p><img src="/assets/1683178186642.png" alt="68317818664"></p><h3 id="3-优势"><a href="#3-优势" class="headerlink" title="3.优势"></a>3.优势</h3><ul><li>共同维护一份数据，<strong>数据集中化管理</strong></li><li><strong>响应式变化</strong></li><li>操作简洁 (vuex提供了一些辅助函数)</li></ul><p><img src="/assets/1683178293366.png" alt="68317829336"></p><h3 id="4-注意："><a href="#4-注意：" class="headerlink" title="4.注意："></a>4.注意：</h3><p>官方原文：</p><ul><li>不是所有的场景都适用于vuex，只有在必要的时候才使用vuex</li><li>使用了vuex之后，会附加更多的框架中的概念进来，增加了项目的复杂度  （数据的操作更便捷，数据的流动更清晰）</li></ul><p>Vuex就像《近视眼镜》, 你自然会知道什么时候需要用它~</p><h2 id="二、需求-多组件共享数据"><a href="#二、需求-多组件共享数据" class="headerlink" title="二、需求: 多组件共享数据"></a>二、需求: 多组件共享数据</h2><p>目标：基于脚手架创建项目，构建 vuex 多组件数据共享环境</p><p><img src="/assets/1683178912695.png" alt="68317891269"></p><p>效果是三个组件共享一份数据:</p><ul><li>任意一个组件都可以修改数据</li><li>三个组件的数据是同步的</li></ul><h3 id="1-创建项目"><a href="#1-创建项目" class="headerlink" title="1.创建项目"></a>1.创建项目</h3><pre><code>vue create vuex-demo</code></pre><h3 id="2-创建三个组件-目录如下"><a href="#2-创建三个组件-目录如下" class="headerlink" title="2.创建三个组件, 目录如下"></a>2.创建三个组件, 目录如下</h3><pre><code>|-components|--Son1.vue|--Son2.vue|-App.vue</code></pre><h3 id="3-源代码如下"><a href="#3-源代码如下" class="headerlink" title="3.源代码如下"></a>3.源代码如下</h3><p><code>App.vue</code>在入口组件中引入 Son1 和 Son2 这两个子组件</p><pre><code class="html">&lt;template&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;h1&gt;根组件&lt;/h1&gt;    &lt;input type=&quot;text&quot;&gt;    &lt;Son1&gt;&lt;/Son1&gt;    &lt;hr&gt;    &lt;Son2&gt;&lt;/Son2&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Son1 from &#39;./components/Son1.vue&#39;import Son2 from &#39;./components/Son2.vue&#39;export default &#123;  name: &#39;app&#39;,  data: function () &#123;    return &#123;    &#125;  &#125;,  components: &#123;    Son1,    Son2  &#125;&#125;&lt;/script&gt;&lt;style&gt;#app &#123;  width: 600px;  margin: 20px auto;  border: 3px solid #ccc;  border-radius: 3px;  padding: 10px;&#125;&lt;/style&gt;</code></pre><p><code>main.js</code></p><pre><code class="js">import Vue from &#39;vue&#39;import App from &#39;./App.vue&#39;Vue.config.productionTip = falsenew Vue(&#123;  render: h =&gt; h(App)&#125;).$mount(&#39;#app&#39;)</code></pre><p><code>Son1.vue</code></p><pre><code class="html">&lt;template&gt;  &lt;div class=&quot;box&quot;&gt;    &lt;h2&gt;Son1 子组件&lt;/h2&gt;    从vuex中获取的值: &lt;label&gt;&lt;/label&gt;    &lt;br&gt;    &lt;button&gt;值 + 1&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;Son1Com&#39;&#125;&lt;/script&gt;&lt;style lang=&quot;css&quot; scoped&gt;.box&#123;  border: 3px solid #ccc;  width: 400px;  padding: 10px;  margin: 20px;&#125;h2 &#123;  margin-top: 10px;&#125;&lt;/style&gt;</code></pre><p><code>Son2.vue</code></p><pre><code class="html">&lt;template&gt;  &lt;div class=&quot;box&quot;&gt;    &lt;h2&gt;Son2 子组件&lt;/h2&gt;    从vuex中获取的值:&lt;label&gt;&lt;/label&gt;    &lt;br /&gt;    &lt;button&gt;值 - 1&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;Son2Com&#39;&#125;&lt;/script&gt;&lt;style lang=&quot;css&quot; scoped&gt;.box &#123;  border: 3px solid #ccc;  width: 400px;  padding: 10px;  margin: 20px;&#125;h2 &#123;  margin-top: 10px;&#125;&lt;/style&gt;</code></pre><h2 id="三、vuex-的使用-创建仓库"><a href="#三、vuex-的使用-创建仓库" class="headerlink" title="三、vuex 的使用 - 创建仓库"></a>三、vuex 的使用 - 创建仓库</h2><p><img src="/assets/1683212784179.png" alt="68321278417"></p><h3 id="1-安装-vuex"><a href="#1-安装-vuex" class="headerlink" title="1.安装 vuex"></a>1.安装 vuex</h3><p>安装vuex与vue-router类似，vuex是一个独立存在的插件，如果脚手架初始化没有选 vuex，就需要额外安装。</p><pre><code class="bash">yarn add vuex@3 或者 npm i vuex@3</code></pre><h3 id="2-新建-store-index-js-专门存放-vuex"><a href="#2-新建-store-index-js-专门存放-vuex" class="headerlink" title="2.新建 store/index.js 专门存放 vuex"></a>2.新建 <code>store/index.js</code> 专门存放 vuex</h3><p>​为了维护项目目录的整洁，在src目录下新建一个store目录其下放置一个index.js文件。 (和 <code>router/index.js</code> 类似)</p><p>​<img src="/assets/1683212805824.png" alt="68321280582"></p><h3 id="3-创建仓库-store-index-js"><a href="#3-创建仓库-store-index-js" class="headerlink" title="3.创建仓库 store/index.js"></a>3.创建仓库 <code>store/index.js</code></h3><pre><code class="jsx">// 导入 vueimport Vue from &#39;vue&#39;// 导入 vueximport Vuex from &#39;vuex&#39;// vuex也是vue的插件, 需要use一下, 进行插件的安装初始化Vue.use(Vuex)// 创建仓库 storeconst store = new Vuex.Store()// 导出仓库export default store</code></pre><h3 id="4-在-main-js-中导入挂载到-Vue-实例上"><a href="#4-在-main-js-中导入挂载到-Vue-实例上" class="headerlink" title="4 在 main.js 中导入挂载到 Vue 实例上"></a>4 在 main.js 中导入挂载到 Vue 实例上</h3><pre><code class="js">import Vue from &#39;vue&#39;import App from &#39;./App.vue&#39;import store from &#39;./store&#39;Vue.config.productionTip = falsenew Vue(&#123;  render: h =&gt; h(App),  store&#125;).$mount(&#39;#app&#39;)</code></pre><p>此刻起, 就成功创建了一个 <strong>空仓库!!</strong></p><h3 id="5-测试打印Vuex"><a href="#5-测试打印Vuex" class="headerlink" title="5.测试打印Vuex"></a>5.测试打印Vuex</h3><p>App.vue</p><pre><code class="js">created()&#123;  console.log(this.$store)&#125;</code></pre><h2 id="四、核心概念-state-状态"><a href="#四、核心概念-state-状态" class="headerlink" title="四、核心概念 - state 状态"></a>四、核心概念 - state 状态</h2><h3 id="1-目标"><a href="#1-目标" class="headerlink" title="1.目标"></a>1.目标</h3><p>明确如何给仓库 提供 数据，如何 使用 仓库的数据</p><h3 id="2-提供数据"><a href="#2-提供数据" class="headerlink" title="2.提供数据"></a>2.提供数据</h3><p>State提供唯一的公共数据源，所有共享的数据都要统一放到Store中的State中存储。</p><p>打开项目中的store.js文件，在state对象中可以添加我们要共享的数据。</p><pre><code class="jsx">// 创建仓库 storeconst store = new Vuex.Store(&#123;  // state 状态, 即数据, 类似于vue组件中的data,  // 区别：  // 1.data 是组件自己的数据,   // 2.state 中的数据整个vue项目的组件都能访问到  state: &#123;    count: 101  &#125;&#125;)</code></pre><h3 id="3-访问Vuex中的数据"><a href="#3-访问Vuex中的数据" class="headerlink" title="3.访问Vuex中的数据"></a>3.访问Vuex中的数据</h3><p>问题: 如何在组件中获取count?</p><ol><li>通过$store直接访问  —&gt;  </li><li>通过辅助函数mapState 映射计算属性  —&gt;  </li></ol><h3 id="4-通过-store访问的语法"><a href="#4-通过-store访问的语法" class="headerlink" title="4.通过$store访问的语法"></a>4.通过$store访问的语法</h3><pre><code class="js">获取 store： 1.Vue模板中获取 this.$store 2.js文件中获取 import 导入 store模板中：     &#123;&#123; $store.state.xxx &#125;&#125;组件逻辑中：  this.$store.state.xxxJS模块中：   store.state.xxx</code></pre><h3 id="5-代码实现"><a href="#5-代码实现" class="headerlink" title="5.代码实现"></a>5.代码实现</h3><h4 id="5-1模板中使用"><a href="#5-1模板中使用" class="headerlink" title="5.1模板中使用"></a>5.1模板中使用</h4><p>组件中可以使用  <strong>$store</strong> 获取到vuex中的store对象实例，可通过<strong>state</strong>属性属性获取<strong>count</strong>， 如下</p><pre><code class="vue">&lt;h1&gt;state的数据 - &#123;&#123; $store.state.count &#125;&#125;&lt;/h1&gt;</code></pre><h4 id="5-2组件逻辑中使用"><a href="#5-2组件逻辑中使用" class="headerlink" title="5.2组件逻辑中使用"></a>5.2组件逻辑中使用</h4><p>将state属性定义在计算属性中 <a href="https://vuex.vuejs.org/zh/guide/state.html">https://vuex.vuejs.org/zh/guide/state.html</a></p><pre><code class="js">&lt;h1&gt;state的数据 - &#123;&#123; count &#125;&#125;&lt;/h1&gt;// 把state中数据，定义在组件内的计算属性中  computed: &#123;    count () &#123;      return this.$store.state.count    &#125;  &#125;</code></pre><h4 id="5-3-js文件中使用"><a href="#5-3-js文件中使用" class="headerlink" title="5.3 js文件中使用"></a>5.3 js文件中使用</h4><pre><code class="vue">//main.jsimport store from &quot;@/store&quot;console.log(store.state.count)</code></pre><p>每次都像这样一个个的提供计算属性, 太麻烦了,我们有没有简单的语法帮我们获取state中的值呢？</p><h2 id="五、通过辅助函数-mapState获取-state中的数据"><a href="#五、通过辅助函数-mapState获取-state中的数据" class="headerlink" title="五、通过辅助函数  - mapState获取 state中的数据"></a>五、通过辅助函数  - mapState获取 state中的数据</h2><blockquote><p>mapState是辅助函数，帮助我们把store中的数据映射到 组件的计算属性中, 它属于一种方便的用法</p></blockquote><p>用法 ：</p><p><img src="/assets/1683214719574.png" alt="68321471957"> </p><h3 id="1-第一步：导入mapState-mapState是vuex中的一个函数"><a href="#1-第一步：导入mapState-mapState是vuex中的一个函数" class="headerlink" title="1.第一步：导入mapState (mapState是vuex中的一个函数)"></a>1.第一步：导入mapState (mapState是vuex中的一个函数)</h3><pre><code class="js">import &#123; mapState &#125; from &#39;vuex&#39;</code></pre><h3 id="2-第二步：采用数组形式引入state属性"><a href="#2-第二步：采用数组形式引入state属性" class="headerlink" title="2.第二步：采用数组形式引入state属性"></a>2.第二步：采用数组形式引入state属性</h3><pre><code class="js">mapState([&#39;count&#39;]) </code></pre><blockquote><p>上面代码的最终得到的是 <strong>类似于</strong></p></blockquote><pre><code class="js">count () &#123;    return this.$store.state.count&#125;</code></pre><h3 id="3-第三步：利用展开运算符将导出的状态映射给计算属性"><a href="#3-第三步：利用展开运算符将导出的状态映射给计算属性" class="headerlink" title="3.第三步：利用展开运算符将导出的状态映射给计算属性"></a>3.第三步：利用<strong>展开运算符</strong>将导出的状态映射给计算属性</h3><pre><code class="js">  computed: &#123;    ...mapState([&#39;count&#39;])  &#125;</code></pre><pre><code class="vue"> &lt;div&gt; state的数据：&#123;&#123; count &#125;&#125;&lt;/div&gt;</code></pre><h2 id="六、开启严格模式及Vuex的单项数据流"><a href="#六、开启严格模式及Vuex的单项数据流" class="headerlink" title="六、开启严格模式及Vuex的单项数据流"></a>六、开启严格模式及Vuex的单项数据流</h2><h3 id="1-目标-1"><a href="#1-目标-1" class="headerlink" title="1.目标"></a>1.目标</h3><p>明确 vuex 同样遵循单向数据流，组件中不能直接修改仓库的数据</p><h3 id="2-直接在组件中修改Vuex中state的值"><a href="#2-直接在组件中修改Vuex中state的值" class="headerlink" title="2.直接在组件中修改Vuex中state的值"></a>2.直接在组件中修改Vuex中state的值</h3><p><img src="/assets/1683215892288.png" alt="68321589228"></p><p>Son1.vue</p><pre><code class="vue">button @click=&quot;handleAdd&quot;&gt;值 + 1&lt;/button&gt;methods:&#123;     handleAdd (n) &#123;      // 错误代码(vue默认不会监测，监测需要成本)       this.$store.state.count++      // console.log(this.$store.state.count)     &#125;,&#125;</code></pre><h3 id="3-开启严格模式"><a href="#3-开启严格模式" class="headerlink" title="3.开启严格模式"></a>3.开启严格模式</h3><p>通过 <code>strict: true</code> 可以开启严格模式,开启严格模式后，直接修改state中的值会报错</p><blockquote><p><strong>state数据的修改只能通过mutations，并且mutations必须是同步的</strong></p></blockquote><p><img src="/assets/1683215821033.png" alt="68321471957"></p><h2 id="七、核心概念-mutations"><a href="#七、核心概念-mutations" class="headerlink" title="七、核心概念-mutations"></a>七、核心概念-mutations</h2><h3 id="1-定义mutations"><a href="#1-定义mutations" class="headerlink" title="1.定义mutations"></a>1.定义mutations</h3><pre><code class="js">const store  = new Vuex.Store(&#123;  state: &#123;    count: 0  &#125;,  // 定义mutations  mutations: &#123;       &#125;&#125;)</code></pre><h3 id="2-格式说明"><a href="#2-格式说明" class="headerlink" title="2.格式说明"></a>2.格式说明</h3><p>mutations是一个对象，对象中存放修改state的方法</p><pre><code class="js">mutations: &#123;    // 方法里参数 第一个参数是当前store的state属性    // payload 载荷 运输参数 调用mutaiions的时候 可以传递参数 传递载荷    addCount (state) &#123;      state.count += 1    &#125;  &#125;,</code></pre><h3 id="3-组件中提交-mutations"><a href="#3-组件中提交-mutations" class="headerlink" title="3.组件中提交 mutations"></a>3.组件中提交 mutations</h3><pre><code class="jsx">this.$store.commit(&#39;addCount&#39;)</code></pre><h3 id="4-练习"><a href="#4-练习" class="headerlink" title="4.练习"></a>4.练习</h3><p>1.在mutations中定义个点击按钮进行 +5 的方法</p><p>2.在mutations中定义个点击按钮进行 改变title 的方法</p><p>3.在组件中调用mutations修改state中的值</p><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h3><p>通过mutations修改state的步骤</p><p>1.定义 mutations 对象，对象中存放修改 state 的方法</p><p>2.组件中提交调用 mutations(通过$store.commit(‘mutations的方法名’))</p><h2 id="八、带参数的-mutations"><a href="#八、带参数的-mutations" class="headerlink" title="八、带参数的 mutations"></a>八、带参数的 mutations</h2><h3 id="1-目标："><a href="#1-目标：" class="headerlink" title="1.目标："></a>1.目标：</h3><p>掌握 mutations 传参语法</p><h3 id="2-语法"><a href="#2-语法" class="headerlink" title="2.语法"></a>2.语法</h3><p>看下面这个案例，每次点击不同的按钮，加的值都不同，每次都要定义不同的mutations处理吗？</p><p><img src="/assets/1683217004239.png" alt="68321700423"></p><p>提交 mutation 是可以传递参数的  <code>this.$store.commit(&#39;xxx&#39;,  参数)</code></p><h4 id="2-1-提供mutation函数（带参数）"><a href="#2-1-提供mutation函数（带参数）" class="headerlink" title="2.1 提供mutation函数（带参数）"></a>2.1 提供mutation函数（带参数）</h4><pre><code class="js">mutations: &#123;  ...  addCount (state, count) &#123;    state.count = count  &#125;&#125;,</code></pre><h4 id="2-2-提交mutation"><a href="#2-2-提交mutation" class="headerlink" title="2.2 提交mutation"></a>2.2 提交mutation</h4><pre><code class="jsx">handle ( ) &#123;  this.$store.commit(&#39;addCount&#39;, 10)&#125;</code></pre><p><strong>小tips: 提交的参数只能是一个, 如果有多个参数要传, 可以传递一个对象</strong></p><pre><code class="jsx">this.$store.commit(&#39;addCount&#39;, &#123;  count: 10&#125;)</code></pre><h2 id="九、练习-mutations的减法功能"><a href="#九、练习-mutations的减法功能" class="headerlink" title="九、练习-mutations的减法功能"></a>九、练习-mutations的减法功能</h2><p><img src="/assets/1683217248752.png" alt="68321724875"></p><h3 id="1-步骤"><a href="#1-步骤" class="headerlink" title="1.步骤"></a>1.步骤</h3><p><img src="/assets/1683217268256.png" alt="68321726825"></p><h3 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2.代码实现"></a>2.代码实现</h3><p>Son2.vue</p><pre><code class="vue">    &lt;button @click=&quot;subCount(1)&quot;&gt;值 - 1&lt;/button&gt;    &lt;button @click=&quot;subCount(5)&quot;&gt;值 - 5&lt;/button&gt;    &lt;button @click=&quot;subCount(10)&quot;&gt;值 - 10&lt;/button&gt;    export default &#123;        methods:&#123;             subCount (n) &#123;                 this.$store.commit(&#39;addCount&#39;, n)        &#125;,        &#125;    &#125;</code></pre><p>store&#x2F;index.js</p><pre><code class="js">mutations:&#123;    subCount (state, n) &#123;      state.count -= n    &#125;,&#125;</code></pre><h2 id="十、练习-Vuex中的值和组件中的input双向绑定"><a href="#十、练习-Vuex中的值和组件中的input双向绑定" class="headerlink" title="十、练习-Vuex中的值和组件中的input双向绑定"></a>十、练习-Vuex中的值和组件中的input双向绑定</h2><h3 id="1-目标-2"><a href="#1-目标-2" class="headerlink" title="1.目标"></a>1.目标</h3><p>实时输入，实时更新，巩固 mutations 传参语法</p><p><img src="/assets/1683217697064.png" alt="68321769706"></p><h3 id="2-实现步骤"><a href="#2-实现步骤" class="headerlink" title="2.实现步骤"></a>2.实现步骤</h3><p><img src="/assets/1683217717788.png" alt="68321771778"></p><h3 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3.代码实现"></a>3.代码实现</h3><p>App.vue</p><pre><code class="vue">&lt;input :value=&quot;count&quot; @input=&quot;handleInput&quot; type=&quot;text&quot;&gt;export default &#123;  methods: &#123;    handleInput (e) &#123;      // 1. 实时获取输入框的值      const num = +e.target.value      // 2. 提交mutation，调用mutation函数      this.$store.commit(&#39;changeCount&#39;, num)    &#125;  &#125;&#125;</code></pre><p>store&#x2F;index.js</p><pre><code class="js">mutations: &#123;    changeCount (state, newCount) &#123;      state.count = newCount   &#125;&#125;,</code></pre><h2 id="十一、辅助函数-mapMutations"><a href="#十一、辅助函数-mapMutations" class="headerlink" title="十一、辅助函数- mapMutations"></a>十一、辅助函数- mapMutations</h2><blockquote><p>mapMutations和mapState很像，它把位于mutations中的方法提取了出来，我们可以将它导入</p></blockquote><pre><code class="js">import  &#123; mapMutations &#125; from &#39;vuex&#39;methods: &#123;    ...mapMutations([&#39;addCount&#39;])&#125;</code></pre><blockquote><p>上面代码的含义是将mutations的方法导入了methods中，等价于</p></blockquote><pre><code class="js">methods: &#123;      // commit(方法名, 载荷参数)      addCount () &#123;          this.$store.commit(&#39;addCount&#39;)      &#125; &#125;</code></pre><p>此时，就可以直接通过this.addCount调用了</p><pre><code class="jsx">&lt;button @click=&quot;addCount&quot;&gt;值+1&lt;/button&gt;</code></pre><p>但是请注意： Vuex中mutations中要求不能写异步代码，如果有异步的ajax请求，应该放置在actions中</p><h2 id="十二、核心概念-actions"><a href="#十二、核心概念-actions" class="headerlink" title="十二、核心概念 - actions"></a>十二、核心概念 - actions</h2><blockquote><p>state是存放数据的，mutations是同步更新数据 (便于监测数据的变化, 更新视图等, 方便于调试工具查看变化)，</p><p>actions则负责进行异步操作</p></blockquote><p><strong>说明：mutations必须是同步的</strong></p><p><strong>需求: 一秒钟之后, 要给一个数 去修改state</strong></p><p><img src="/assets/1683218603674.png" alt="68321860367"></p><h3 id="1-定义actions"><a href="#1-定义actions" class="headerlink" title="1.定义actions"></a><strong>1.定义actions</strong></h3><pre><code class="js">mutations: &#123;  changeCount (state, newCount) &#123;    state.count = newCount  &#125;&#125;actions: &#123;  setAsyncCount (context, num) &#123;    // 一秒后, 给一个数, 去修改 num    setTimeout(() =&gt; &#123;      context.commit(&#39;changeCount&#39;, num)    &#125;, 1000)  &#125;&#125;,</code></pre><h3 id="2-组件中通过dispatch调用"><a href="#2-组件中通过dispatch调用" class="headerlink" title="2.组件中通过dispatch调用"></a><strong>2.组件中通过dispatch调用</strong></h3><pre><code class="js">setAsyncCount () &#123;  this.$store.dispatch(&#39;setAsyncCount&#39;, 666)&#125;</code></pre><p><img src="/assets/1683441987572.png" alt="68344198757"></p><h2 id="十三、辅助函数-mapActions"><a href="#十三、辅助函数-mapActions" class="headerlink" title="十三、辅助函数 -mapActions"></a>十三、辅助函数 -mapActions</h2><p>1.目标：掌握辅助函数 mapActions，映射方法</p><blockquote><p>mapActions 是把位于 actions中的方法提取了出来，映射到组件methods中</p></blockquote><p>Son2.vue</p><pre><code class="js">import &#123; mapActions &#125; from &#39;vuex&#39;methods: &#123;   ...mapActions([&#39;changeCountAction&#39;])&#125;//mapActions映射的代码 本质上是以下代码的写法//methods: &#123;//  changeCountAction (n) &#123;//    this.$store.dispatch(&#39;changeCountAction&#39;, n)//  &#125;,//&#125;</code></pre><p>直接通过 this.方法 就可以调用</p><pre><code class="vue">&lt;button @click=&quot;changeCountAction(200)&quot;&gt;+异步&lt;/button&gt;</code></pre><h2 id="十四、核心概念-getters"><a href="#十四、核心概念-getters" class="headerlink" title="十四、核心概念 - getters"></a>十四、核心概念 - getters</h2><blockquote><p>除了state之外，有时我们还需要从state中<strong>筛选出符合条件的一些数据</strong>，这些数据是依赖state的，此时会用到getters</p></blockquote><p>例如，state中定义了list，为1-10的数组，</p><pre><code class="js">state: &#123;    list: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]&#125;</code></pre><p>组件中，需要显示所有大于5的数据，正常的方式，是需要list在组件中进行再一步的处理，但是getters可以帮助我们实现它</p><h3 id="1-定义getters"><a href="#1-定义getters" class="headerlink" title="1.定义getters"></a>1.定义getters</h3><pre><code class="js">  getters: &#123;    // getters函数的第一个参数是 state    // 必须要有返回值     filterList:  state =&gt;  state.list.filter(item =&gt; item &gt; 5)  &#125;</code></pre><h3 id="2-使用getters"><a href="#2-使用getters" class="headerlink" title="2.使用getters"></a>2.使用getters</h3><h4 id="2-1原始方式-store"><a href="#2-1原始方式-store" class="headerlink" title="2.1原始方式-$store"></a>2.1原始方式-$store</h4><pre><code class="vue">&lt;div&gt;&#123;&#123; $store.getters.filterList &#125;&#125;&lt;/div&gt;</code></pre><h4 id="2-2辅助函数-mapGetters"><a href="#2-2辅助函数-mapGetters" class="headerlink" title="2.2辅助函数 - mapGetters"></a>2.2辅助函数 - mapGetters</h4><pre><code class="js">computed: &#123;    ...mapGetters([&#39;filterList&#39;])&#125;</code></pre><pre><code class="vue"> &lt;div&gt;&#123;&#123; filterList &#125;&#125;&lt;/div&gt;</code></pre><h2 id="十五、使用小结"><a href="#十五、使用小结" class="headerlink" title="十五、使用小结"></a>十五、使用小结</h2><p><img src="/assets/1683442133911.png" alt="68344213391"></p><h2 id="十六、核心概念-module"><a href="#十六、核心概念-module" class="headerlink" title="十六、核心概念 - module"></a>十六、核心概念 - module</h2><h3 id="1-目标-3"><a href="#1-目标-3" class="headerlink" title="1.目标"></a>1.目标</h3><p>掌握核心概念 module 模块的创建</p><h3 id="2-问题"><a href="#2-问题" class="headerlink" title="2.问题"></a>2.问题</h3><p>由于使用<strong>单一状态树</strong>，应用的所有状态<strong>会集中到一个比较大的对象</strong>。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。</p><p>这句话的意思是，如果把所有的状态都放在state中，当项目变得越来越大的时候，Vuex会变得越来越难以维护</p><p>由此，又有了Vuex的模块化</p><p><img src="/assets/1683425758358.png" alt="68342575835"></p><h3 id="3-模块定义-准备-state"><a href="#3-模块定义-准备-state" class="headerlink" title="3.模块定义 - 准备 state"></a><strong>3.模块定义</strong> - 准备 state</h3><p>定义两个模块   <strong>user</strong> 和  <strong>setting</strong></p><p>user中管理用户的信息状态  userInfo  <code>modules/user.js</code></p><pre><code class="jsx">const state = &#123;  userInfo: &#123;    name: &#39;zs&#39;,    age: 18  &#125;&#125;const mutations = &#123;&#125;const actions = &#123;&#125;const getters = &#123;&#125;export default &#123;  state,  mutations,  actions,  getters&#125;</code></pre><p>setting中管理项目应用的  主题色 theme，描述 desc， <code>modules/setting.js</code></p><pre><code class="jsx">const state = &#123;  theme: &#39;dark&#39;  desc: &#39;描述真呀真不错&#39;&#125;const mutations = &#123;&#125;const actions = &#123;&#125;const getters = &#123;&#125;export default &#123;  state,  mutations,  actions,  getters&#125;</code></pre><p>在<code>store/index.js</code>文件中的modules配置项中，注册这两个模块</p><pre><code class="js">import user from &#39;./modules/user&#39;import setting from &#39;./modules/setting&#39;const store = new Vuex.Store(&#123;    modules:&#123;        user,        setting    &#125;&#125;)</code></pre><p>使用模块中的数据,  可以直接通过模块名访问 <code>$store.state.模块名.xxx</code>  &#x3D;&gt;  <code>$store.state.setting.desc</code></p><p>也可以通过 mapState 映射</p><h2 id="十七、获取模块内的state数据"><a href="#十七、获取模块内的state数据" class="headerlink" title="十七、获取模块内的state数据"></a>十七、获取模块内的state数据</h2><h3 id="1-目标：-1"><a href="#1-目标：-1" class="headerlink" title="1.目标："></a>1.目标：</h3><p>掌握模块中 state 的访问语法</p><p>尽管已经分模块了，但其实子模块的状态，还是会挂到根级别的 state 中，属性名就是模块名</p><p><img src="/assets/1683427841660.png" alt="68342784166"></p><h3 id="2-使用模块中的数据"><a href="#2-使用模块中的数据" class="headerlink" title="2.使用模块中的数据"></a>2.使用模块中的数据</h3><ol><li>直接通过模块名访问 $store.state.模块名.xxx</li><li>通过 mapState 映射：</li><li>默认根级别的映射  mapState([ ‘xxx’ ])     </li><li>子模块的映射 ：mapState(‘模块名’, [‘xxx’])  -  需要开启命名空间 <strong>namespaced:true</strong></li></ol><p><code>modules/user.js</code></p><pre><code class="jsx">const state = &#123;  userInfo: &#123;    name: &#39;zs&#39;,    age: 18  &#125;,  myMsg: &#39;我的数据&#39;&#125;const mutations = &#123;  updateMsg (state, msg) &#123;    state.myMsg = msg  &#125;&#125;const actions = &#123;&#125;const getters = &#123;&#125;export default &#123;  namespaced: true,  state,  mutations,  actions,  getters&#125;</code></pre><h3 id="3-代码示例"><a href="#3-代码示例" class="headerlink" title="3.代码示例"></a>3.代码示例</h3><p>$store直接访问</p><pre><code class="js">$store.state.user.userInfo.name</code></pre><p>mapState辅助函数访问</p><pre><code class="js">...mapState(&#39;user&#39;, [&#39;userInfo&#39;]),...mapState(&#39;setting&#39;, [&#39;theme&#39;, &#39;desc&#39;]),</code></pre><h2 id="十八、获取模块内的getters数据"><a href="#十八、获取模块内的getters数据" class="headerlink" title="十八、获取模块内的getters数据"></a>十八、获取模块内的getters数据</h2><h3 id="1-目标：-2"><a href="#1-目标：-2" class="headerlink" title="1.目标："></a>1.目标：</h3><p>掌握模块中 getters 的访问语</p><h3 id="2-语法："><a href="#2-语法：" class="headerlink" title="2.语法："></a>2.语法：</h3><p>使用模块中 getters 中的数据： </p><ol><li>直接通过模块名访问<code> $store.getters[&#39;模块名/xxx &#39;]</code></li><li>通过 mapGetters 映射      <ol><li>默认根级别的映射  <code>mapGetters([ &#39;xxx&#39; ]) </code></li><li>子模块的映射  <code>mapGetters(&#39;模块名&#39;, [&#39;xxx&#39;])</code> -  需要开启命名空间</li></ol></li></ol><h3 id="3-代码演示"><a href="#3-代码演示" class="headerlink" title="3.代码演示"></a>3.代码演示</h3><p><code>modules/user.js</code></p><pre><code class="js">const getters = &#123;  // 分模块后，state指代子模块的state  UpperCaseName (state) &#123;    return state.userInfo.name.toUpperCase()  &#125;&#125;</code></pre><p>Son1.vue 直接访问getters</p><pre><code class="html">&lt;!-- 测试访问模块中的getters - 原生 --&gt;&lt;div&gt;&#123;&#123; $store.getters['user/UpperCaseName'] &#125;&#125;&lt;/div&gt;</code></pre><p>Son2.vue 通过命名空间访问</p><pre><code class="js">computed:&#123;  ...mapGetters(&#39;user&#39;, [&#39;UpperCaseName&#39;])&#125;</code></pre><h2 id="十九、获取模块内的mutations方法"><a href="#十九、获取模块内的mutations方法" class="headerlink" title="十九、获取模块内的mutations方法"></a>十九、获取模块内的mutations方法</h2><h3 id="1-目标：-3"><a href="#1-目标：-3" class="headerlink" title="1.目标："></a>1.目标：</h3><p>掌握模块中 mutation 的调用语法</p><h3 id="2-注意："><a href="#2-注意：" class="headerlink" title="2.注意："></a>2.注意：</h3><p>默认模块中的 mutation 和 actions 会被挂载到全局，<strong>需要开启命名空间</strong>，才会挂载到子模块。</p><h3 id="3-调用方式："><a href="#3-调用方式：" class="headerlink" title="3.调用方式："></a>3.调用方式：</h3><ol><li>直接通过 store 调用   $store.commit(‘模块名&#x2F;xxx ‘,  额外参数)</li><li>通过 mapMutations 映射    <ol><li>默认根级别的映射  mapMutations([ ‘xxx’ ])     </li><li>子模块的映射 mapMutations(‘模块名’, [‘xxx’])  -  需要开启命名空间</li></ol></li></ol><h3 id="4-代码实现"><a href="#4-代码实现" class="headerlink" title="4.代码实现"></a>4.代码实现</h3><p><code>modules/user.js</code></p><pre><code class="js">const mutations = &#123;  setUser (state, newUserInfo) &#123;    state.userInfo = newUserInfo  &#125;&#125;</code></pre><p><code>modules/setting.js</code></p><pre><code class="js">const mutations = &#123;  setTheme (state, newTheme) &#123;    state.theme = newTheme  &#125;&#125;</code></pre><p>Son1.vue</p><pre><code class="vue">&lt;button @click=&quot;updateUser&quot;&gt;更新个人信息&lt;/button&gt; &lt;button @click=&quot;updateTheme&quot;&gt;更新主题色&lt;/button&gt;export default &#123;  methods: &#123;    updateUser () &#123;      // $store.commit(&#39;模块名/mutation名&#39;, 额外传参)      this.$store.commit(&#39;user/setUser&#39;, &#123;        name: &#39;xiaowang&#39;,        age: 25      &#125;)    &#125;,     updateTheme () &#123;      this.$store.commit(&#39;setting/setTheme&#39;, &#39;pink&#39;)    &#125;  &#125;&#125;</code></pre><p>Son2.vue</p><pre><code class="vue">&lt;button @click=&quot;setUser(&#123; name: &#39;xiaoli&#39;, age: 80 &#125;)&quot;&gt;更新个人信息&lt;/button&gt;&lt;button @click=&quot;setTheme(&#39;skyblue&#39;)&quot;&gt;更新主题&lt;/button&gt;methods:&#123;// 分模块的映射...mapMutations(&#39;setting&#39;, [&#39;setTheme&#39;]),...mapMutations(&#39;user&#39;, [&#39;setUser&#39;]),&#125;</code></pre><h2 id="二十、获取模块内的actions方法"><a href="#二十、获取模块内的actions方法" class="headerlink" title="二十、获取模块内的actions方法"></a>二十、获取模块内的actions方法</h2><h3 id="1-目标：-4"><a href="#1-目标：-4" class="headerlink" title="1.目标："></a>1.目标：</h3><p>掌握模块中 action 的调用语法 (同理 - 直接类比 mutation 即可)</p><h3 id="2-注意：-1"><a href="#2-注意：-1" class="headerlink" title="2.注意："></a>2.注意：</h3><p>默认模块中的 mutation 和 actions 会被挂载到全局，<strong>需要开启命名空间</strong>，才会挂载到子模块。</p><h3 id="3-调用语法："><a href="#3-调用语法：" class="headerlink" title="3.调用语法："></a>3.调用语法：</h3><ol><li>直接通过 store 调用   $store.dispatch(‘模块名&#x2F;xxx ‘,  额外参数)</li><li>通过 mapActions 映射     <ol><li>默认根级别的映射  mapActions([ ‘xxx’ ])     </li><li>子模块的映射 mapActions(‘模块名’, [‘xxx’])  -  需要开启命名空间</li></ol></li></ol><h3 id="4-代码实现-1"><a href="#4-代码实现-1" class="headerlink" title="4.代码实现"></a>4.代码实现</h3><p>需求：</p><p><img src="/assets/1683431615694.png" alt="68343161569"></p><p><code>modules/user.js</code></p><pre><code class="js">const actions = &#123;  setUserSecond (context, newUserInfo) &#123;    // 将异步在action中进行封装    setTimeout(() =&gt; &#123;      // 调用mutation   context上下文，默认提交的就是自己模块的action和mutation      context.commit(&#39;setUser&#39;, newUserInfo)    &#125;, 1000)  &#125;&#125;</code></pre><p>Son1.vue  直接通过store调用</p><pre><code class="vue">&lt;button @click=&quot;updateUser2&quot;&gt;一秒后更新信息&lt;/button&gt;methods:&#123;    updateUser2 () &#123;      // 调用action dispatch      this.$store.dispatch(&#39;user/setUserSecond&#39;, &#123;        name: &#39;xiaohong&#39;,        age: 28      &#125;)    &#125;,&#125;</code></pre><p>Son2.vue mapActions映射</p><pre><code class="js">&lt;button @click=&quot;setUserSecond(&#123; name: &#39;xiaoli&#39;, age: 80 &#125;)&quot;&gt;一秒后更新信息&lt;/button&gt;methods:&#123;  ...mapActions(&#39;user&#39;, [&#39;setUserSecond&#39;])&#125;</code></pre><h2 id="二十一、Vuex模块化的使用小结"><a href="#二十一、Vuex模块化的使用小结" class="headerlink" title="二十一、Vuex模块化的使用小结"></a>二十一、Vuex模块化的使用小结</h2><h3 id="1-直接使用"><a href="#1-直接使用" class="headerlink" title="1.直接使用"></a>1.直接使用</h3><ol><li>state –&gt; $store.state.<strong>模块名</strong>.数据项名</li><li>getters –&gt; $store.getters[‘<strong>模块名</strong>&#x2F;属性名’]</li><li>mutations –&gt; $store.commit(‘<strong>模块名</strong>&#x2F;方法名’, 其他参数)</li><li>actions –&gt; $store.dispatch(‘<strong>模块名</strong>&#x2F;方法名’, 其他参数)</li></ol><h3 id="2-借助辅助方法使用"><a href="#2-借助辅助方法使用" class="headerlink" title="2.借助辅助方法使用"></a>2.借助辅助方法使用</h3><p>1.import { mapXxxx, mapXxx } from ‘vuex’</p><p>computed、methods: {</p><p>​     &#x2F;&#x2F; <strong>…mapState、…mapGetters放computed中；</strong></p><p>​    &#x2F;&#x2F;  <strong>…mapMutations、…mapActions放methods中；</strong></p><p>​    …mapXxxx(<strong>‘模块名’</strong>, [‘数据项|方法’]),</p><p>​    …mapXxxx(<strong>‘模块名’</strong>, { 新的名字: 原来的名字 }),</p><p>}</p><p>2.组件中直接使用 属性 <code>&#123;&#123; age &#125;&#125;</code> 或 方法 <code>@click=&quot;updateAge(2)&quot;</code></p><h2 id="二十二、综合案例-创建项目"><a href="#二十二、综合案例-创建项目" class="headerlink" title="二十二、综合案例 - 创建项目"></a>二十二、综合案例 - 创建项目</h2><ol><li><p>脚手架新建项目 (注意：<strong>勾选vuex</strong>)      </p><p>版本说明：</p><p>vue2   vue-router3   vuex3               </p><p>vue3  vue-router4  vuex4&#x2F;pinia</p></li></ol><pre><code>vue create vue-cart-demo</code></pre><ol start="2"><li>将原本src内容清空，替换成教学资料的《vuex-cart-准备代码》</li></ol><p><img src="/assets/1683432959356.png" alt="68343295935"></p><p>需求：</p><ol><li>发请求动态渲染购物车，数据存vuex （存cart模块， 将来还会有user模块，article模块…）</li><li>数字框可以修改数据</li><li>动态计算总价和总数量</li></ol><h2 id="二十三、综合案例-构建vuex-cart模块"><a href="#二十三、综合案例-构建vuex-cart模块" class="headerlink" title="二十三、综合案例-构建vuex-cart模块"></a>二十三、综合案例-构建vuex-cart模块</h2><ol><li>新建 <code>store/modules/cart.js</code></li></ol><pre><code class="jsx">export default &#123;  namespaced: true,  state () &#123;    return &#123;      list: []    &#125;  &#125;,&#125;</code></pre><ol start="2"><li>挂载到 vuex 仓库上 <code>store/cart.js</code></li></ol><pre><code class="jsx">import Vuex from &#39;vuex&#39;import Vue from &#39;vue&#39;import cart from &#39;./modules/cart&#39;Vue.use(Vuex)const store = new Vuex.Store(&#123;  modules: &#123;    cart  &#125;&#125;)export default store</code></pre><h2 id="二十四、综合案例-准备后端接口服务环境-了解"><a href="#二十四、综合案例-准备后端接口服务环境-了解" class="headerlink" title="二十四、综合案例-准备后端接口服务环境(了解)"></a>二十四、综合案例-准备后端接口服务环境(了解)</h2><ol><li>安装全局工具 json-server （全局工具仅需要安装一次）</li></ol><pre><code>yarn global add json-server 或 npm i json-server  -g</code></pre><ol start="2"><li>代码根目录新建一个 db 目录</li><li>将资料 index.json 移入 db 目录</li><li>进入 db 目录，执行命令，启动后端接口服务 (使用–watch 参数 可以实时监听 json 文件的修改)</li></ol><pre><code>json-server  --watch  index.json</code></pre><h2 id="二十五、综合案例-请求动态渲染数据"><a href="#二十五、综合案例-请求动态渲染数据" class="headerlink" title="二十五、综合案例-请求动态渲染数据"></a>二十五、综合案例-请求动态渲染数据</h2><h3 id="1-目标-4"><a href="#1-目标-4" class="headerlink" title="1.目标"></a>1.目标</h3><p>请求获取数据存入 vuex, 映射渲染</p><p><img src="/assets/1683436471929.png" alt="68343647192"></p><ol><li>安装 axios</li></ol><pre><code class="jsx">yarn add axios</code></pre><ol start="2"><li>准备actions 和 mutations</li></ol><pre><code class="jsx">import axios from &#39;axios&#39;export default &#123;  namespaced: true,  state () &#123;    return &#123;      list: []    &#125;  &#125;,  mutations: &#123;    updateList (state, payload) &#123;      state.list = payload    &#125;  &#125;,  actions: &#123;    async getList (ctx) &#123;      const res = await axios.get(&#39;http://localhost:3000/cart&#39;)      ctx.commit(&#39;updateList&#39;, res.data)    &#125;  &#125;&#125;</code></pre><ol start="3"><li><code>App.vue</code>页面中调用 action,  获取数据</li></ol><pre><code class="jsx">import &#123; mapState &#125; from &#39;vuex&#39;export default &#123;  name: &#39;App&#39;,  components: &#123;    CartHeader,    CartFooter,    CartItem  &#125;,  created () &#123;    this.$store.dispatch(&#39;cart/getList&#39;)  &#125;,  computed: &#123;    ...mapState(&#39;cart&#39;, [&#39;list&#39;])  &#125;&#125;</code></pre><ol start="4"><li>动态渲染</li></ol><pre><code class="jsx">&lt;!-- 商品 Item 项组件 --&gt;&lt;cart-item v-for=&quot;item in list&quot; :key=&quot;item.id&quot; :item=&quot;item&quot;&gt;&lt;/cart-item&gt;</code></pre><p><code>cart-item.vue</code></p><pre><code class="jsx">&lt;template&gt;  &lt;div class=&quot;goods-container&quot;&gt;    &lt;!-- 左侧图片区域 --&gt;    &lt;div class=&quot;left&quot;&gt;      &lt;img :src=&quot;item.thumb&quot; class=&quot;avatar&quot; alt=&quot;&quot;&gt;    &lt;/div&gt;    &lt;!-- 右侧商品区域 --&gt;    &lt;div class=&quot;right&quot;&gt;      &lt;!-- 标题 --&gt;      &lt;div class=&quot;title&quot;&gt;&#123;&#123;item.name&#125;&#125;&lt;/div&gt;      &lt;div class=&quot;info&quot;&gt;        &lt;!-- 单价 --&gt;        &lt;span class=&quot;price&quot;&gt;￥&#123;&#123;item.price&#125;&#125;&lt;/span&gt;        &lt;div class=&quot;btns&quot;&gt;          &lt;!-- 按钮区域 --&gt;          &lt;button class=&quot;btn btn-light&quot;&gt;-&lt;/button&gt;          &lt;span class=&quot;count&quot;&gt;&#123;&#123;item.count&#125;&#125;&lt;/span&gt;          &lt;button class=&quot;btn btn-light&quot;&gt;+&lt;/button&gt;        &lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;CartItem&#39;,  props: &#123;    item: Object  &#125;,  methods: &#123;  &#125;&#125;&lt;/script&gt;</code></pre><h2 id="二十六、综合案例-修改数量"><a href="#二十六、综合案例-修改数量" class="headerlink" title="二十六、综合案例-修改数量"></a>二十六、综合案例-修改数量</h2><p><img src="/assets/1683437346997.png" alt="68343734699"></p><ol><li>注册点击事件</li></ol><pre><code class="jsx">&lt;!-- 按钮区域 --&gt;&lt;button class=&quot;btn btn-light&quot; @click=&quot;onBtnClick(-1)&quot;&gt;-&lt;/button&gt;&lt;span class=&quot;count&quot;&gt;&#123;&#123;item.count&#125;&#125;&lt;/span&gt;&lt;button class=&quot;btn btn-light&quot; @click=&quot;onBtnClick(1)&quot;&gt;+&lt;/button&gt;</code></pre><ol start="2"><li>页面中dispatch action</li></ol><pre><code class="jsx">onBtnClick (step) &#123;  const newCount = this.item.count + step  if (newCount &lt; 1) return  // 发送修改数量请求  this.$store.dispatch(&#39;cart/updateCount&#39;, &#123;    id: this.item.id,    count: newCount  &#125;)&#125;</code></pre><ol start="3"><li>提供action函数</li></ol><pre><code class="jsx">async updateCount (ctx, payload) &#123;  await axios.patch(&#39;http://localhost:3000/cart/&#39; + payload.id, &#123;    count: payload.count  &#125;)  ctx.commit(&#39;updateCount&#39;, payload)&#125;</code></pre><ol start="4"><li>提供mutation处理函数</li></ol><pre><code class="jsx">mutations: &#123;  ...,  updateCount (state, payload) &#123;    const goods = state.list.find((item) =&gt; item.id === payload.id)    goods.count = payload.count  &#125;&#125;,</code></pre><h2 id="二十七、综合案例-底部总价展示"><a href="#二十七、综合案例-底部总价展示" class="headerlink" title="二十七、综合案例-底部总价展示"></a>二十七、综合案例-底部总价展示</h2><ol><li>提供getters</li></ol><pre><code class="jsx">getters: &#123;  total(state) &#123;    return state.list.reduce((p, c) =&gt; p + c.count, 0);  &#125;,  totalPrice (state) &#123;    return state.list.reduce((p, c) =&gt; p + c.count * c.price, 0);  &#125;,&#125;,</code></pre><ol start="2"><li>动态渲染</li></ol><pre><code class="jsx">&lt;template&gt;  &lt;div class=&quot;footer-container&quot;&gt;    &lt;!-- 中间的合计 --&gt;    &lt;div&gt;      &lt;span&gt;共 &#123;&#123;total&#125;&#125; 件商品，合计：&lt;/span&gt;      &lt;span class=&quot;price&quot;&gt;￥&#123;&#123;totalPrice&#125;&#125;&lt;/span&gt;    &lt;/div&gt;    &lt;!-- 右侧结算按钮 --&gt;    &lt;button class=&quot;btn btn-success btn-settle&quot;&gt;结算&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; mapGetters &#125; from &#39;vuex&#39;export default &#123;  name: &#39;CartFooter&#39;,  computed: &#123;    ...mapGetters(&#39;cart&#39;, [&#39;total&#39;, &#39;totalPrice&#39;])  &#125;&#125;&lt;/script&gt;</code></pre>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
