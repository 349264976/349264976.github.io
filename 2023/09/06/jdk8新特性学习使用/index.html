<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>jdk8新特性学习使用 | fuguangmengying</title><meta name="author" content="en"><meta name="copyright" content="en"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="JDK8新特性学习及使用1.Lambda表达式初体验代码片段对比 开启一个新的线程 需要执行的代码 普通代码块 new Thread(     new Runnable()&amp;#123;     @Override     public void run()&amp;#123;     System.outprintlin(&quot;新线程中执行的代码&quot;+Thread.currentThread">
<meta property="og:type" content="article">
<meta property="og:title" content="jdk8新特性学习使用">
<meta property="og:url" content="https://349264976.github.io/2023/09/06/jdk8%E6%96%B0%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8/index.html">
<meta property="og:site_name" content="fuguangmengying">
<meta property="og:description" content="JDK8新特性学习及使用1.Lambda表达式初体验代码片段对比 开启一个新的线程 需要执行的代码 普通代码块 new Thread(     new Runnable()&amp;#123;     @Override     public void run()&amp;#123;     System.outprintlin(&quot;新线程中执行的代码&quot;+Thread.currentThread">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://349264976.github.io/img/avatar.jpg">
<meta property="article:published_time" content="2023-09-06T13:03:35.000Z">
<meta property="article:modified_time" content="2023-09-27T13:13:50.366Z">
<meta property="article:author" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://349264976.github.io/img/avatar.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://349264976.github.io/2023/09/06/jdk8%E6%96%B0%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'jdk8新特性学习使用',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-09-27 21:13:50'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">41</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/default_top_img.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="fuguangmengying"><span class="site-name">fuguangmengying</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">jdk8新特性学习使用</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-09-06T13:03:35.000Z" title="发表于 2023-09-06 21:03:35">2023-09-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-09-27T13:13:50.366Z" title="更新于 2023-09-27 21:13:50">2023-09-27</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="jdk8新特性学习使用"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="JDK8新特性学习及使用"><a href="#JDK8新特性学习及使用" class="headerlink" title="JDK8新特性学习及使用"></a>JDK8新特性学习及使用</h1><h2 id="1-Lambda表达式初体验"><a href="#1-Lambda表达式初体验" class="headerlink" title="1.Lambda表达式初体验"></a>1.Lambda表达式初体验</h2><p><strong>代码片段对比<img src="/2023/09/06/jdk8%E6%96%B0%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8/image-20230927203405662.png" class title="image-20230927203405662"></strong></p>
<p>开启一个新的线程 需要执行的代码</p>
<p><strong>普通代码块</strong></p>
<pre><code>new Thread(
    new Runnable()&#123;
    @Override
    public void run()&#123;
    System.outprintlin(&quot;新线程中执行的代码&quot;+Thread.currentThread().getname())
    &#125;
    &#125;
).start
</code></pre>
<p><strong>Lambad代码块</strong></p>
<p>Lambda表达式是一个匿名函数可以理解为一段可以传递的代码片段</p>
<p>使用Lambda时不关心方法名称 不关心 方法名称 只关心方法参数 方法内部步骤 </p>
<pre><code>new Thread(()-&gt;&#123;System.outprintlin(&quot;新线程中执行的代码&quot;+Thread.currentThread().getname()) &#125; ).start（）;
</code></pre>
<p>Lambda表达式的有点：简化了匿名内部类的使用，语法更加简单</p>
<p><strong>Lambad表达式语法规则</strong></p>
<p>Lambad 省去了面向对象的限制  标准的格式是三个部分：</p>
<pre><code>(参数类型 参数名称)-&gt;&#123;
    代码体；
&#125;
</code></pre>
<img src="/2023/09/06/jdk8%E6%96%B0%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8/image-20230909133854880.png" class title="image-20230909133854880">

<h2 id="补充知识集合比较"><a href="#补充知识集合比较" class="headerlink" title="补充知识集合比较"></a>补充知识集合比较</h2><pre><code class="java">        List&lt;Person&gt; list = new ArrayList&lt;&gt;();
        list.add(new Person(&quot;周杰伦&quot;,33,175));
        list.add(new Person(&quot;刘德华&quot;,43,185));
        list.add(new Person(&quot;周星驰&quot;,38,177));
        list.add(new Person(&quot;郭富城&quot;,23,170));
        
        Collections.sort(list, new Comparator&lt;Person&gt;() &#123;
            @Override
            public int compare(Person o1, Person o2) &#123;
                return o1.getHeight() - o2.getHeight();
            &#125;
        &#125;);
</code></pre>
<p><strong>源码解读</strong></p>
<p>比较其两个顺序参数。返回负整数、零或正整数，因为第一个参数小于、等于或大于第二个参数。在前面的描述中，符号 sgn（expression） 指定数学符号函数，该函数被定义为根据表达式的值是负、零还是正返回 -1、0 或 1 之一。实现者必须确保 sgn（compare（x， y）） &#x3D;&#x3D; -sgn（compare（y， x）） 对于所有 x 和 y。 （这意味着 compare（x， y） 必须抛出异常当且仅当 compare（y， x） 抛出异常。实现者还必须确保关系是传递的：（（compare（x， y）&gt;0） &amp;&amp; （compare（y， z）&gt;0）） 意味着 compare（x， z）&gt;0。最后，实现者必须确保 compare（x， y）&#x3D;&#x3D;0 意味着所有 z 的 sgn（compare（x， z））&#x3D;&#x3D;sgn（compare（y， z））。一般情况下是这样，但不是严格要求的（compare（x， y）&#x3D;&#x3D;0） &#x3D;&#x3D; （x.equals（y））。一般而言，任何违反此条件的比较器都应明确指出这一事实。推荐的语言是“注意：此比较器施加的排序与相等不一致。参数：o1 – 要比较的第一个对象。O2 – 要比较的第二个对象。返回：负整数、零或正整数，因为第一个参数小于、等于或大于第二个参数。抛出：NullPointerException – 如果参数为 null 并且此比较器不允许空参数 ClassCastException – 如果参数的类型阻止此比较器比较它们。</p>
<p>int compare(T o1, T o2); </p>
<p>针对这段代码我这边翻看了一下源码</p>
<p>在集合比较的过程中</p>
<p>我们利用jdk工具进行集合的比较</p>
<pre><code> Collections.sort(list, new Comparator&lt;Person&gt;() &#123;
            @Override
            public int compare(Person o1, Person o2) &#123;
                return o1.getHeight() - o2.getHeight();
            &#125;
        &#125;);
</code></pre>
<p>会进入sort方法</p>
<pre><code>  public static &lt;T&gt; void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c) &#123;
        list.sort(c);
    &#125;
</code></pre>
<p>会调用list的sort方法 并且把比较器传递进去</p>
<p>这里先转换成      Object[] a &#x3D; this.toArray();数组</p>
<pre><code class="java">    @SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)
    default void sort(Comparator&lt;? super E&gt; c) &#123;
        Object[] a = this.toArray();
        Arrays.sort(a, (Comparator) c);
        ListIterator&lt;E&gt; i = this.listIterator();
        for (Object e : a) &#123;
            i.next();
            i.set((E) e);
        &#125;
    &#125;
</code></pre>
<p>调用</p>
<p> Arrays.sort(a, (Comparator) c);</p>
<p>真可怕 一个小小的排序用到了不下二十余个方法</p>
<p>我这边扒了一些最终找到 当我们传递了比较器的比较方法</p>
<pre><code class="java">   private static void mergeSort(Object[] src,
                                  Object[] dest,
                                  int low, int high, int off,
                                  Comparator c) &#123;
        int length = high - low;

        // Insertion sort on smallest arrays
        if (length &lt; INSERTIONSORT_THRESHOLD) &#123;
            for (int i=low; i&lt;high; i++)
                for (int j=i; j&gt;low &amp;&amp; c.compare(dest[j-1], dest[j])&gt;0; j--)
                    swap(dest, j, j-1);
            return;
        &#125;

        // Recursively sort halves of dest into src
        int destLow  = low;
        int destHigh = high;
        low  += off;
        high += off;
        int mid = (low + high) &gt;&gt;&gt; 1;
        mergeSort(dest, src, low, mid, -off, c);
        mergeSort(dest, src, mid, high, -off, c);

        // If list is already sorted, just copy from src to dest.  This is an
        // optimization that results in faster sorts for nearly ordered lists.
        if (c.compare(src[mid-1], src[mid]) &lt;= 0) &#123;
           System.arraycopy(src, low, dest, destLow, length);
           return;
        &#125;

        // Merge sorted halves (now in src) into dest
        for(int i = destLow, p = low, q = mid; i &lt; destHigh; i++) &#123;
            if (q &gt;= high || p &lt; mid &amp;&amp; c.compare(src[p], src[q]) &lt;= 0)
                dest[i] = src[p++];
            else
                dest[i] = src[q++];
        &#125;
    &#125;
</code></pre>
<pre><code class="java">    private static void mergeSort(Object[] src,
                                  Object[] dest,
                                  int low, int high, int off,
                                  Comparator c) &#123;
        int length = high - low;

        // Insertion sort on smallest arrays
        if (length &lt; INSERTIONSORT_THRESHOLD) &#123;
            for (int i=low; i&lt;high; i++)
                for (int j=i; j&gt;low &amp;&amp; c.compare(dest[j-1], dest[j])&gt;0; j--)
                    swap(dest, j, j-1);
            return;
        &#125;
</code></pre>
<p>太难lwc</p>
<p>先简单理解  </p>
<pre><code class="java">  Collections.sort(list, new Comparator&lt;Person&gt;() &#123;
            @Override
            public int compare(Person o1, Person o2) &#123;
                return o1.getHeight() - o2.getHeight();
            &#125;
        &#125;);
</code></pre>
<p>compare 一般是是传入比较的值 返回值  -1则是前面的值小</p>
<p>0则是相等 1则是后面的值大</p>
<p>具体排序不做深入研究</p>
<p>这里继续研究Lambda </p>
<p>既然这里是需要匿名内部类那我们就可以改写成Lambda</p>
<pre><code class="java">  Collections.sort(list,(Person o1, Person o2)-&gt;&#123;
                return o1.getHeight() - o2.getHeight();
            &#125;
        &#125;);
</code></pre>
<p>既然这里我们没有写方法名字那我们可以大胆判断 </p>
<p>我们的匿名内部类的实现的接口必定只有一个参数为两个的方法</p>
<p>int compare(T o1, T o2);</p>
<p>果然经过查看接口</p>
<p>只有一个唯一的方法</p>
<p>@FunctionalInterface</p>
<p>你提到的<code>Comparator&lt;T&gt;</code>接口被<code>@FunctionalInterface</code>修饰是因为它只包含一个抽象方法<code>compare()</code>，满足函数式接口的要求。函数式接口是指只有一个抽象方法的接口，可以用作Lambda表达式和方法引用的目标类型。</p>
<p>虽然<code>Comparator&lt;T&gt;</code>接口只有一个抽象方法，但它可以包含其他默认方法和静态方法。这些方法提供了额外的功能和操作，以便更方便地使用和组合比较器。这些附加的默认方法和静态方法并不违反函数式接口的定义，因为它们不会影响接口的函数式特性。</p>
<p>默认方法是接口中具有默认实现的方法。它们允许在接口中添加新的方法，而不会破坏现有的实现类。<code>Comparator&lt;T&gt;</code>接口中的默认方法提供了一些便捷的比较器组合操作。例如，<code>thenComparing()</code>方法允许在现有的比较器基础上添加额外的比较规则，实现多级排序。</p>
<p>静态方法是接口中的类级别方法，可以直接通过接口名称调用。<code>Comparator&lt;T&gt;</code>接口中的静态方法提供了一些实用的工具方法，用于创建和组合比较器。例如，<code>comparing()</code>方法用于基于对象的某个属性提取器创建比较器。</p>
<p>尽管<code>Comparator&lt;T&gt;</code>接口包含默认方法和静态方法，但它仍然是一个函数式接口，因为它只有一个抽象方法<code>compare()</code>。这意味着你可以使用Lambda表达式或方法引用来创建<code>Comparator&lt;T&gt;</code>的实例，而不需要实现额外的方法。</p>
<p>总之，虽然<code>Comparator&lt;T&gt;</code>接口包含一些默认方法和静态方法，但它仍然被标记为<code>@FunctionalInterface</code>，因为它只有一个抽象方法，满足函数式接口的要求。这使得它可以被用作Lambda表达式和方法引用的目标类型，提供了更灵活和便捷的比较器操作。</p>
<p>**关于Lambda我们需要知道的是 他只适用于函数时接口 **</p>
<p>我个人理解 Lambda只是语法糖</p>
<p>实际上还是一个匿名内部类 去重写这个方法</p>
<h3 id="Lambda-表达式的省略写法"><a href="#Lambda-表达式的省略写法" class="headerlink" title="Lambda 表达式的省略写法"></a>Lambda 表达式的省略写法</h3><p>在lambda的表达式的标准写法上可以省略写法的规则为</p>
<p>1.小括号内的参数类型可以省略</p>
<p>2.如果小括号内有且仅有一个参数则小括号可以省略</p>
<p>3.如果大括号有且仅有一个语句 可以同时省略大括号 return关键子以及语句分号</p>
<p><img src="/2023/09/06/jdk8%E6%96%B0%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8/personboke\blog\source_posts\jdk8新特性学习使用\image-20230907220250280.png" alt="image-20230907220250280"></p>
<h2 id="二、接口中新增的方法"><a href="#二、接口中新增的方法" class="headerlink" title="二、接口中新增的方法"></a>二、接口中新增的方法</h2><h3 id="1-0JDK8中接口的新增"><a href="#1-0JDK8中接口的新增" class="headerlink" title="1.0JDK8中接口的新增"></a>1.0JDK8中接口的新增</h3><p>在jdk8中这妞的接口有做增强  j8之前</p>
<pre><code>interface 接口名&#123;
    静态常量；
    抽象方法；
&#125;
</code></pre>
<pre><code>interface 接口名&#123;
    静态常量；
    抽象方法；
    默认方法；
    静态方法；
&#125;
</code></pre>
<h3 id="2静态方法"><a href="#2静态方法" class="headerlink" title="2静态方法"></a>2静态方法</h3><h4 id="为什么要增加？"><a href="#为什么要增加？" class="headerlink" title="为什么要增加？"></a>为什么要增加？</h4><p>为了解决咱们如果一个接口被多个实现类实现了  </p>
<p>再增加方法实现类都要实现  非常差的体验 </p>
<pre><code>interface A&#123;
public  default String method（）&#123;
sout（&quot;接口中的方法&quot;）
&#125;
&#125;
</code></pre>
<pre><code>class b implment A&#123;
@Override
public  String method（）&#123;
sout（&quot;实现类中的方法&quot;）
&#125;
&#125;
</code></pre>
<h3 id="3默认方法"><a href="#3默认方法" class="headerlink" title="3默认方法"></a>3默认方法</h3><p>作用：拓展接口的功能</p>
<h4 id="3-1语法规则"><a href="#3-1语法规则" class="headerlink" title="3.1语法规则"></a>3.1语法规则</h4><pre><code>
interface A&#123;
public static String test4()&#123;
 sout(&quot;接口中的静态方法&quot;)；
&#125;
&#125;
&#125;
class b implment A&#123;
不能重写静态方法
只能
A.staticMethod();
&#125;

</code></pre>
<h2 id="三、函数式接口"><a href="#三、函数式接口" class="headerlink" title="三、函数式接口"></a>三、函数式接口</h2><h3 id="1-函数式接口的由来"><a href="#1-函数式接口的由来" class="headerlink" title="1.函数式接口的由来"></a>1.函数式接口的由来</h3><p>我们知道lambda表达式的前提式需要有函数时接口 而lambad表达式使用时不关心接口名抽象方法名、只关心抽象方法的参数列表和返回值类型。因此为了我们可以使用lambda表达式更加的方法在jdk中提供的大量的常用的函数式接口</p>
<p>1.Consumer接口</p>
<p>void accept（T t）；</p>
<p>2.Supplier接口</p>
<p>R apply（T t）；</p>
<h3 id="2-函数式接口介绍"><a href="#2-函数式接口介绍" class="headerlink" title="2.函数式接口介绍"></a>2.函数式接口介绍</h3><h4 id="2-1Supplier"><a href="#2-1Supplier" class="headerlink" title="2.1Supplier"></a>2.1Supplier</h4><p><strong>无参有返回值  供给型</strong></p>
<pre><code>@FunctionalInterfave
public interface Supplier&lt;T&gt;&#123;

/**
Gets a result
@Return a result；
**/
T get();

&#125;
</code></pre>
<h3 id="2-1-1使用"><a href="#2-1-1使用" class="headerlink" title="2.1.1使用"></a>2.1.1使用</h3><pre><code>  
public class SupplierTest &#123;

    public static void main(String[] args) &#123;
        fun1(()-&gt;&#123;
            int arr[] = &#123;22,33,55,66,44,99,10&#125;;
            // 计算出数组中的最大值
            Arrays.sort(arr);
            return arr[arr.length-1];
        &#125;);
        funcition(()-&gt;&#123;
            String getString=&quot;Supplier&lt;Integer&gt; supplier&quot;;
            return getString;
        &#125;);
    &#125;

    private static void fun1(Supplier&lt;Integer&gt; supplier)&#123;
        // get() 是一个无参的有返回值的 抽象方法
        Integer max = supplier.get();
        System.out.println(&quot;max = &quot; + max);
    &#125;

    private static void funcition(Supplier&lt;String&gt; supplier)&#123;
        // get() 是一个无参的有返回值的 抽象方法
        String getString = supplier.get();
        System.out.println(getString);

    &#125;
&#125;
</code></pre>
<h4 id="2-2Consumer"><a href="#2-2Consumer" class="headerlink" title="2.2Consumer"></a>2.2Consumer</h4><p><strong>有参无返回值</strong></p>
<p><strong>Consumer接口是用来消费数据的 使用的售后需要指定反省来定义参数类型</strong></p>
<pre><code>@FunctionalInterface
public interface Consumer&lt;T&gt; &#123;

    /**
     * Performs this operation on the given argument.
     *
     * @param t the input argument
     */
    void accept(T t);

&#125;
</code></pre>
<p><img src="/2023/09/06/jdk8%E6%96%B0%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8/personboke\blog\source_posts\jdk8新特性学习使用\image-20230908231516817.png" alt="image-20230908231516817"></p>
<pre><code>   public static void main(String[] args) &#123;
        test2(msg1-&gt;&#123;
            System.out.println(msg1 + &quot;-&gt; 转换为小写：&quot; + msg1.toLowerCase());
        &#125;,msg2-&gt;&#123;
            System.out.println(msg2 + &quot;-&gt; 转换为大写：&quot; + msg2.toUpperCase());
        &#125;);
    &#125;


    public static void test2(Consumer&lt;String&gt; c1,Consumer&lt;String&gt; c2)&#123;
        String str = &quot;Hello World&quot;;
        //c1.accept(str); // 转小写
        //c2.accept(str); // 转大写
        //c1.andThen(c2).accept(str);
        c2.andThen(c1).accept(str);
    &#125;
</code></pre>
<h3 id="2-3-Function"><a href="#2-3-Function" class="headerlink" title="2.3 Function"></a>2.3 Function</h3><p><strong>有参有返回值</strong></p>
<p><strong>function 根据一个类型的数据得到另一个类型的数据 前者称为前置条件</strong></p>
<p><strong>后者成为后置条件  有参有返回值</strong></p>
<pre><code>@FunctionalInterface
public interface Function&lt;T, R&gt; &#123;
    /**
     * Applies this function to the given argument.
     * @param t the function argument
     * @return the function result
     */
    R apply(T t);
    
    &#125;
</code></pre>
<pre><code>  public static void main(String[] args) &#123;
        test(msg -&gt;&#123;
            return Integer.parseInt(msg);
        &#125;);
    &#125;

    public static void test(Function&lt;String,Integer&gt; function)&#123;
        Integer apply = function.apply(&quot;666&quot;);
        System.out.println(&quot;apply = &quot; + apply);
    &#125;
</code></pre>
<p>默认方法 </p>
<p>andThen()</p>
<pre><code>    public static void main(String[] args) &#123;
        test(msg -&gt;&#123;
            return Integer.parseInt(msg);
        &#125;,msg2-&gt;&#123;
            return msg2 * 10;
        &#125;);
    &#125;

    public static void test(Function&lt;String,Integer&gt; f1,Function&lt;Integer,Integer&gt; f2)&#123;
        /*Integer i1 = f1.apply(&quot;666&quot;);
        Integer i2 = f2.apply(i1);*/
       // Integer i2 = f1.andThen(f2).apply(&quot;666&quot;);
        Integer i2 = f2.compose(f1).apply(&quot;666&quot;);
        System.out.println(&quot;i2:&quot; + i2);

    &#125;
</code></pre>
<p>compose方法的作用顺序和andThen方法刚好相反</p>
<p>静态方法identity则是输入什么参数就返回什么参数</p>
<h4 id="2-4Predicate"><a href="#2-4Predicate" class="headerlink" title="2.4Predicate"></a>2.4Predicate</h4><p>有参有返回值 切返回值为布尔</p>
<pre><code>@FunctionalInterface
public interface Predicate&lt;T&gt; &#123;

    /**
     * Evaluates this predicate on the given argument.
     *
     * @param t the input argument
     * @return &#123;@code true&#125; if the input argument matches the predicate,
     * otherwise &#123;@code false&#125;
     */
    boolean test(T t);
&#125;
</code></pre>
<p>test（）</p>
<pre><code>
    public static void main(String[] args) &#123;
        test(msg1 -&gt; &#123;
            return msg1.contains(&quot;H&quot;);
        &#125;,msg2 -&gt; &#123;
            return msg2.contains(&quot;W&quot;);
        &#125;);
    &#125;

    private static void test(Predicate&lt;String&gt; p1,Predicate&lt;String&gt; p2)&#123;
        /*boolean b1 = predicate.test(msg);
        boolean b2 = predicate.test(&quot;Hello&quot;);*/
        // b1 包含H b2 包含W
        // p1 包含H 同时 p2 包含W
        boolean bb1 = p1.and(p2).test(&quot;Hello&quot;);
        // p1 包含H 或者 p2 包含W
        boolean bb2 = p1.or(p2).test(&quot;Hello&quot;);
        // p1 不包含H
        boolean bb3 = p1.negate().test(&quot;Hello&quot;);
        System.out.println(bb1); // FALSE
        System.out.println(bb2); // TRUE
        System.out.println(bb3); // FALSE
    &#125;
</code></pre>
<h2 id="四、方法引用"><a href="#四、方法引用" class="headerlink" title="四、方法引用"></a>四、方法引用</h2><p>符号标识：：</p>
<p>符号说明： 双冒号为方法引用运算符 而他所在的表达式被称为方法引用</p>
<p>应用场景： 如果Lambda表达式所要实现方案已经有方法存在相同方案 那么可以使用方法引用</p>
<p>常见的引用方法</p>
<p> ag：</p>
<pre><code>1. instanceName::methodName 对象::方法名
2.Classname::staticMethodName 类名：：静态方法
3.ClassName：：methodName 类名：：普通方法
4.ClassName：：new 类名：：new 调用的构造器
5.Typename[]::new String[]::new 调用数组的构造器
</code></pre>
<p><img src="/2023/09/06/jdk8%E6%96%B0%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8/personboke\blog\source_posts\jdk8新特性学习使用\image-20230909003224091.png" alt="image-20230909003224091"></p>
<h2 id="User-getUsername-相当于"><a href="#User-getUsername-相当于" class="headerlink" title="**User::getUsername **  相当于"></a>**User::getUsername **  相当于</h2><p><strong>实际上也是一个实现类的方法</strong></p>
<h2 id="User-user-gt-user-getUsername"><a href="#User-user-gt-user-getUsername" class="headerlink" title="(User user) -&gt; user.getUsername()"></a>(User user) -&gt; user.getUsername()</h2><pre><code class="java">    @Override
    public List&lt;User&gt; queryUsers(String username, Integer status, Long min, Long max) &#123;
        return lambdaQuery().like(User::getUsername, username).list();
    &#125;
</code></pre>
<h2 id="记忆深化案例"><a href="#记忆深化案例" class="headerlink" title="记忆深化案例"></a>记忆深化案例</h2><p><strong>以下是一个示例，展示了如何创建一个匿名实现类：</strong></p>
<pre><code class="java">interface MyInterface &#123;
    void doSomething();
&#125;

public class Main &#123;
    public static void main(String[] args) &#123;
        // 创建匿名实现类
        MyInterface myInterface = new MyInterface() &#123;
            @Override
            public void doSomething() &#123;
                System.out.println(&quot;Doing something in anonymous implementation.&quot;);
            &#125;
        &#125;;

        // 调用匿名实现类的方法
        myInterface.doSomething();
    &#125;
&#125;
</code></pre>
<p><strong>使用 Lambda 表达式：</strong></p>
<pre><code class="java">interface MyInterface &#123;
    void doSomething();
&#125;

public class Main &#123;
    public static void main(String[] args) &#123;
        // 使用 Lambda 表达式创建接口实例
        MyInterface myInterface = () -&gt; &#123;
            System.out.println(&quot;Doing something in Lambda expression.&quot;);
        &#125;;

        // 调用接口方法
        myInterface.doSomething();
    &#125;
&#125;
</code></pre>
<p><strong>使用方法引用：</strong></p>
<pre><code class="java">interface MyInterface &#123;
    void doSomething();
&#125;

public class Main &#123;
    public static void main(String[] args) &#123;
        // 使用方法引用创建接口实例
        MyInterface myInterface = Main::doSomethingMethodReference;

        // 调用接口方法
        myInterface.doSomething();
    &#125;

    // 静态方法作为方法引用的目标
    public static void doSomethingMethodReference() &#123;
        System.out.println(&quot;Doing something in method reference.&quot;);
    &#125;
</code></pre>
<p><strong>再次记忆深化</strong></p>
<pre><code class="java">new MyInterface() &#123;
            @Override
            public void doSomething() &#123;
                System.out.println(&quot;Doing something in anonymous implementation.&quot;);
            &#125;
        &#125;;
</code></pre>
<p>等价于</p>
<pre><code>() -&gt; System.out.println(&quot;Doing something in lambda expression.&quot;)).doSomething();
    &#125;
</code></pre>
<h2 id="五、Stream-APi"><a href="#五、Stream-APi" class="headerlink" title="五、Stream APi"></a>五、Stream APi</h2><h4 id="1-集合处理数据的弊端"><a href="#1-集合处理数据的弊端" class="headerlink" title="1.集合处理数据的弊端"></a>1.集合处理数据的弊端</h4><p>当我们需要对集合中的元素进行操作的时候除了必须的添加删除获取外 </p>
<p>最典型的操作就是集合遍历</p>
<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><pre><code>    list.forEach(new Consumer&lt;String&gt;() &#123;
            @Override
            public void accept(String a) &#123;
                System.out.println(a);
            &#125;
        &#125;);
        list.forEach(s -&gt; &#123;
            System.out.println(s);
        &#125;);

        list.forEach(System.out::println);
</code></pre>
<p>foreach里面的对象类型必须跟方法引用得参数保持一致</p>
<pre><code>// 定义一个List集合
        List&lt;String&gt; list = Arrays.asList(&quot;张三&quot;,&quot;张三丰&quot;,&quot;成龙&quot;,&quot;周星驰&quot;);
        // 1.获取所有 姓张的信息
        // 2.获取名称长度为3的用户
        // 3. 输出所有的用户信息
        list.stream()
                .filter(s-&gt;s.startsWith(&quot;张&quot;))
                .filter(s-&gt;s.length() == 3)
                .forEach(s-&gt;&#123;
                    System.out.println(s);
                &#125;);
        System.out.println(&quot;----------&quot;);
        list.stream()
                .filter(s-&gt;s.startsWith(&quot;张&quot;))
                .filter(s-&gt;s.length() == 3)
                .forEach(System.out::println);
        
</code></pre>
<h3 id="Stream流的获取方式"><a href="#Stream流的获取方式" class="headerlink" title="Stream流的获取方式"></a>Stream流的获取方式</h3><h4 id="3-1-根据Collection获取"><a href="#3-1-根据Collection获取" class="headerlink" title="3.1 根据Collection获取"></a>3.1 根据Collection获取</h4><p> <strong>java.util.Collection接口中假如default方法 Stream 也就是Collection</strong></p>
<p><strong>接口下的所有实现都可以通过stream方法来获取Stream流</strong></p>
<pre><code>  public static void main(String[] args) &#123;
        Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();
        Stream&lt;String&gt; stream = map.keySet().stream(); // key
        Stream&lt;Object&gt; stream1 = map.values().stream(); // value
        Stream&lt;Map.Entry&lt;String, Object&gt;&gt; stream2 = map.entrySet().stream(); // entry
    &#125;
</code></pre>
<p>Map接口没有实现collection接口如何获取？</p>
<p> 通过 Map key集合 和value集合来获取</p>
<pre><code>    Stream&lt;String&gt; stream = map.keySet().stream(); // key
    Stream&lt;Object&gt; stream1 = map.values().stream(); // value
</code></pre>
<h3 id="3-2-Stream的of方法"><a href="#3-2-Stream的of方法" class="headerlink" title="3.2 Stream的of方法"></a><strong>3.2 Stream的of方法</strong></h3><p><strong>在实际开发中我们不可避免的还是会操作到数组中的数据 由于数组对象 中不可能添加默认方法 所有的Stream接口中提供了静态方法 of</strong></p>
<pre><code>   Stream&lt;String&gt; a1 = Stream.of(&quot;a1&quot;, &quot;a2&quot;, &quot;a3&quot;);
        String[] arr1 = &#123;&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;&#125;;
        Stream&lt;String&gt; arr11 = Stream.of(arr1);
        Integer[] arr2 = &#123;1,2,3,4&#125;;
        Stream&lt;Integer&gt; arr21 = Stream.of(arr2);
        arr21.forEach(System.out::println);
        // 注意：基本数据类型的数组是不行的
        int[] arr3 = &#123;1,2,3,4&#125;;
        Stream.of(arr3).forEach(System.out::println);
       
</code></pre>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">方法作用</th>
<th align="center">返回值类型</th>
<th align="center">方法种类</th>
</tr>
</thead>
<tbody><tr>
<td align="center">count</td>
<td align="center">统计个数</td>
<td align="center">long</td>
<td align="center">终结</td>
</tr>
<tr>
<td align="center">forEach</td>
<td align="center">逐一遍历</td>
<td align="center">void</td>
<td align="center">终结</td>
</tr>
<tr>
<td align="center">filter</td>
<td align="center">过滤</td>
<td align="center">Stream</td>
<td align="center">函数拼接</td>
</tr>
<tr>
<td align="center">limit</td>
<td align="center">取用前几个</td>
<td align="center">Stream</td>
<td align="center">函数拼接</td>
</tr>
<tr>
<td align="center">skip</td>
<td align="center">跳过前几个</td>
<td align="center">Stream</td>
<td align="center">函数拼接</td>
</tr>
<tr>
<td align="center">map</td>
<td align="center">映射</td>
<td align="center">Stream</td>
<td align="center">函数拼接</td>
</tr>
<tr>
<td align="center">concat</td>
<td align="center">组合 连接</td>
<td align="center">Stream</td>
<td align="center">函数拼接</td>
</tr>
<tr>
<td align="center">Match</td>
<td align="center">匹配集合中元素是否符合</td>
<td align="center">Boolean</td>
<td align="center">匹配</td>
</tr>
</tbody></table>
<p><strong>终结方法</strong>：返回值类型不再是Stream类型的方法不再支持链式调用</p>
<p>count 和forEach</p>
<p><strong>非终结方法</strong>： 返回值类型仍然是Stream类型的方法 支持链式调用</p>
<p>除了终结方法则为非终结</p>
<p><strong>Stream流注意事项）</strong></p>
<p>1.Stream流只能操作一次</p>
<p>2.Stream流方法返回最新的流</p>
<p>3.Stream不调用终结方法中间的操作不会执行</p>
<h4 id="3-11-ForEach"><a href="#3-11-ForEach" class="headerlink" title="3.11 ForEach"></a>3.11 ForEach</h4><pre><code> public static void main(String[] args) &#123;
        Stream.of(&quot;a1&quot;, &quot;a2&quot;, &quot;a3&quot;).forEach(System.out::println);;
    &#125;
</code></pre>
<h4 id="3-12-Count"><a href="#3-12-Count" class="headerlink" title="3.12 Count"></a>3.12 Count</h4><pre><code>   public static void main(String[] args) &#123;
        long count = Stream.of(&quot;a1&quot;, &quot;a2&quot;, &quot;a3&quot;).count();
        System.out.println(count);
    &#125;
</code></pre>
<h4 id="3-13Filter"><a href="#3-13Filter" class="headerlink" title="3.13Filter"></a>3.13Filter</h4><h4 id="3-14Limit"><a href="#3-14Limit" class="headerlink" title="3.14Limit"></a>3.14Limit</h4><h4 id="3-15Skip"><a href="#3-15Skip" class="headerlink" title="3.15Skip"></a>3.15Skip</h4><h4 id="3-16Map方法"><a href="#3-16Map方法" class="headerlink" title="3.16Map方法"></a>3.16Map方法</h4><h4 id="3-17Sorted"><a href="#3-17Sorted" class="headerlink" title="3.17Sorted"></a>3.17Sorted</h4><h4 id="3-18Distinct"><a href="#3-18Distinct" class="headerlink" title="3.18Distinct"></a>3.18Distinct</h4><h4 id="3-19-match"><a href="#3-19-match" class="headerlink" title="3.19 match"></a>3.19 match</h4><p>终结方法</p>
<p><strong>allMatch(s -&gt; s &gt; 0) 所有元素都大于0</strong><br><strong>anyMatch(s -&gt; s &gt;0 ）集合中任意元素大于0</strong></p>
<pre><code>    public static void main(String[] args) &#123;
        boolean b = Stream.of(&quot;1&quot;, &quot;3&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;1&quot;, &quot;7&quot;)
                .map(Integer::parseInt)
                //.allMatch(s -&gt; s &gt; 0)
                //.anyMatch(s -&gt; s &gt;4) 
                .noneMatch(s -&gt; s &gt; 4)
                ;
        System.out.println(b);
    &#125;
</code></pre>
<h4 id="3-20Find"><a href="#3-20Find" class="headerlink" title="3.20Find"></a>3.20Find</h4><p>找到符合条件的数据</p>
<pre><code class="java">   public static void main(String[] args) &#123;
        Optional&lt;String&gt; first = Stream.of(&quot;1&quot;, &quot;3&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;1&quot;, &quot;7&quot;).findFirst();
        System.out.println(first.get());

        Optional&lt;String&gt; any = Stream.of(&quot;1&quot;, &quot;3&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;1&quot;, &quot;7&quot;).findAny();
        System.out.println(any.get());
    &#125;
</code></pre>
<p><strong>Optional<String> any &#x3D; Stream.<em>of</em>(“10”, “3”, “3”, “4”, “5”, “0”, “7”).findAny();</String></strong><br><strong>System.<em>out</em>.println(any.get());</strong></p>
<p><strong>我测试时一直返回第一个元素</strong></p>
<h4 id="3-21Max和Min"><a href="#3-21Max和Min" class="headerlink" title="3.21Max和Min"></a>3.21Max和Min</h4><pre><code class="java">     Optional&lt;Integer&gt; max = Stream.of(&quot;1&quot;, &quot;3&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;1&quot;, &quot;7&quot;)
                .map(Integer::parseInt)
                .max((o1,o2)-&gt;o1-o2);
        System.out.println(max.get());

        Optional&lt;Integer&gt; min = Stream.of(&quot;1&quot;, &quot;3&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;1&quot;, &quot;7&quot;)
                .map(Integer::parseInt)
                .min((o1,o2)-&gt;o1-o2);
        System.out.println(min.get());
</code></pre>
<h4 id="3-22Reduce方法"><a href="#3-22Reduce方法" class="headerlink" title="3.22Reduce方法"></a>3.22Reduce方法</h4><pre><code class="java">   public static void main(String[] args) &#123;
        Integer sum = Stream.of(4, 5, 3, 9)
                .reduce(0,(x,y)-&gt;&#123;
                    return x + y;
                &#125;);
                // identity默认值
                // 第一次的时候会将默认值赋值给x
                //操作时 x=x+y   y=collection（index）

//        reduce(0,(x,y)设置为0时就是 return的数据会赋值给x 
//                集合元素数据赋值给y
        Integer max = Stream.of(4, 5, 3, 9)
                .reduce(0,(x,y)-&gt;&#123;
                    return x&gt;y?x:y;
                &#125;);
        System.out.println(sum);
        System.out.println(max);
    &#125;
</code></pre>
<h4 id="3-23-map和reduce组合"><a href="#3-23-map和reduce组合" class="headerlink" title="3.23 map和reduce组合"></a>3.23 map和reduce组合</h4><pre><code class="java">     // 1.求出所有年龄的总和
        Integer sumAge = Stream.of(
                new Person(&quot;张三&quot;, 18)
                , new Person(&quot;李四&quot;, 22)
                , new Person(&quot;张三&quot;, 13)
                , new Person(&quot;王五&quot;, 15)
                , new Person(&quot;张三&quot;, 19)
        ).map(Person::getAge) // 实现数据类型的转换
                .reduce(0, Integer::sum);
        System.out.println(sumAge);

        // 2.求出所有年龄中的最大值
        Integer maxAge = Stream.of(
                new Person(&quot;张三&quot;, 18)
                , new Person(&quot;李四&quot;, 22)
                , new Person(&quot;张三&quot;, 13)
                , new Person(&quot;王五&quot;, 15)
                , new Person(&quot;张三&quot;, 19)  
        ).map(Person::getAge) // 实现数据类型的转换，符合reduce对数据的要求
                .reduce(0, Math::max); // reduce实现数据的处理
        System.out.println(maxAge);
        // 3.统计 字符 a 出现的次数
        Integer count = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;a&quot;, &quot;c&quot;, &quot;a&quot;)
                .map(ch -&gt; &quot;a&quot;.equals(ch) ? 1 : 0)
                .reduce(0, Integer::sum);
        System.out.println(count);
    &#125;
</code></pre>
<h4 id="3-24MapToInt"><a href="#3-24MapToInt" class="headerlink" title="3.24MapToInt"></a>3.24MapToInt</h4><p>主要是将集合元素转换成int</p>
<pre><code>       // Integer占用的内存比int多很多，在Stream流操作中会自动装修和拆箱操作
        Integer arr[] = &#123;1,2,3,5,6,8&#125;;
        Stream.of(arr)
                .filter(i-&gt;i&gt;0)
                .forEach(System.out::println);
        System.out.println(&quot;---------&quot;);
        // 为了提高程序代码的效率，我们可以先将流中Integer数据转换为int数据，然后再操作
        IntStream intStream = Stream.of(arr)
                .mapToInt(Integer::intValue);
        intStream.filter(i-&gt;i&gt;3)
                .forEach(System.out::println);
    &#125;
</code></pre>
<h4 id="3-25Concat"><a href="#3-25Concat" class="headerlink" title="3.25Concat"></a>3.25Concat</h4><pre><code>        Stream&lt;String&gt; stream1 = Stream.of(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);
        Stream&lt;String&gt; stream2 = Stream.of(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;);
        // 通过concat方法将两个流合并为一个新的流
        Stream.concat(stream1,stream2).forEach(System.out::println);
</code></pre>
<h2 id="2-流的常用创建方式"><a href="#2-流的常用创建方式" class="headerlink" title="2. 流的常用创建方式"></a>2. 流的常用创建方式</h2><pre><code class="java">/**
 * stream，获取各种集合的stream流
 */
@Test
public void testCollectionStream()&#123;
    //List集合  
    List&lt;String&gt; stringList = new ArrayList&lt;&gt;();
    //Set集合
    Set&lt;String&gt; stringSet = new HashSet&lt;&gt;();
    //Map集合
    Map&lt;String,Object&gt; stringObjectMap = new HashMap&lt;&gt;();
    //数组
    String[] stringArray = &#123;&quot;张三三&quot;,&quot;李四&quot;,&quot;王五&quot;,&quot;王五&quot;,&quot;赵八&quot;,&#125;;

    //通过list获取stream流
    Stream&lt;String&gt; streamList = stringList.stream();
    //通过set获取stream流
    Stream&lt;String&gt; streamSet = stringSet.stream();
    //通过map获取stream流
    Stream&lt;String&gt; streamMap = stringObjectMap.keySet().stream();
    //通过array获取stream流
    Stream&lt;String&gt; streamArray1 = Stream.of(stringArray);
&#125;
</code></pre>
<h2 id="3-构造流的几种常见方法"><a href="#3-构造流的几种常见方法" class="headerlink" title="3. 构造流的几种常见方法"></a>3. 构造流的几种常见方法</h2><pre><code class="java">@Test
public void testCollectionStream()&#123;
   // 1. Individual values
  Stream stream = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);
  
  // 2. Arrays
  String[] strArray = new String[]&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;;
  stream = Stream.of(strArray);
  stream = Arrays.stream(strArray);
  
  // 3. Collections
  List&lt;String&gt; list = Arrays.asList(strArray);
  stream = list.stream();
  
&#125;
</code></pre>
<h1 id="五-Stream在代码中的使用方式"><a href="#五-Stream在代码中的使用方式" class="headerlink" title="五. Stream在代码中的使用方式"></a>五. Stream在代码中的使用方式</h1><p>关于Stream的常见操作方式，主要分为两大类： 中间操作和终止操作 ，接下来就通过这两大分类，讲解下具体的语法用法。</p>
<h2 id="1-流的中间操作"><a href="#1-流的中间操作" class="headerlink" title="1. 流的中间操作"></a>1. 流的中间操作</h2><h3 id="1-1-筛选过滤"><a href="#1-1-筛选过滤" class="headerlink" title="1.1 筛选过滤"></a>1.1 筛选过滤</h3><ul>
<li><p>filter：过滤流中的某些元素</p>
<pre><code class="java">   /**
     * filter 方法 ， 返回符合过滤条件的值
     */
    @Test
    public void testFilter() &#123;
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add(&quot;张三三&quot;);
        list.add(&quot;李四&quot;);
        list.add(&quot;王五&quot;);
        list.add(&quot;孙七&quot;);
        list.add(&quot;赵八&quot;);
        list.stream().filter(e -&gt; e.contains(&quot;张&quot;)).forEach(System.out::println);
    &#125;
</code></pre>
<p>或</p>
<ul>
<li>filter多个过滤筛选条件</li>
</ul>
<pre><code class="java">   /**
  * list集合stream流式操作
  */
 @Test
 public void testStreamList() &#123;
     List&lt;String&gt; list = new ArrayList&lt;&gt;();
     list.add(&quot;张三三&quot;);
     list.add(&quot;李四&quot;);
     list.add(&quot;王五&quot;);
     list.add(&quot;孙七&quot;);
     list.add(&quot;赵八&quot;);
     list.stream().filter(e -&gt; e.startsWith(&quot;张&quot;)) //过滤所有姓张的人
             .filter(e -&gt; e.length() == 3) //过滤所有姓名是3个字的人
             .forEach(System.out::println); //遍历打印,System.out::println表明System.out调用println打印方法
 &#125;
</code></pre>
</li>
<li><p>limit(n)：获取前n个元素</p>
<pre><code class="java"> /**
     * limit 方法 ，返回前n个元素数据值组成的Stream。
     */
    @Test
    public void testLimit() &#123;
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add(&quot;张三三&quot;);
        list.add(&quot;李四&quot;);
        list.add(&quot;王五&quot;);
        list.add(&quot;孙七&quot;);
        list.add(&quot;赵八&quot;);
        list.add(&quot;王二麻子&quot;);
        list.stream().limit(3).forEach(System.out::println); //取前3个
    &#125;
</code></pre>
</li>
<li><p>skip(n)：跳过n元素，配合limit(n)可实现分页</p>
<pre><code class="java"> /**
     * skip方法 ，跳过前n个元素的中间流操作，返回剩下的值。
     */
    @Test
    public void testSkip() &#123;
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add(&quot;张三三&quot;);
        list.add(&quot;李四&quot;);
        list.add(&quot;王五&quot;);
        list.add(&quot;孙七&quot;);
        list.add(&quot;赵八&quot;);
        list.add(&quot;王二麻子&quot;);
        //list.stream().skip(3).forEach(System.out::println); //跳过前3个
        list.stream().skip(3).limit(2).forEach(System.out::println); //skip+limit实现分页
    &#125;
</code></pre>
</li>
<li><p>distinct：通过流中元素的 hashCode() 和 equals() 去除重复元素</p>
<pre><code class="java"> /**
     * distinct， 返回去重的Stream
     */
    @Test
    public void testDistinct() &#123;
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add(&quot;张三三&quot;);
        list.add(&quot;李四&quot;);
        list.add(&quot;李四&quot;);
        list.add(&quot;王五&quot;);
        list.add(&quot;王五&quot;);
        list.add(&quot;孙七&quot;);
        list.add(&quot;赵八&quot;);
        list.add(&quot;王二麻子&quot;);
        list.stream().distinct().collect(Collectors.toList()).forEach(System.out::println);
    &#125;
</code></pre>
</li>
</ul>
<h3 id="1-2-排序"><a href="#1-2-排序" class="headerlink" title="1.2 排序"></a>1.2 排序</h3><ul>
<li><p>sorted()：自然排序，流中元素需实现Comparable接口</p>
<pre><code class="java"> /**
     * sorted: 返回一个排序的Stream
     */
    @Test
    public void testSorted() &#123;
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add(&quot;张三三&quot;);
        list.add(&quot;李四&quot;);
        list.add(&quot;李四&quot;);
        list.add(&quot;王五&quot;);
        list.add(&quot;王五&quot;);
        list.add(&quot;孙七&quot;);
        list.add(&quot;赵八&quot;);
        list.add(&quot;王二麻子&quot;);
        list.stream().distinct().sorted().collect(Collectors.toList()).forEach(System.out::println);
    &#125;
</code></pre>
</li>
<li><p>sorted(Comparator com)：定制排序，自定义Comparator排序器</p>
</li>
</ul>
<h3 id="1-3-映射"><a href="#1-3-映射" class="headerlink" title="1.3 映射"></a>1.3 映射</h3><ul>
<li>map：接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。</li>
</ul>
<pre><code class="java">/**
    * 遍历map集合，截取substring(2)开始的值
    */
   @Test
   public void testMap() &#123;
       List&lt;String&gt; list = new ArrayList&lt;&gt;();
       list.add(&quot;张三三&quot;);
       list.add(&quot;李四&quot;);
       list.add(&quot;王五&quot;);
       list.add(&quot;孙七&quot;);
       list.add(&quot;赵八&quot;);
       list.add(&quot;王二麻子&quot;);
       Stream&lt;String&gt; stream = list.stream().map(e -&gt; e.substring(2));
       stream.forEach(System.out::println);
   &#125;
</code></pre>
<ul>
<li><p>forEach：ForEach流式遍历集合</p>
<pre><code class="java">  /**
     * forEach， ForEach流式遍历list集合
     */
    @Test
    public void testForEach() &#123;
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add(&quot;张三三&quot;);
        list.add(&quot;李四&quot;);
        list.add(&quot;王五&quot;);
        list.add(&quot;孙七&quot;);
        list.add(&quot;赵八&quot;);
        list.stream().forEach(System.out::println);
    &#125;
</code></pre>
</li>
</ul>
<h2 id="2-流的终止操作"><a href="#2-流的终止操作" class="headerlink" title="2. 流的终止操作"></a>2. 流的终止操作</h2><h3 id="2-1-匹配、聚合操作"><a href="#2-1-匹配、聚合操作" class="headerlink" title="2.1 匹配、聚合操作"></a><strong>2.1 匹配、聚合操作</strong></h3><ul>
<li><p>allMatch：接收一个 Predicate 函数，当流中每个元素都符合该断言时才返回true，否则返回false</p>
<pre><code class="java"> /**
     * allMatch：接收一个 Predicate 函数，当流中每个元素都符合该断言时才返回true，否则返回false
     */
    @Test
    public void testAllMatch() &#123;
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add(&quot;张三三&quot;);
        list.add(&quot;李四&quot;);
        list.add(&quot;李四&quot;);
        list.add(&quot;王五&quot;);
        list.add(&quot;王五&quot;);
        list.add(&quot;孙七&quot;);
        list.add(&quot;赵八&quot;);
        list.add(&quot;王二麻子&quot;);
        boolean b = list.stream()
                .allMatch(e -&gt; list.size() &gt; 8);
        System.out.println(&quot;b = &quot; + b);
    &#125;
</code></pre>
</li>
<li><p>noneMatch：接收一个 Predicate 函数，当流中每个元素都不符合该断言时才返回true，否则返回false</p>
<pre><code class="java">    /**
     * noneMatch: 接收一个 Predicate 函数，当流中每个元素都不符合该断言时才返回true，否则返回false
     */
    @Test
    public void testNoneMatch() &#123;
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add(&quot;张三三&quot;);
        list.add(&quot;李四&quot;);
        list.add(&quot;李四&quot;);
        list.add(&quot;王五&quot;);
        list.add(&quot;王五&quot;);
        list.add(&quot;孙七&quot;);
        list.add(&quot;赵八&quot;);
        list.add(&quot;王二麻子&quot;);
        boolean b = list.stream().noneMatch(e-&gt;e.equals(&quot;张三&quot;));
        System.out.println(&quot;b = &quot; + b);
    &#125;
</code></pre>
</li>
<li><p>anyMatch：接收一个 Predicate 函数，只要流中有一个元素满足该断言则返回true，否则返回false</p>
<pre><code class="java">/**
     * anyMatch：接收一个 Predicate 函数，只要流中有一个元素满足该断言则返回true，否则返回false
     */
    @Test
    public void testAnyMatch() &#123;
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add(&quot;张三三&quot;);
        list.add(&quot;李四&quot;);
        list.add(&quot;李四&quot;);
        list.add(&quot;王五&quot;);
        list.add(&quot;王五&quot;);
        list.add(&quot;孙七&quot;);
        list.add(&quot;赵八&quot;);
        list.add(&quot;王二麻子&quot;);
        boolean b = list.stream().anyMatch(e -&gt; e.equals(&quot;王二麻子&quot;));
        System.out.println(&quot;b = &quot; + b);
    &#125;
</code></pre>
</li>
<li><p>findFirst：返回流中第一个元素</p>
<pre><code class="java"> /**
     * findFirst：返回流中第一个元素
     */
    @Test
    public void testFindFirsth() &#123;
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add(&quot;张三三&quot;);
        list.add(&quot;李四&quot;);
        list.add(&quot;李四&quot;);
        list.add(&quot;王五&quot;);
        list.add(&quot;王五&quot;);
        list.add(&quot;孙七&quot;);
        list.add(&quot;赵八&quot;);
        list.add(&quot;王二麻子&quot;);
        Optional&lt;String&gt; first = list.stream().findFirst();
        System.out.println(&quot;first = &quot; + first.get());
    &#125;
</code></pre>
</li>
<li><p>findAny：返回流中的任意元素</p>
<pre><code class="java">    /**
     * findAny：返回流中第一个元素
     */
    @Test
    public void testFindAny() &#123;
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add(&quot;张三三&quot;);
        list.add(&quot;李四&quot;);
        list.add(&quot;李四&quot;);
        list.add(&quot;王五&quot;);
        list.add(&quot;王五&quot;);
        list.add(&quot;孙七&quot;);
        list.add(&quot;赵八&quot;);
        list.add(&quot;王二麻子&quot;);
        Optional&lt;String&gt; any = list.stream().findAny();
        System.out.println(&quot;any = &quot; + any.get());
    &#125;
</code></pre>
</li>
<li><p>count：返回流中元素的总个数</p>
<pre><code class="java"> /**
     * count，获取List集合的长度
     */
    @Test
    public void testCount() &#123;
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add(&quot;张三三&quot;);
        list.add(&quot;李四&quot;);
        list.add(&quot;王五&quot;);
        list.add(&quot;孙七&quot;);
        list.add(&quot;赵八&quot;);
        list.add(&quot;王二麻子&quot;);
        long count = list.stream().count();
        System.out.println(&quot;count = &quot; + count);
        int size = list.size();
        System.out.println(&quot;size = &quot; + size);
    &#125;
</code></pre>
</li>
<li><p>max：返回流中元素最大值</p>
<pre><code class="java">/**
     * max：返回流中元素最大值
     */
    @Test
    public void testMax() &#123;
        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
        list.add(11);
        list.add(22);
        list.add(33);
        list.add(44);
        list.add(55);
        list.add(66);
        list.add(77);
        list.add(88);
        Integer integer = list.stream().max(Integer::compareTo).get();
        System.out.println(&quot;integer = &quot; + integer);
    &#125;
</code></pre>
</li>
<li><p>min：返回流中元素最小值</p>
<pre><code class="java">/**
 * min：返回流中元素最小值
 */
@Test
public void testMin() &#123;
    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
    list.add(11);
    list.add(22);
    list.add(33);
    list.add(44);
    list.add(55);
    list.add(66);
    list.add(77);
    list.add(88);
    Integer integer = list.stream().min(Integer::compareTo).get();
    System.out.println(&quot;integer = &quot; + integer);
    list.stream().limit(1).limit(2).distinct().skip(3).filter(f -&gt; f.equals(55)).forEach(System.out::println);
&#125;
</code></pre>
</li>
<li><p>collect：聚合操作，封装目标数据，将流转换为其他形式接收，List、Map、Set等</p>
</li>
</ul>
<pre><code class="java">   /**
     * collect，将流转化为List集合，然后遍历集合
     */
    @Test
    public void testCollect() &#123;
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add(&quot;张三三&quot;);
        list.add(&quot;李四&quot;);
        list.add(&quot;王五&quot;);
        list.add(&quot;孙七&quot;);
        list.add(&quot;赵八&quot;);
        list.add(&quot;王二麻子&quot;);
        List&lt;String&gt; collect = list.stream().skip(3).limit(2).collect(Collectors.toList());
        collect.forEach(System.out::println);
    &#125;
</code></pre>
<ul>
<li>reduce：聚合操作，用来做统计，将流中元素反复结合起来统计计算，得到一个值</li>
</ul>
<pre><code class="java">    /**
     * reduce： 聚合操作，用来做统计，将流中元素反复结合起来统计计算，得到一个值.
     */
    @Test
    public void testReduce() &#123;
        //1.求集合元素只和
        Stream&lt;Integer&gt; stream = Arrays.stream(new Integer[]&#123;1, 2, 3, 4, 5, 6, 7, 8&#125;);
        Integer result = stream.reduce(0, Integer::sum);
        System.out.println(result);

        //2.求和
        Stream&lt;Integer&gt; stream1 = Arrays.stream(new Integer[]&#123;1, 2, 3, 4, 5, 6, 7&#125;);
        stream1.reduce((i, j) -&gt; i + j).ifPresent(System.out::println);

        //3.求最大值
        Stream&lt;Integer&gt; stream2 = Arrays.stream(new Integer[]&#123;1, 2, 3, 4, 5, 6, 7&#125;);
        stream2.reduce(Integer::max).ifPresent(System.out::println);

        //4.求最小值
        Stream&lt;Integer&gt; stream3 = Arrays.stream(new Integer[]&#123;1, 2, 3, 4, 5, 6, 7&#125;);
        stream3.reduce(Integer::min).ifPresent(System.out::println);

        //5.做逻辑
        Stream&lt;Integer&gt; stream4 = Arrays.stream(new Integer[]&#123;1, 2, 3, 4, 5, 6, 7&#125;);
        stream4.reduce((i, j) -&gt; i &gt; j ? j : i).ifPresent(System.out::println);

        //6.求逻辑求乘机
        Stream&lt;Integer&gt; stream5 = Arrays.stream(new Integer[]&#123;1, 2, 3, 4, 5, 6, 7&#125;);
        int result2 = stream5.filter(i -&gt; i % 2 == 0).reduce(1, (i, j) -&gt; i * j);
        Optional.of(result2).ifPresent(System.out::println);
    &#125;
</code></pre>
<h3 id="2-2-Collector-工具库：Collectors"><a href="#2-2-Collector-工具库：Collectors" class="headerlink" title="2.2 Collector 工具库：Collectors"></a>2.2 Collector 工具库：Collectors</h3><ul>
<li><p><strong>Collectors</strong></p>
<pre><code class="java">Student s1 = new Student(&quot;aa&quot;, 10,1);
Student s2 = new Student(&quot;bb&quot;, 20,2);
Student s3 = new Student(&quot;cc&quot;, 10,3);
List&lt;Student&gt; list = Arrays.asList(s1, s2, s3);
  
//stream转成list
List&lt;Integer&gt; ageList = list.stream().map(Student::getAge).collect(Collectors.toList()); // [10, 20, 10]
  
//stream转成set
Set&lt;Integer&gt; ageSet = list.stream().map(Student::getAge).collect(Collectors.toSet()); // [20, 10]
  
//stream转成map,注:key不能相同，否则报错
Map&lt;String, Integer&gt; studentMap = list.stream().collect(Collectors.toMap(Student::getName, Student::getAge)); // &#123;cc=10, bb=20, aa=10&#125;
  
//字符串分隔符连接
String joinName = list.stream().map(Student::getName).collect(Collectors.joining(&quot;,&quot;, &quot;(&quot;, &quot;)&quot;)); // (aa,bb,cc)
  
//聚合操作
//1.学生总数
Long count = list.stream().collect(Collectors.counting()); // 3
//2.最大年龄 (最小的minBy同理)
Integer maxAge = list.stream().map(Student::getAge).collect(Collectors.maxBy(Integer::compare)).get(); // 20
//3.所有人的年龄
Integer sumAge = list.stream().collect(Collectors.summingInt(Student::getAge)); // 40
//4.平均年龄
Double averageAge = list.stream().collect(Collectors.averagingDouble(Student::getAge)); // 13.333333333333334
// 带上以上所有方法
DoubleSummaryStatistics statistics = list.stream().collect(Collectors.summarizingDouble(Student::getAge));
System.out.println(&quot;count:&quot; + statistics.getCount() + &quot;,max:&quot; + statistics.getMax() + &quot;,sum:&quot; + statistics.getSum() + &quot;,average:&quot; + statistics.getAverage());
  
//分组
Map&lt;Integer, List&lt;Student&gt;&gt; ageMap = list.stream().collect(Collectors.groupingBy(Student::getAge));
//多重分组,先根据类型分再根据年龄分
Map&lt;Integer, Map&lt;Integer, List&lt;Student&gt;&gt;&gt; typeAgeMap = list.stream().collect(Collectors.groupingBy(Student::getType, Collectors.groupingBy(Student::getAge)));
  
//分区
//分成两部分，一部分大于10岁，一部分小于等于10岁
Map&lt;Boolean, List&lt;Student&gt;&gt; partMap = list.stream().collect(Collectors.partitioningBy(v -&gt; v.getAge() &gt; 10));
  
//规约
Integer allAge = list.stream().map(Student::getAge).collect(Collectors.reducing(Integer::sum)).get(); //40　　
</code></pre>
</li>
</ul>
<h3 id="综合案例"><a href="#综合案例" class="headerlink" title="综合案例"></a>综合案例</h3><p>定义两个集合，然后在集合中存储多个用户名称 完成一下操作</p>
<ol>
<li>第一个队伍只保留姓名长度为3的成员</li>
<li>第一个队伍删选后只要前三个人</li>
<li>第二个队伍只要姓张的成员</li>
<li>第二个队伍筛选之后只要后2个人</li>
<li>将两给i五合并为一个队伍</li>
<li>根据姓名创建person对象</li>
<li>打印整个队伍的person值</li>
</ol>
<pre><code>//        List&lt;String&gt; list1 = new ArrayList&lt;&gt;();
//        List&lt;String&gt; list2 = new ArrayList&lt;&gt;();
//        list1.add(&quot;张三&quot;);
//        list1.add(&quot;李四&quot;);
//        list1.add(&quot;王五&quot;);
//        list1.add(&quot;孙吧1&quot;);
//        list1.add(&quot;钱七2&quot;);
//        list1.add(&quot;赵六&quot;);
//
//        list2.add(&quot;张三l2&quot;);
//        list2.add(&quot;李l2&quot;);
//        list2.add(&quot;王五l2&quot;);
//        list2.add(&quot;孙吧1l2&quot;);
//        list2.add(&quot;钱2l2&quot;);
//        list2.add(&quot;赵l2&quot;);
        List&lt;String&gt; list1 = Arrays.asList(&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;, &quot;孙吧1&quot;, &quot;钱七2&quot;, &quot;赵六&quot;);
        List&lt;String&gt; list2 = Arrays.asList(&quot;李2&quot;, &quot;王五2&quot;, &quot;孙吧2&quot;, &quot;钱七22&quot;, &quot;张2&quot;);
        Stream&lt;String&gt; limit3andsize3 = list1.stream().filter(s -&gt; &#123;
            return s.length() == 3;
        &#125;).limit(3);
        Stream&lt;String&gt; limit2 = list2.stream().filter(s -&gt; &#123;
                    return s.startsWith(&quot;张&quot;);
                &#125;
        ).skip(list2.size()-2);

        Stream&lt;Person&gt; personStream = Stream.concat(limit3andsize3, limit2).map(Person::new);
        List&lt;Person&gt; collect = personStream.collect(Collectors.toList());
        collect.stream().forEach(System.out::println);
    &#125;
</code></pre>
<h3 id="三-结果收集"><a href="#三-结果收集" class="headerlink" title="三 结果收集"></a>三 结果收集</h3><p>结果收集到集合中</p>
<pre><code>  @Test
    public void test01()&#123;
        // Stream&lt;String&gt; stream = Stream.of(&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;);
        List&lt;String&gt; list = Stream.of(&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;,&quot;aa&quot;)
                .collect(Collectors.toList());
        System.out.println(list);
        // 收集到 Set集合中
        Set&lt;String&gt; set = Stream.of(&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;, &quot;aa&quot;)
                .collect(Collectors.toSet());
        System.out.println(set);
        // 如果需要获取的类型为具体的实现，比如：ArrayList HashSet

        ArrayList&lt;String&gt; arrayList = Stream.of(&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;, &quot;aa&quot;)
                //.collect(Collectors.toCollection(() -&gt; new ArrayList&lt;&gt;()));
                .collect(Collectors.toCollection(ArrayList::new));
        System.out.println(arrayList);
        HashSet&lt;String&gt; hashSet = Stream.of(&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;, &quot;aa&quot;)
                .collect(Collectors.toCollection(HashSet::new));
        System.out.println(hashSet);
    &#125;
</code></pre>
<p>结果收集到数组中</p>
<pre><code>   @Test
    public void test02()&#123;
        Object[] objects = Stream.of(&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;, &quot;aa&quot;)
                .toArray(); // 返回的数组中的元素是 Object类型
        System.out.println(Arrays.toString(objects));
        // 如果我们需要指定返回的数组中的元素类型
        String[] strings = Stream.of(&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;, &quot;aa&quot;)
                .toArray(String[]::new);
        System.out.println(Arrays.toString(strings));

    &#125;
</code></pre>
<h3 id="5-3结果集聚合计算"><a href="#5-3结果集聚合计算" class="headerlink" title="5.3结果集聚合计算"></a>5.3结果集聚合计算</h3><p>当我们使用Stream流处理数据后，可以像数据库的聚合函数一样对某个字段进行操作</p>
<p>如 最大值 最小值 </p>
<pre><code class="java">   /**
     * Stream流中数据的聚合计算
     */
    @Test
    public void test03()&#123;
        // 获取年龄的最大值
        Optional&lt;Person&gt; maxAge = Stream.of(
                new Person(&quot;张三&quot;, 18)
                , new Person(&quot;李四&quot;, 22)
                , new Person(&quot;张三&quot;, 13)
                , new Person(&quot;王五&quot;, 15)
                , new Person(&quot;张三&quot;, 19)
        ).collect(Collectors.maxBy((p1, p2) -&gt; p1.getAge() - p2.getAge()));
        System.out.println(&quot;最大年龄：&quot; + maxAge.get());
        // 获取年龄的最小值
        Optional&lt;Person&gt; minAge = Stream.of(
                new Person(&quot;张三&quot;, 18)
                , new Person(&quot;李四&quot;, 22)
                , new Person(&quot;张三&quot;, 13)
                , new Person(&quot;王五&quot;, 15)
                , new Person(&quot;张三&quot;, 19)
        ).collect(Collectors.minBy((p1, p2) -&gt; p1.getAge() - p2.getAge()));
        System.out.println(&quot;最新年龄:&quot; + minAge.get());
        // 求所有人的年龄之和
        Integer sumAge = Stream.of(
                new Person(&quot;张三&quot;, 18)
                , new Person(&quot;李四&quot;, 22)
                , new Person(&quot;张三&quot;, 13)
                , new Person(&quot;王五&quot;, 15)
                , new Person(&quot;张三&quot;, 19)
        )
                //.collect(Collectors.summingInt(s -&gt; s.getAge()))
                .collect(Collectors.summingInt(Person::getAge))
                ;
        System.out.println(&quot;年龄总和：&quot; + sumAge);
        // 年龄的平均值
        Double avgAge = Stream.of(
                new Person(&quot;张三&quot;, 18)
                , new Person(&quot;李四&quot;, 22)
                , new Person(&quot;张三&quot;, 13)
                , new Person(&quot;王五&quot;, 15)
                , new Person(&quot;张三&quot;, 19)
        ).collect(Collectors.averagingInt(Person::getAge));
        System.out.println(&quot;年龄的平均值：&quot; + avgAge);
        // 统计数量
        Long count = Stream.of(
                new Person(&quot;张三&quot;, 18)
                , new Person(&quot;李四&quot;, 22)
                , new Person(&quot;张三&quot;, 13)
                , new Person(&quot;王五&quot;, 15)
                , new Person(&quot;张三&quot;, 19)
        ).filter(p-&gt;p.getAge() &gt; 18)
                .collect(Collectors.counting());
        System.out.println(&quot;满足条件的记录数:&quot; + count);

    &#125;

    /**
     * 分组计算
     */
    @Test
    public void test04()&#123;
        // 根据账号对数据进行分组
        Map&lt;String, List&lt;Person&gt;&gt; map1 = Stream.of(
                new Person(&quot;张三&quot;, 18, 175)
                , new Person(&quot;李四&quot;, 22, 177)
                , new Person(&quot;张三&quot;, 14, 165)
                , new Person(&quot;李四&quot;, 15, 166)
                , new Person(&quot;张三&quot;, 19, 182)
        ).collect(Collectors.groupingBy(Person::getName));
        map1.forEach((k,v)-&gt; System.out.println(&quot;k=&quot; + k +&quot;\t&quot;+ &quot;v=&quot; + v));
        System.out.println(&quot;-----------&quot;);
        // 根据年龄分组 如果大于等于18 成年否则未成年
        Map&lt;String, List&lt;Person&gt;&gt; map2 = Stream.of(
                new Person(&quot;张三&quot;, 18, 175)
                , new Person(&quot;李四&quot;, 22, 177)
                , new Person(&quot;张三&quot;, 14, 165)
                , new Person(&quot;李四&quot;, 15, 166)
                , new Person(&quot;张三&quot;, 19, 182)
        ).collect(Collectors.groupingBy(p -&gt; p.getAge() &gt;= 18 ? &quot;成年&quot; : &quot;未成年&quot;));
        map2.forEach((k,v)-&gt; System.out.println(&quot;k=&quot; + k +&quot;\t&quot;+ &quot;v=&quot; + v));

    &#125;
    /**
    * 分组计算--多级分组
     */
    @Test
    public void test05()&#123;
        // 先根据name分组，然后根据age(成年和未成年)分组
        Map&lt;String,Map&lt;Object,List&lt;Person&gt;&gt;&gt; map =  Stream.of(
                new Person(&quot;张三&quot;, 18, 175)
                , new Person(&quot;李四&quot;, 22, 177)
                , new Person(&quot;张三&quot;, 14, 165)
                , new Person(&quot;李四&quot;, 15, 166)
                , new Person(&quot;张三&quot;, 19, 182)
        ).collect(Collectors.groupingBy(
                Person::getName
                ,Collectors.groupingBy(p-&gt;p.getAge()&gt;=18?&quot;成年&quot;:&quot;未成年&quot;
                )
        ));
        map.forEach((k,v)-&gt;&#123;
            System.out.println(k);
            v.forEach((k1,v1)-&gt;&#123;
                System.out.println(&quot;\t&quot;+k1 + &quot;=&quot; + v1);
            &#125;);
        &#125;);
    &#125;

    /**
     * 分区操作
     */
    @Test
    public void test06()&#123;
        Map&lt;Boolean, List&lt;Person&gt;&gt; map = Stream.of(
                new Person(&quot;张三&quot;, 18, 175)
                , new Person(&quot;李四&quot;, 22, 177)
                , new Person(&quot;张三&quot;, 14, 165)
                , new Person(&quot;李四&quot;, 15, 166)
                , new Person(&quot;张三&quot;, 19, 182)
        ).collect(Collectors.partitioningBy(p -&gt; p.getAge() &gt; 18));
        map.forEach((k,v)-&gt; System.out.println(k+&quot;\t&quot; + v));
    &#125;

    /**
     * 对流中的数据做拼接操作
     */
    @Test
    public void test07()&#123;
        String s1 = Stream.of(
                new Person(&quot;张三&quot;, 18, 175)
                , new Person(&quot;李四&quot;, 22, 177)
                , new Person(&quot;张三&quot;, 14, 165)
                , new Person(&quot;李四&quot;, 15, 166)
                , new Person(&quot;张三&quot;, 19, 182)
        ).map(Person::getName)
                .collect(Collectors.joining());
        // 张三李四张三李四张三
        System.out.println(s1);
        String s2 = Stream.of(
                new Person(&quot;张三&quot;, 18, 175)
                , new Person(&quot;李四&quot;, 22, 177)
                , new Person(&quot;张三&quot;, 14, 165)
                , new Person(&quot;李四&quot;, 15, 166)
                , new Person(&quot;张三&quot;, 19, 182)
        ).map(Person::getName)
                .collect(Collectors.joining(&quot;_&quot;));
        // 张三_李四_张三_李四_张三
        System.out.println(s2);

        String s3 = Stream.of(
                new Person(&quot;张三&quot;, 18, 175)
                , new Person(&quot;李四&quot;, 22, 177)
                , new Person(&quot;张三&quot;, 14, 165)
                , new Person(&quot;李四&quot;, 15, 166)
                , new Person(&quot;张三&quot;, 19, 182)
        ).map(Person::getName)
                .collect(Collectors.joining(&quot;_&quot;, &quot;###&quot;, &quot;$$$&quot;));
        // ###张三_李四_张三_李四_张三$$$
        System.out.println(s3);
    &#125;
&#125;
</code></pre>
<h3 id="5-4并行的Stream"><a href="#5-4并行的Stream" class="headerlink" title="5.4并行的Stream"></a>5.4并行的Stream</h3><p>多线程下的Stream</p>
<p>parallelStram其实就是一个并行执行的流</p>
<p>它通过ForkjoinPool可以提高多线程的任务速度</p>
<p><em>&#x2F;</em>*<br>* *** *获取并行流的两种方式<br>* **&#x2F;</p>
<ol>
<li><strong>通过List 接口 直接获取并行流</strong></li>
<li><strong>将已有的串行流转换为并行流</strong></li>
</ol>
<pre><code>*@Test
public void test02()&#123;
    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
    // 通过List 接口 直接获取并行流
    Stream&lt;Integer&gt; integerStream = list.parallelStream();
    // 将已有的串行流转换为并行流
    Stream&lt;Integer&gt; parallel = Stream.*of*(1, 2, 3).parallel();
&#125;
</code></pre>
<p>AA</p>
<p><em>&#x2F;</em>*<br>* *** *并行流操作<br>* **&#x2F;</p>
<pre><code>@Test
public void test03()&#123;

​    Stream.*of*(1,4,2,6,1,5,9)
​            .parallel() // 将流转换为并发流，Stream处理的时候就会通过多线程处理
​            .filter(s-&gt;&#123;
​                System.*out*.println(Thread.*currentThread*() + &quot; s=&quot; +s);
​                return s &gt; 2;
​            &#125;).count();
&#125;
</code></pre>
<h5 id="并行流的线程安全问题"><a href="#并行流的线程安全问题" class="headerlink" title="并行流的线程安全问题"></a>并行流的线程安全问题</h5><pre><code>    /**
     * 并行流中的数据安全问题
     */
    @Test
    public void test01()&#123;
        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; 1000; i++) &#123;
            list.add(i);
        &#125;
        System.out.println(list.size());
        List&lt;Integer&gt; listNew = new ArrayList&lt;&gt;();
        // 使用并行流来向集合中添加数据
        list.parallelStream()
                //.forEach(s-&gt;listNew.add(s));
                .forEach(listNew::add);
        System.out.println(listNew.size());
    &#125;

    /**
     * 加同步锁
     */
    @Test
    public void test02()&#123;
        List&lt;Integer&gt; listNew = new ArrayList&lt;&gt;();
        Object obj = new Object();
        IntStream.rangeClosed(1,1000)
                .parallel()
                .forEach(i-&gt;&#123;
                    synchronized (obj)&#123;
                        listNew.add(i);
                    &#125;

                &#125;);
        System.out.println(listNew.size());
    &#125;

    /**
     * 使用线程安全的容器
     */
    @Test
    public void test03()&#123;
        Vector v = new Vector();
        Object obj = new Object();
        IntStream.rangeClosed(1,1000)
                .parallel()
                .forEach(i-&gt;&#123;
                    synchronized (obj)&#123;
                        v.add(i);
                    &#125;

                &#125;);
        System.out.println(v.size());
    &#125;

    /**
     * 将线程不安全的容器转换为线程安全的容器
     */
    @Test
    public void test04()&#123;
        List&lt;Integer&gt; listNew = new ArrayList&lt;&gt;();
        // 将线程不安全的容器包装为线程安全的容器
        List&lt;Integer&gt; synchronizedList = Collections.synchronizedList(listNew);
        Object obj = new Object();
        IntStream.rangeClosed(1,1000)
                .parallel()
                .forEach(i-&gt;&#123;
                        synchronizedList.add(i);
                &#125;);
        System.out.println(synchronizedList.size());
    &#125;


    /**
     * 我们还可以通过Stream中的 toArray方法或者 collect方法来操作
     * 就是满足线程安全的要求
     */
    @Test
    public void test05()&#123;
        List&lt;Integer&gt; listNew = new ArrayList&lt;&gt;();
        Object obj = new Object();
        List&lt;Integer&gt; list = IntStream.rangeClosed(1, 1000)
                .parallel()
                .boxed()
                .collect(Collectors.toList());
        System.out.println(list.size());
    &#125;
</code></pre>
<h1 id="ForkJoin详解"><a href="#ForkJoin详解" class="headerlink" title="ForkJoin详解"></a>ForkJoin详解</h1><h2 id="ForkJoin简介"><a href="#ForkJoin简介" class="headerlink" title="ForkJoin简介"></a>ForkJoin简介</h2><p>Fork&#x2F;Join框架是Java 7提供的一种用于并行执行任务的框架，它将大任务分解为若干个小任务,并行执行这些小任务，最终通过合并每个小任务的结果得到大任务的结果。</p>
<p>Fork&#x2F;Join采用的是分而治之的基本思想，分而治之就是将一个复杂的任务，按照规定的阈值划分成多个简单的小任务，然后将这些小任务的结果再进行汇总返回，得到最终的任务。</p>
<blockquote>
<p>欢迎关注个人公众号【好好学技术】交流学习</p>
</blockquote>
<h2 id="并行和并发的区别"><a href="#并行和并发的区别" class="headerlink" title="并行和并发的区别"></a>并行和并发的区别</h2><p>并行和并发是计算机科学中的两个概念，它们之间有一些相似之处，但也有明显的区别。</p>
<p>并行是指多个处理器或者是多核的处理器同时处理多个不同的任务。并行可以在多处理器系统中实现，利用每个处理机来处理一个可并发执行的程序，从而实现多个程序的同时执行。在并行执行时，每个处理器可以同时执行多个程序，从而提高计算效率。</p>
<p>并发是指逻辑上的同时发生（即 true 的同时性），而并行是物理上的同时发生。在多道程序环境下，并发性是指在一段时间内宏观上有多个程序在同时运行，但在单处理机系统中，每一时刻却仅能有一道程序执行，故微观上这些程序只能是分时地交替执行。</p>
<p>简而言之，并行是指多个处理器或多核处理器同时处理多个任务，而并发是指在同一时间内多个任务同时发生。</p>
<h2 id="工作窃取算法"><a href="#工作窃取算法" class="headerlink" title="工作窃取算法"></a>工作窃取算法</h2><p>工作窃取算法是指某个线程从其他队列里窃取任务来执行。当工作队列中有空闲任务时，就将任务从原线程的队列中窃取过来，执行完成后再将结果返回给原线程。这样就保证了原线程不会一直等待空闲任务，从而提高了程序的效率。</p>
<p>Fork&#x2F;Join框架使用ForkJoinPool这个特殊的线程池来处理任务之间有依赖的情况，其实现了“work-stealing”算法（工作量窃取算法）并执行ForkJoinTask对象。ForkJoinPool保持多个线程，其线程数量默认为机器cpu核心数。每个线程都有一个特殊类型的deques队列（双端队列），放置该线程的所有任务，而不是所有线程共享一个公共队列。</p>
<p>每个线程都会保证将自己队列中的任务执行完，当自己的任务执行完成之后，在去看其他线程的任务队列中是否有未处理完的任务，如果有则会帮助其他线程执行。</p>
<p>这时双端队列的优势就体现出来了,被窃取的任务只会从队列的头部获取任务，而正常处理的线程每次都是从队列的尾部获取任务。</p>
<h2 id="求1到1亿的和"><a href="#求1到1亿的和" class="headerlink" title="求1到1亿的和"></a>求1到1亿的和</h2><pre><code class="java">package com.fandf.test.forkjoin;  
  
import lombok.extern.slf4j.Slf4j;  
import org.springframework.util.StopWatch;  
  
import java.util.concurrent.ForkJoinPool;  
import java.util.concurrent.Future;  
import java.util.concurrent.RecursiveTask;  
  
/**  
* @author fandongfeng  
*/  
@Slf4j  
public class ForkJoinDemo extends RecursiveTask&lt;Long&gt; &#123;  
  
    /**  
    * 小任务的大小阈值  
    */  
    public static final int TASK_SIZE = 100000;  
    /**  
    * 开始数字  
    */  
    private final Long start;  
    /**  
    * 结束数字  
    */  
    private final Long end;  

    public ForkJoinDemo(Long start, Long end) &#123;  
        this.start = start;  
        this.end = end;  
    &#125;  

    @Override  
    protected Long compute() &#123;  
        long sum = 0L;  
        //如果任务足够小就计算任务  
        boolean canCompute = (end - start) &lt;= TASK_SIZE;  
        if (canCompute) &#123;  
            for (Long i = start; i &lt;= end; i++) &#123;  
                sum += i;  
            &#125;  
        &#125; else &#123;  
            // 如果任务大于阈值，就分裂成两个子任务计算  
            long middle = (start + end) / 2;  
            ForkJoinDemo leftTask = new ForkJoinDemo(start, middle);  
            ForkJoinDemo rightTask = new ForkJoinDemo(middle + 1, end);  

            // 执行子任务  
            leftTask.fork();  
            rightTask.fork();  

            // 等待任务执行结束合并其结果  
            Long leftResult = leftTask.join();  
            Long rightResult = rightTask.join();  

            // 合并子任务  
            sum = leftResult + rightResult;  
        &#125;  
        return sum;  
    &#125;  

    public static void main(String[] args) &#123;  
        ForkJoinPool forkjoinPool = new ForkJoinPool();  
        //生成一个计算任务，计算1+2+3+4+...+100000000  
        ForkJoinDemo task = new ForkJoinDemo(1L, 100000000L);  
        StopWatch stopWatch = new StopWatch();  
        stopWatch.start();  
        //执行一个任务  
        Future&lt;Long&gt; result = forkjoinPool.submit(task);  

        try &#123;  
            System.out.println(&quot;result:&quot; + result.get());  
        &#125; catch (Exception e) &#123;  
            log.error(&quot;exception&quot;, e);  
        &#125;  
        stopWatch.stop();  
        System.out.println(&quot;总耗时：&quot; + stopWatch.getTotalTimeMillis() + &quot;毫秒&quot;);  
        System.out.println(&quot;getParallelism:&quot; + forkjoinPool.getParallelism());  
        System.out.println(&quot;getPoolSize:&quot; + forkjoinPool.getPoolSize());  
    &#125;  
&#125;
</code></pre>
<p>输出结果</p>
<pre><code class="java">result:5000000050000000
总耗时：330毫秒
getParallelism:6
getPoolSize:7
</code></pre>
<h2 id="ForkJoin框架实现"><a href="#ForkJoin框架实现" class="headerlink" title="ForkJoin框架实现"></a>ForkJoin框架实现</h2><h3 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a>ForkJoinPool</h3><p><code>ForkJoinPool</code>是用于运行<code>ForkJoinTasks</code>的线程池，实现了<code>Executor</code>接口</p>
<p><img src="https://img-blog.csdnimg.cn/e036acdd7317493dbfad45955346f1ce.png" alt="在这里插入图片描述"></p>
<pre><code class="java">public ForkJoinPool() &#123;  
    this(Math.min(MAX_CAP, Runtime.getRuntime().availableProcessors()),  
        defaultForkJoinWorkerThreadFactory, null, false);  
&#125;

public ForkJoinPool(int parallelism,  
                    ForkJoinWorkerThreadFactory factory,  
                    UncaughtExceptionHandler handler,  
                    boolean asyncMode) &#123;  
    this(checkParallelism(parallelism),  
        checkFactory(factory),  
        handler,  
        asyncMode ? FIFO_QUEUE : LIFO_QUEUE,  
        &quot;ForkJoinPool-&quot; + nextPoolId() + &quot;-worker-&quot;);  
    checkPermission();  
&#125;
</code></pre>
<p>ForkJoinPool构造方法有四个参数：</p>
<ul>
<li>parallelism：期望并发数。默认会使用<code>Runtime.getRuntime().availableProcessors()</code>的值</li>
<li>factory：创建ForkJoin工作线程的工厂，默认为defaultForkJoinWorkerThreadFactory</li>
<li>handler：执行任务时遇到不可恢复的错误时的处理程序，默认为null</li>
<li>asyncMode：工作线程获取任务使用FIFO(先进先出)模式还是LIFO(后进先出)模式，默认为LIFO</li>
</ul>
<h3 id="ForkJoinTask"><a href="#ForkJoinTask" class="headerlink" title="ForkJoinTask"></a>ForkJoinTask</h3><p><code>ForkJoinTask</code>是对于在<code>ForkJoinPool</code>中运行任务的抽象类定义。</p>
<p>JDK为我们提供了三种特定类型的ForkJoinTask父类供我们自定义时继承使用。</p>
<ul>
<li><strong>RecursiveAction</strong>：子任务不返回结果</li>
<li><strong>RecursiveTask</strong>：子任务返回结果</li>
<li><strong>CountedCompleter</strong>：在任务完成执行后会触发执行</li>
</ul>
<h3 id="ForkJoinWorkerThread"><a href="#ForkJoinWorkerThread" class="headerlink" title="ForkJoinWorkerThread"></a>ForkJoinWorkerThread</h3><p><code>ForkJoinPool</code>中用于执行<code>ForkJoinTask</code>的线程。<br>ForkJoinPool实现了Executor接口。但是和我们常用的ThreadPoolExecutor又有一些区别。</p>
<p>如果使用ThreadPoolExecutor来实现上面分治任务，那么每个子任务都需要创建一个线程，如果子任务的数量很大，假设有上万个，那么使用ThreadPoolExecutor创建出上万个线程，这显然是不可行也不合理的；</p>
<p>而ForkJoinPool在处理任务时，并不会按照任务开启线程，而是按照指定的期望并行数量创建线程。在每个线程工作时，如果需要继续拆分子任务，则会将当前任务放入ForkJoinWorkerThread的任务队列中，递归处理直到最外层的任务。</p>
<h3 id="ForkJoinTask启动方式"><a href="#ForkJoinTask启动方式" class="headerlink" title="ForkJoinTask启动方式"></a>ForkJoinTask启动方式</h3><ul>
<li>异步执行<br>forkjoinPool.execute(task);无返回结果</li>
<li>同步执行<br>forkjoinPool.invoke(task);等待返回结果</li>
<li>异步执行，通过Future获取结果<br>forkjoinPool.submit(task);</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在使用Fork&#x2F;Join框架时，需要注意以下几点：</p>
<ol>
<li>必须首先创建一个ForkJoinTask对象。</li>
<li>在分发任务时，需要注意线程安全问题，防止多个线程同时访问共享资源。可以使用synchronized关键字或者Lock对象来保证线程安全。</li>
<li>在合并结果时，也需要注意线程安全问题，可以使用CountDownLatch对象来确保每个Fork执行完成后才能提交结果。</li>
<li>在使用Fork&#x2F;Join框架时，需要考虑算法的效率和性能问题。可以使用Cache技术来减少不必要的计算，使用join策略来合并结果等。</li>
</ol>
<p>总之，Fork&#x2F;Join框架是一种非常有用的并行计算框架，可以大大提高程序的执行效率和并发能力。</p>
<h3 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h3><h1 id="Java-8特性之Optional详解"><a href="#Java-8特性之Optional详解" class="headerlink" title="Java 8特性之Optional详解"></a>Java 8特性之Optional详解</h1><h1 id="一、Optional类-简介"><a href="#一、Optional类-简介" class="headerlink" title="一、Optional类 简介"></a>一、Optional类 简介</h1><p>Optional类是 Java 8 引入的一个很有趣的特性。它主要解决的问题是臭名昭著的空指针异常（NullPointerException）</p>
<ul>
<li>Optional 类是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。</li>
<li>Optional 是个容器：它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。</li>
<li>Optional 类的引入很好的解决空指针异常。</li>
</ul>
<p>Optional 是一个对象容器，具有以下两个特点：</p>
<ul>
<li>提示用户要注意该对象有可能为null</li>
<li>简化if else代码</li>
</ul>
<p>举一个简单的例子，在 Java 8 之前，任何访问对象方法或属性的调用都可能导致 NullPointerException：</p>
<pre><code class="java">用户 -&gt; 家庭住址  -&gt; 城市  -&gt;邮编
String postCode = user.getAddress().getCity().getPostCode();
</code></pre>
<p>在这个示例中，为了避免异常，就得在访问每一个值之前对其进行明确地检查：</p>
<pre><code class="java">if (user != null) &#123;
    Address address = user.getAddress();
    if (address != null) &#123;
        City city= address.getCity();
        if (city != null) &#123;
            String postCode = city.getPostCode();
            if (postCode != null) &#123;
                //对postCode进行操作
               test(postCode);
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p>这很容易就变得冗长，难以维护。<br>为了简化这个过程，我们就可以用 Optional 类。</p>
<h1 id="二、Optional类的使用"><a href="#二、Optional类的使用" class="headerlink" title="二、Optional类的使用"></a>二、Optional类的使用</h1><h2 id="1-创建："><a href="#1-创建：" class="headerlink" title="1. 创建："></a>1. 创建：</h2><p>Optional类的实例创建有三种方式：</p>
<ul>
<li><p><strong>Optional.empty()</strong> ：创建一个空的 Optional 实例。</p>
</li>
<li><p><strong>Optional.of(T t)</strong> ：创建一个 Optional 实例，当 t为null时抛出异常（NullPointerException）。</p>
</li>
<li><p><strong>Optional.ofNullable(T t)</strong> ：创建一个 Optional 实例，但当 t为null时不会抛出异常，而是返回一个空的实例。</p>
<h5 id="Optional中的常用方法介绍"><a href="#Optional中的常用方法介绍" class="headerlink" title="Optional中的常用方法介绍"></a>Optional中的常用方法介绍</h5><p>*<em>get():</em> *如果Optional有值则返回，否则抛出NoSuchElementException异常<br>get()通常和isPresent方法一块使用<br>isPresent():判断是否包含值，包含值返回true，不包含值返回false orElse(T t):如果调用对象包含值，就返回该值，否则返回t<br>orElseGet(Supplier s):*<em>如果调用对象包含值，就返回该值，否则返回</em>  Lambda表达式的返回值</p>
<p>**</p>
</li>
</ul>
<h2 id="2-获取："><a href="#2-获取：" class="headerlink" title="2. 获取："></a><strong>2. 获取</strong>：</h2><ul>
<li>**get()**：获取optional实例中的对象，当optional 容器为空时报错。</li>
</ul>
<h2 id="3-判断："><a href="#3-判断：" class="headerlink" title="3. 判断："></a>3. 判断：</h2><ul>
<li>**isPresent()**：判断optional是否为空，如果空则返回false，否则返回true</li>
<li>**ifPresent(Consumer c)**：如果optional不为空，则将optional中的对象传给Comsumer函数</li>
</ul>
<pre><code class="java">public class OptionalDemo &#123;
    public static void main(String[] args) &#123;
        User user = new User(&quot;王也&quot;, &quot;5&quot;);
        User userNull= null;

        Optional&lt;User&gt; optional = Optional.ofNullable(user);
        System.out.println(optional.isPresent());
        
        optional.ifPresent(u -&gt; System.out.println(&quot;optional不为null  &quot;+u));
    &#125;
&#125;
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/3776490092084d9785bc5432f4cd1159.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAUGx1dG8zNzI=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<ul>
<li>**orElse(T other)**：如果optional不为空，则返回optional中的对象；如果为null，则返回 other 这个默认值</li>
</ul>
<pre><code class="java">   User user = new User(&quot;王也&quot;, &quot;5&quot;);
   User userNull= null;
   //orElse的工作方式非常直接，如果有值则返回该值，否则返回传递给它的参数值：
   User user1 = Optional.ofNullable(userNull).orElse(user);
   System.out.println(user1);

   //控制台输出：User(name=王也, age=5)
</code></pre>
<ul>
<li>**orElseGet(Supplier other)**：如果optional不为空，则返回optional中的对象；如果为null，则使用Supplier函数生成默认值other</li>
</ul>
<pre><code class="java">  User user1 = Optional.ofNullable(userNull).orElseGet(()-&gt;user );
  //结果同上
</code></pre>
<ul>
<li>**orElseThrow(Supplier exception)**：如果optional不为空，则返回optional中的对象；如果为null，则抛出Supplier函数生成的异常</li>
</ul>
<pre><code class="java">//这个方法让我们有更丰富的语义，可以决定抛出什么样的异常，而不总是抛出 NullPointerException。
 User result = Optional.ofNullable(userNull)
      .orElseThrow( () -&gt; new IllegalArgumentException());
</code></pre>
<h3 id="orElse-和-orElseGet-的不同之处"><a href="#orElse-和-orElseGet-的不同之处" class="headerlink" title="orElse() 和 orElseGet() 的不同之处"></a>orElse() 和 orElseGet() 的不同之处</h3><p>乍一看，这两种方法似乎起着同样的作用。然而事实并非如此。我们创建一些示例来突出二者行为上的异同。</p>
<p><strong>（1）当对象为空时：</strong></p>
<pre><code class="java">public class OptionalDemo &#123;
    public static void main(String[] args) &#123;

        User userNull = null;
        
        System.out.println(&quot;使用orElse()：&quot;);
        User result = Optional.ofNullable(userNull).orElse(createNewUser());

        System.out.println(&quot;使用orElseGet()：&quot;);
        User result2 = Optional.ofNullable(userNull).orElseGet(() -&gt; createNewUser());
    &#125;
    private static User createNewUser() &#123;
        System.out.println(&quot;Creating New User&quot;);
        return new User(&quot;新的user对象&quot;, &quot;1234&quot;);
    &#125;
&#125;
</code></pre>
<p>上面的代码中，两种方法都调用了 createNewUser() 方法，这个方法会记录一个消息并返回 User 对象。</p>
<p>控制台输出:</p>
<pre><code class="java">使用orElse()：
Creating New User
使用orElseGet()：
Creating New User
</code></pre>
<p>由此可见，当对象为空而返回默认对象时，行为并无差异。</p>
<p><strong>（2）当对象不为空时：</strong></p>
<pre><code class="java">public class OptionalDemo &#123;
    public static void main(String[] args) &#123;

        User user = new User(&quot;王也&quot;, &quot;5&quot;);
        
        System.out.println(&quot;使用orElse()：&quot;);
        User result = Optional.ofNullable(user).orElse(createNewUser());

        System.out.println(&quot;使用orElseGet()：&quot;);
        User result2 = Optional.ofNullable(user).orElseGet(() -&gt; createNewUser());
    &#125;
    private static User createNewUser() &#123;
        System.out.println(&quot;Creating New User&quot;);
        return new User(&quot;新的user对象&quot;, &quot;1234&quot;);
    &#125;
&#125;
</code></pre>
<p>控制台输出:</p>
<pre><code class="java">使用orElse()：
Creating New User
使用orElseGet()：
</code></pre>
<p>这个示例中，两个 Optional 对象都包含非空值，两个方法都会返回对应的非空值。不过，orElse() 方法仍然创建了 User 对象。与之相反，orElseGet() 方法不创建 User 对象。</p>
<p>在执行较密集的调用时，比如调用 Web 服务或数据查询，这个差异会对性能产生重大影响。</p>
<p><strong>demo</strong></p>
<pre><code>
    @Test
    public void test01()&#123;
        //String userName = &quot;张三&quot;;
        String userName = null;
        if(userName != null)&#123;
            System.out.println(&quot;字符串的长度：&quot; + userName.length());
        &#125;else&#123;
            System.out.println(&quot;字符串为空&quot;);
        &#125;

    &#125;

    /**
     * Optional对象的创建方式
     */
    @Test
    public void test02()&#123;
        // 第一种方式 通过of方法  of方法是不支持null的
        Optional&lt;String&gt; op1 = Optional.of(&quot;zhangsan&quot;);
        //Optional&lt;Object&gt; op2 = Optional.of(null);

        // 第二种方式通过 ofNullable方法 支持null
        Optional&lt;String&gt; op3 = Optional.ofNullable(&quot;lisi&quot;);
        Optional&lt;Object&gt; op4 = Optional.ofNullable(null);

        // 第三种方式 通过empty方法直接创建一个空的Optional对象
        Optional&lt;Object&gt; op5 = Optional.empty();

    &#125;

    /**
     * Optional中的常用方法介绍
     *   get(): 如果Optional有值则返回，否则抛出NoSuchElementException异常
     *          get()通常和isPresent方法一块使用
     *   isPresent():判断是否包含值，包含值返回true，不包含值返回false
     *   orElse(T t):如果调用对象包含值，就返回该值，否则返回t
     *   orElseGet(Supplier s):如果调用对象包含值，就返回该值，否则返回 Lambda表达式的返回值
     */
    @Test
    public void test03()&#123;
        Optional&lt;String&gt; op1 = Optional.of(&quot;zhangsan&quot;);
        Optional&lt;String&gt; op2 = Optional.empty();

        // 获取Optional中的值
        if(op1.isPresent())&#123;
            String s1 = op1.get();
            System.out.println(&quot;用户名称:&quot; +s1);
        &#125;

        if(op2.isPresent())&#123;
            System.out.println(op2.get());
        &#125;else&#123;
            System.out.println(&quot;op2是一个空Optional对象&quot;);
        &#125;

        String s3 = op1.orElse(&quot;李四&quot;);
        System.out.println(s3);
        String s4 = op2.orElse(&quot;王五&quot;);
        System.out.println(s4);

        String s5 = op2.orElseGet(()-&gt;&#123;
            return &quot;Hello&quot;;
        &#125;);
        System.out.println(s5);
    &#125;


    @Test
    public void test04()&#123;
        Optional&lt;String&gt; op1 = Optional.of(&quot;zhangsan&quot;);
        Optional&lt;String&gt; op2 = Optional.empty();
        // 如果存在值 就做什么
        op1.ifPresent(s-&gt; System.out.println(&quot;有值:&quot; +s));
        op1.ifPresent(System.out::println);
    &#125;

    /**
     * 自定义一个方法，将Person对象中的 name 转换为大写 并返回
     */
    @Test
    public void test05()&#123;
        Person p = new Person(&quot;zhangsan&quot;,18);
        Optional&lt;Person&gt; op = Optional.of(p);
        String name = getNameForOptional(op);
        System.out.println(&quot;name=&quot;+name);

    &#125;

    /**
     * 根据Person对象 将name转换为大写并返回
     *    通过Optional方式实现
     * @param op
     * @return
     */
    public String getNameForOptional(Optional&lt;Person&gt; op)&#123;
       if(op.isPresent())&#123;
           String msg = //op.map(p -&gt; p.getName())
                   op.map(Person::getName)
                   //.map(p -&gt; p.toUpperCase())
                   .map(String::toUpperCase)
                   .orElse(&quot;空值&quot;);
           return msg;
       &#125;
       return null;
    &#125;

    /**
     * 根据Person对象 将name转换为大写并返回
     * @param person
     * @return
     */
    public String getName(Person person)&#123;
        if(person != null)&#123;
            String name = person.getName();
            if(name != null)&#123;
                return name.toUpperCase();
            &#125;else&#123;
                return null;
            &#125;
        &#125;else&#123;
            return null;
        &#125;
    &#125;

&#125;
</code></pre>
<h2 id="四、jdk的时间操作"><a href="#四、jdk的时间操作" class="headerlink" title="四、jdk的时间操作"></a>四、jdk的时间操作</h2><p><strong>旧版本的日期格式</strong></p>
<pre><code>public class Test07 &#123;

    /**
     * 旧版日期时间设计的问题
     */
    @Test
    public void test01() throws Exception&#123;
        // 1.设计不合理
        Date date = new Date(2021,05,05);
        System.out.println(date);

        // 2.时间格式化和解析操作是线程不安全的
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
        for (int i = 0; i &lt; 50; i++) &#123;
            new Thread(()-&gt;&#123;
               // System.out.println(sdf.format(date));
                try &#123;
                    System.out.println(sdf.parse(&quot;2021-05-06&quot;));
                &#125; catch (ParseException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;).start();
        &#125;
    &#125;
&#125;
</code></pre>
<p>缺点</p>
<p>1.设计不合理 在java.util和java.sql包下都有日期类 java.util.Date同时包含日期和时间</p>
<p>而java.sql.Date仅仅包含日期，此外用于格式化和解析的类在java.text包下</p>
<p>2.非线程安全 java.util.Date是非线程安全的所有的日期是可变的这是java日期类的问题</p>
<p>3.时区处理不支持国际化</p>
<h1 id="JDK8时间API整理"><a href="#JDK8时间API整理" class="headerlink" title="JDK8时间API整理"></a>JDK8时间API整理</h1><p>在jdk8之前经常使用到的时间API包括（Date、Calendar），date与字符串之间的转换使用SimpleDateFormat进行转换，用SimpleDateFormat类的parse方法，可以将满足格式要求的字符串转换成Date对象，使用SimpleDateFormat类的format方法，可以将Date类型的对象转换成一定格式的字符串。然而SimpleDateFormat并非是线程安全的。在jdk8中为了使用时间更加便利，在java.time包下新增时间API。使用DateTimeFormatter的parse将字符串转换成时间格式，format方法将日期、时间转换成字符串格式。</p>
<h3 id="1-1、时间API"><a href="#1-1、时间API" class="headerlink" title="1.1、时间API"></a>1.1、时间API</h3><ol>
<li>ZoneId:时区ID,用来确定Instant和LocalDateTime互相转换的规则。</li>
<li>Instant:用来表示时间线上的一个点。</li>
<li>LocalDate:表示没有时区的日期，LocalDate是不可变且线程安全的。</li>
<li>LocalTime:表示没有时区的时间，LocalTime是不可变且线程安全的。</li>
<li>LocalDateTime:表示没有时区的日期时间，LocalDateTime是不可变且线程安全的。</li>
<li>Clock:用于访问当前时刻、日期、时间、用到时区。</li>
<li>Duration:用秒和纳秒表示时间。</li>
</ol>
<p>最常用的就是LocalDate、LocalTime、LocalDateTime了、从他们的名字可以看出是操作日期、时间的。</p>
<p><strong>LocalDate</strong>（<strong>日期</strong>）</p>
<table>
<thead>
<tr>
<th>说明</th>
<th>方法</th>
<th>返回结果示例</th>
</tr>
</thead>
<tbody><tr>
<td>获取当前日期</td>
<td>LocalDate.now()</td>
<td>2019-05-14</td>
</tr>
<tr>
<td>日期构造</td>
<td>LocalDate.of(2019,05,14)</td>
<td>2019-05-14</td>
</tr>
<tr>
<td>字符串转LocalDate</td>
<td>LocalDate.parse(“2019-06-01”)</td>
<td>2019-06-01</td>
</tr>
<tr>
<td>获取明天的日期</td>
<td>LocalDate.now().plusDays(1) &#x2F; LocalDate.now().plus(1, ChronoUnit.DAYS)</td>
<td>2019-05-15</td>
</tr>
<tr>
<td>在今天的基础上减去一个月</td>
<td>LocalDate.now().minusMonths(1)&#x2F;LocalDate.now().minus(1, ChronoUnit.MONTHS)</td>
<td>2019-04-14</td>
</tr>
<tr>
<td>解析日期，获取星期</td>
<td>LocalDate.parse(“2019-05-14”).getDayOfWeek()</td>
<td>TUESDAY</td>
</tr>
<tr>
<td>解析日期，获取本月的第几天</td>
<td>LocalDate.parse(“2019-05-14”).getDayOfMonth()</td>
<td>14</td>
</tr>
<tr>
<td>判断今年是否为闰年</td>
<td>LocalDate.now().isLeapYear()</td>
<td>false</td>
</tr>
<tr>
<td>获取本月的第一天</td>
<td>LocalDate.parse(“2019-05-14”).with(TemporalAdjusters.firstDayOfMonth())</td>
<td>2019-05-01</td>
</tr>
</tbody></table>
<p>显示详细信息</p>
<p><strong>LocalTime</strong>（<strong>时间</strong>）</p>
<table>
<thead>
<tr>
<th>说明</th>
<th>方法</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>获取当前时间</td>
<td>LocalTime.now()</td>
<td>20:46:15.170</td>
</tr>
<tr>
<td>时间构造</td>
<td>LocalTime.of(17,30,14)</td>
<td>17:30:14</td>
</tr>
<tr>
<td>字符串时间解析为LocalTime</td>
<td>LocalTime.parse(“17:30”)</td>
<td>17:30</td>
</tr>
<tr>
<td>获取小时</td>
<td>LocalTime.now().getHour()</td>
<td>20</td>
</tr>
<tr>
<td>获取分钟</td>
<td>LocalTime.now().getMinute()</td>
<td>46</td>
</tr>
<tr>
<td>判断一个时间是否在另一时间之前</td>
<td>LocalTime.parse(“17:30”).isBefore(LocalTime.parse(“17:29”))</td>
<td>false</td>
</tr>
<tr>
<td>判断一个时间是否在另一时间之后</td>
<td>LocalTime.parse(“17:30”).isAfter(LocalTime.parse(“17:29”))</td>
<td>true</td>
</tr>
<tr>
<td>每天的开始</td>
<td>LocalTime.MIN</td>
<td>00:00</td>
</tr>
<tr>
<td>每天的结束</td>
<td>LocalTime.MAX</td>
<td>23:59:59.999999999</td>
</tr>
</tbody></table>
<p>显示详细信息</p>
<p><strong>LocalDateTime</strong>（日期时间，可通过getXX获取年月日时分秒）</p>
<table>
<thead>
<tr>
<th>说明</th>
<th>方法</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>获取当前日期的时间</td>
<td>LocalDateTime.now()</td>
<td>2019-05-14T20:57:18.094</td>
</tr>
<tr>
<td>日期时间构造</td>
<td>LocalDateTime.of(2019,05,14,17,30,14)</td>
<td>2019-05-14T17:30:14</td>
</tr>
<tr>
<td>日期时间加1天</td>
<td>LocalDateTime.now().plusDays(1)</td>
<td>2019-05-15T20:57:18.094</td>
</tr>
<tr>
<td>日期时间减1天</td>
<td>LocalDateTime.now().minusDays(1)</td>
<td>2019-05-13T20:57:18.094</td>
</tr>
</tbody></table>
<p><strong>Instant(时间戳)</strong></p>
<table>
<thead>
<tr>
<th>说明</th>
<th>方法</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>当前UTC时区</td>
<td>Instant.now()</td>
<td>2019-05-14T13:10:33.982Z</td>
</tr>
<tr>
<td>东八区</td>
<td>Instant.now().atOffset(ZoneOffset.ofHours(8))</td>
<td>2019-05-14T21:10:34.022+08:00</td>
</tr>
<tr>
<td>获取毫秒值</td>
<td>Instant.now().toEpochMilli()</td>
<td>1557839434023</td>
</tr>
<tr>
<td>通过毫秒获取时间（UTC时区）</td>
<td>Instant.ofEpochMilli(1)</td>
<td>1970-01-01T00:00:00.001Z</td>
</tr>
<tr>
<td>通过时区ID获取时间</td>
<td>LocalDateTime.now(ZoneId.of(“Europe&#x2F;London”))</td>
<td>2019-05-14T14:10:34.030</td>
</tr>
<tr>
<td>比较两个日期的差别</td>
<td>ChronoUnit.DAYS.between(temporal1,temporal2)</td>
<td>相差的天数</td>
</tr>
</tbody></table>
<p><strong>DateTimeFormatter</strong>（时间与字符串之间的转换）</p>
<table>
<thead>
<tr>
<th>说明</th>
<th>方法</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>转换格式</td>
<td>DateTimeFormatter.ofPattern(“yyyy-MM-dd HH:mm:ss.SSS”)</td>
<td></td>
</tr>
<tr>
<td>字符串转LocalDateTime</td>
<td>LocalDateTime.parse(“2019-05-14 21:15:30.555”,DateTimeFormatter.ofPattern(“yyyy-MM-dd HH:mm:ss.SSS”))</td>
<td>2019-05-14T21:15:30.555</td>
</tr>
<tr>
<td>LocalDateTime转字符串</td>
<td>DateTimeFormatter.ofPattern(“yyyy-MM-dd HH:mm:ss.SSS”).format(LocalDateTime.now())</td>
<td>2019-05-14 21:18:22.902</td>
</tr>
</tbody></table>
<p><strong>各时间与Date之间互转</strong></p>
<table>
<thead>
<tr>
<th>说明</th>
<th>方法</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>Date转换为LocalDateTime</td>
<td>Date.from(Instant.now()).toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime()</td>
<td>2019-05-14T21:43:57.650</td>
</tr>
<tr>
<td>LocalDateTime转Date</td>
<td>Date.from(LocalDateTime.now().atZone(ZoneId.systemDefault()).toInstant())</td>
<td>Tue May 14 21:43:57 CST 2019</td>
</tr>
<tr>
<td>LocalDate转Date</td>
<td>Date.from(LocalDate.now().atStartOfDay(ZoneId.systemDefault()).toInstant())</td>
<td>Tue May 14 00:00:00 CST 2019</td>
</tr>
<tr>
<td>Date转字符串</td>
<td>DateTimeFormatter.ofPattern(“yyyy-MM-dd HH:mm:ss.SSS”).format(Date.from(new Date().toInstant()).toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime())</td>
<td>2019-05-14 21:43:57.706</td>
</tr>
</tbody></table>
<h3 id="JDK8时间操作demo"><a href="#JDK8时间操作demo" class="headerlink" title="JDK8时间操作demo"></a>JDK8时间操作demo</h3><pre><code>public class Test08 &#123;

    /**
     * JDK8 日期时间操作
     */
    @Test
    public void test01()&#123;
        // 1.创建指定的日期
        LocalDate date1 = LocalDate.of(2021, 05, 06);
        System.out.println(&quot;date1 = &quot;+date1);

        // 2.得到当前的日期
        LocalDate now = LocalDate.now();
        System.out.println(&quot;now = &quot;+now);

        // 3.根据LocalDate对象获取对应的日期信息
        System.out.println(&quot;年：&quot; + now.getYear());
        System.out.println(&quot;月：&quot; + now.getMonth().getValue());
        System.out.println(&quot;日：&quot; + now.getDayOfMonth());
        System.out.println(&quot;星期：&quot; + now.getDayOfWeek().getValue());
    &#125;

    /**
     * 时间操作
     */
    @Test
    public void test02()&#123;
        // 1.得到指定的时间
        LocalTime time = LocalTime.of(5,26,33,23145);
        System.out.println(time);
        // 2.获取当前的时间
        LocalTime now = LocalTime.now();
        System.out.println(now);
        // 3.获取时间信息
        System.out.println(now.getHour());
        System.out.println(now.getMinute());
        System.out.println(now.getSecond());
        System.out.println(now.getNano());
    &#125;

    /**
     * 日期时间类型  LocalDateTime
     */
    @Test
    public void test03()&#123;
        // 获取指定的日期时间
        LocalDateTime dateTime =
                LocalDateTime.of(2020
                        , 06
                        , 01
                        , 12
                        , 12
                        , 33
                        , 213);
        System.out.println(dateTime);
        // 获取当前的日期时间
        LocalDateTime now = LocalDateTime.now();
        System.out.println(now);
        // 获取日期时间信息
        System.out.println(now.getYear());
        System.out.println(now.getMonth().getValue());
        System.out.println(now.getDayOfMonth());
        System.out.println(now.getDayOfWeek().getValue());
        System.out.println(now.getHour());
        System.out.println(now.getMinute());
        System.out.println(now.getSecond());
        System.out.println(now.getNano());
    &#125;
&#125;
</code></pre>
<h4 id="日期时间的修改"><a href="#日期时间的修改" class="headerlink" title="日期时间的修改"></a>日期时间的修改</h4><pre><code>    /**
     * 日期时间的修改
     */
    @Test
    public void test01()&#123;
        LocalDateTime now = LocalDateTime.now();
        System.out.println(&quot;now = &quot;+now);
        // 修改日期时间  对日期时间的修改，对已存在的LocalDate对象，创建了它模板
        // 并不会修改原来的信息
        LocalDateTime localDateTime = now.withYear(1998);
        System.out.println(&quot;now :&quot;+now);
        System.out.println(&quot;修改后的：&quot; + localDateTime);

        System.out.println(&quot;月份：&quot; + now.withMonth(10));
        System.out.println(&quot;天：&quot; + now.withDayOfMonth(6));
        System.out.println(&quot;小时：&quot; + now.withHour(8));
        System.out.println(&quot;分钟:&quot; + now.withMinute(15));

        // 在当前日期时间的基础上 加上或者减去指定的时间
        System.out.println(&quot;两天后:&quot; + now.plusDays(2));
        System.out.println(&quot;10年后:&quot;+now.plusYears(10));
        System.out.println(&quot;6个月后 = &quot; + now.plusMonths(6));

        System.out.println(&quot;10年前 = &quot; + now.minusYears(10));
        System.out.println(&quot;半年前 = &quot; + now.minusMonths(6));
        System.out.println(&quot;一周前 = &quot; + now.minusDays(7));
    &#125;

    /**
     * 日期时间的比较
     */
    @Test
    public void test02()&#123;
        LocalDate now = LocalDate.now();
        LocalDate date = LocalDate.of(2020, 1, 3);
        // 在JDK8中要实现 日期的比较 isAfter  isBefore isEqual 通过这几个方法来直接比较
        System.out.println(now.isAfter(date)); // true
        System.out.println(now.isBefore(date)); // false
        System.out.println(now.isEqual(date)); // false
    &#125;
&#125;
</code></pre>
<h3 id="日期的解析与格式化"><a href="#日期的解析与格式化" class="headerlink" title="日期的解析与格式化"></a>日期的解析与格式化</h3><pre><code>   /**
     * 日期格式化
     */
    @Test
    public void test01()&#123;
        LocalDateTime now = LocalDateTime.now();
        // 指定格式  使用系统默认的格式 2021-05-27T16:16:38.139
        DateTimeFormatter isoLocalDateTime = DateTimeFormatter.ISO_LOCAL_DATE_TIME;
        // 将日期时间转换为字符串
        String format = now.format(isoLocalDateTime);
        System.out.println(&quot;format = &quot; + format);

        // 通过 ofPattern 方法来指定特定的格式
        DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);
        String format1 = now.format(dateTimeFormatter);
        // 2021-05-27 16:16:38
        System.out.println(&quot;format1 = &quot; + format1);

        // 将字符串解析为一个 日期时间类型
        LocalDateTime parse = LocalDateTime.parse(&quot;1997-05-06 22:45:16&quot;, dateTimeFormatter);
        // parse = 1997-05-06T22:45:16
        System.out.println(&quot;parse = &quot; + parse);
    &#125;
</code></pre>
<h3 id="Instant-类"><a href="#Instant-类" class="headerlink" title="Instant 类"></a>Instant 类</h3><p>在jdk8中给我们新增一个instant类（时间戳&#x2F;时间线）内部保存了从1970年1月1日 0时0分0秒</p>
<pre><code>  @Test
    public void test01() throws Exception&#123;
        Instant now = Instant.now();
        System.out.println(&quot;now = &quot; + now);

        // 获取从1970年一月一日 00:00:00 到现在的 纳秒
        System.out.println(now.getNano());
        Thread.sleep(5);
        Instant now1 = Instant.now();
        System.out.println(&quot;耗时：&quot; + (now1.getNano() - now.getNano()));

    &#125;
</code></pre>
<h3 id="计算日期时间差"><a href="#计算日期时间差" class="headerlink" title="计算日期时间差"></a>计算日期时间差</h3><p><strong>通过Duration来计算时间差</strong></p>
<p> <strong>计算日期差period</strong> </p>
<p>  <strong>时间校正器</strong></p>
<pre><code>  /**
     * 计算日期时间差
     */
    @Test
    public void test01()&#123;
        // 计算时间差
        LocalTime now = LocalTime.now();
        LocalTime time = LocalTime.of(22, 48, 59);
        System.out.println(&quot;now = &quot; + now);
        // 通过Duration来计算时间差
        Duration duration = Duration.between(now, time);
        System.out.println(duration.toDays()); // 0
        System.out.println(duration.toHours()); // 6
        System.out.println(duration.toMinutes()); // 368
        System.out.println(duration.toMillis()); // 22124240

        // 计算日期差period 
        LocalDate nowDate = LocalDate.now();
        LocalDate date = LocalDate.of(1997, 12, 5);
        Period period = Period.between(date, nowDate);
        System.out.println(period.getYears()); // 23
        System.out.println(period.getMonths()); // 5
        System.out.println(period.getDays()); // 22
    &#125;

    /**
     * 时间校正器
     */
    @Test
    public void test02()&#123;
        LocalDateTime now = LocalDateTime.now();
        // 将当前的日期调整到下个月的一号
        TemporalAdjuster adJuster = (temporal)-&gt;&#123;
            LocalDateTime dateTime = (LocalDateTime) temporal;
            LocalDateTime nextMonth = dateTime.plusMonths(1).withDayOfMonth(1);
            System.out.println(&quot;nextMonth = &quot; + nextMonth);
            return nextMonth;
        &#125;;
        // 我们可以通过TemporalAdjusters 来实现
        // LocalDateTime nextMonth = now.with(adJuster);
        LocalDateTime nextMonth = now.with(TemporalAdjusters.firstDayOfNextMonth());
        System.out.println(&quot;nextMonth = &quot; + nextMonth);
    &#125;
</code></pre>
<h3 id="jdk8的关于时区的定义"><a href="#jdk8的关于时区的定义" class="headerlink" title="jdk8的关于时区的定义"></a>jdk8的关于时区的定义</h3><pre><code>   @Test
    public void test01()&#123;
        // 1.获取所有的时区id
        // ZoneId.getAvailableZoneIds().forEach(System.out::println);

        // 获取当前时间 中国使用的 东八区的时区，比标准时间早8个小时
        LocalDateTime now = LocalDateTime.now();
        System.out.println(&quot;now = &quot; + now); // 2021-05-27T17:17:06.951
        // 获取标准时间
        ZonedDateTime bz = ZonedDateTime.now(Clock.systemUTC());
        System.out.println(&quot;bz = &quot; + bz); // 2021-05-27T09:17:06.952Z

        // 使用计算机默认的时区，创建日期时间
        ZonedDateTime now1 = ZonedDateTime.now();
        System.out.println(&quot;now1 = &quot; + now1); //2021-05-27T17:17:06.952+08:00[Asia/Shanghai]

        // 使用指定的时区创建日期时间
        ZonedDateTime now2 = ZonedDateTime.now(ZoneId.of(&quot;America/Marigot&quot;));
        System.out.println(&quot;now2 = &quot; + now2);

    &#125;
</code></pre>
<h2 id="jdk新的日期和时间api优势"><a href="#jdk新的日期和时间api优势" class="headerlink" title="jdk新的日期和时间api优势"></a>jdk新的日期和时间api优势</h2><p>1.新版api 日期时间不可变 改变时生成新的对象</p>
<p>2.提供不同的两种方式区分了人和机器</p>
<p>3.TemporalAdjuster精确的操作时期</p>
<p>4.线程安全</p>
<h2 id="其他新特性重复注解"><a href="#其他新特性重复注解" class="headerlink" title="其他新特性重复注解"></a>其他新特性重复注解</h2><pre><code>
@MyAnnotation(&quot;test1&quot;)
@MyAnnotation(&quot;test2&quot;)
@MyAnnotation(&quot;test3&quot;)
public class AnnoTest01 &#123;

    @MyAnnotation(&quot;fun1&quot;)
    @MyAnnotation(&quot;fun2&quot;)
    public void test01()&#123;

    &#125;

    /**
     * 解析重复注解
     * @param args
     */
    public static void main(String[] args) throws NoSuchMethodException &#123;
        // 获取类中标注的重复注解
        MyAnnotation[] annotationsByType = AnnoTest01.class.getAnnotationsByType(MyAnnotation.class);
        for (MyAnnotation myAnnotation : annotationsByType) &#123;
            System.out.println(myAnnotation.value());
        &#125;
        // 获取方法上标注的重复注解
        MyAnnotation[] test01s = AnnoTest01.class.getMethod(&quot;test01&quot;)
                .getAnnotationsByType(MyAnnotation.class);
        for (MyAnnotation test01 : test01s) &#123;
            System.out.println(test01.value());
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h2></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://349264976.github.io">en</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://349264976.github.io/2023/09/06/jdk8%E6%96%B0%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8/">https://349264976.github.io/2023/09/06/jdk8%E6%96%B0%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://349264976.github.io" target="_blank">fuguangmengying</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/09/10/Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%20%E5%B5%A9%E5%B1%B1%E7%89%88/" title="Java 开发手册 嵩山版"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java 开发手册 嵩山版</div></div></a></div><div class="next-post pull-right"><a href="/2023/09/03/mybatis-plus/" title="mybatis_plus"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">mybatis_plus</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">en</div><div class="author-info__description">漫漫长路</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">41</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JDK8%E6%96%B0%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BD%BF%E7%94%A8"><span class="toc-number">1.</span> <span class="toc-text">JDK8新特性学习及使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%88%9D%E4%BD%93%E9%AA%8C"><span class="toc-number">1.1.</span> <span class="toc-text">1.Lambda表达式初体验</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88%E6%AF%94%E8%BE%83"><span class="toc-number">1.2.</span> <span class="toc-text">补充知识集合比较</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E7%9C%81%E7%95%A5%E5%86%99%E6%B3%95"><span class="toc-number">1.2.1.</span> <span class="toc-text">Lambda 表达式的省略写法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%8E%A5%E5%8F%A3%E4%B8%AD%E6%96%B0%E5%A2%9E%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.</span> <span class="toc-text">二、接口中新增的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-0JDK8%E4%B8%AD%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%96%B0%E5%A2%9E"><span class="toc-number">1.3.1.</span> <span class="toc-text">1.0JDK8中接口的新增</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.2.</span> <span class="toc-text">2静态方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%A2%9E%E5%8A%A0%EF%BC%9F"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">为什么要增加？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.3.</span> <span class="toc-text">3默认方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">3.1语法规则</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.4.</span> <span class="toc-text">三、函数式接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%94%B1%E6%9D%A5"><span class="toc-number">1.4.1.</span> <span class="toc-text">1.函数式接口的由来</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.4.2.</span> <span class="toc-text">2.函数式接口介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1Supplier"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">2.1Supplier</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1%E4%BD%BF%E7%94%A8"><span class="toc-number">1.4.3.</span> <span class="toc-text">2.1.1使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2Consumer"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">2.2Consumer</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-Function"><span class="toc-number">1.4.4.</span> <span class="toc-text">2.3 Function</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4Predicate"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">2.4Predicate</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="toc-number">1.5.</span> <span class="toc-text">四、方法引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#User-getUsername-%E7%9B%B8%E5%BD%93%E4%BA%8E"><span class="toc-number">1.6.</span> <span class="toc-text">**User::getUsername **  相当于</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#User-user-gt-user-getUsername"><span class="toc-number">1.7.</span> <span class="toc-text">(User user) -&gt; user.getUsername()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%B0%E5%BF%86%E6%B7%B1%E5%8C%96%E6%A1%88%E4%BE%8B"><span class="toc-number">1.8.</span> <span class="toc-text">记忆深化案例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81Stream-APi"><span class="toc-number">1.9.</span> <span class="toc-text">五、Stream APi</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%9B%86%E5%90%88%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E7%9A%84%E5%BC%8A%E7%AB%AF"><span class="toc-number">1.9.0.1.</span> <span class="toc-text">1.集合处理数据的弊端</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B"><span class="toc-number">1.10.</span> <span class="toc-text">举例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Stream%E6%B5%81%E7%9A%84%E8%8E%B7%E5%8F%96%E6%96%B9%E5%BC%8F"><span class="toc-number">1.10.1.</span> <span class="toc-text">Stream流的获取方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E6%A0%B9%E6%8D%AECollection%E8%8E%B7%E5%8F%96"><span class="toc-number">1.10.1.1.</span> <span class="toc-text">3.1 根据Collection获取</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-Stream%E7%9A%84of%E6%96%B9%E6%B3%95"><span class="toc-number">1.10.2.</span> <span class="toc-text">3.2 Stream的of方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-11-ForEach"><span class="toc-number">1.10.2.1.</span> <span class="toc-text">3.11 ForEach</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-12-Count"><span class="toc-number">1.10.2.2.</span> <span class="toc-text">3.12 Count</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-13Filter"><span class="toc-number">1.10.2.3.</span> <span class="toc-text">3.13Filter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-14Limit"><span class="toc-number">1.10.2.4.</span> <span class="toc-text">3.14Limit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-15Skip"><span class="toc-number">1.10.2.5.</span> <span class="toc-text">3.15Skip</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-16Map%E6%96%B9%E6%B3%95"><span class="toc-number">1.10.2.6.</span> <span class="toc-text">3.16Map方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-17Sorted"><span class="toc-number">1.10.2.7.</span> <span class="toc-text">3.17Sorted</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-18Distinct"><span class="toc-number">1.10.2.8.</span> <span class="toc-text">3.18Distinct</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-19-match"><span class="toc-number">1.10.2.9.</span> <span class="toc-text">3.19 match</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-20Find"><span class="toc-number">1.10.2.10.</span> <span class="toc-text">3.20Find</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-21Max%E5%92%8CMin"><span class="toc-number">1.10.2.11.</span> <span class="toc-text">3.21Max和Min</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-22Reduce%E6%96%B9%E6%B3%95"><span class="toc-number">1.10.2.12.</span> <span class="toc-text">3.22Reduce方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-23-map%E5%92%8Creduce%E7%BB%84%E5%90%88"><span class="toc-number">1.10.2.13.</span> <span class="toc-text">3.23 map和reduce组合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-24MapToInt"><span class="toc-number">1.10.2.14.</span> <span class="toc-text">3.24MapToInt</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-25Concat"><span class="toc-number">1.10.2.15.</span> <span class="toc-text">3.25Concat</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%B5%81%E7%9A%84%E5%B8%B8%E7%94%A8%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="toc-number">1.11.</span> <span class="toc-text">2. 流的常用创建方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%9E%84%E9%80%A0%E6%B5%81%E7%9A%84%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95"><span class="toc-number">1.12.</span> <span class="toc-text">3. 构造流的几种常见方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94-Stream%E5%9C%A8%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">五. Stream在代码中的使用方式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%B5%81%E7%9A%84%E4%B8%AD%E9%97%B4%E6%93%8D%E4%BD%9C"><span class="toc-number">2.1.</span> <span class="toc-text">1. 流的中间操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E7%AD%9B%E9%80%89%E8%BF%87%E6%BB%A4"><span class="toc-number">2.1.1.</span> <span class="toc-text">1.1 筛选过滤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E6%8E%92%E5%BA%8F"><span class="toc-number">2.1.2.</span> <span class="toc-text">1.2 排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E6%98%A0%E5%B0%84"><span class="toc-number">2.1.3.</span> <span class="toc-text">1.3 映射</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%B5%81%E7%9A%84%E7%BB%88%E6%AD%A2%E6%93%8D%E4%BD%9C"><span class="toc-number">2.2.</span> <span class="toc-text">2. 流的终止操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%8C%B9%E9%85%8D%E3%80%81%E8%81%9A%E5%90%88%E6%93%8D%E4%BD%9C"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.1 匹配、聚合操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-Collector-%E5%B7%A5%E5%85%B7%E5%BA%93%EF%BC%9ACollectors"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2 Collector 工具库：Collectors</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B"><span class="toc-number">2.2.3.</span> <span class="toc-text">综合案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89-%E7%BB%93%E6%9E%9C%E6%94%B6%E9%9B%86"><span class="toc-number">2.2.4.</span> <span class="toc-text">三 结果收集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3%E7%BB%93%E6%9E%9C%E9%9B%86%E8%81%9A%E5%90%88%E8%AE%A1%E7%AE%97"><span class="toc-number">2.2.5.</span> <span class="toc-text">5.3结果集聚合计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4%E5%B9%B6%E8%A1%8C%E7%9A%84Stream"><span class="toc-number">2.2.6.</span> <span class="toc-text">5.4并行的Stream</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E6%B5%81%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">2.2.6.0.1.</span> <span class="toc-text">并行流的线程安全问题</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ForkJoin%E8%AF%A6%E8%A7%A3"><span class="toc-number">3.</span> <span class="toc-text">ForkJoin详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ForkJoin%E7%AE%80%E4%BB%8B"><span class="toc-number">3.1.</span> <span class="toc-text">ForkJoin简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%B9%B6%E5%8F%91%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.2.</span> <span class="toc-text">并行和并发的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E7%AA%83%E5%8F%96%E7%AE%97%E6%B3%95"><span class="toc-number">3.3.</span> <span class="toc-text">工作窃取算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B1%821%E5%88%B01%E4%BA%BF%E7%9A%84%E5%92%8C"><span class="toc-number">3.4.</span> <span class="toc-text">求1到1亿的和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ForkJoin%E6%A1%86%E6%9E%B6%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.5.</span> <span class="toc-text">ForkJoin框架实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ForkJoinPool"><span class="toc-number">3.5.1.</span> <span class="toc-text">ForkJoinPool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ForkJoinTask"><span class="toc-number">3.5.2.</span> <span class="toc-text">ForkJoinTask</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ForkJoinWorkerThread"><span class="toc-number">3.5.3.</span> <span class="toc-text">ForkJoinWorkerThread</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ForkJoinTask%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">3.5.4.</span> <span class="toc-text">ForkJoinTask启动方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.6.</span> <span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Optional"><span class="toc-number">3.6.1.</span> <span class="toc-text">Optional</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-8%E7%89%B9%E6%80%A7%E4%B9%8BOptional%E8%AF%A6%E8%A7%A3"><span class="toc-number">4.</span> <span class="toc-text">Java 8特性之Optional详解</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81Optional%E7%B1%BB-%E7%AE%80%E4%BB%8B"><span class="toc-number">5.</span> <span class="toc-text">一、Optional类 简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Optional%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">6.</span> <span class="toc-text">二、Optional类的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA%EF%BC%9A"><span class="toc-number">6.1.</span> <span class="toc-text">1. 创建：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Optional%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E4%BB%8B%E7%BB%8D"><span class="toc-number">6.1.0.0.1.</span> <span class="toc-text">Optional中的常用方法介绍</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%8E%B7%E5%8F%96%EF%BC%9A"><span class="toc-number">6.2.</span> <span class="toc-text">2. 获取：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%88%A4%E6%96%AD%EF%BC%9A"><span class="toc-number">6.3.</span> <span class="toc-text">3. 判断：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#orElse-%E5%92%8C-orElseGet-%E7%9A%84%E4%B8%8D%E5%90%8C%E4%B9%8B%E5%A4%84"><span class="toc-number">6.3.1.</span> <span class="toc-text">orElse() 和 orElseGet() 的不同之处</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81jdk%E7%9A%84%E6%97%B6%E9%97%B4%E6%93%8D%E4%BD%9C"><span class="toc-number">6.4.</span> <span class="toc-text">四、jdk的时间操作</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JDK8%E6%97%B6%E9%97%B4API%E6%95%B4%E7%90%86"><span class="toc-number">7.</span> <span class="toc-text">JDK8时间API整理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1%E3%80%81%E6%97%B6%E9%97%B4API"><span class="toc-number">7.0.1.</span> <span class="toc-text">1.1、时间API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK8%E6%97%B6%E9%97%B4%E6%93%8D%E4%BD%9Cdemo"><span class="toc-number">7.0.2.</span> <span class="toc-text">JDK8时间操作demo</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E7%9A%84%E4%BF%AE%E6%94%B9"><span class="toc-number">7.0.2.1.</span> <span class="toc-text">日期时间的修改</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E7%9A%84%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="toc-number">7.0.3.</span> <span class="toc-text">日期的解析与格式化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Instant-%E7%B1%BB"><span class="toc-number">7.0.4.</span> <span class="toc-text">Instant 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E5%B7%AE"><span class="toc-number">7.0.5.</span> <span class="toc-text">计算日期时间差</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jdk8%E7%9A%84%E5%85%B3%E4%BA%8E%E6%97%B6%E5%8C%BA%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">7.0.6.</span> <span class="toc-text">jdk8的关于时区的定义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jdk%E6%96%B0%E7%9A%84%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4api%E4%BC%98%E5%8A%BF"><span class="toc-number">7.1.</span> <span class="toc-text">jdk新的日期和时间api优势</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%96%B0%E7%89%B9%E6%80%A7%E9%87%8D%E5%A4%8D%E6%B3%A8%E8%A7%A3"><span class="toc-number">7.2.</span> <span class="toc-text">其他新特性重复注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3"><span class="toc-number">7.3.</span> <span class="toc-text">类型注解</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/17/RabbitMqhm/" title="RabbitMqhm">RabbitMqhm</a><time datetime="2023-10-17T14:37:58.000Z" title="发表于 2023-10-17 22:37:58">2023-10-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/05/%E5%BE%AE%E6%9C%8D%E5%8A%A1learning/" title="微服务learning">微服务learning</a><time datetime="2023-10-05T12:54:07.000Z" title="发表于 2023-10-05 20:54:07">2023-10-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/09/27/testphotos/" title="testphotos">testphotos</a><time datetime="2023-09-27T12:46:43.000Z" title="发表于 2023-09-27 20:46:43">2023-09-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/09/19/docker%E5%AD%A6%E4%B9%A0/" title="docker学习">docker学习</a><time datetime="2023-09-19T13:24:15.000Z" title="发表于 2023-09-19 21:24:15">2023-09-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/09/11/Springsecurity%E5%85%A5%E9%97%A8/" title="Springsecurity入门">Springsecurity入门</a><time datetime="2023-09-11T14:40:54.000Z" title="发表于 2023-09-11 22:40:54">2023-09-11</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By en</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>