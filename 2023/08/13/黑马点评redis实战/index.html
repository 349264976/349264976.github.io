<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>黑马点评redis实战 | fuguangmengying</title><meta name="author" content="en"><meta name="copyright" content="en"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="开篇 redis实战 黑马点评1.0 redis项目部署hmdp 前端采用nginx直接运行即可 注意*** 前端不要有中文路径***  后端导入项目修改redis配置 虚拟机ip 端口 redis是否有密码 mysql账号密码 maven配置   功能1发送短信验证码 采用session做记录小功能  ctrl+h开启所有类展示图  工具类正则校验  &#x2F;**  * @author 虎哥  *&#x2F;">
<meta property="og:type" content="article">
<meta property="og:title" content="黑马点评redis实战">
<meta property="og:url" content="https://349264976.github.io/2023/08/13/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84redis%E5%AE%9E%E6%88%98/index.html">
<meta property="og:site_name" content="fuguangmengying">
<meta property="og:description" content="开篇 redis实战 黑马点评1.0 redis项目部署hmdp 前端采用nginx直接运行即可 注意*** 前端不要有中文路径***  后端导入项目修改redis配置 虚拟机ip 端口 redis是否有密码 mysql账号密码 maven配置   功能1发送短信验证码 采用session做记录小功能  ctrl+h开启所有类展示图  工具类正则校验  &#x2F;**  * @author 虎哥  *&#x2F;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://349264976.github.io/img/avatar.jpg">
<meta property="article:published_time" content="2023-08-13T03:33:05.000Z">
<meta property="article:modified_time" content="2023-08-15T15:34:16.583Z">
<meta property="article:author" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://349264976.github.io/img/avatar.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://349264976.github.io/2023/08/13/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84redis%E5%AE%9E%E6%88%98/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '黑马点评redis实战',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-08-15 23:34:16'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">31</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/default_top_img.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="fuguangmengying"><span class="site-name">fuguangmengying</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">黑马点评redis实战</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-08-13T03:33:05.000Z" title="发表于 2023-08-13 11:33:05">2023-08-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-08-15T15:34:16.583Z" title="更新于 2023-08-15 23:34:16">2023-08-15</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="黑马点评redis实战"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="开篇-redis实战-黑马点评"><a href="#开篇-redis实战-黑马点评" class="headerlink" title="开篇 redis实战 黑马点评"></a>开篇 redis实战 黑马点评</h1><h2 id="1-0-redis项目部署hmdp"><a href="#1-0-redis项目部署hmdp" class="headerlink" title="1.0 redis项目部署hmdp"></a>1.0 redis项目部署hmdp</h2><ul>
<li><p>前端采用nginx直接运行即可 注意*** 前端不要有中文路径***</p>
</li>
<li><p>后端导入项目修改redis配置 虚拟机ip 端口 redis是否有密码 mysql账号密码 maven配置</p>
</li>
</ul>
<h4 id="功能1发送短信验证码-采用session做"><a href="#功能1发送短信验证码-采用session做" class="headerlink" title="功能1发送短信验证码 采用session做"></a>功能1发送短信验证码 采用session做</h4><p>记录小功能</p>
<ul>
<li><em><strong>ctrl+h开启所有类展示图</strong></em></li>
</ul>
<p><strong>工具类正则校验</strong></p>
<pre><code>
/**
 * @author 虎哥
 */
public abstract class RegexPatterns &#123;
    /**
     * 手机号正则
     */
    public static final String PHONE_REGEX = &quot;^1([38][0-9]|4[579]|5[0-3,5-9]|6[6]|7[0135678]|9[89])\\d&#123;8&#125;$&quot;;
    /**
     * 邮箱正则
     */
    public static final String EMAIL_REGEX = &quot;^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\\.[a-zA-Z0-9_-]+)+$&quot;;
    /**
     * 密码正则。4~32位的字母、数字、下划线
     */
    public static final String PASSWORD_REGEX = &quot;^\\w&#123;4,32&#125;$&quot;;
    /**
     * 验证码正则, 6位数字或字母
     */
    public static final String VERIFY_CODE_REGEX = &quot;^[a-zA-Z\\d]&#123;6&#125;$&quot;;

&#125;
</code></pre>
<h3 id="初期方案"><a href="#初期方案" class="headerlink" title="初期方案"></a>初期方案</h3><h3 id="1-2-、基于Session实现登录流程"><a href="#1-2-、基于Session实现登录流程" class="headerlink" title="1.2 、基于Session实现登录流程"></a>1.2 、基于Session实现登录流程</h3><p><strong>发送验证码：</strong></p>
<p>用户在提交手机号后，会校验手机号是否合法，如果不合法，则要求用户重新输入手机号</p>
<p>如果手机号合法，后台此时生成对应的验证码，同时将验证码进行保存，然后再通过短信的方式将验证码发送给用户</p>
<p><strong>短信验证码登录、注册：</strong></p>
<p>用户将验证码和手机号进行输入，后台从session中拿到当前验证码，然后和用户输入的验证码进行校验，如果不一致，则无法通过校验，如果一致，则后台根据手机号查询用户，如果用户不存在，则为用户创建账号信息，保存到数据库，无论是否存在，都会将用户信息保存到session中，方便后续获得当前登录信息</p>
<p><strong>校验登录状态:</strong></p>
<p>用户在请求时候，会从cookie中携带者JsessionId到后台，后台通过JsessionId从session中拿到用户信息，如果没有session信息，则进行拦截，如果有session信息，则将用户信息保存到threadLocal中，并且放行</p>
<p><img src="/2023/08/13/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84redis%E5%AE%9E%E6%88%98/personboke/blog/source/_posts/Redis实战篇.assets/1653066208144.png" alt="1653066208144"></p>
<h3 id="1-3-、实现发送短信验证码功能"><a href="#1-3-、实现发送短信验证码功能" class="headerlink" title="1.3 、实现发送短信验证码功能"></a>1.3 、实现发送短信验证码功能</h3><p><strong>页面流程</strong></p>
<p><img src="/2023/08/13/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84redis%E5%AE%9E%E6%88%98/personboke/blog/source/_posts/Redis实战篇.assets/1653067054461.png" alt="1653067054461"></p>
<p><strong>具体代码如下</strong></p>
<p><strong>贴心小提示：</strong></p>
<p>具体逻辑上文已经分析，我们仅 仅只需要按照提示的逻辑写出代码即可。</p>
<ul>
<li>发送验证码</li>
</ul>
<pre><code class="java">    @Override
    public Result sendCode(String phone, HttpSession session) &#123;
        // 1.校验手机号
        if (RegexUtils.isPhoneInvalid(phone)) &#123;
            // 2.如果不符合，返回错误信息
            return Result.fail(&quot;手机号格式错误！&quot;);
        &#125;
        // 3.符合，生成验证码
        String code = RandomUtil.randomNumbers(6);

        // 4.保存验证码到 session
        session.setAttribute(&quot;code&quot;,code);
        // 5.发送验证码
        log.debug(&quot;发送短信验证码成功，验证码：&#123;&#125;&quot;, code);
        // 返回ok
        return Result.ok();
    &#125;
</code></pre>
<ul>
<li>登录</li>
</ul>
<pre><code class="java">    @Override
    public Result login(LoginFormDTO loginForm, HttpSession session) &#123;
        // 1.校验手机号
        String phone = loginForm.getPhone();
        if (RegexUtils.isPhoneInvalid(phone)) &#123;
            // 2.如果不符合，返回错误信息
            return Result.fail(&quot;手机号格式错误！&quot;);
        &#125;
        // 3.校验验证码
        Object cacheCode = session.getAttribute(&quot;code&quot;);
        String code = loginForm.getCode();
        if(cacheCode == null || !cacheCode.toString().equals(code))&#123;
             //3.不一致，报错
            return Result.fail(&quot;验证码错误&quot;);
        &#125;
        //一致，根据手机号查询用户
        User user = query().eq(&quot;phone&quot;, phone).one();

        //5.判断用户是否存在
        if(user == null)&#123;
            //不存在，则创建
            user =  createUserWithPhone(phone);
        &#125;
        //7.保存用户信息到session中
        session.setAttribute(&quot;user&quot;,user);

        return Result.ok();
    &#125;
</code></pre>
<h3 id="1-4、实现登录拦截功能"><a href="#1-4、实现登录拦截功能" class="headerlink" title="1.4、实现登录拦截功能"></a>1.4、实现登录拦截功能</h3><p><strong>温馨小贴士：tomcat的运行原理</strong></p>
<p><img src="/2023/08/13/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84redis%E5%AE%9E%E6%88%98/personboke/blog/source/_posts/Redis实战篇.assets/1653068196656.png" alt="1653068196656"></p>
<p>当用户发起请求时，会访问我们像tomcat注册的端口，任何程序想要运行，都需要有一个线程对当前端口号进行监听，tomcat也不例外，当监听线程知道用户想要和tomcat连接连接时，那会由监听线程创建socket连接，socket都是成对出现的，用户通过socket像互相传递数据，当tomcat端的socket接受到数据后，此时监听线程会从tomcat的线程池中取出一个线程执行用户请求，在我们的服务部署到tomcat后，线程会找到用户想要访问的工程，然后用这个线程转发到工程中的controller，service，dao中，并且访问对应的DB，在用户执行完请求后，再统一返回，再找到tomcat端的socket，再将数据写回到用户端的socket，完成请求和响应</p>
<p>通过以上讲解，我们可以得知 每个用户其实对应都是去找tomcat线程池中的一个线程来完成工作的， 使用完成后再进行回收，既然每个请求都是独立的，所以在每个用户去访问我们的工程时，我们可以使用threadlocal来做到线程隔离，每个线程操作自己的一份数据</p>
<p><strong>温馨小贴士：关于threadlocal</strong></p>
<p>如果小伙伴们看过threadLocal的源码，你会发现在threadLocal中，无论是他的put方法和他的get方法， 都是先从获得当前用户的线程，然后从线程中取出线程的成员变量map，只要线程不一样，map就不一样，所以可以通过这种方式来做到线程隔离</p>
<p><img src="/2023/08/13/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84redis%E5%AE%9E%E6%88%98/personboke/blog/source/_posts/Redis实战篇.assets/1653068874258.png" alt="1653068874258"></p>
<p>拦截器代码</p>
<pre><code class="Java">public class LoginInterceptor implements HandlerInterceptor &#123;

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;
       //1.获取session
        HttpSession session = request.getSession();
        //2.获取session中的用户
        Object user = session.getAttribute(&quot;user&quot;);
        //3.判断用户是否存在
        if(user == null)&#123;
              //4.不存在，拦截，返回401状态码
              response.setStatus(401);
              return false;
        &#125;
        //5.存在，保存用户信息到Threadlocal
        UserHolder.saveUser((User)user);
        //6.放行
        return true;
    &#125;
&#125;
</code></pre>
<p>让拦截器生效</p>
<pre><code class="java">@Configuration
public class MvcConfig implements WebMvcConfigurer &#123;

    @Resource
    private StringRedisTemplate stringRedisTemplate;

    @Override
    public void addInterceptors(InterceptorRegistry registry) &#123;
        // 登录拦截器
        registry.addInterceptor(new LoginInterceptor())
                .excludePathPatterns(
                        &quot;/shop/**&quot;,
                        &quot;/voucher/**&quot;,
                        &quot;/shop-type/**&quot;,
                        &quot;/upload/**&quot;,
                        &quot;/blog/hot&quot;,
                        &quot;/user/code&quot;,
                        &quot;/user/login&quot;
                ).order(1);
        // token刷新的拦截器
        registry.addInterceptor(new RefreshTokenInterceptor(stringRedisTemplate)).addPathPatterns(&quot;/**&quot;).order(0);
    &#125;
&#125;
</code></pre>
<h3 id="1-5、隐藏用户敏感信息"><a href="#1-5、隐藏用户敏感信息" class="headerlink" title="1.5、隐藏用户敏感信息"></a>1.5、隐藏用户敏感信息</h3><p>我们通过浏览器观察到此时用户的全部信息都在，这样极为不靠谱，所以我们应当在返回用户信息之前，将用户的敏感信息进行隐藏，采用的核心思路就是书写一个UserDto对象，这个UserDto对象就没有敏感信息了，我们在返回前，将有用户敏感信息的User对象转化成没有敏感信息的UserDto对象，那么就能够避免这个尴尬的问题了</p>
<p><strong>在登录方法处修改</strong></p>
<pre><code class="java">//7.保存用户信息到session中
session.setAttribute(&quot;user&quot;, BeanUtils.copyProperties(user,UserDTO.class));
</code></pre>
<p><strong>在拦截器处：</strong></p>
<pre><code class="java">//5.存在，保存用户信息到Threadlocal
UserHolder.saveUser((UserDTO) user);
</code></pre>
<p><strong>在UserHolder处：将user对象换成UserDTO</strong></p>
<pre><code class="java">public class UserHolder &#123;
    private static final ThreadLocal&lt;UserDTO&gt; tl = new ThreadLocal&lt;&gt;();

    public static void saveUser(UserDTO user)&#123;
        tl.set(user);
    &#125;

    public static UserDTO getUser()&#123;
        return tl.get();
    &#125;

    public static void removeUser()&#123;
        tl.remove();
    &#125;
&#125;
</code></pre>
<h3 id="1-6、session共享问题"><a href="#1-6、session共享问题" class="headerlink" title="1.6、session共享问题"></a>1.6、session共享问题</h3><p><strong>核心思路分析：</strong></p>
<p>每个tomcat中都有一份属于自己的session,假设用户第一次访问第一台tomcat，并且把自己的信息存放到第一台服务器的session中，但是第二次这个用户访问到了第二台tomcat，那么在第二台服务器上，肯定没有第一台服务器存放的session，所以此时 整个登录拦截功能就会出现问题，我们能如何解决这个问题呢？早期的方案是session拷贝，就是说虽然每个tomcat上都有不同的session，但是每当任意一台服务器的session修改时，都会同步给其他的Tomcat服务器的session，这样的话，就可以实现session的共享了</p>
<p>但是这种方案具有两个大问题</p>
<p>1、每台服务器中都有完整的一份session数据，服务器压力过大。</p>
<p>2、session拷贝数据时，可能会出现延迟</p>
<p>所以咱们后来采用的方案都是基于redis来完成，我们把session换成redis，redis数据本身就是共享的，就可以避免session共享的问题了</p>
<p><img src="/2023/08/13/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84redis%E5%AE%9E%E6%88%98/personboke/blog/source/_posts/Redis实战篇.assets/1653069893050.png" alt="1653069893050"></p>
<h3 id="1-7-Redis代替session的业务流程"><a href="#1-7-Redis代替session的业务流程" class="headerlink" title="1.7 Redis代替session的业务流程"></a>1.7 Redis代替session的业务流程</h3><h4 id="1-7-1、设计key的结构"><a href="#1-7-1、设计key的结构" class="headerlink" title="1.7.1、设计key的结构"></a>1.7.1、设计key的结构</h4><p>首先我们要思考一下利用redis来存储数据，那么到底使用哪种结构呢？由于存入的数据比较简单，我们可以考虑使用String，或者是使用哈希，如下图，如果使用String，同学们注意他的value，用多占用一点空间，如果使用哈希，则他的value中只会存储他数据本身，如果不是特别在意内存，其实使用String就可以啦。</p>
<p><img src="/2023/08/13/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84redis%E5%AE%9E%E6%88%98/personboke/blog/source/_posts/Redis实战篇.assets/1653319261433.png" alt="1653319261433"></p>
<h4 id="1-7-2、设计key的具体细节"><a href="#1-7-2、设计key的具体细节" class="headerlink" title="1.7.2、设计key的具体细节"></a>1.7.2、设计key的具体细节</h4><p>所以我们可以使用String结构，就是一个简单的key，value键值对的方式，但是关于key的处理，session他是每个用户都有自己的session，但是redis的key是共享的，咱们就不能使用code了</p>
<p>在设计这个key的时候，我们之前讲过需要满足两点</p>
<p>1、key要具有唯一性</p>
<p>2、key要方便携带</p>
<p>如果我们采用phone：手机号这个的数据来存储当然是可以的，但是如果把这样的敏感数据存储到redis中并且从页面中带过来毕竟不太合适，所以我们在后台生成一个随机串token，然后让前端带来这个token就能完成我们的整体逻辑了</p>
<h4 id="1-7-3、整体访问流程"><a href="#1-7-3、整体访问流程" class="headerlink" title="1.7.3、整体访问流程"></a>1.7.3、整体访问流程</h4><p>当注册完成后，用户去登录会去校验用户提交的手机号和验证码，是否一致，如果一致，则根据手机号查询用户信息，不存在则新建，最后将用户数据保存到redis，并且生成token作为redis的key，当我们校验用户是否登录时，会去携带着token进行访问，从redis中取出token对应的value，判断是否存在这个数据，如果没有则拦截，如果存在则将其保存到threadLocal中，并且放行。</p>
<h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><p>关于用户信息 这里保存为hash结构并且关键细节为 设置用户信息30分钟当超过30分支清除用户信息</p>
<p>但是当用户处于登陆状态时操作 会刷新用户信息保存时长30分钟</p>
<h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1><pre><code class="java">package com.hmdp.service.impl;

import cn.hutool.core.collection.ListUtil;
import cn.hutool.json.JSONUtil;
import com.hmdp.dto.Result;
import com.hmdp.entity.ShopType;
import com.hmdp.mapper.ShopTypeMapper;
import com.hmdp.service.IShopTypeService;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;
import javax.annotation.Resource;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;

import static com.hmdp.utils.RedisConstants.CACHE_SHOPTYPE_KEY;

/**
 * &lt;p&gt;
 *  服务实现类
 * &lt;/p&gt;
 *
 * @author 李开恩
 * @since 
 */
@Service
public class ShopTypeServiceImpl extends ServiceImpl&lt;ShopTypeMapper, ShopType&gt; implements IShopTypeService &#123;
    @Resource
    private RedisTemplate redisTemplate;
    @Override
//    @Cacheable(value = CACHE_SHOPTYPE_KEY,key = &quot;typeList&quot;)
    public Result getShopTypeList() &#123;
        //1.从redis中查询数据库
        List&lt;ShopType&gt; TypeList = redisTemplate.opsForList().range(CACHE_SHOPTYPE_KEY, 0, -1);
        //2.判断是否有元素
        if (TypeList.size() != 0) &#123;
            //3.不存在查询数据库存在直接返回
            return Result.ok(TypeList);
        &#125;
        //4.不存在查询数据库
        List&lt;ShopType&gt; shoptypeList = query().orderByAsc(&quot;sort&quot;).list();
       //5.不存在返回错误
        if (shoptypeList.size()==0)&#123;
            return Result.fail(&quot;Please select is null&quot;);
        &#125;
        //6.存在写入到redis注解实现
        redisTemplate.opsForList().rightPushAll(CACHE_SHOPTYPE_KEY, shoptypeList);
        return Result.ok(shoptypeList);
    &#125;
&#125;
</code></pre>
<h2 id="问题-数据库与缓存不一致性"><a href="#问题-数据库与缓存不一致性" class="headerlink" title="问题 数据库与缓存不一致性"></a>问题 数据库与缓存不一致性</h2><p>先删除缓存在操作数据库</p>
<p>可能会出现线程1 删除缓存 更新数据库 在更新期间</p>
<p>线程2查询缓存未命中（已删除） 查询数据库未修改 缓存旧数据 </p>
<p>线程1更新数据库完成 </p>
<p>此时出现缓存与数据库不一致性</p>
<p>先操作数据库在删除缓存</p>
<p>该操作比较可靠</p>
<h3 id="2-3-缓存更新策略"><a href="#2-3-缓存更新策略" class="headerlink" title="2.3 缓存更新策略"></a>2.3 缓存更新策略</h3><p>缓存更新是redis为了节约内存而设计出来的一个东西，主要是因为内存数据宝贵，当我们向redis插入太多数据，此时就可能会导致缓存中的数据过多，所以redis会对部分数据进行更新，或者把他叫为淘汰更合适。</p>
<p><strong>内存淘汰：</strong>redis自动进行，当redis内存达到咱们设定的max-memery的时候，会自动触发淘汰机制，淘汰掉一些不重要的数据(可以自己设置策略方式)</p>
<p><strong>超时剔除：</strong>当我们给redis设置了过期时间ttl之后，redis会将超时的数据进行删除，方便咱们继续使用缓存</p>
<p><strong>主动更新：</strong>我们可以手动调用方法把缓存删掉，通常用于解决缓存和数据库不一致问题</p>
<p><img src="/2023/08/13/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84redis%E5%AE%9E%E6%88%98/personboke/blog/source/_posts/Redis实战篇.assets/1653322506393.png" alt="1653322506393"></p>
<h4 id="2-3-1-、数据库缓存不一致解决方案："><a href="#2-3-1-、数据库缓存不一致解决方案：" class="headerlink" title="2.3.1 、数据库缓存不一致解决方案："></a>2.3.1 、数据库缓存不一致解决方案：</h4><p>由于我们的<strong>缓存的数据源来自于数据库</strong>,而数据库的<strong>数据是会发生变化的</strong>,因此,如果当数据库中<strong>数据发生变化,而缓存却没有同步</strong>,此时就会有<strong>一致性问题存在</strong>,其后果是:</p>
<p>用户使用缓存中的过时数据,就会产生类似多线程数据安全问题,从而影响业务,产品口碑等;怎么解决呢？有如下几种方案</p>
<p>Cache Aside Pattern 人工编码方式：缓存调用者在更新完数据库后再去更新缓存，也称之为双写方案</p>
<p>Read&#x2F;Write Through Pattern : 由系统本身完成，数据库与缓存的问题交由系统本身去处理</p>
<p>Write Behind Caching Pattern ：调用者只操作缓存，其他线程去异步处理数据库，实现最终一致</p>
<p><img src="/2023/08/13/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84redis%E5%AE%9E%E6%88%98/personboke/blog/source/_posts/Redis实战篇.assets/1653322857620.png" alt="1653322857620"></p>
<h4 id="2-3-2-、数据库和缓存不一致采用什么方案"><a href="#2-3-2-、数据库和缓存不一致采用什么方案" class="headerlink" title="2.3.2 、数据库和缓存不一致采用什么方案"></a>2.3.2 、数据库和缓存不一致采用什么方案</h4><p>综合考虑使用方案一，但是方案一调用者如何处理呢？这里有几个问题</p>
<p>操作缓存和数据库时有三个问题需要考虑：</p>
<p>如果采用第一个方案，那么假设我们每次操作数据库后，都操作缓存，但是中间如果没有人查询，那么这个更新动作实际上只有最后一次生效，中间的更新动作意义并不大，我们可以把缓存删除，等待再次查询时，将缓存中的数据加载出来</p>
<ul>
<li><p>删除缓存还是更新缓存？</p>
<ul>
<li>更新缓存：每次更新数据库都更新缓存，无效写操作较多</li>
<li>删除缓存：更新数据库时让缓存失效，查询时再更新缓存</li>
</ul>
</li>
<li><p>如何保证缓存与数据库的操作的同时成功或失败？</p>
<ul>
<li>单体系统，将缓存与数据库操作放在一个事务</li>
<li>分布式系统，利用TCC等分布式事务方案</li>
</ul>
</li>
</ul>
<p>应该具体操作缓存还是操作数据库，我们应当是先操作数据库，再删除缓存，原因在于，如果你选择第一种方案，在两个线程并发来访问时，假设线程1先来，他先把缓存删了，此时线程2过来，他查询缓存数据并不存在，此时他写入缓存，当他写入缓存后，线程1再执行更新动作时，实际上写入的就是旧的数据，新的数据被旧数据覆盖了。</p>
<ul>
<li>先操作缓存还是先操作数据库？<ul>
<li>先删除缓存，再操作数据库</li>
<li>先操作数据库，再删除缓存</li>
</ul>
</li>
</ul>
<p><img src="/2023/08/13/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84redis%E5%AE%9E%E6%88%98/personboke/blog/source/_posts/Redis实战篇.assets/1653323595206.png" alt="1653323595206"></p>
<h3 id="2-4-实现商铺和缓存与数据库双写一致"><a href="#2-4-实现商铺和缓存与数据库双写一致" class="headerlink" title="2.4 实现商铺和缓存与数据库双写一致"></a>2.4 实现商铺和缓存与数据库双写一致</h3><p>核心思路如下：</p>
<p>修改ShopController中的业务逻辑，满足下面的需求：</p>
<p>根据id查询店铺时，如果缓存未命中，则查询数据库，将数据库结果写入缓存，并设置超时时间</p>
<p>根据id修改店铺时，先修改数据库，再删除缓存</p>
<p><strong>修改重点代码1</strong>：修改<strong>ShopServiceImpl</strong>的queryById方法</p>
<p><strong>设置redis缓存时添加过期时间</strong></p>
<p><img src="/2023/08/13/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84redis%E5%AE%9E%E6%88%98/personboke/blog/source/_posts/Redis实战篇.assets/1653325871232.png" alt="1653325871232"></p>
<p><strong>修改重点代码2</strong></p>
<p>代码分析：通过之前的淘汰，我们确定了采用删除策略，来解决双写问题，当我们修改了数据之后，然后把缓存中的数据进行删除，查询时发现缓存中没有数据，则会从mysql中加载最新的数据，从而避免数据库和缓存不一致的问题</p>
<p><img src="/2023/08/13/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84redis%E5%AE%9E%E6%88%98/personboke/blog/source/_posts/Redis实战篇.assets/1653325929549.png" alt="1653325929549"></p>
<h3 id="2-5-缓存穿透问题的解决思路"><a href="#2-5-缓存穿透问题的解决思路" class="headerlink" title="2.5 缓存穿透问题的解决思路"></a>2.5 缓存穿透问题的解决思路</h3><p>缓存穿透 ：缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。</p>
<p>常见的解决方案有两种：</p>
<ul>
<li>缓存空对象<ul>
<li>优点：实现简单，维护方便</li>
<li>缺点：<ul>
<li>额外的内存消耗</li>
<li>可能造成短期的不一致</li>
</ul>
</li>
</ul>
</li>
<li>布隆过滤<ul>
<li>优点：内存占用较少，没有多余key</li>
<li>缺点：<ul>
<li>实现复杂</li>
<li>存在误判可能</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>缓存空对象思路分析：</strong>当我们客户端访问不存在的数据时，先请求redis，但是此时redis中没有数据，此时会访问到数据库，但是数据库中也没有数据，这个数据穿透了缓存，直击数据库，我们都知道数据库能够承载的并发不如redis这么高，如果大量的请求同时过来访问这种不存在的数据，这些请求就都会访问到数据库，简单的解决方案就是哪怕这个数据在数据库中也不存在，我们也把这个数据存入到redis中去，这样，下次用户过来访问这个不存在的数据，那么在redis中也能找到这个数据就不会进入到缓存了</p>
<p><strong>布隆过滤：</strong>布隆过滤器其实采用的是哈希思想来解决这个问题，通过一个庞大的二进制数组，走哈希思想去判断当前这个要查询的这个数据是否存在，如果布隆过滤器判断存在，则放行，这个请求会去访问redis，哪怕此时redis中的数据过期了，但是数据库中一定存在这个数据，在数据库中查询出来这个数据后，再将其放入到redis中，</p>
<p>假设布隆过滤器判断这个数据不存在，则直接返回</p>
<p>这种方式优点在于节约内存空间，存在误判，误判原因在于：布隆过滤器走的是哈希思想，只要哈希思想，就可能存在哈希冲突</p>
<p><img src="/2023/08/13/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84redis%E5%AE%9E%E6%88%98/personboke/blog/source/_posts/Redis实战篇.assets/1653326156516.png" alt="1653326156516"></p>
<h2 id="redis热点问题"><a href="#redis热点问题" class="headerlink" title="redis热点问题"></a>redis热点问题</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p><strong>指的是缓存中没有数据&#x2F;数据库中没有此数据不会做缓存的情况下 但是却有大量请求请求到数据库并且不会缓存就很可怕</strong>  </p>
<p><strong>解决方案</strong> </p>
<p>  <strong>1.缓存空数据 对于请求的数据如果没查到就缓存空数据 前端再次请求从缓存中去拿 拿出来判断为空则没有该数据</strong>  </p>
<p><strong>2.布隆过滤器 了解 可以设置布隆过滤器 他存储的是数据库中数据的哈希值 一种算法 可以对比请求的数据进行对比请求过滤 但是这中情况可能会有哈希冲突（了解）误判为存在实际上不存在</strong></p>
<p><strong>3.对于查询的id做复杂化处理 比如设置更长的id更复杂的配合</strong> </p>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p><strong>大量的缓存数据同一时间失效 或者redis服务器宕机</strong></p>
<p><strong>解决方案 1.设置不同的过期时间</strong></p>
<p><strong>2.集群模式 高可用配置</strong></p>
<h3 id="缓存穿透-1"><a href="#缓存穿透-1" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>热点数据失效 一些热点数据被大量访问 同时缓存失效 请求就会打在数据库上导致数据库崩溃</p>
<p>互斥锁</p>
<p>1.多个线程同时在请求数据</p>
<p>只会有一个线程构建缓存数据 其他数据请求锁 如果请求不到就等待 休眠一会在请求</p>
<p>2.设置逻辑过期 </p>
<p>设置缓存数据的逻辑过期时间</p>
<p>第一个线程获取数据 发现缓存实现 开启一个新线程 重建缓存 自己返回旧数据 在重建过程中 所有线程都是旧数据  不保证一致性 有额外内存消耗 保证了高可用用户交互性比较好 </p>
<pre><code>@Override
    public Result queryByid(Long id) &#123;

        //缓存穿透
//        Shop shop = queryWithPassThrough(id);

        //互斥锁解决缓存击穿
        Shop shop = queryWithMutex(id);
        if (shop == null) &#123;
            return Result.fail(&quot;店铺不存在&quot;);
        &#125;

        return Result.ok(shop);
    &#125;
//
//    @Override
//    public Result queryByid(Long id) &#123;
//        //1.从redis查询商铺缓存
//        String shopJson = stringRedisTemplate.opsForValue().get(CACHE_SHOP_KEY+ id);
//        //2.判断是否存在
//        if (StrUtil.isNotBlank(shopJson)) &#123;
//            //3.存在直接返回
//            Shop shop = JSONUtil.toBean(shopJson, Shop.class);
//            return  Result.ok(shop);
//        &#125;
//        //判断命中的是否是空值
//        if(shopJson != null) &#123;
//            //返回一个错误信息
//            return Result.fail(&quot;店铺信息不存在&quot;);
//        &#125;
//        //4.不存在根据id查询数据库
//        Shop shop=getById(id);
//        //5.不存在返回错误
//        if (shop == null) &#123;
//            //将空值写入到redis
//            stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY+ id,&quot;&quot;,CACHE_NULL_TTL,TimeUnit.MINUTES);
//            return Result.fail(&quot;Shop not found&quot;);
//        &#125;
//        //6.存在写入到redis
//        stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY+id,JSONUtil.toJsonStr(shop),30L, TimeUnit.MINUTES);
//        return Result.ok(shop);
//    &#125;
    //缓存穿透
    public Shop queryWithPassThrough(Long id)&#123;
        //1.从redis查询商铺缓存
        String shopJson = stringRedisTemplate.opsForValue().get(CACHE_SHOP_KEY+ id);
        //2.判断是否存在
        if (StrUtil.isNotBlank(shopJson)) &#123;
            //3.存在直接返回
            return  JSONUtil.toBean(shopJson, Shop.class);

        &#125;
        //判断命中的是否是空值
        if(shopJson != null) &#123;
            //返回一个错误信息
           return null;
        &#125;
        //4.不存在根据id查询数据库
        Shop shop=getById(id);
        //5.不存在返回错误
        if (shop == null) &#123;
            //将空值写入到redis
            stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY+ id,&quot;&quot;,CACHE_NULL_TTL,TimeUnit.MINUTES);
            return null;
        &#125;
        //6.存在写入到redis
        stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY+id,JSONUtil.toJsonStr(shop),30L, TimeUnit.MINUTES);
        return shop;
    &#125;

    public Shop queryWithMutex(Long id) &#123;
        String locKey=&quot;lock:shop&quot;+id;
        Shop shop=null;
        try &#123;//1.从redis查询商铺缓存
        String shopJson = stringRedisTemplate.opsForValue().get(CACHE_SHOP_KEY+ id);
        //2.判断是否存在
        if (StrUtil.isNotBlank(shopJson)) &#123;
            //3.存在直接返回
            return  JSONUtil.toBean(shopJson, Shop.class);

        &#125;
        //判断命中的是否是空值
        if(shopJson != null) &#123;
            //返回一个错误信息
            return null;
        &#125;
        //4.不存在根据id查询数据库
        //4.1获取互斥锁

        boolean isLock=tryLock(locKey);
        //4.2判断是否成功
        if (!isLock)&#123;
            //4.3失败则休眠并重试
                Thread.sleep(50);
            return queryWithMutex(id);
        &#125;
        //4.4成功根据id查询数据库
      shop=getById(id);
        //5.不存在返回错误
        if (shop == null) &#123;
            //将空值写入到redis
            stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY+ id,&quot;&quot;,CACHE_NULL_TTL,TimeUnit.MINUTES);
            return null;
        &#125;
        //6.存在写入到redis
        stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY+id,JSONUtil.toJsonStr(shop),30L, TimeUnit.MINUTES);
        &#125; catch (InterruptedException e) &#123;
            throw new RuntimeException(e);
        &#125;finally &#123;
            //7.释放互斥锁
            unlock(locKey);
        &#125;
        return shop;
    &#125;

    private boolean tryLock(String key)&#123;
        Boolean aBoolean = stringRedisTemplate.opsForValue().setIfAbsent(key, &quot;1&quot;, 10, TimeUnit.SECONDS);
        return BooleanUtil.isTrue(aBoolean);
    &#125;
    private void unlock(String key)&#123;
            stringRedisTemplate.delete(key);
    &#125;

    @Override
    @Transactional
    public Result updateShop(Shop shop) &#123;

        //1.更新数据库
        updateById(shop);

        if (shop.getId() ==null)&#123;
            return Result.fail(&quot;Shop not found&quot;);
        &#125;
        //2.删除缓存
        stringRedisTemplate.delete(CACHE_SHOP_KEY+shop.getId());


        return Result.ok();
    &#125;
&#125;
</code></pre>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://349264976.github.io">en</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://349264976.github.io/2023/08/13/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84redis%E5%AE%9E%E6%88%98/">https://349264976.github.io/2023/08/13/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84redis%E5%AE%9E%E6%88%98/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://349264976.github.io" target="_blank">fuguangmengying</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/08/13/Redis%E5%AE%9E%E6%88%98%E7%AF%87/" title=""><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info"></div></div></a></div><div class="next-post pull-right"><a href="/2023/08/08/Pinia/" title="Vue3 状态管理 - Pinia"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Vue3 状态管理 - Pinia</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">en</div><div class="author-info__description">漫漫长路</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">31</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%80%E7%AF%87-redis%E5%AE%9E%E6%88%98-%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84"><span class="toc-number">1.</span> <span class="toc-text">开篇 redis实战 黑马点评</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-0-redis%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2hmdp"><span class="toc-number">1.1.</span> <span class="toc-text">1.0 redis项目部署hmdp</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD1%E5%8F%91%E9%80%81%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81-%E9%87%87%E7%94%A8session%E5%81%9A"><span class="toc-number">1.1.0.1.</span> <span class="toc-text">功能1发送短信验证码 采用session做</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E6%9C%9F%E6%96%B9%E6%A1%88"><span class="toc-number">1.1.1.</span> <span class="toc-text">初期方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E3%80%81%E5%9F%BA%E4%BA%8ESession%E5%AE%9E%E7%8E%B0%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2 、基于Session实现登录流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E3%80%81%E5%AE%9E%E7%8E%B0%E5%8F%91%E9%80%81%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81%E5%8A%9F%E8%83%BD"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.3 、实现发送短信验证码功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4%E3%80%81%E5%AE%9E%E7%8E%B0%E7%99%BB%E5%BD%95%E6%8B%A6%E6%88%AA%E5%8A%9F%E8%83%BD"><span class="toc-number">1.1.4.</span> <span class="toc-text">1.4、实现登录拦截功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5%E3%80%81%E9%9A%90%E8%97%8F%E7%94%A8%E6%88%B7%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF"><span class="toc-number">1.1.5.</span> <span class="toc-text">1.5、隐藏用户敏感信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6%E3%80%81session%E5%85%B1%E4%BA%AB%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.6.</span> <span class="toc-text">1.6、session共享问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7-Redis%E4%BB%A3%E6%9B%BFsession%E7%9A%84%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B"><span class="toc-number">1.1.7.</span> <span class="toc-text">1.7 Redis代替session的业务流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-7-1%E3%80%81%E8%AE%BE%E8%AE%A1key%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.7.1.</span> <span class="toc-text">1.7.1、设计key的结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-7-2%E3%80%81%E8%AE%BE%E8%AE%A1key%E7%9A%84%E5%85%B7%E4%BD%93%E7%BB%86%E8%8A%82"><span class="toc-number">1.1.7.2.</span> <span class="toc-text">1.7.2、设计key的具体细节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-7-3%E3%80%81%E6%95%B4%E4%BD%93%E8%AE%BF%E9%97%AE%E6%B5%81%E7%A8%8B"><span class="toc-number">1.1.7.3.</span> <span class="toc-text">1.7.3、整体访问流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%86%E8%8A%82"><span class="toc-number">1.2.</span> <span class="toc-text">细节</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%9C%E4%B8%9A"><span class="toc-number">2.</span> <span class="toc-text">作业</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E7%BC%93%E5%AD%98%E4%B8%8D%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">2.1.</span> <span class="toc-text">问题 数据库与缓存不一致性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5"><span class="toc-number">2.1.1.</span> <span class="toc-text">2.3 缓存更新策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%93%E5%AD%98%E4%B8%8D%E4%B8%80%E8%87%B4%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">2.3.1 、数据库缓存不一致解决方案：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%BC%93%E5%AD%98%E4%B8%8D%E4%B8%80%E8%87%B4%E9%87%87%E7%94%A8%E4%BB%80%E4%B9%88%E6%96%B9%E6%A1%88"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">2.3.2 、数据库和缓存不一致采用什么方案</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E5%AE%9E%E7%8E%B0%E5%95%86%E9%93%BA%E5%92%8C%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4"><span class="toc-number">2.1.2.</span> <span class="toc-text">2.4 实现商铺和缓存与数据库双写一致</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF"><span class="toc-number">2.1.3.</span> <span class="toc-text">2.5 缓存穿透问题的解决思路</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis%E7%83%AD%E7%82%B9%E9%97%AE%E9%A2%98"><span class="toc-number">2.2.</span> <span class="toc-text">redis热点问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">2.2.1.</span> <span class="toc-text">缓存穿透</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">2.2.2.</span> <span class="toc-text">缓存雪崩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F-1"><span class="toc-number">2.2.3.</span> <span class="toc-text">缓存穿透</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/13/Redis%E5%AE%9E%E6%88%98%E7%AF%87/" title="无题">无题</a><time datetime="2023-08-13T03:34:38.851Z" title="发表于 2023-08-13 11:34:38">2023-08-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/13/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84redis%E5%AE%9E%E6%88%98/" title="黑马点评redis实战">黑马点评redis实战</a><time datetime="2023-08-13T03:33:05.000Z" title="发表于 2023-08-13 11:33:05">2023-08-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/08/Pinia/" title="Vue3 状态管理 - Pinia">Vue3 状态管理 - Pinia</a><time datetime="2023-08-08T11:55:11.000Z" title="发表于 2023-08-08 19:55:11">2023-08-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/08/Vue3%E5%85%A5%E9%97%A8/" title="无题">无题</a><time datetime="2023-08-08T11:44:00.000Z" title="发表于 2023-08-08 19:44:00">2023-08-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/08/%E5%A4%A7%E4%BA%8B%E4%BB%B6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/" title="无题">无题</a><time datetime="2023-08-08T11:33:00.000Z" title="发表于 2023-08-08 19:33:00">2023-08-08</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By en</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>