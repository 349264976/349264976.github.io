<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>黑马点评redis实战 | fuguangmengying</title><meta name="author" content="en"><meta name="copyright" content="en"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="开篇 redis实战 黑马点评1.0 redis项目部署hmdp 前端采用nginx直接运行即可 注意*** 前端不要有中文路径***  后端导入项目修改redis配置 虚拟机ip 端口 redis是否有密码 mysql账号密码 maven配置   功能1发送短信验证码 采用session做记录小功能  ctrl+h开启所有类展示图  工具类正则校验  &#x2F;**  * @author 虎哥  *&#x2F;">
<meta property="og:type" content="article">
<meta property="og:title" content="黑马点评redis实战">
<meta property="og:url" content="https://349264976.github.io/2023/08/13/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84redis%E5%AE%9E%E6%88%98/index.html">
<meta property="og:site_name" content="fuguangmengying">
<meta property="og:description" content="开篇 redis实战 黑马点评1.0 redis项目部署hmdp 前端采用nginx直接运行即可 注意*** 前端不要有中文路径***  后端导入项目修改redis配置 虚拟机ip 端口 redis是否有密码 mysql账号密码 maven配置   功能1发送短信验证码 采用session做记录小功能  ctrl+h开启所有类展示图  工具类正则校验  &#x2F;**  * @author 虎哥  *&#x2F;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://349264976.github.io/img/avatar.jpg">
<meta property="article:published_time" content="2023-08-13T03:33:05.000Z">
<meta property="article:modified_time" content="2023-08-27T09:48:49.475Z">
<meta property="article:author" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://349264976.github.io/img/avatar.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://349264976.github.io/2023/08/13/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84redis%E5%AE%9E%E6%88%98/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '黑马点评redis实战',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-08-27 17:48:49'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">36</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/default_top_img.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="fuguangmengying"><span class="site-name">fuguangmengying</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">黑马点评redis实战</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-08-13T03:33:05.000Z" title="发表于 2023-08-13 11:33:05">2023-08-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-08-27T09:48:49.475Z" title="更新于 2023-08-27 17:48:49">2023-08-27</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="黑马点评redis实战"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="开篇-redis实战-黑马点评"><a href="#开篇-redis实战-黑马点评" class="headerlink" title="开篇 redis实战 黑马点评"></a>开篇 redis实战 黑马点评</h1><h2 id="1-0-redis项目部署hmdp"><a href="#1-0-redis项目部署hmdp" class="headerlink" title="1.0 redis项目部署hmdp"></a>1.0 redis项目部署hmdp</h2><ul>
<li><p>前端采用nginx直接运行即可 注意*** 前端不要有中文路径***</p>
</li>
<li><p>后端导入项目修改redis配置 虚拟机ip 端口 redis是否有密码 mysql账号密码 maven配置</p>
</li>
</ul>
<h4 id="功能1发送短信验证码-采用session做"><a href="#功能1发送短信验证码-采用session做" class="headerlink" title="功能1发送短信验证码 采用session做"></a>功能1发送短信验证码 采用session做</h4><p>记录小功能</p>
<ul>
<li><em><strong>ctrl+h开启所有类展示图</strong></em></li>
</ul>
<p><strong>工具类正则校验</strong></p>
<pre><code>
/**
 * @author 虎哥
 */
public abstract class RegexPatterns &#123;
    /**
     * 手机号正则
     */
    public static final String PHONE_REGEX = &quot;^1([38][0-9]|4[579]|5[0-3,5-9]|6[6]|7[0135678]|9[89])\\d&#123;8&#125;$&quot;;
    /**
     * 邮箱正则
     */
    public static final String EMAIL_REGEX = &quot;^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\\.[a-zA-Z0-9_-]+)+$&quot;;
    /**
     * 密码正则。4~32位的字母、数字、下划线
     */
    public static final String PASSWORD_REGEX = &quot;^\\w&#123;4,32&#125;$&quot;;
    /**
     * 验证码正则, 6位数字或字母
     */
    public static final String VERIFY_CODE_REGEX = &quot;^[a-zA-Z\\d]&#123;6&#125;$&quot;;

&#125;
</code></pre>
<h3 id="初期方案"><a href="#初期方案" class="headerlink" title="初期方案"></a>初期方案</h3><h3 id="1-2-、基于Session实现登录流程"><a href="#1-2-、基于Session实现登录流程" class="headerlink" title="1.2 、基于Session实现登录流程"></a>1.2 、基于Session实现登录流程</h3><p><strong>发送验证码：</strong></p>
<p>用户在提交手机号后，会校验手机号是否合法，如果不合法，则要求用户重新输入手机号</p>
<p>如果手机号合法，后台此时生成对应的验证码，同时将验证码进行保存，然后再通过短信的方式将验证码发送给用户</p>
<p><strong>短信验证码登录、注册：</strong></p>
<p>用户将验证码和手机号进行输入，后台从session中拿到当前验证码，然后和用户输入的验证码进行校验，如果不一致，则无法通过校验，如果一致，则后台根据手机号查询用户，如果用户不存在，则为用户创建账号信息，保存到数据库，无论是否存在，都会将用户信息保存到session中，方便后续获得当前登录信息</p>
<p><strong>校验登录状态:</strong></p>
<p>用户在请求时候，会从cookie中携带者JsessionId到后台，后台通过JsessionId从session中拿到用户信息，如果没有session信息，则进行拦截，如果有session信息，则将用户信息保存到threadLocal中，并且放行</p>
<p><img src="/2023/08/13/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84redis%E5%AE%9E%E6%88%98/personboke/blog/source/_posts/Redis实战篇.assets/1653066208144.png" alt="1653066208144"></p>
<h3 id="1-3-、实现发送短信验证码功能"><a href="#1-3-、实现发送短信验证码功能" class="headerlink" title="1.3 、实现发送短信验证码功能"></a>1.3 、实现发送短信验证码功能</h3><p><strong>页面流程</strong></p>
<p><img src="/2023/08/13/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84redis%E5%AE%9E%E6%88%98/personboke/blog/source/_posts/Redis实战篇.assets/1653067054461.png" alt="1653067054461"></p>
<p><strong>具体代码如下</strong></p>
<p><strong>贴心小提示：</strong></p>
<p>具体逻辑上文已经分析，我们仅 仅只需要按照提示的逻辑写出代码即可。</p>
<ul>
<li>发送验证码</li>
</ul>
<pre><code class="java">    @Override
    public Result sendCode(String phone, HttpSession session) &#123;
        // 1.校验手机号
        if (RegexUtils.isPhoneInvalid(phone)) &#123;
            // 2.如果不符合，返回错误信息
            return Result.fail(&quot;手机号格式错误！&quot;);
        &#125;
        // 3.符合，生成验证码
        String code = RandomUtil.randomNumbers(6);

        // 4.保存验证码到 session
        session.setAttribute(&quot;code&quot;,code);
        // 5.发送验证码
        log.debug(&quot;发送短信验证码成功，验证码：&#123;&#125;&quot;, code);
        // 返回ok
        return Result.ok();
    &#125;
</code></pre>
<ul>
<li>登录</li>
</ul>
<pre><code class="java">    @Override
    public Result login(LoginFormDTO loginForm, HttpSession session) &#123;
        // 1.校验手机号
        String phone = loginForm.getPhone();
        if (RegexUtils.isPhoneInvalid(phone)) &#123;
            // 2.如果不符合，返回错误信息
            return Result.fail(&quot;手机号格式错误！&quot;);
        &#125;
        // 3.校验验证码
        Object cacheCode = session.getAttribute(&quot;code&quot;);
        String code = loginForm.getCode();
        if(cacheCode == null || !cacheCode.toString().equals(code))&#123;
             //3.不一致，报错
            return Result.fail(&quot;验证码错误&quot;);
        &#125;
        //一致，根据手机号查询用户
        User user = query().eq(&quot;phone&quot;, phone).one();

        //5.判断用户是否存在
        if(user == null)&#123;
            //不存在，则创建
            user =  createUserWithPhone(phone);
        &#125;
        //7.保存用户信息到session中
        session.setAttribute(&quot;user&quot;,user);

        return Result.ok();
    &#125;
</code></pre>
<h3 id="1-4、实现登录拦截功能"><a href="#1-4、实现登录拦截功能" class="headerlink" title="1.4、实现登录拦截功能"></a>1.4、实现登录拦截功能</h3><p><strong>温馨小贴士：tomcat的运行原理</strong></p>
<p><img src="/2023/08/13/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84redis%E5%AE%9E%E6%88%98/personboke/blog/source/_posts/Redis实战篇.assets/1653068196656.png" alt="1653068196656"></p>
<p>当用户发起请求时，会访问我们像tomcat注册的端口，任何程序想要运行，都需要有一个线程对当前端口号进行监听，tomcat也不例外，当监听线程知道用户想要和tomcat连接连接时，那会由监听线程创建socket连接，socket都是成对出现的，用户通过socket像互相传递数据，当tomcat端的socket接受到数据后，此时监听线程会从tomcat的线程池中取出一个线程执行用户请求，在我们的服务部署到tomcat后，线程会找到用户想要访问的工程，然后用这个线程转发到工程中的controller，service，dao中，并且访问对应的DB，在用户执行完请求后，再统一返回，再找到tomcat端的socket，再将数据写回到用户端的socket，完成请求和响应</p>
<p>通过以上讲解，我们可以得知 每个用户其实对应都是去找tomcat线程池中的一个线程来完成工作的， 使用完成后再进行回收，既然每个请求都是独立的，所以在每个用户去访问我们的工程时，我们可以使用threadlocal来做到线程隔离，每个线程操作自己的一份数据</p>
<p><strong>温馨小贴士：关于threadlocal</strong></p>
<p>如果小伙伴们看过threadLocal的源码，你会发现在threadLocal中，无论是他的put方法和他的get方法， 都是先从获得当前用户的线程，然后从线程中取出线程的成员变量map，只要线程不一样，map就不一样，所以可以通过这种方式来做到线程隔离</p>
<p><img src="/2023/08/13/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84redis%E5%AE%9E%E6%88%98/personboke/blog/source/_posts/Redis实战篇.assets/1653068874258.png" alt="1653068874258"></p>
<p>拦截器代码</p>
<pre><code class="Java">public class LoginInterceptor implements HandlerInterceptor &#123;

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;
       //1.获取session
        HttpSession session = request.getSession();
        //2.获取session中的用户
        Object user = session.getAttribute(&quot;user&quot;);
        //3.判断用户是否存在
        if(user == null)&#123;
              //4.不存在，拦截，返回401状态码
              response.setStatus(401);
              return false;
        &#125;
        //5.存在，保存用户信息到Threadlocal
        UserHolder.saveUser((User)user);
        //6.放行
        return true;
    &#125;
&#125;
</code></pre>
<p>让拦截器生效</p>
<pre><code class="java">@Configuration
public class MvcConfig implements WebMvcConfigurer &#123;

    @Resource
    private StringRedisTemplate stringRedisTemplate;

    @Override
    public void addInterceptors(InterceptorRegistry registry) &#123;
        // 登录拦截器
        registry.addInterceptor(new LoginInterceptor())
                .excludePathPatterns(
                        &quot;/shop/**&quot;,
                        &quot;/voucher/**&quot;,
                        &quot;/shop-type/**&quot;,
                        &quot;/upload/**&quot;,
                        &quot;/blog/hot&quot;,
                        &quot;/user/code&quot;,
                        &quot;/user/login&quot;
                ).order(1);
        // token刷新的拦截器
        registry.addInterceptor(new RefreshTokenInterceptor(stringRedisTemplate)).addPathPatterns(&quot;/**&quot;).order(0);
    &#125;
&#125;
</code></pre>
<h3 id="1-5、隐藏用户敏感信息"><a href="#1-5、隐藏用户敏感信息" class="headerlink" title="1.5、隐藏用户敏感信息"></a>1.5、隐藏用户敏感信息</h3><p>我们通过浏览器观察到此时用户的全部信息都在，这样极为不靠谱，所以我们应当在返回用户信息之前，将用户的敏感信息进行隐藏，采用的核心思路就是书写一个UserDto对象，这个UserDto对象就没有敏感信息了，我们在返回前，将有用户敏感信息的User对象转化成没有敏感信息的UserDto对象，那么就能够避免这个尴尬的问题了</p>
<p><strong>在登录方法处修改</strong></p>
<pre><code class="java">//7.保存用户信息到session中
session.setAttribute(&quot;user&quot;, BeanUtils.copyProperties(user,UserDTO.class));
</code></pre>
<p><strong>在拦截器处：</strong></p>
<pre><code class="java">//5.存在，保存用户信息到Threadlocal
UserHolder.saveUser((UserDTO) user);
</code></pre>
<p><strong>在UserHolder处：将user对象换成UserDTO</strong></p>
<pre><code class="java">public class UserHolder &#123;
    private static final ThreadLocal&lt;UserDTO&gt; tl = new ThreadLocal&lt;&gt;();

    public static void saveUser(UserDTO user)&#123;
        tl.set(user);
    &#125;

    public static UserDTO getUser()&#123;
        return tl.get();
    &#125;

    public static void removeUser()&#123;
        tl.remove();
    &#125;
&#125;
</code></pre>
<h3 id="1-6、session共享问题"><a href="#1-6、session共享问题" class="headerlink" title="1.6、session共享问题"></a>1.6、session共享问题</h3><p><strong>核心思路分析：</strong></p>
<p>每个tomcat中都有一份属于自己的session,假设用户第一次访问第一台tomcat，并且把自己的信息存放到第一台服务器的session中，但是第二次这个用户访问到了第二台tomcat，那么在第二台服务器上，肯定没有第一台服务器存放的session，所以此时 整个登录拦截功能就会出现问题，我们能如何解决这个问题呢？早期的方案是session拷贝，就是说虽然每个tomcat上都有不同的session，但是每当任意一台服务器的session修改时，都会同步给其他的Tomcat服务器的session，这样的话，就可以实现session的共享了</p>
<p>但是这种方案具有两个大问题</p>
<p>1、每台服务器中都有完整的一份session数据，服务器压力过大。</p>
<p>2、session拷贝数据时，可能会出现延迟</p>
<p>所以咱们后来采用的方案都是基于redis来完成，我们把session换成redis，redis数据本身就是共享的，就可以避免session共享的问题了</p>
<p><img src="/2023/08/13/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84redis%E5%AE%9E%E6%88%98/personboke/blog/source/_posts/Redis实战篇.assets/1653069893050.png" alt="1653069893050"></p>
<h3 id="1-7-Redis代替session的业务流程"><a href="#1-7-Redis代替session的业务流程" class="headerlink" title="1.7 Redis代替session的业务流程"></a>1.7 Redis代替session的业务流程</h3><h4 id="1-7-1、设计key的结构"><a href="#1-7-1、设计key的结构" class="headerlink" title="1.7.1、设计key的结构"></a>1.7.1、设计key的结构</h4><p>首先我们要思考一下利用redis来存储数据，那么到底使用哪种结构呢？由于存入的数据比较简单，我们可以考虑使用String，或者是使用哈希，如下图，如果使用String，同学们注意他的value，用多占用一点空间，如果使用哈希，则他的value中只会存储他数据本身，如果不是特别在意内存，其实使用String就可以啦。</p>
<p><img src="/2023/08/13/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84redis%E5%AE%9E%E6%88%98/personboke/blog/source/_posts/Redis实战篇.assets/1653319261433.png" alt="1653319261433"></p>
<h4 id="1-7-2、设计key的具体细节"><a href="#1-7-2、设计key的具体细节" class="headerlink" title="1.7.2、设计key的具体细节"></a>1.7.2、设计key的具体细节</h4><p>所以我们可以使用String结构，就是一个简单的key，value键值对的方式，但是关于key的处理，session他是每个用户都有自己的session，但是redis的key是共享的，咱们就不能使用code了</p>
<p>在设计这个key的时候，我们之前讲过需要满足两点</p>
<p>1、key要具有唯一性</p>
<p>2、key要方便携带</p>
<p>如果我们采用phone：手机号这个的数据来存储当然是可以的，但是如果把这样的敏感数据存储到redis中并且从页面中带过来毕竟不太合适，所以我们在后台生成一个随机串token，然后让前端带来这个token就能完成我们的整体逻辑了</p>
<h4 id="1-7-3、整体访问流程"><a href="#1-7-3、整体访问流程" class="headerlink" title="1.7.3、整体访问流程"></a>1.7.3、整体访问流程</h4><p>当注册完成后，用户去登录会去校验用户提交的手机号和验证码，是否一致，如果一致，则根据手机号查询用户信息，不存在则新建，最后将用户数据保存到redis，并且生成token作为redis的key，当我们校验用户是否登录时，会去携带着token进行访问，从redis中取出token对应的value，判断是否存在这个数据，如果没有则拦截，如果存在则将其保存到threadLocal中，并且放行。</p>
<h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><p>关于用户信息 这里保存为hash结构并且关键细节为 设置用户信息30分钟当超过30分支清除用户信息</p>
<p>但是当用户处于登陆状态时操作 会刷新用户信息保存时长30分钟</p>
<h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1><pre><code class="java">package com.hmdp.service.impl;

import cn.hutool.core.collection.ListUtil;
import cn.hutool.json.JSONUtil;
import com.hmdp.dto.Result;
import com.hmdp.entity.ShopType;
import com.hmdp.mapper.ShopTypeMapper;
import com.hmdp.service.IShopTypeService;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;
import javax.annotation.Resource;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;

import static com.hmdp.utils.RedisConstants.CACHE_SHOPTYPE_KEY;

/**
 * &lt;p&gt;
 *  服务实现类
 * &lt;/p&gt;
 *
 * @author 李开恩
 * @since 
 */
@Service
public class ShopTypeServiceImpl extends ServiceImpl&lt;ShopTypeMapper, ShopType&gt; implements IShopTypeService &#123;
    @Resource
    private RedisTemplate redisTemplate;
    @Override
//    @Cacheable(value = CACHE_SHOPTYPE_KEY,key = &quot;typeList&quot;)
    public Result getShopTypeList() &#123;
        //1.从redis中查询数据库
        List&lt;ShopType&gt; TypeList = redisTemplate.opsForList().range(CACHE_SHOPTYPE_KEY, 0, -1);
        //2.判断是否有元素
        if (TypeList.size() != 0) &#123;
            //3.不存在查询数据库存在直接返回
            return Result.ok(TypeList);
        &#125;
        //4.不存在查询数据库
        List&lt;ShopType&gt; shoptypeList = query().orderByAsc(&quot;sort&quot;).list();
       //5.不存在返回错误
        if (shoptypeList.size()==0)&#123;
            return Result.fail(&quot;Please select is null&quot;);
        &#125;
        //6.存在写入到redis注解实现
        redisTemplate.opsForList().rightPushAll(CACHE_SHOPTYPE_KEY, shoptypeList);
        return Result.ok(shoptypeList);
    &#125;
&#125;
</code></pre>
<h2 id="问题-数据库与缓存不一致性"><a href="#问题-数据库与缓存不一致性" class="headerlink" title="问题 数据库与缓存不一致性"></a>问题 数据库与缓存不一致性</h2><p>先删除缓存在操作数据库</p>
<p>可能会出现线程1 删除缓存 更新数据库 在更新期间</p>
<p>线程2查询缓存未命中（已删除） 查询数据库未修改 缓存旧数据 </p>
<p>线程1更新数据库完成 </p>
<p>此时出现缓存与数据库不一致性</p>
<p>先操作数据库在删除缓存</p>
<p>该操作比较可靠</p>
<h3 id="2-3-缓存更新策略"><a href="#2-3-缓存更新策略" class="headerlink" title="2.3 缓存更新策略"></a>2.3 缓存更新策略</h3><p>缓存更新是redis为了节约内存而设计出来的一个东西，主要是因为内存数据宝贵，当我们向redis插入太多数据，此时就可能会导致缓存中的数据过多，所以redis会对部分数据进行更新，或者把他叫为淘汰更合适。</p>
<p><strong>内存淘汰：</strong>redis自动进行，当redis内存达到咱们设定的max-memery的时候，会自动触发淘汰机制，淘汰掉一些不重要的数据(可以自己设置策略方式)</p>
<p><strong>超时剔除：</strong>当我们给redis设置了过期时间ttl之后，redis会将超时的数据进行删除，方便咱们继续使用缓存</p>
<p><strong>主动更新：</strong>我们可以手动调用方法把缓存删掉，通常用于解决缓存和数据库不一致问题</p>
<p><img src="/2023/08/13/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84redis%E5%AE%9E%E6%88%98/personboke/blog/source/_posts/Redis实战篇.assets/1653322506393.png" alt="1653322506393"></p>
<h4 id="2-3-1-、数据库缓存不一致解决方案："><a href="#2-3-1-、数据库缓存不一致解决方案：" class="headerlink" title="2.3.1 、数据库缓存不一致解决方案："></a>2.3.1 、数据库缓存不一致解决方案：</h4><p>由于我们的<strong>缓存的数据源来自于数据库</strong>,而数据库的<strong>数据是会发生变化的</strong>,因此,如果当数据库中<strong>数据发生变化,而缓存却没有同步</strong>,此时就会有<strong>一致性问题存在</strong>,其后果是:</p>
<p>用户使用缓存中的过时数据,就会产生类似多线程数据安全问题,从而影响业务,产品口碑等;怎么解决呢？有如下几种方案</p>
<p>Cache Aside Pattern 人工编码方式：缓存调用者在更新完数据库后再去更新缓存，也称之为双写方案</p>
<p>Read&#x2F;Write Through Pattern : 由系统本身完成，数据库与缓存的问题交由系统本身去处理</p>
<p>Write Behind Caching Pattern ：调用者只操作缓存，其他线程去异步处理数据库，实现最终一致</p>
<p><img src="/2023/08/13/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84redis%E5%AE%9E%E6%88%98/personboke/blog/source/_posts/Redis实战篇.assets/1653322857620.png" alt="1653322857620"></p>
<h4 id="2-3-2-、数据库和缓存不一致采用什么方案"><a href="#2-3-2-、数据库和缓存不一致采用什么方案" class="headerlink" title="2.3.2 、数据库和缓存不一致采用什么方案"></a>2.3.2 、数据库和缓存不一致采用什么方案</h4><p>综合考虑使用方案一，但是方案一调用者如何处理呢？这里有几个问题</p>
<p>操作缓存和数据库时有三个问题需要考虑：</p>
<p>如果采用第一个方案，那么假设我们每次操作数据库后，都操作缓存，但是中间如果没有人查询，那么这个更新动作实际上只有最后一次生效，中间的更新动作意义并不大，我们可以把缓存删除，等待再次查询时，将缓存中的数据加载出来</p>
<ul>
<li><p>删除缓存还是更新缓存？</p>
<ul>
<li>更新缓存：每次更新数据库都更新缓存，无效写操作较多</li>
<li>删除缓存：更新数据库时让缓存失效，查询时再更新缓存</li>
</ul>
</li>
<li><p>如何保证缓存与数据库的操作的同时成功或失败？</p>
<ul>
<li>单体系统，将缓存与数据库操作放在一个事务</li>
<li>分布式系统，利用TCC等分布式事务方案</li>
</ul>
</li>
</ul>
<p>应该具体操作缓存还是操作数据库，我们应当是先操作数据库，再删除缓存，原因在于，如果你选择第一种方案，在两个线程并发来访问时，假设线程1先来，他先把缓存删了，此时线程2过来，他查询缓存数据并不存在，此时他写入缓存，当他写入缓存后，线程1再执行更新动作时，实际上写入的就是旧的数据，新的数据被旧数据覆盖了。</p>
<ul>
<li>先操作缓存还是先操作数据库？<ul>
<li>先删除缓存，再操作数据库</li>
<li>先操作数据库，再删除缓存</li>
</ul>
</li>
</ul>
<p><img src="/2023/08/13/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84redis%E5%AE%9E%E6%88%98/personboke/blog/source/_posts/Redis实战篇.assets/1653323595206.png" alt="1653323595206"></p>
<h3 id="2-4-实现商铺和缓存与数据库双写一致"><a href="#2-4-实现商铺和缓存与数据库双写一致" class="headerlink" title="2.4 实现商铺和缓存与数据库双写一致"></a>2.4 实现商铺和缓存与数据库双写一致</h3><p>核心思路如下：</p>
<p>修改ShopController中的业务逻辑，满足下面的需求：</p>
<p>根据id查询店铺时，如果缓存未命中，则查询数据库，将数据库结果写入缓存，并设置超时时间</p>
<p>根据id修改店铺时，先修改数据库，再删除缓存</p>
<p><strong>修改重点代码1</strong>：修改<strong>ShopServiceImpl</strong>的queryById方法</p>
<p><strong>设置redis缓存时添加过期时间</strong></p>
<p><img src="/2023/08/13/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84redis%E5%AE%9E%E6%88%98/personboke/blog/source/_posts/Redis实战篇.assets/1653325871232.png" alt="1653325871232"></p>
<p><strong>修改重点代码2</strong></p>
<p>代码分析：通过之前的淘汰，我们确定了采用删除策略，来解决双写问题，当我们修改了数据之后，然后把缓存中的数据进行删除，查询时发现缓存中没有数据，则会从mysql中加载最新的数据，从而避免数据库和缓存不一致的问题</p>
<p><img src="/2023/08/13/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84redis%E5%AE%9E%E6%88%98/personboke/blog/source/_posts/Redis实战篇.assets/1653325929549.png" alt="1653325929549"></p>
<h3 id="2-5-缓存穿透问题的解决思路"><a href="#2-5-缓存穿透问题的解决思路" class="headerlink" title="2.5 缓存穿透问题的解决思路"></a>2.5 缓存穿透问题的解决思路</h3><p>缓存穿透 ：缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。</p>
<p>常见的解决方案有两种：</p>
<ul>
<li>缓存空对象<ul>
<li>优点：实现简单，维护方便</li>
<li>缺点：<ul>
<li>额外的内存消耗</li>
<li>可能造成短期的不一致</li>
</ul>
</li>
</ul>
</li>
<li>布隆过滤<ul>
<li>优点：内存占用较少，没有多余key</li>
<li>缺点：<ul>
<li>实现复杂</li>
<li>存在误判可能</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>缓存空对象思路分析：</strong>当我们客户端访问不存在的数据时，先请求redis，但是此时redis中没有数据，此时会访问到数据库，但是数据库中也没有数据，这个数据穿透了缓存，直击数据库，我们都知道数据库能够承载的并发不如redis这么高，如果大量的请求同时过来访问这种不存在的数据，这些请求就都会访问到数据库，简单的解决方案就是哪怕这个数据在数据库中也不存在，我们也把这个数据存入到redis中去，这样，下次用户过来访问这个不存在的数据，那么在redis中也能找到这个数据就不会进入到缓存了</p>
<p><strong>布隆过滤：</strong>布隆过滤器其实采用的是哈希思想来解决这个问题，通过一个庞大的二进制数组，走哈希思想去判断当前这个要查询的这个数据是否存在，如果布隆过滤器判断存在，则放行，这个请求会去访问redis，哪怕此时redis中的数据过期了，但是数据库中一定存在这个数据，在数据库中查询出来这个数据后，再将其放入到redis中，</p>
<p>假设布隆过滤器判断这个数据不存在，则直接返回</p>
<p>这种方式优点在于节约内存空间，存在误判，误判原因在于：布隆过滤器走的是哈希思想，只要哈希思想，就可能存在哈希冲突</p>
<p><img src="/2023/08/13/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84redis%E5%AE%9E%E6%88%98/personboke/blog/source/_posts/Redis实战篇.assets/1653326156516.png" alt="1653326156516"></p>
<h2 id="redis热点问题"><a href="#redis热点问题" class="headerlink" title="redis热点问题"></a>redis热点问题</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p><strong>指的是缓存中没有数据&#x2F;数据库中没有此数据不会做缓存的情况下 但是却有大量请求请求到数据库并且不会缓存就很可怕</strong>  </p>
<p><strong>解决方案</strong> </p>
<p>  <strong>1.缓存空数据 对于请求的数据如果没查到就缓存空数据 前端再次请求从缓存中去拿 拿出来判断为空则没有该数据</strong>  </p>
<p><strong>2.布隆过滤器 了解 可以设置布隆过滤器 他存储的是数据库中数据的哈希值 一种算法 可以对比请求的数据进行对比请求过滤 但是这中情况可能会有哈希冲突（了解）误判为存在实际上不存在</strong></p>
<p><strong>3.对于查询的id做复杂化处理 比如设置更长的id更复杂的配合</strong> </p>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p><strong>大量的缓存数据同一时间失效 或者redis服务器宕机</strong></p>
<p><strong>解决方案 1.设置不同的过期时间</strong></p>
<p><strong>2.集群模式 高可用配置</strong></p>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>热点数据失效 一些热点数据被大量访问 同时缓存失效 请求就会打在数据库上导致数据库崩溃</p>
<p>互斥锁</p>
<p>1.多个线程同时在请求数据</p>
<p>只会有一个线程构建缓存数据 其他数据请求锁 如果请求不到就等待 休眠一会在请求</p>
<p>2.设置逻辑过期 </p>
<p>设置缓存数据的逻辑过期时间</p>
<p>第一个线程获取数据 发现缓存实现 开启一个新线程 重建缓存 自己返回旧数据 在重建过程中 所有线程都是旧数据  不保证一致性 有额外内存消耗 保证了高可用用户交互性比较好 </p>
<h3 id="添加商户缓存"><a href="#添加商户缓存" class="headerlink" title="添加商户缓存"></a>添加商户缓存</h3><p>在我们查询商户信息时，我们是直接操作从数据库中去进行查询的，大致逻辑是这样，直接查询数据库那肯定慢咯，所以我们需要增加缓存</p>
<pre><code>@GetMapping(&quot;/&#123;id&#125;&quot;)
public Result queryShopById(@PathVariable(&quot;id&quot;) Long id) &#123;
    //这里是直接查询数据库
    return shopService.queryById(id);
&#125;
</code></pre>
<h4 id="2-2-1-、缓存模型和思路"><a href="#2-2-1-、缓存模型和思路" class="headerlink" title="2.2.1 、缓存模型和思路"></a>2.2.1 、缓存模型和思路</h4><p>标准的操作方式就是查询数据库之前先查询缓存，如果缓存数据存在，则直接从缓存中返回，如果缓存数据不存在，再查询数据库，然后将数据存入redis。</p>
<p><img src="/2023/08/13/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84redis%E5%AE%9E%E6%88%98/personboke/blog/source/_posts/Redis实战篇.assets/1653322097736.png" alt="1653322097736"></p>
<h4 id="2-1-2、代码如下"><a href="#2-1-2、代码如下" class="headerlink" title="2.1.2、代码如下"></a>2.1.2、代码如下</h4><p>代码思路：如果缓存有，则直接返回，如果缓存不存在，则查询数据库，然后存入redis。</p>
<p><img src="/2023/08/13/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84redis%E5%AE%9E%E6%88%98/personboke/blog/source/_posts/Redis实战篇.assets/1653322190155.png" alt="1653322190155"></p>
<h3 id="2-3-缓存更新策略-1"><a href="#2-3-缓存更新策略-1" class="headerlink" title="2.3 缓存更新策略"></a>2.3 缓存更新策略</h3><p>缓存更新是redis为了节约内存而设计出来的一个东西，主要是因为内存数据宝贵，当我们向redis插入太多数据，此时就可能会导致缓存中的数据过多，所以redis会对部分数据进行更新，或者把他叫为淘汰更合适。</p>
<p><strong>内存淘汰：</strong>redis自动进行，当redis内存达到咱们设定的max-memery的时候，会自动触发淘汰机制，淘汰掉一些不重要的数据(可以自己设置策略方式)</p>
<p><strong>超时剔除：</strong>当我们给redis设置了过期时间ttl之后，redis会将超时的数据进行删除，方便咱们继续使用缓存</p>
<p><strong>主动更新：</strong>我们可以手动调用方法把缓存删掉，通常用于解决缓存和数据库不一致问题</p>
<p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653322506393.png" alt="1653322506393"></p>
<h4 id="2-3-1-、数据库缓存不一致解决方案：-1"><a href="#2-3-1-、数据库缓存不一致解决方案：-1" class="headerlink" title="2.3.1 、数据库缓存不一致解决方案："></a>2.3.1 、数据库缓存不一致解决方案：</h4><p>由于我们的<strong>缓存的数据源来自于数据库</strong>,而数据库的<strong>数据是会发生变化的</strong>,因此,如果当数据库中<strong>数据发生变化,而缓存却没有同步</strong>,此时就会有<strong>一致性问题存在</strong>,其后果是:</p>
<p>用户使用缓存中的过时数据,就会产生类似多线程数据安全问题,从而影响业务,产品口碑等;怎么解决呢？有如下几种方案</p>
<p>Cache Aside Pattern 人工编码方式：缓存调用者在更新完数据库后再去更新缓存，也称之为双写方案</p>
<p>Read&#x2F;Write Through Pattern : 由系统本身完成，数据库与缓存的问题交由系统本身去处理</p>
<p>Write Behind Caching Pattern ：调用者只操作缓存，其他线程去异步处理数据库，实现最终一致</p>
<p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653322857620.png" alt="1653322857620"></p>
<h4 id="2-3-2-、数据库和缓存不一致采用什么方案-1"><a href="#2-3-2-、数据库和缓存不一致采用什么方案-1" class="headerlink" title="2.3.2 、数据库和缓存不一致采用什么方案"></a>2.3.2 、数据库和缓存不一致采用什么方案</h4><p>综合考虑使用方案一，但是方案一调用者如何处理呢？这里有几个问题</p>
<p>操作缓存和数据库时有三个问题需要考虑：</p>
<p>如果采用第一个方案，那么假设我们每次操作数据库后，都操作缓存，但是中间如果没有人查询，那么这个更新动作实际上只有最后一次生效，中间的更新动作意义并不大，我们可以把缓存删除，等待再次查询时，将缓存中的数据加载出来</p>
<ul>
<li><p>删除缓存还是更新缓存？</p>
<ul>
<li>更新缓存：每次更新数据库都更新缓存，无效写操作较多</li>
<li>删除缓存：更新数据库时让缓存失效，查询时再更新缓存</li>
</ul>
</li>
<li><p>如何保证缓存与数据库的操作的同时成功或失败？</p>
<ul>
<li>单体系统，将缓存与数据库操作放在一个事务</li>
<li>分布式系统，利用TCC等分布式事务方案</li>
</ul>
</li>
</ul>
<p>应该具体操作缓存还是操作数据库，我们应当是先操作数据库，再删除缓存，原因在于，如果你选择第一种方案，在两个线程并发来访问时，假设线程1先来，他先把缓存删了，此时线程2过来，他查询缓存数据并不存在，此时他写入缓存，当他写入缓存后，线程1再执行更新动作时，实际上写入的就是旧的数据，新的数据被旧数据覆盖了。</p>
<ul>
<li>先操作缓存还是先操作数据库？<ul>
<li>先删除缓存，再操作数据库</li>
<li>先操作数据库，再删除缓存</li>
</ul>
</li>
</ul>
<p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653323595206.png" alt="1653323595206"></p>
<h3 id="2-4-实现商铺和缓存与数据库双写一致-1"><a href="#2-4-实现商铺和缓存与数据库双写一致-1" class="headerlink" title="2.4 实现商铺和缓存与数据库双写一致"></a>2.4 实现商铺和缓存与数据库双写一致</h3><p>核心思路如下：</p>
<p>修改ShopController中的业务逻辑，满足下面的需求：</p>
<p>根据id查询店铺时，如果缓存未命中，则查询数据库，将数据库结果写入缓存，并设置超时时间</p>
<p>根据id修改店铺时，先修改数据库，再删除缓存</p>
<p><strong>修改重点代码1</strong>：修改<strong>ShopServiceImpl</strong>的queryById方法</p>
<p><strong>设置redis缓存时添加过期时间</strong></p>
<p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653325871232.png" alt="1653325871232"></p>
<p><strong>修改重点代码2</strong></p>
<p>代码分析：通过之前的淘汰，我们确定了采用删除策略，来解决双写问题，当我们修改了数据之后，然后把缓存中的数据进行删除，查询时发现缓存中没有数据，则会从mysql中加载最新的数据，从而避免数据库和缓存不一致的问题</p>
<p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653325929549.png" alt="1653325929549"></p>
<h3 id="2-5-缓存穿透问题的解决思路-1"><a href="#2-5-缓存穿透问题的解决思路-1" class="headerlink" title="2.5 缓存穿透问题的解决思路"></a>2.5 缓存穿透问题的解决思路</h3><p>缓存穿透 ：缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。</p>
<p>常见的解决方案有两种：</p>
<ul>
<li>缓存空对象<ul>
<li>优点：实现简单，维护方便</li>
<li>缺点：<ul>
<li>额外的内存消耗</li>
<li>可能造成短期的不一致</li>
</ul>
</li>
</ul>
</li>
<li>布隆过滤<ul>
<li>优点：内存占用较少，没有多余key</li>
<li>缺点：<ul>
<li>实现复杂</li>
<li>存在误判可能</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>缓存空对象思路分析：</strong>当我们客户端访问不存在的数据时，先请求redis，但是此时redis中没有数据，此时会访问到数据库，但是数据库中也没有数据，这个数据穿透了缓存，直击数据库，我们都知道数据库能够承载的并发不如redis这么高，如果大量的请求同时过来访问这种不存在的数据，这些请求就都会访问到数据库，简单的解决方案就是哪怕这个数据在数据库中也不存在，我们也把这个数据存入到redis中去，这样，下次用户过来访问这个不存在的数据，那么在redis中也能找到这个数据就不会进入到缓存了</p>
<p><strong>布隆过滤：</strong>布隆过滤器其实采用的是哈希思想来解决这个问题，通过一个庞大的二进制数组，走哈希思想去判断当前这个要查询的这个数据是否存在，如果布隆过滤器判断存在，则放行，这个请求会去访问redis，哪怕此时redis中的数据过期了，但是数据库中一定存在这个数据，在数据库中查询出来这个数据后，再将其放入到redis中，</p>
<p>假设布隆过滤器判断这个数据不存在，则直接返回</p>
<p>这种方式优点在于节约内存空间，存在误判，误判原因在于：布隆过滤器走的是哈希思想，只要哈希思想，就可能存在哈希冲突</p>
<p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653326156516.png" alt="1653326156516"></p>
<h3 id="2-6-编码解决商品查询的缓存穿透问题："><a href="#2-6-编码解决商品查询的缓存穿透问题：" class="headerlink" title="2.6 编码解决商品查询的缓存穿透问题："></a>2.6 编码解决商品查询的缓存穿透问题：</h3><p>核心思路如下：</p>
<p>在原来的逻辑中，我们如果发现这个数据在mysql中不存在，直接就返回404了，这样是会存在缓存穿透问题的</p>
<p>现在的逻辑中：如果这个数据不存在，我们不会返回404 ，还是会把这个数据写入到Redis中，并且将value设置为空，欧当再次发起查询时，我们如果发现命中之后，判断这个value是否是null，如果是null，则是之前写入的数据，证明是缓存穿透数据，如果不是，则直接返回数据。</p>
<p><img src="/2023/08/13/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84redis%E5%AE%9E%E6%88%98/personboke/blog/source/_posts/Redis实战篇.assets/1653327124561.png" alt="1653327124561"></p>
<p><strong>小总结：</strong></p>
<p>缓存穿透产生的原因是什么？</p>
<ul>
<li>用户请求的数据在缓存中和数据库中都不存在，不断发起这样的请求，给数据库带来巨大压力</li>
</ul>
<p>缓存穿透的解决方案有哪些？</p>
<ul>
<li>缓存null值</li>
<li>布隆过滤</li>
<li>增强id的复杂度，避免被猜测id规律</li>
<li>做好数据的基础格式校验</li>
<li>加强用户权限校验</li>
<li>做好热点参数的限流</li>
</ul>
<h3 id="2-7-缓存雪崩问题及解决思路"><a href="#2-7-缓存雪崩问题及解决思路" class="headerlink" title="2.7 缓存雪崩问题及解决思路"></a>2.7 缓存雪崩问题及解决思路</h3><p>缓存雪崩是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。</p>
<p>解决方案：</p>
<ul>
<li>给不同的Key的TTL添加随机值</li>
<li>利用Redis集群提高服务的可用性</li>
<li>给缓存业务添加降级限流策略</li>
<li>给业务添加多级缓存</li>
</ul>
<p><img src="/2023/08/13/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84redis%E5%AE%9E%E6%88%98/personboke/blog/source/_posts/Redis实战篇.assets/1653327884526.png" alt="1653327884526"></p>
<h3 id="2-8-缓存击穿问题及解决思路"><a href="#2-8-缓存击穿问题及解决思路" class="headerlink" title="2.8 缓存击穿问题及解决思路"></a>2.8 缓存击穿问题及解决思路</h3><p>缓存击穿问题也叫热点Key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。</p>
<p>常见的解决方案有两种：</p>
<ul>
<li>互斥锁</li>
<li>逻辑过期</li>
</ul>
<p>逻辑分析：假设线程1在查询缓存之后，本来应该去查询数据库，然后把这个数据重新加载到缓存的，此时只要线程1走完这个逻辑，其他线程就都能从缓存中加载这些数据了，但是假设在线程1没有走完的时候，后续的线程2，线程3，线程4同时过来访问当前这个方法， 那么这些线程都不能从缓存中查询到数据，那么他们就会同一时刻来访问查询缓存，都没查到，接着同一时间去访问数据库，同时的去执行数据库代码，对数据库访问压力过大</p>
<p><img src="/2023/08/13/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84redis%E5%AE%9E%E6%88%98/personboke/blog/source/_posts/Redis实战篇.assets/1653328022622.png" alt="1653328022622"></p>
<p>解决方案一、使用锁来解决：</p>
<p>因为锁能实现互斥性。假设线程过来，只能一个人一个人的来访问数据库，从而避免对于数据库访问压力过大，但这也会影响查询的性能，因为此时会让查询的性能从并行变成了串行，我们可以采用tryLock方法 + double check来解决这样的问题。</p>
<p>假设现在线程1过来访问，他查询缓存没有命中，但是此时他获得到了锁的资源，那么线程1就会一个人去执行逻辑，假设现在线程2过来，线程2在执行过程中，并没有获得到锁，那么线程2就可以进行到休眠，直到线程1把锁释放后，线程2获得到锁，然后再来执行逻辑，此时就能够从缓存中拿到数据了。</p>
<p><img src="/2023/08/13/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84redis%E5%AE%9E%E6%88%98/personboke/blog/source/_posts/Redis实战篇.assets/1653328288627.png" alt="1653328288627"></p>
<p>解决方案二、逻辑过期方案</p>
<p>方案分析：我们之所以会出现这个缓存击穿问题，主要原因是在于我们对key设置了过期时间，假设我们不设置过期时间，其实就不会有缓存击穿的问题，但是不设置过期时间，这样数据不就一直占用我们内存了吗，我们可以采用逻辑过期方案。</p>
<p>我们把过期时间设置在 redis的value中，注意：这个过期时间并不会直接作用于redis，而是我们后续通过逻辑去处理。假设线程1去查询缓存，然后从value中判断出来当前的数据已经过期了，此时线程1去获得互斥锁，那么其他线程会进行阻塞，获得了锁的线程他会开启一个 线程去进行 以前的重构数据的逻辑，直到新开的线程完成这个逻辑后，才释放锁， 而线程1直接进行返回，假设现在线程3过来访问，由于线程线程2持有着锁，所以线程3无法获得锁，线程3也直接返回数据，只有等到新开的线程2把重建数据构建完后，其他线程才能走返回正确的数据。</p>
<p>这种方案巧妙在于，异步的构建缓存，缺点在于在构建完缓存之前，返回的都是脏数据。</p>
<p><img src="/2023/08/13/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84redis%E5%AE%9E%E6%88%98/personboke/blog/source/_posts/Redis实战篇.assets/1653328663897.png" alt="1653328663897"></p>
<p>进行对比</p>
<p><strong>互斥锁方案：</strong>由于保证了互斥性，所以数据一致，且实现简单，因为仅仅只需要加一把锁而已，也没其他的事情需要操心，所以没有额外的内存消耗，缺点在于有锁就有死锁问题的发生，且只能串行执行性能肯定受到影响</p>
<p><strong>逻辑过期方案：</strong> 线程读取过程中不需要等待，性能好，有一个额外的线程持有锁去进行重构数据，但是在重构数据完成前，其他的线程只能返回之前的数据，且实现起来麻烦</p>
<p><img src="/2023/08/13/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84redis%E5%AE%9E%E6%88%98/personboke/blog/source/_posts/Redis实战篇.assets/1653357522914.png" alt="1653357522914"></p>
<h3 id="2-9-利用互斥锁解决缓存击穿问题"><a href="#2-9-利用互斥锁解决缓存击穿问题" class="headerlink" title="2.9 利用互斥锁解决缓存击穿问题"></a>2.9 利用互斥锁解决缓存击穿问题</h3><p>核心思路：相较于原来从缓存中查询不到数据后直接查询数据库而言，现在的方案是 进行查询之后，如果从缓存没有查询到数据，则进行互斥锁的获取，获取互斥锁后，判断是否获得到了锁，如果没有获得到，则休眠，过一会再进行尝试，直到获取到锁为止，才能进行查询</p>
<p>如果获取到了锁的线程，再去进行查询，查询后将数据写入redis，再释放锁，返回数据，利用互斥锁就能保证只有一个线程去执行操作数据库的逻辑，防止缓存击穿</p>
<p><img src="/2023/08/13/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84redis%E5%AE%9E%E6%88%98/personboke/blog/source/_posts/Redis实战篇.assets/1653357860001.png" alt="1653357860001"></p>
<p><strong>操作锁的代码：</strong></p>
<p>核心思路就是利用redis的setnx方法来表示获取锁，该方法含义是redis中如果没有这个key，则插入成功，返回1，在stringRedisTemplate中返回true，  如果有这个key则插入失败，则返回0，在stringRedisTemplate返回false，我们可以通过true，或者是false，来表示是否有线程成功插入key，成功插入的key的线程我们认为他就是获得到锁的线程。</p>
<pre><code>@Override
    public Result queryByid(Long id) &#123;

        //缓存穿透
//        Shop shop = queryWithPassThrough(id);

        //互斥锁解决缓存击穿
        Shop shop = queryWithMutex(id);
        if (shop == null) &#123;
            return Result.fail(&quot;店铺不存在&quot;);
        &#125;

        return Result.ok(shop);
    &#125;
//
//    @Override
//    public Result queryByid(Long id) &#123;
//        //1.从redis查询商铺缓存
//        String shopJson = stringRedisTemplate.opsForValue().get(CACHE_SHOP_KEY+ id);
//        //2.判断是否存在
//        if (StrUtil.isNotBlank(shopJson)) &#123;
//            //3.存在直接返回
//            Shop shop = JSONUtil.toBean(shopJson, Shop.class);
//            return  Result.ok(shop);
//        &#125;
//        //判断命中的是否是空值
//        if(shopJson != null) &#123;
//            //返回一个错误信息
//            return Result.fail(&quot;店铺信息不存在&quot;);
//        &#125;
//        //4.不存在根据id查询数据库
//        Shop shop=getById(id);
//        //5.不存在返回错误
//        if (shop == null) &#123;
//            //将空值写入到redis
//            stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY+ id,&quot;&quot;,CACHE_NULL_TTL,TimeUnit.MINUTES);
//            return Result.fail(&quot;Shop not found&quot;);
//        &#125;
//        //6.存在写入到redis
//        stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY+id,JSONUtil.toJsonStr(shop),30L, TimeUnit.MINUTES);
//        return Result.ok(shop);
//    &#125;
    //缓存穿透
    public Shop queryWithPassThrough(Long id)&#123;
        //1.从redis查询商铺缓存
        String shopJson = stringRedisTemplate.opsForValue().get(CACHE_SHOP_KEY+ id);
        //2.判断是否存在
        if (StrUtil.isNotBlank(shopJson)) &#123;
            //3.存在直接返回
            return  JSONUtil.toBean(shopJson, Shop.class);

        &#125;
        //判断命中的是否是空值
        if(shopJson != null) &#123;
            //返回一个错误信息
           return null;
        &#125;
        //4.不存在根据id查询数据库
        Shop shop=getById(id);
        //5.不存在返回错误
        if (shop == null) &#123;
            //将空值写入到redis
            stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY+ id,&quot;&quot;,CACHE_NULL_TTL,TimeUnit.MINUTES);
            return null;
        &#125;
        //6.存在写入到redis
        stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY+id,JSONUtil.toJsonStr(shop),30L, TimeUnit.MINUTES);
        return shop;
    &#125;

    public Shop queryWithMutex(Long id) &#123;
        String locKey=&quot;lock:shop&quot;+id;
        Shop shop=null;
        try &#123;//1.从redis查询商铺缓存
        String shopJson = stringRedisTemplate.opsForValue().get(CACHE_SHOP_KEY+ id);
        //2.判断是否存在
        if (StrUtil.isNotBlank(shopJson)) &#123;
            //3.存在直接返回
            return  JSONUtil.toBean(shopJson, Shop.class);

        &#125;
        //判断命中的是否是空值
        if(shopJson != null) &#123;
            //返回一个错误信息
            return null;
        &#125;
        //4.不存在根据id查询数据库
        //4.1获取互斥锁

        boolean isLock=tryLock(locKey);
        //4.2判断是否成功
        if (!isLock)&#123;
            //4.3失败则休眠并重试
                Thread.sleep(50);
            return queryWithMutex(id);
        &#125;
        //4.4成功根据id查询数据库
      shop=getById(id);
        //5.不存在返回错误
        if (shop == null) &#123;
            //将空值写入到redis
            stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY+ id,&quot;&quot;,CACHE_NULL_TTL,TimeUnit.MINUTES);
            return null;
        &#125;
        //6.存在写入到redis
        stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY+id,JSONUtil.toJsonStr(shop),30L, TimeUnit.MINUTES);
        &#125; catch (InterruptedException e) &#123;
            throw new RuntimeException(e);
        &#125;finally &#123;
            //7.释放互斥锁
            unlock(locKey);
        &#125;
        return shop;
    &#125;

    private boolean tryLock(String key)&#123;
        Boolean aBoolean = stringRedisTemplate.opsForValue().setIfAbsent(key, &quot;1&quot;, 10, TimeUnit.SECONDS);
        return BooleanUtil.isTrue(aBoolean);
    &#125;
    private void unlock(String key)&#123;
            stringRedisTemplate.delete(key);
    &#125;

    @Override
    @Transactional
    public Result updateShop(Shop shop) &#123;

        //1.更新数据库
        updateById(shop);

        if (shop.getId() ==null)&#123;
            return Result.fail(&quot;Shop not found&quot;);
        &#125;
        //2.删除缓存
        stringRedisTemplate.delete(CACHE_SHOP_KEY+shop.getId());


        return Result.ok();
    &#125;
&#125;
</code></pre>
<h1 id="redis解决缓存穿透缓存击穿-工具类"><a href="#redis解决缓存穿透缓存击穿-工具类" class="headerlink" title="redis解决缓存穿透缓存击穿 工具类"></a>redis解决缓存穿透缓存击穿 工具类</h1><pre><code>package com.hmdp.utils;

import cn.hutool.core.util.BooleanUtil;
import cn.hutool.core.util.StrUtil;
import cn.hutool.json.JSONObject;
import cn.hutool.json.JSONUtil;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.stereotype.Component;

import java.time.LocalDateTime;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.function.Function;

import static com.hmdp.utils.RedisConstants.CACHE_NULL_TTL;
import static com.hmdp.utils.RedisConstants.LOCK_SHOP_KEY;

@Slf4j
@Component
public class CacheClient &#123;

    private final StringRedisTemplate stringRedisTemplate;

    private static final ExecutorService CACHE_REBUILD_EXECUTOR = Executors.newFixedThreadPool(10);

    public CacheClient(StringRedisTemplate stringRedisTemplate) &#123;
        this.stringRedisTemplate = stringRedisTemplate;
    &#125;

    public void set(String key, Object value, Long time, TimeUnit unit) &#123;
        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), time, unit);
    &#125;

    public void setWithLogicalExpire(String key, Object value, Long time, TimeUnit unit) &#123;
        // 设置逻辑过期
        RedisData redisData = new RedisData();
        redisData.setData(value);
        redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(time)));
        // 写入Redis
        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));
    &#125;

    public &lt;R,ID&gt; R queryWithPassThrough(
            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)&#123;
        String key = keyPrefix + id;
        // 1.从redis查询商铺缓存
        String json = stringRedisTemplate.opsForValue().get(key);
        // 2.判断是否存在
        if (StrUtil.isNotBlank(json)) &#123;
            // 3.存在，直接返回
            return JSONUtil.toBean(json, type);
        &#125;
        // 判断命中的是否是空值
        if (json != null) &#123;
            // 返回一个错误信息
            return null;
        &#125;

        // 4.不存在，根据id查询数据库
        R r = dbFallback.apply(id);
        // 5.不存在，返回错误
        if (r == null) &#123;
            // 将空值写入redis
            stringRedisTemplate.opsForValue().set(key, &quot;&quot;, CACHE_NULL_TTL, TimeUnit.MINUTES);
            // 返回错误信息
            return null;
        &#125;
        // 6.存在，写入redis
        this.set(key, r, time, unit);
        return r;
    &#125;

    public &lt;R, ID&gt; R queryWithLogicalExpire(
            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit) &#123;
        String key = keyPrefix + id;
        // 1.从redis查询商铺缓存
        String json = stringRedisTemplate.opsForValue().get(key);
        // 2.判断是否存在
        if (StrUtil.isBlank(json)) &#123;
            // 3.存在，直接返回
            return null;
        &#125;
        // 4.命中，需要先把json反序列化为对象
        RedisData redisData = JSONUtil.toBean(json, RedisData.class);
        R r = JSONUtil.toBean((JSONObject) redisData.getData(), type);
        LocalDateTime expireTime = redisData.getExpireTime();
        // 5.判断是否过期
        if(expireTime.isAfter(LocalDateTime.now())) &#123;
            // 5.1.未过期，直接返回店铺信息
            return r;
        &#125;
        // 5.2.已过期，需要缓存重建
        // 6.缓存重建
        // 6.1.获取互斥锁
        String lockKey = LOCK_SHOP_KEY + id;
        boolean isLock = tryLock(lockKey);
        // 6.2.判断是否获取锁成功
        if (isLock)&#123;
            // 6.3.成功，开启独立线程，实现缓存重建
            CACHE_REBUILD_EXECUTOR.submit(() -&gt; &#123;
                try &#123;
                    // 查询数据库
                    R newR = dbFallback.apply(id);
                    // 重建缓存
                    this.setWithLogicalExpire(key, newR, time, unit);
                &#125; catch (Exception e) &#123;
                    throw new RuntimeException(e);
                &#125;finally &#123;
                    // 释放锁
                    unlock(lockKey);
                &#125;
            &#125;);
        &#125;
        // 6.4.返回过期的商铺信息
        return r;
    &#125;

    public &lt;R, ID&gt; R queryWithMutex(
            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit) &#123;
        String key = keyPrefix + id;
        // 1.从redis查询商铺缓存
        String shopJson = stringRedisTemplate.opsForValue().get(key);
        // 2.判断是否存在
        if (StrUtil.isNotBlank(shopJson)) &#123;
            // 3.存在，直接返回
            return JSONUtil.toBean(shopJson, type);
        &#125;
        // 判断命中的是否是空值
        if (shopJson != null) &#123;
            // 返回一个错误信息
            return null;
        &#125;

        // 4.实现缓存重建
        // 4.1.获取互斥锁
        String lockKey = LOCK_SHOP_KEY + id;
        R r = null;
        try &#123;
            boolean isLock = tryLock(lockKey);
            // 4.2.判断是否获取成功
            if (!isLock) &#123;
                // 4.3.获取锁失败，休眠并重试
                Thread.sleep(50);
                return queryWithMutex(keyPrefix, id, type, dbFallback, time, unit);
            &#125;
            // 4.4.获取锁成功，根据id查询数据库
            r = dbFallback.apply(id);
            // 5.不存在，返回错误
            if (r == null) &#123;
                // 将空值写入redis
                stringRedisTemplate.opsForValue().set(key, &quot;&quot;, CACHE_NULL_TTL, TimeUnit.MINUTES);
                // 返回错误信息
                return null;
            &#125;
            // 6.存在，写入redis
            this.set(key, r, time, unit);
        &#125; catch (InterruptedException e) &#123;
            throw new RuntimeException(e);
        &#125;finally &#123;
            // 7.释放锁
            unlock(lockKey);
        &#125;
        // 8.返回
        return r;
    &#125;

    private boolean tryLock(String key) &#123;
        Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key, &quot;1&quot;, 10, TimeUnit.SECONDS);
        return BooleanUtil.isTrue(flag);
    &#125;

    private void unlock(String key) &#123;
        stringRedisTemplate.delete(key);
    &#125;
&#125;
</code></pre>
<h2 id="redis实现秒杀问题解决"><a href="#redis实现秒杀问题解决" class="headerlink" title="redis实现秒杀问题解决"></a>redis实现秒杀问题解决</h2><h3 id="3-3-添加优惠卷"><a href="#3-3-添加优惠卷" class="headerlink" title="3.3 添加优惠卷"></a>3.3 添加优惠卷</h3><p>每个店铺都可以发布优惠券，分为平价券和特价券。平价券可以任意购买，而特价券需要秒杀抢购：</p>
<p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653365145124.png" alt="1653365145124"></p>
<p>tb_voucher：优惠券的基本信息，优惠金额、使用规则等<br>tb_seckill_voucher：优惠券的库存、开始抢购时间，结束抢购时间。特价优惠券才需要填写这些信息</p>
<p>平价卷由于优惠力度并不是很大，所以是可以任意领取</p>
<p>而代金券由于优惠力度大，所以像第二种卷，就得限制数量，从表结构上也能看出，特价卷除了具有优惠卷的基本信息以外，还具有库存，抢购时间，结束时间等等字段</p>
<p>**新增普通卷代码：  **VoucherController</p>
<pre><code class="java">@PostMapping
public Result addVoucher(@RequestBody Voucher voucher) &#123;
    voucherService.save(voucher);
    return Result.ok(voucher.getId());
&#125;
</code></pre>
<p><strong>新增秒杀卷代码：</strong></p>
<p><strong>VoucherController</strong></p>
<pre><code class="java">@PostMapping(&quot;seckill&quot;)
public Result addSeckillVoucher(@RequestBody Voucher voucher) &#123;
    voucherService.addSeckillVoucher(voucher);
    return Result.ok(voucher.getId());
&#125;
</code></pre>
<p><strong>VoucherServiceImpl</strong></p>
<pre><code class="java">@Override
@Transactional
public void addSeckillVoucher(Voucher voucher) &#123;
    // 保存优惠券
    save(voucher);
    // 保存秒杀信息
    SeckillVoucher seckillVoucher = new SeckillVoucher();
    seckillVoucher.setVoucherId(voucher.getId());
    seckillVoucher.setStock(voucher.getStock());
    seckillVoucher.setBeginTime(voucher.getBeginTime());
    seckillVoucher.setEndTime(voucher.getEndTime());
    seckillVoucherService.save(seckillVoucher);
    // 保存秒杀库存到Redis中
    stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString());
&#125;
</code></pre>
<h3 id="3-4-实现秒杀下单"><a href="#3-4-实现秒杀下单" class="headerlink" title="3.4 实现秒杀下单"></a>3.4 实现秒杀下单</h3><p>下单核心思路：当我们点击抢购时，会触发右侧的请求，我们只需要编写对应的controller即可</p>
<p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653365839526.png" alt="1653365839526"></p>
<p>秒杀下单应该思考的内容：</p>
<p>下单时需要判断两点：</p>
<ul>
<li>秒杀是否开始或结束，如果尚未开始或已经结束则无法下单</li>
<li>库存是否充足，不足则无法下单</li>
</ul>
<p>下单核心逻辑分析：</p>
<p>当用户开始进行下单，我们应当去查询优惠卷信息，查询到优惠卷信息，判断是否满足秒杀条件</p>
<p>比如时间是否充足，如果时间充足，则进一步判断库存是否足够，如果两者都满足，则扣减库存，创建订单，然后返回订单id，如果有一个条件不满足则直接结束。</p>
<p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653366238564.png" alt="1653366238564"></p>
<p>VoucherOrderServiceImpl</p>
<pre><code class="java">@Override
public Result seckillVoucher(Long voucherId) &#123;
    // 1.查询优惠券
    SeckillVoucher voucher = seckillVoucherService.getById(voucherId);
    // 2.判断秒杀是否开始
    if (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;
        // 尚未开始
        return Result.fail(&quot;秒杀尚未开始！&quot;);
    &#125;
    // 3.判断秒杀是否已经结束
    if (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;
        // 尚未开始
        return Result.fail(&quot;秒杀已经结束！&quot;);
    &#125;
    // 4.判断库存是否充足
    if (voucher.getStock() &lt; 1) &#123;
        // 库存不足
        return Result.fail(&quot;库存不足！&quot;);
    &#125;
    //5，扣减库存
    boolean success = seckillVoucherService.update()
            .setSql(&quot;stock= stock -1&quot;)
            .eq(&quot;voucher_id&quot;, voucherId).update();
    if (!success) &#123;
        //扣减库存
        return Result.fail(&quot;库存不足！&quot;);
    &#125;
    //6.创建订单
    VoucherOrder voucherOrder = new VoucherOrder();
    // 6.1.订单id
    long orderId = redisIdWorker.nextId(&quot;order&quot;);
    voucherOrder.setId(orderId);
    // 6.2.用户id
    Long userId = UserHolder.getUser().getId();
    voucherOrder.setUserId(userId);
    // 6.3.代金券id
    voucherOrder.setVoucherId(voucherId);
    save(voucherOrder);

    return Result.ok(orderId);

&#125;
</code></pre>
<h3 id="3-5-库存超卖问题分析"><a href="#3-5-库存超卖问题分析" class="headerlink" title="3.5 库存超卖问题分析"></a>3.5 库存超卖问题分析</h3><p>有关超卖问题分析：在我们原有代码中是这么写的</p>
<pre><code class="java"> if (voucher.getStock() &lt; 1) &#123;
        // 库存不足
        return Result.fail(&quot;库存不足！&quot;);
    &#125;
    //5，扣减库存
    boolean success = seckillVoucherService.update()
            .setSql(&quot;stock= stock -1&quot;)
            .eq(&quot;voucher_id&quot;, voucherId).update();
    if (!success) &#123;
        //扣减库存
        return Result.fail(&quot;库存不足！&quot;);
    &#125;
</code></pre>
<p>假设线程1过来查询库存，判断出来库存大于1，正准备去扣减库存，但是还没有来得及去扣减，此时线程2过来，线程2也去查询库存，发现这个数量一定也大于1，那么这两个线程都会去扣减库存，最终多个线程相当于一起去扣减库存，此时就会出现库存的超卖问题。</p>
<p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653368335155.png" alt="1653368335155"></p>
<p>超卖问题是典型的多线程安全问题，针对这一问题的常见解决方案就是加锁：而对于加锁，我们通常有两种解决方案：见下图：</p>
<p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653368562591.png" alt="1653368562591"></p>
<p><strong>悲观锁：</strong></p>
<p> 悲观锁可以实现对于数据的串行化执行，比如syn，和lock都是悲观锁的代表，同时，悲观锁中又可以再细分为公平锁，非公平锁，可重入锁，等等</p>
<p><strong>乐观锁：</strong></p>
<p>  乐观锁：会有一个版本号，每次操作数据会对版本号+1，再提交回数据时，会去校验是否比之前的版本大1 ，如果大1 ，则进行操作成功，这套机制的核心逻辑在于，如果在操作过程中，版本号只比原来大1 ，那么就意味着操作过程中没有人对他进行过修改，他的操作就是安全的，如果不大1，则数据被修改过，当然乐观锁还有一些变种的处理方式比如cas</p>
<p>  乐观锁的典型代表：就是cas，利用cas进行无锁化机制加锁，var5 是操作前读取的内存值，while中的var1+var2 是预估值，如果预估值 &#x3D;&#x3D; 内存值，则代表中间没有被人修改过，此时就将新值去替换 内存值</p>
<p>  其中do while 是为了在操作失败时，再次进行自旋操作，即把之前的逻辑再操作一次。</p>
<pre><code class="java">int var5;
do &#123;
    var5 = this.getIntVolatile(var1, var2);
&#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));

return var5;
</code></pre>
<p><strong>课程中的使用方式：</strong></p>
<p>课程中的使用方式是没有像cas一样带自旋的操作，也没有对version的版本号+1 ，他的操作逻辑是在操作时，对版本号进行+1 操作，然后要求version 如果是1 的情况下，才能操作，那么第一个线程在操作后，数据库中的version变成了2，但是他自己满足version&#x3D;1 ，所以没有问题，此时线程2执行，线程2 最后也需要加上条件version &#x3D;1 ，但是现在由于线程1已经操作过了，所以线程2，操作时就不满足version&#x3D;1 的条件了，所以线程2无法执行成功</p>
<p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653369268550.png" alt="1653369268550"></p>
<h3 id="3-6-乐观锁解决超卖问题"><a href="#3-6-乐观锁解决超卖问题" class="headerlink" title="3.6 乐观锁解决超卖问题"></a>3.6 乐观锁解决超卖问题</h3><p><strong>修改代码方案一、</strong></p>
<p>VoucherOrderServiceImpl 在扣减库存时，改为：</p>
<pre><code class="java">boolean success = seckillVoucherService.update()
            .setSql(&quot;stock= stock -1&quot;) //set stock = stock -1
            .eq(&quot;voucher_id&quot;, voucherId).eq(&quot;stock&quot;,voucher.getStock()).update(); //where id = ？ and stock = ?
</code></pre>
<p>以上逻辑的核心含义是：只要我扣减库存时的库存和之前我查询到的库存是一样的，就意味着没有人在中间修改过库存，那么此时就是安全的，但是以上这种方式通过测试发现会有很多失败的情况，失败的原因在于：在使用乐观锁过程中假设100个线程同时都拿到了100的库存，然后大家一起去进行扣减，但是100个人中只有1个人能扣减成功，其他的人在处理时，他们在扣减时，库存已经被修改过了，所以此时其他线程都会失败</p>
<p><strong>修改代码方案二、</strong></p>
<p>之前的方式要修改前后都保持一致，但是这样我们分析过，成功的概率太低，所以我们的乐观锁需要变一下，改成stock大于0 即可</p>
<pre><code class="java">boolean success = seckillVoucherService.update()
            .setSql(&quot;stock= stock -1&quot;)
            .eq(&quot;voucher_id&quot;, voucherId).update().gt(&quot;stock&quot;,0); //where id = ? and stock &gt; 0
</code></pre>
<p><strong>知识小扩展：</strong></p>
<p>针对cas中的自旋压力过大，我们可以使用Longaddr这个类去解决</p>
<p>Java8 提供的一个对AtomicLong改进后的一个类，LongAdder</p>
<p>大量线程并发更新一个原子性的时候，天然的问题就是自旋，会导致并发性问题，当然这也比我们直接使用syn来的好</p>
<p>所以利用这么一个类，LongAdder来进行优化</p>
<p>如果获取某个值，则会对cell和base的值进行递增，最后返回一个完整的值</p>
<p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653370271627.png" alt="1653370271627"></p>
<h3 id="3-6-优惠券秒杀-一人一单"><a href="#3-6-优惠券秒杀-一人一单" class="headerlink" title="3.6 优惠券秒杀-一人一单"></a>3.6 优惠券秒杀-一人一单</h3><p>需求：修改秒杀业务，要求同一个优惠券，一个用户只能下一单</p>
<p><strong>现在的问题在于：</strong></p>
<p>优惠卷是为了引流，但是目前的情况是，一个人可以无限制的抢这个优惠卷，所以我们应当增加一层逻辑，让一个用户只能下一个单，而不是让一个用户下多个单</p>
<p>具体操作逻辑如下：比如时间是否充足，如果时间充足，则进一步判断库存是否足够，然后再根据优惠卷id和用户id查询是否已经下过这个订单，如果下过这个订单，则不再下单，否则进行下单</p>
<p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653371854389.png" alt="1653371854389"></p>
<p>VoucherOrderServiceImpl  </p>
<p><strong>初步代码：增加一人一单逻辑</strong></p>
<pre><code class="java">@Override
public Result seckillVoucher(Long voucherId) &#123;
    // 1.查询优惠券
    SeckillVoucher voucher = seckillVoucherService.getById(voucherId);
    // 2.判断秒杀是否开始
    if (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;
        // 尚未开始
        return Result.fail(&quot;秒杀尚未开始！&quot;);
    &#125;
    // 3.判断秒杀是否已经结束
    if (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;
        // 尚未开始
        return Result.fail(&quot;秒杀已经结束！&quot;);
    &#125;
    // 4.判断库存是否充足
    if (voucher.getStock() &lt; 1) &#123;
        // 库存不足
        return Result.fail(&quot;库存不足！&quot;);
    &#125;
    // 5.一人一单逻辑
    // 5.1.用户id
    Long userId = UserHolder.getUser().getId();
    int count = query().eq(&quot;user_id&quot;, userId).eq(&quot;voucher_id&quot;, voucherId).count();
    // 5.2.判断是否存在
    if (count &gt; 0) &#123;
        // 用户已经购买过了
        return Result.fail(&quot;用户已经购买过一次！&quot;);
    &#125;

    //6，扣减库存
    boolean success = seckillVoucherService.update()
            .setSql(&quot;stock= stock -1&quot;)
            .eq(&quot;voucher_id&quot;, voucherId).update();
    if (!success) &#123;
        //扣减库存
        return Result.fail(&quot;库存不足！&quot;);
    &#125;
    //7.创建订单
    VoucherOrder voucherOrder = new VoucherOrder();
    // 7.1.订单id
    long orderId = redisIdWorker.nextId(&quot;order&quot;);
    voucherOrder.setId(orderId);

    voucherOrder.setUserId(userId);
    // 7.3.代金券id
    voucherOrder.setVoucherId(voucherId);
    save(voucherOrder);

    return Result.ok(orderId);

&#125;
</code></pre>
<p><strong>存在问题：</strong>现在的问题还是和之前一样，并发过来，查询数据库，都不存在订单，所以我们还是需要加锁，但是乐观锁比较适合更新数据，而现在是插入数据，所以我们需要使用悲观锁操作</p>
<p><strong>注意：</strong>在这里提到了非常多的问题，我们需要慢慢的来思考，首先我们的初始方案是封装了一个createVoucherOrder方法，同时为了确保他线程安全，在方法上添加了一把synchronized 锁</p>
<pre><code class="java">@Transactional
public synchronized Result createVoucherOrder(Long voucherId) &#123;

    Long userId = UserHolder.getUser().getId();
         // 5.1.查询订单
        int count = query().eq(&quot;user_id&quot;, userId).eq(&quot;voucher_id&quot;, voucherId).count();
        // 5.2.判断是否存在
        if (count &gt; 0) &#123;
            // 用户已经购买过了
            return Result.fail(&quot;用户已经购买过一次！&quot;);
        &#125;

        // 6.扣减库存
        boolean success = seckillVoucherService.update()
                .setSql(&quot;stock = stock - 1&quot;) // set stock = stock - 1
                .eq(&quot;voucher_id&quot;, voucherId).gt(&quot;stock&quot;, 0) // where id = ? and stock &gt; 0
                .update();
        if (!success) &#123;
            // 扣减失败
            return Result.fail(&quot;库存不足！&quot;);
        &#125;

        // 7.创建订单
        VoucherOrder voucherOrder = new VoucherOrder();
        // 7.1.订单id
        long orderId = redisIdWorker.nextId(&quot;order&quot;);
        voucherOrder.setId(orderId);
        // 7.2.用户id
        voucherOrder.setUserId(userId);
        // 7.3.代金券id
        voucherOrder.setVoucherId(voucherId);
        save(voucherOrder);

        // 7.返回订单id
        return Result.ok(orderId);
&#125;
</code></pre>
<p>，但是这样添加锁，锁的粒度太粗了，在使用锁过程中，控制<strong>锁粒度</strong> 是一个非常重要的事情，因为如果锁的粒度太大，会导致每个线程进来都会锁住，所以我们需要去控制锁的粒度，以下这段代码需要修改为：<br>intern() 这个方法是从常量池中拿到数据，如果我们直接使用userId.toString() 他拿到的对象实际上是不同的对象，new出来的对象，我们使用锁必须保证锁必须是同一把，所以我们需要使用intern()方法</p>
<pre><code class="java">@Transactional
public  Result createVoucherOrder(Long voucherId) &#123;
    Long userId = UserHolder.getUser().getId();
    synchronized(userId.toString().intern())&#123;
         // 5.1.查询订单
        int count = query().eq(&quot;user_id&quot;, userId).eq(&quot;voucher_id&quot;, voucherId).count();
        // 5.2.判断是否存在
        if (count &gt; 0) &#123;
            // 用户已经购买过了
            return Result.fail(&quot;用户已经购买过一次！&quot;);
        &#125;

        // 6.扣减库存
        boolean success = seckillVoucherService.update()
                .setSql(&quot;stock = stock - 1&quot;) // set stock = stock - 1
                .eq(&quot;voucher_id&quot;, voucherId).gt(&quot;stock&quot;, 0) // where id = ? and stock &gt; 0
                .update();
        if (!success) &#123;
            // 扣减失败
            return Result.fail(&quot;库存不足！&quot;);
        &#125;

        // 7.创建订单
        VoucherOrder voucherOrder = new VoucherOrder();
        // 7.1.订单id
        long orderId = redisIdWorker.nextId(&quot;order&quot;);
        voucherOrder.setId(orderId);
        // 7.2.用户id
        voucherOrder.setUserId(userId);
        // 7.3.代金券id
        voucherOrder.setVoucherId(voucherId);
        save(voucherOrder);

        // 7.返回订单id
        return Result.ok(orderId);
    &#125;
&#125;
</code></pre>
<p>但是以上代码还是存在问题，问题的原因在于当前方法被spring的事务控制，如果你在方法内部加锁，可能会导致当前方法事务还没有提交，但是锁已经释放也会导致问题，所以我们选择将当前方法整体包裹起来，确保事务不会出现问题：如下：</p>
<p>在seckillVoucher 方法中，添加以下逻辑，这样就能保证事务的特性，同时也控制了锁的粒度</p>
<p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653373434815.png" alt="1653373434815"></p>
<p>但是以上做法依然有问题，因为你调用的方法，其实是this.的方式调用的，事务想要生效，还得利用代理来生效，所以这个地方，我们需要获得原始的事务对象， 来操作事务</p>
<p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653383810643.png" alt="1653383810643"></p>
<h3 id="3-7-集群环境下的并发问题"><a href="#3-7-集群环境下的并发问题" class="headerlink" title="3.7 集群环境下的并发问题"></a>3.7 集群环境下的并发问题</h3><p>通过加锁可以解决在单机情况下的一人一单安全问题，但是在集群模式下就不行了。</p>
<p>1、我们将服务启动两份，端口分别为8081和8082：</p>
<p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653373887844.png" alt="1653373887844"></p>
<p>2、然后修改nginx的conf目录下的nginx.conf文件，配置反向代理和负载均衡：</p>
<p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653373908620.png" alt="1653373908620"></p>
<p><strong>具体操作(略)</strong></p>
<p><strong>有关锁失效原因分析</strong></p>
<p>由于现在我们部署了多个tomcat，每个tomcat都有一个属于自己的jvm，那么假设在服务器A的tomcat内部，有两个线程，这两个线程由于使用的是同一份代码，那么他们的锁对象是同一个，是可以实现互斥的，但是如果现在是服务器B的tomcat内部，又有两个线程，但是他们的锁对象写的虽然和服务器A一样，但是锁对象却不是同一个，所以线程3和线程4可以实现互斥，但是却无法和线程1和线程2实现互斥，这就是 集群环境下，syn锁失效的原因，在这种情况下，我们就需要使用分布式锁来解决这个问题。</p>
<p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653374044740.png" alt="1653374044740"></p>
<h2 id="4、分布式锁"><a href="#4、分布式锁" class="headerlink" title="4、分布式锁"></a>4、分布式锁</h2><h3 id="4-1-、基本原理和实现方式对比"><a href="#4-1-、基本原理和实现方式对比" class="headerlink" title="4.1 、基本原理和实现方式对比"></a>4.1 、基本原理和实现方式对比</h3><p>分布式锁：满足分布式系统或集群模式下多进程可见并且互斥的锁。</p>
<p>分布式锁的核心思想就是让大家都使用同一把锁，只要大家使用的是同一把锁，那么我们就能锁住线程，不让线程进行，让程序串行执行，这就是分布式锁的核心思路</p>
<p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653374296906.png" alt="1653374296906"></p>
<p>那么分布式锁他应该满足一些什么样的条件呢？</p>
<p>可见性：多个线程都能看到相同的结果，注意：这个地方说的可见性并不是并发编程中指的内存可见性，只是说多个进程之间都能感知到变化的意思</p>
<p>互斥：互斥是分布式锁的最基本的条件，使得程序串行执行</p>
<p>高可用：程序不易崩溃，时时刻刻都保证较高的可用性</p>
<p>高性能：由于加锁本身就让性能降低，所有对于分布式锁本身需要他就较高的加锁性能和释放锁性能</p>
<p>安全性：安全也是程序中必不可少的一环</p>
<p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653381992018.png" alt="1653381992018"></p>
<p>常见的分布式锁有三种</p>
<p>Mysql：mysql本身就带有锁机制，但是由于mysql性能本身一般，所以采用分布式锁的情况下，其实使用mysql作为分布式锁比较少见</p>
<p>Redis：redis作为分布式锁是非常常见的一种使用方式，现在企业级开发中基本都使用redis或者zookeeper作为分布式锁，利用setnx这个方法，如果插入key成功，则表示获得到了锁，如果有人插入成功，其他人插入失败则表示无法获得到锁，利用这套逻辑来实现分布式锁</p>
<p>Zookeeper：zookeeper也是企业级开发中较好的一个实现分布式锁的方案，由于本套视频并不讲解zookeeper的原理和分布式锁的实现，所以不过多阐述</p>
<p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653382219377.png" alt="1653382219377"></p>
<h3 id="4-2-、Redis分布式锁的实现核心思路"><a href="#4-2-、Redis分布式锁的实现核心思路" class="headerlink" title="4.2 、Redis分布式锁的实现核心思路"></a>4.2 、Redis分布式锁的实现核心思路</h3><p>实现分布式锁时需要实现的两个基本方法：</p>
<ul>
<li><p>获取锁：</p>
<ul>
<li>互斥：确保只能有一个线程获取锁</li>
<li>非阻塞：尝试一次，成功返回true，失败返回false</li>
</ul>
</li>
<li><p>释放锁：</p>
<ul>
<li>手动释放</li>
<li>超时释放：获取锁时添加一个超时时间</li>
</ul>
<p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653382669900.png" alt="1653382669900"></p>
</li>
</ul>
<p>核心思路：</p>
<p>我们利用redis 的setNx 方法，当有多个线程进入时，我们就利用该方法，第一个线程进入时，redis 中就有这个key 了，返回了1，如果结果是1，则表示他抢到了锁，那么他去执行业务，然后再删除锁，退出锁逻辑，没有抢到锁的哥们，等待一定时间后重试即可</p>
<p> <img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653382830810.png" alt="1653382830810"></p>
<h3 id="4-3-实现分布式锁版本一"><a href="#4-3-实现分布式锁版本一" class="headerlink" title="4.3 实现分布式锁版本一"></a>4.3 实现分布式锁版本一</h3><ul>
<li>加锁逻辑</li>
</ul>
<p><strong>锁的基本接口</strong></p>
<p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1656079017728.png" alt="1656079017728"></p>
<p><strong>SimpleRedisLock</strong></p>
<p>利用setnx方法进行加锁，同时增加过期时间，防止死锁，此方法可以保证加锁和增加过期时间具有原子性</p>
<pre><code class="java">private static final String KEY_PREFIX=&quot;lock:&quot;
@Override
public boolean tryLock(long timeoutSec) &#123;
    // 获取线程标示
    String threadId = Thread.currentThread().getId()
    // 获取锁
    Boolean success = stringRedisTemplate.opsForValue()
            .setIfAbsent(KEY_PREFIX + name, threadId + &quot;&quot;, timeoutSec, TimeUnit.SECONDS);
    return Boolean.TRUE.equals(success);
&#125;
</code></pre>
<ul>
<li>释放锁逻辑</li>
</ul>
<p>SimpleRedisLock</p>
<p>释放锁，防止删除别人的锁</p>
<pre><code class="java">public void unlock() &#123;
    //通过del删除锁
    stringRedisTemplate.delete(KEY_PREFIX + name);
&#125;
</code></pre>
<ul>
<li>修改业务代码</li>
</ul>
<pre><code class="java">  @Override
    public Result seckillVoucher(Long voucherId) &#123;
        // 1.查询优惠券
        SeckillVoucher voucher = seckillVoucherService.getById(voucherId);
        // 2.判断秒杀是否开始
        if (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;
            // 尚未开始
            return Result.fail(&quot;秒杀尚未开始！&quot;);
        &#125;
        // 3.判断秒杀是否已经结束
        if (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;
            // 尚未开始
            return Result.fail(&quot;秒杀已经结束！&quot;);
        &#125;
        // 4.判断库存是否充足
        if (voucher.getStock() &lt; 1) &#123;
            // 库存不足
            return Result.fail(&quot;库存不足！&quot;);
        &#125;
        Long userId = UserHolder.getUser().getId();
        //创建锁对象(新增代码)
        SimpleRedisLock lock = new SimpleRedisLock(&quot;order:&quot; + userId, stringRedisTemplate);
        //获取锁对象
        boolean isLock = lock.tryLock(1200);
        //加锁失败
        if (!isLock) &#123;
            return Result.fail(&quot;不允许重复下单&quot;);
        &#125;
        try &#123;
            //获取代理对象(事务)
            IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();
            return proxy.createVoucherOrder(voucherId);
        &#125; finally &#123;
            //释放锁
            lock.unlock();
        &#125;
    &#125;
</code></pre>
<h3 id="4-4-Redis分布式锁误删情况说明"><a href="#4-4-Redis分布式锁误删情况说明" class="headerlink" title="4.4 Redis分布式锁误删情况说明"></a>4.4 Redis分布式锁误删情况说明</h3></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://349264976.github.io">en</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://349264976.github.io/2023/08/13/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84redis%E5%AE%9E%E6%88%98/">https://349264976.github.io/2023/08/13/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84redis%E5%AE%9E%E6%88%98/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://349264976.github.io" target="_blank">fuguangmengying</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/08/13/Redis%E5%AE%9E%E6%88%98%E7%AF%87/" title=""><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info"></div></div></a></div><div class="next-post pull-right"><a href="/2023/08/08/Pinia/" title="Vue3 状态管理 - Pinia"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Vue3 状态管理 - Pinia</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">en</div><div class="author-info__description">漫漫长路</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">36</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%80%E7%AF%87-redis%E5%AE%9E%E6%88%98-%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84"><span class="toc-number">1.</span> <span class="toc-text">开篇 redis实战 黑马点评</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-0-redis%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2hmdp"><span class="toc-number">1.1.</span> <span class="toc-text">1.0 redis项目部署hmdp</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD1%E5%8F%91%E9%80%81%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81-%E9%87%87%E7%94%A8session%E5%81%9A"><span class="toc-number">1.1.0.1.</span> <span class="toc-text">功能1发送短信验证码 采用session做</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E6%9C%9F%E6%96%B9%E6%A1%88"><span class="toc-number">1.1.1.</span> <span class="toc-text">初期方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E3%80%81%E5%9F%BA%E4%BA%8ESession%E5%AE%9E%E7%8E%B0%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2 、基于Session实现登录流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E3%80%81%E5%AE%9E%E7%8E%B0%E5%8F%91%E9%80%81%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81%E5%8A%9F%E8%83%BD"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.3 、实现发送短信验证码功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4%E3%80%81%E5%AE%9E%E7%8E%B0%E7%99%BB%E5%BD%95%E6%8B%A6%E6%88%AA%E5%8A%9F%E8%83%BD"><span class="toc-number">1.1.4.</span> <span class="toc-text">1.4、实现登录拦截功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5%E3%80%81%E9%9A%90%E8%97%8F%E7%94%A8%E6%88%B7%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF"><span class="toc-number">1.1.5.</span> <span class="toc-text">1.5、隐藏用户敏感信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6%E3%80%81session%E5%85%B1%E4%BA%AB%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.6.</span> <span class="toc-text">1.6、session共享问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7-Redis%E4%BB%A3%E6%9B%BFsession%E7%9A%84%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B"><span class="toc-number">1.1.7.</span> <span class="toc-text">1.7 Redis代替session的业务流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-7-1%E3%80%81%E8%AE%BE%E8%AE%A1key%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.7.1.</span> <span class="toc-text">1.7.1、设计key的结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-7-2%E3%80%81%E8%AE%BE%E8%AE%A1key%E7%9A%84%E5%85%B7%E4%BD%93%E7%BB%86%E8%8A%82"><span class="toc-number">1.1.7.2.</span> <span class="toc-text">1.7.2、设计key的具体细节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-7-3%E3%80%81%E6%95%B4%E4%BD%93%E8%AE%BF%E9%97%AE%E6%B5%81%E7%A8%8B"><span class="toc-number">1.1.7.3.</span> <span class="toc-text">1.7.3、整体访问流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%86%E8%8A%82"><span class="toc-number">1.2.</span> <span class="toc-text">细节</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%9C%E4%B8%9A"><span class="toc-number">2.</span> <span class="toc-text">作业</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E7%BC%93%E5%AD%98%E4%B8%8D%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">2.1.</span> <span class="toc-text">问题 数据库与缓存不一致性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5"><span class="toc-number">2.1.1.</span> <span class="toc-text">2.3 缓存更新策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%93%E5%AD%98%E4%B8%8D%E4%B8%80%E8%87%B4%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">2.3.1 、数据库缓存不一致解决方案：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%BC%93%E5%AD%98%E4%B8%8D%E4%B8%80%E8%87%B4%E9%87%87%E7%94%A8%E4%BB%80%E4%B9%88%E6%96%B9%E6%A1%88"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">2.3.2 、数据库和缓存不一致采用什么方案</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E5%AE%9E%E7%8E%B0%E5%95%86%E9%93%BA%E5%92%8C%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4"><span class="toc-number">2.1.2.</span> <span class="toc-text">2.4 实现商铺和缓存与数据库双写一致</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF"><span class="toc-number">2.1.3.</span> <span class="toc-text">2.5 缓存穿透问题的解决思路</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis%E7%83%AD%E7%82%B9%E9%97%AE%E9%A2%98"><span class="toc-number">2.2.</span> <span class="toc-text">redis热点问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">2.2.1.</span> <span class="toc-text">缓存穿透</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">2.2.2.</span> <span class="toc-text">缓存雪崩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-number">2.2.3.</span> <span class="toc-text">缓存击穿</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E5%95%86%E6%88%B7%E7%BC%93%E5%AD%98"><span class="toc-number">2.2.4.</span> <span class="toc-text">添加商户缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-%E3%80%81%E7%BC%93%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%80%9D%E8%B7%AF"><span class="toc-number">2.2.4.1.</span> <span class="toc-text">2.2.1 、缓存模型和思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2%E3%80%81%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B"><span class="toc-number">2.2.4.2.</span> <span class="toc-text">2.1.2、代码如下</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5-1"><span class="toc-number">2.2.5.</span> <span class="toc-text">2.3 缓存更新策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%93%E5%AD%98%E4%B8%8D%E4%B8%80%E8%87%B4%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A-1"><span class="toc-number">2.2.5.1.</span> <span class="toc-text">2.3.1 、数据库缓存不一致解决方案：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%BC%93%E5%AD%98%E4%B8%8D%E4%B8%80%E8%87%B4%E9%87%87%E7%94%A8%E4%BB%80%E4%B9%88%E6%96%B9%E6%A1%88-1"><span class="toc-number">2.2.5.2.</span> <span class="toc-text">2.3.2 、数据库和缓存不一致采用什么方案</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E5%AE%9E%E7%8E%B0%E5%95%86%E9%93%BA%E5%92%8C%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4-1"><span class="toc-number">2.2.6.</span> <span class="toc-text">2.4 实现商铺和缓存与数据库双写一致</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF-1"><span class="toc-number">2.2.7.</span> <span class="toc-text">2.5 缓存穿透问题的解决思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E7%BC%96%E7%A0%81%E8%A7%A3%E5%86%B3%E5%95%86%E5%93%81%E6%9F%A5%E8%AF%A2%E7%9A%84%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-number">2.2.8.</span> <span class="toc-text">2.6 编码解决商品查询的缓存穿透问题：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF"><span class="toc-number">2.2.9.</span> <span class="toc-text">2.7 缓存雪崩问题及解决思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF"><span class="toc-number">2.2.10.</span> <span class="toc-text">2.8 缓存击穿问题及解决思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-9-%E5%88%A9%E7%94%A8%E4%BA%92%E6%96%A5%E9%94%81%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E9%97%AE%E9%A2%98"><span class="toc-number">2.2.11.</span> <span class="toc-text">2.9 利用互斥锁解决缓存击穿问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#redis%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF-%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">3.</span> <span class="toc-text">redis解决缓存穿透缓存击穿 工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#redis%E5%AE%9E%E7%8E%B0%E7%A7%92%E6%9D%80%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3"><span class="toc-number">3.1.</span> <span class="toc-text">redis实现秒杀问题解决</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E6%B7%BB%E5%8A%A0%E4%BC%98%E6%83%A0%E5%8D%B7"><span class="toc-number">3.1.1.</span> <span class="toc-text">3.3 添加优惠卷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E5%AE%9E%E7%8E%B0%E7%A7%92%E6%9D%80%E4%B8%8B%E5%8D%95"><span class="toc-number">3.1.2.</span> <span class="toc-text">3.4 实现秒杀下单</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E5%BA%93%E5%AD%98%E8%B6%85%E5%8D%96%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="toc-number">3.1.3.</span> <span class="toc-text">3.5 库存超卖问题分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-%E4%B9%90%E8%A7%82%E9%94%81%E8%A7%A3%E5%86%B3%E8%B6%85%E5%8D%96%E9%97%AE%E9%A2%98"><span class="toc-number">3.1.4.</span> <span class="toc-text">3.6 乐观锁解决超卖问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-%E4%BC%98%E6%83%A0%E5%88%B8%E7%A7%92%E6%9D%80-%E4%B8%80%E4%BA%BA%E4%B8%80%E5%8D%95"><span class="toc-number">3.1.5.</span> <span class="toc-text">3.6 优惠券秒杀-一人一单</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98"><span class="toc-number">3.1.6.</span> <span class="toc-text">3.7 集群环境下的并发问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">3.2.</span> <span class="toc-text">4、分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E3%80%81%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94"><span class="toc-number">3.2.1.</span> <span class="toc-text">4.1 、基本原理和实现方式对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E3%80%81Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%A0%B8%E5%BF%83%E6%80%9D%E8%B7%AF"><span class="toc-number">3.2.2.</span> <span class="toc-text">4.2 、Redis分布式锁的实现核心思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%89%88%E6%9C%AC%E4%B8%80"><span class="toc-number">3.2.3.</span> <span class="toc-text">4.3 实现分布式锁版本一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E8%AF%AF%E5%88%A0%E6%83%85%E5%86%B5%E8%AF%B4%E6%98%8E"><span class="toc-number">3.2.4.</span> <span class="toc-text">4.4 Redis分布式锁误删情况说明</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/09/10/Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%20%E5%B5%A9%E5%B1%B1%E7%89%88/" title="Java 开发手册 嵩山版">Java 开发手册 嵩山版</a><time datetime="2023-09-10T02:03:35.000Z" title="发表于 2023-09-10 10:03:35">2023-09-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/09/06/jdk8%E6%96%B0%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8/" title="jdk8新特性学习使用">jdk8新特性学习使用</a><time datetime="2023-09-06T13:03:35.000Z" title="发表于 2023-09-06 21:03:35">2023-09-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/09/03/mybatis-plus/" title="mybatis_plus">mybatis_plus</a><time datetime="2023-09-03T13:06:27.000Z" title="发表于 2023-09-03 21:06:27">2023-09-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/29/mysql%E5%9F%BA%E4%BA%8Edatetime%E5%BE%97%E6%97%B6%E9%97%B4%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2/" title="mysql基于datetime得时间范围查询">mysql基于datetime得时间范围查询</a><time datetime="2023-08-29T15:46:22.000Z" title="发表于 2023-08-29 23:46:22">2023-08-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/19/Swagger2/" title="swagger">swagger</a><time datetime="2023-08-19T11:55:11.000Z" title="发表于 2023-08-19 19:55:11">2023-08-19</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By en</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>